import{f as o,D as i,o as p,c as h,a2 as a,G as l,w as n,k as e,a as s}from"./chunks/framework.DpNgdNqH.js";const P=JSON.parse('{"title":"Sprite3D","description":"","frontmatter":{"title":"Sprite3D","order":2},"headers":[],"relativePath":"ko/assets/sprite/sprite.md","filePath":"ko/assets/sprite/sprite.md","lastUpdated":1770625747000}'),c={name:"ko/assets/sprite/sprite.md"};function k(g,t,u,x,y,b){const r=i("CodePen"),d=i("ClientOnly");return p(),h("div",null,[t[1]||(t[1]=a(`<h1 id="sprite3d" tabindex="-1">Sprite3D <a class="header-anchor" href="#sprite3d" aria-label="Permalink to &quot;Sprite3D&quot;">​</a></h1><p><strong>Sprite3D</strong> 는 3D 공간 내에 배치되는 2D 평면 객체입니다. 일반적인 메시와 달리 <strong>빌보드</strong>(Billboard) 기능을 기본으로 내장하고 있어, 카메라의 회전 방향에 관계없이 항상 정면을 유지해야 하는 요소(아이콘, 이름표, 특수 효과 등)를 구현하는 데 최적화되어 있습니다.</p><h2 id="_1-주요-특징" tabindex="-1">1. 주요 특징 <a class="header-anchor" href="#_1-주요-특징" aria-label="Permalink to &quot;1. 주요 특징&quot;">​</a></h2><ul><li><strong>Billboard</strong> : 카메라를 항상 정면으로 바라보는 기능을 기본으로 지원합니다.</li><li><strong>자동 비율 유지</strong>: 할당된 텍스처의 원본 비율(Aspect Ratio)을 자동으로 계산하여 평면의 크기를 조절합니다.</li><li><strong>UI 친화적</strong> : 3D 공간 내에서의 위치(World Position)와 2D적인 표현 방식을 결합하여 공간감 있는 UI 요소를 제공합니다.</li></ul><h2 id="_2-기본-사용법" tabindex="-1">2. 기본 사용법 <a class="header-anchor" href="#_2-기본-사용법" aria-label="Permalink to &quot;2. 기본 사용법&quot;">​</a></h2><p><code>Sprite3D</code> 는 내부적으로 <strong>Plane</strong> 지오메트리를 사용하며, 이미지를 출력하기 위해 <strong>BitmapMaterial</strong> 과 함께 사용됩니다.</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;https://redcamel.github.io/RedGPU/dist/index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. 텍스처 및 재질 생성</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> texture</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU.Resource.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BitmapTexture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(redGPUContext, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;https://redcamel.github.io/RedGPU/examples/assets/texture/crate.png&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> material</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU.Material.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BitmapMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(redGPUContext, texture);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. 스프라이트 생성 및 추가</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sprite</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU.Display.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Sprite3D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(redGPUContext, material);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scene.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sprite);</span></span></code></pre></div><h2 id="_3-핵심-속성-제어" tabindex="-1">3. 핵심 속성 제어 <a class="header-anchor" href="#_3-핵심-속성-제어" aria-label="Permalink to &quot;3. 핵심 속성 제어&quot;">​</a></h2><p>스프라이트의 빌보드 동작과 시각적 표현을 제어하는 주요 속성들입니다.</p><h3 id="빌보드-설정" tabindex="-1">빌보드 설정 <a class="header-anchor" href="#빌보드-설정" aria-label="Permalink to &quot;빌보드 설정&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">속성명</th><th style="text-align:left;">설명</th><th style="text-align:left;">기본값</th></tr></thead><tbody><tr><td style="text-align:left;"><strong><code>useBillboard</code></strong></td><td style="text-align:left;">카메라를 항상 향하게 할지 여부</td><td style="text-align:left;"><code>true</code></td></tr></tbody></table><h3 id="크기-및-렌더링-모드" tabindex="-1">크기 및 렌더링 모드 <a class="header-anchor" href="#크기-및-렌더링-모드" aria-label="Permalink to &quot;크기 및 렌더링 모드&quot;">​</a></h3><p><code>Sprite3D</code>는 월드 단위 크기 또는 고정된 픽셀 크기로 렌더링할 수 있는 옵션을 제공합니다.</p><table tabindex="0"><thead><tr><th style="text-align:left;">속성명</th><th style="text-align:left;">설명</th><th style="text-align:left;">기본값</th></tr></thead><tbody><tr><td style="text-align:left;"><strong><code>worldSize</code></strong></td><td style="text-align:left;">월드 공간에서의 세로 크기 (Unit 단위). 가로 크기는 비율에 맞춰 자동 조절됩니다.</td><td style="text-align:left;"><code>1</code></td></tr><tr><td style="text-align:left;"><strong><code>usePixelSize</code></strong></td><td style="text-align:left;">고정 픽셀 크기 모드 사용 여부. <code>true</code>일 경우 거리에 관계없이 일정한 픽셀 크기로 렌더링됩니다.</td><td style="text-align:left;"><code>false</code></td></tr><tr><td style="text-align:left;"><strong><code>pixelSize</code></strong></td><td style="text-align:left;">고정 픽셀 크기 값 (<code>px</code> 단위). <code>usePixelSize</code>가 <code>true</code>일 때만 적용됩니다.</td><td style="text-align:left;"><code>0</code></td></tr></tbody></table><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. 월드 단위 크기 설정 (거리에 따라 작아짐)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sprite.worldSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. 고정 픽셀 크기 설정 (아이콘 등 UI 스타일, 거리에 관계없이 크기 일정)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sprite.usePixelSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sprite.pixelSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="_3-3-월드-사이즈와-픽셀-사이즈의-관계" tabindex="-1">3.3 월드 사이즈와 픽셀 사이즈의 관계 <a class="header-anchor" href="#_3-3-월드-사이즈와-픽셀-사이즈의-관계" aria-label="Permalink to &quot;3.3 월드 사이즈와 픽셀 사이즈의 관계&quot;">​</a></h3><p><code>Sprite3D</code>에서 크기와 선명도를 결정하는 핵심 요소들의 관계를 이해하면 상황에 맞는 최적의 연출이 가능합니다.</p><h4 id="_3-3-1-소스-해상도-texture-resolution" tabindex="-1">3.3.1 소스 해상도 (Texture Resolution) <a class="header-anchor" href="#_3-3-1-소스-해상도-texture-resolution" aria-label="Permalink to &quot;3.3.1 소스 해상도 (Texture Resolution)&quot;">​</a></h4><ul><li><strong>역할</strong>: 원본 이미지의 크기가 스프라이트의 <strong>최대 선명도</strong>를 결정합니다.</li><li><strong>특징</strong>: <code>usePixelSize</code> 모드를 사용할 때, <code>pixelSize</code>를 원본 해상도보다 크게 설정하면 이미지가 흐려질 수 있습니다.</li></ul><h4 id="_3-3-2-월드-사이즈-worldsize" tabindex="-1">3.3.2 월드 사이즈 (<code>worldSize</code>) <a class="header-anchor" href="#_3-3-2-월드-사이즈-worldsize" aria-label="Permalink to &quot;3.3.2 월드 사이즈 (\`worldSize\`)&quot;">​</a></h4><ul><li><strong>역할</strong>: 3D 월드 공간 내에서의 <strong>물리적 세로 높이</strong>(Unit 단위)를 결정합니다.</li><li><strong>동작</strong>: <code>usePixelSize</code>가 <code>false</code>일 때 작동하며, 일반적인 3D 오브젝트처럼 거리에 따른 원근감이 적용됩니다.</li></ul><h4 id="_3-3-3-고정-픽셀-모드-usepixelsize-pixelsize" tabindex="-1">3.3.3 고정 픽셀 모드 (<code>usePixelSize</code> &amp; <code>pixelSize</code>) <a class="header-anchor" href="#_3-3-3-고정-픽셀-모드-usepixelsize-pixelsize" aria-label="Permalink to &quot;3.3.3 고정 픽셀 모드 (\`usePixelSize\` &amp; \`pixelSize\`)&quot;">​</a></h4><ul><li><strong>역할</strong>: 3D 공간에 위치하지만, 화면에는 <strong>지정한 픽셀 크기</strong> 그대로 표시합니다.</li><li><strong>특징</strong>: 이 모드가 활성화되면 <code>worldSize</code>는 무시됩니다. 기본적으로 텍스처가 로드될 때의 **원본 높이(Height)**가 <code>pixelSize</code>에 자동으로 할당됩니다. 아이콘이나 마커처럼 거리에 상관없이 일정한 크기와 가독성을 유지해야 할 때 사용합니다.</li></ul><div class="tip custom-block"><p class="custom-block-title">[픽셀 크기 조절]</p><p><code>usePixelSize</code>가 활성화된 상태에서 스프라이트가 너무 크거나 작게 보인다면, <code>worldSize</code>가 아닌 <code>pixelSize</code> 속성을 직접 변경하여 조절하십시오.</p></div><h2 id="_4-실습-예제-렌더링-모드별-비교" tabindex="-1">4. 실습 예제: 렌더링 모드별 비교 <a class="header-anchor" href="#_4-실습-예제-렌더링-모드별-비교" aria-label="Permalink to &quot;4. 실습 예제: 렌더링 모드별 비교&quot;">​</a></h2><p>3D 공간에 서로 다른 설정의 스프라이트를 배치하여 시각적 차이를 확인해 봅니다.</p>`,26)),l(d,null,{default:n(()=>[l(r,{title:"RedGPU - Sprite3D Showcase",slugHash:"sprite3d-showcase"},{default:n(()=>[...t[0]||(t[0]=[e("pre",{"data-lang":"html"},`<canvas id="redgpu-canvas"></canvas>
`,-1),e("pre",{"data-lang":"css"},`body { margin: 0; overflow: hidden; background: #000; }
canvas { display: block; width: 100vw; height: 100vh; }
`,-1),e("pre",{"data-lang":"js"},[s(`import * as RedGPU from "https://redcamel.github.io/RedGPU/dist/index.js";
`),e("p",null,'const canvas = document.getElementById("redgpu-canvas");'),s(`
`),e("p",null,`RedGPU.init(canvas, (redGPUContext) => {
const scene = new RedGPU.Display.Scene();`),s(`
`),e("pre",null,[e("code",null,`// 공용 재질 생성
const texture = new RedGPU.Resource.BitmapTexture(redGPUContext, 'https://redcamel.github.io/RedGPU/examples/assets/texture/crate.png');
const material = new RedGPU.Material.BitmapMaterial(redGPUContext, texture);

// 1. 기본 월드 사이즈 (World Size)
const sprite1 = new RedGPU.Display.Sprite3D(redGPUContext, material);
sprite1.x = -3; sprite1.y = 1;
sprite1.worldSize = 1.5;
scene.addChild(sprite1);

// 2. 고정 픽셀 사이즈 (Pixel Size) - 멀어져도 크기가 변하지 않음
const sprite2 = new RedGPU.Display.Sprite3D(redGPUContext, material);
sprite2.x = 3; sprite2.y = 1;
sprite2.usePixelSize = true;
sprite2.pixelSize = 100;
scene.addChild(sprite2);

// 3. 옵션 설명 라벨 (TextField3D)
const createLabel = (text, x, y) => {
    const label = new RedGPU.Display.TextField3D(redGPUContext, text);
    label.x = x; label.y = y;
    label.color = '#ffffff';
    label.fontSize = 16;
    label.background = '#ff3333';
    label.padding = 8;
    label.useBillboard = true;
    scene.addChild(label);
};

createLabel('World Size', -3, 2.5);
createLabel('Pixel Size', 3, 2.5);

// 3D 뷰 설정
const controller = new RedGPU.Camera.OrbitController(redGPUContext);
controller.distance = 12;
const view = new RedGPU.Display.View3D(redGPUContext, scene, controller);
view.grid = true;
redGPUContext.addView(view);

const renderer = new RedGPU.Renderer();
renderer.start(redGPUContext);
`)]),s(`
`),e("p",null,"});"),s(`
`)],-1)])]),_:1})]),_:1}),t[2]||(t[2]=a('<hr><h2 id="핵심-요약" tabindex="-1">핵심 요약 <a class="header-anchor" href="#핵심-요약" aria-label="Permalink to &quot;핵심 요약&quot;">​</a></h2><ul><li><strong>Sprite3D</strong> 는 3D 좌표계를 가지면서도 카메라를 정면으로 바라보는 <strong>Billboard</strong> 기능을 제공합니다.</li><li><code>usePixelSize</code> 속성을 통해 거리에 관계없이 일정한 크기로 표현되는 UI 스타일 요소를 구현할 수 있습니다.</li><li>텍스처의 해상도와 비율에 따라 지오메트리 크기가 자동 조정되어 편리하게 사용할 수 있습니다.</li></ul><hr><h2 id="다음-학습-추천" tabindex="-1">다음 학습 추천 <a class="header-anchor" href="#다음-학습-추천" aria-label="Permalink to &quot;다음 학습 추천&quot;">​</a></h2><p>스프라이트를 활용한 애니메이션 효과에 대해 알아봅니다.</p><ul><li><strong><a href="./../sprite/spritesheet.html">SpriteSheet3D</a></strong></li></ul>',7))])}const D=o(c,[["render",k]]);export{P as __pageData,D as default};
