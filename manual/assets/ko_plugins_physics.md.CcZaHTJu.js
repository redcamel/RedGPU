import{f as i,o as a,c as e,a2 as l}from"./chunks/framework.DZW1bhNM.js";const c=JSON.parse('{"title":"Physics (Rapier)","description":"","frontmatter":{"title":"Physics (Rapier)","order":1},"headers":[],"relativePath":"ko/plugins/physics.md","filePath":"ko/plugins/physics.md","lastUpdated":1770713971000}'),n={name:"ko/plugins/physics.md"};function t(h,s,p,r,d,o){return a(),e("div",null,[...s[0]||(s[0]=[l(`<h1 id="물리-엔진-플러그인-rapier" tabindex="-1">물리 엔진 플러그인 (Rapier) <a class="header-anchor" href="#물리-엔진-플러그인-rapier" aria-label="Permalink to &quot;물리 엔진 플러그인 (Rapier)&quot;">​</a></h1><p>RedGPU는 고성능 WASM 기반 물리 엔진인 <strong>Rapier</strong>를 플러그인 형태로 지원합니다. 이 플러그인을 통해 3D 공간에서의 강체(Rigid Body) 시뮬레이션, 정밀한 충돌 감지, 캐릭터 컨트롤러 등을 엔진과 완벽하게 통합하여 사용할 수 있습니다.</p><div class="warning custom-block"><p class="custom-block-title">실험적 기능 (Experimental)</p><p>물리 엔진 플러그인은 현재 <strong>실험적 단계</strong>에 있습니다. 개발 과정에서 API 명세나 동작 방식이 예고 없이 변경될 수 있으니 주의하여 사용하시기 바랍니다.</p></div><h2 id="_0-인터페이스와-플러그인-분리-및-통합-설계-의도" tabindex="-1">0. 인터페이스와 플러그인 분리 및 통합 설계 의도 <a class="header-anchor" href="#_0-인터페이스와-플러그인-분리-및-통합-설계-의도" aria-label="Permalink to &quot;0. 인터페이스와 플러그인 분리 및 통합 설계 의도&quot;">​</a></h2><p>RedGPU의 물리 시스템은 공통 인터페이스(<code>IPhysicsEngine</code>)를 통한 확장성과 엔진 내부로의 <strong>심리스한 통합</strong>을 목표로 설계되었습니다.</p><ol><li><strong>코어 엔진 경량화 (Bundle Size Optimization)</strong>: 물리 엔진은 상당히 큰 바이너리 용량을 차지합니다. 모든 프로젝트가 물리가 필요한 것은 아니기에, 메인 엔진 번들에 이를 포함하지 않음으로써 초기 로딩 속도를 최적화합니다.</li><li><strong>번거로운 동기화 자동화 (Seamless Integration)</strong>: 일반적인 물리 엔진 사용 시 개발자를 가장 괴롭히는 작업은 &#39;물리 월드의 좌표를 3D 메쉬에 매 프레임 복사&#39;하는 일입니다. RedGPU는 이를 엔진 레벨에서 자동화하여, <code>createBody</code> 호출 한 번으로 위치, 회전, 스케일은 물론 <strong>복잡한 자식 메쉬들의 계층 구조까지 자동으로 물리 월드에 반영</strong>합니다.</li><li><strong>엔진 교체 및 확장성 (Interchangeability)</strong>: 사용자 코드는 <code>IPhysicsEngine</code>이라는 약속된 규격에 의존합니다. 따라서 향후 Rapier 외에 다른 물리 엔진으로 교체하더라도, 기존의 씬 구성이나 로직 코드를 최소한으로 수정하여 전환할 수 있는 유연성을 제공합니다.</li><li><strong>비동기 초기화 제어</strong>: WASM 로딩은 본질적으로 비동기 작업입니다. 이를 플러그인으로 분리함으로써 메인 엔진의 초기화 흐름을 방해하지 않고 개발자가 준비 시점을 명확하게 제어할 수 있습니다.</li></ol><h2 id="_1-초기화-및-설정" tabindex="-1">1. 초기화 및 설정 <a class="header-anchor" href="#_1-초기화-및-설정" aria-label="Permalink to &quot;1. 초기화 및 설정&quot;">​</a></h2><p>물리 엔진은 메인 엔진 번들과 분리되어 있으므로 별도로 임포트해야 합니다. WASM 바이너리를 로드하는 과정이 포함되어 있어 초기화는 비동기로 진행됩니다.</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;https://redcamel.github.io/RedGPU/dist/index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { RapierPhysics } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;https://redcamel.github.io/RedGPU/dist/plugins/physics/rapier/index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. 물리 엔진 인스턴스 생성</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> physicsEngine</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RapierPhysics</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. 엔진 초기화 (WASM 로드 및 월드 생성)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> physicsEngine.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3. 씬(Scene)에 물리 엔진 등록</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 등록 시 씬 내부의 객체들과 물리 시뮬레이션이 연결될 준비가 완료됩니다.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scene.physicsEngine </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> physicsEngine;</span></span></code></pre></div><h2 id="_2-시뮬레이션-자동-통합" tabindex="-1">2. 시뮬레이션 자동 통합 <a class="header-anchor" href="#_2-시뮬레이션-자동-통합" aria-label="Permalink to &quot;2. 시뮬레이션 자동 통합&quot;">​</a></h2><p>RedGPU는 씬(Scene)에 등록된 물리 엔진을 렌더링 루프와 동기화하여 <strong>자동으로 업데이트</strong>합니다. 따라서 개발자가 별도의 <code>step()</code> 함수를 매 프레임 호출할 필요가 없습니다.</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 씬에 물리 엔진을 등록하는 것만으로 자동 시뮬레이션이 시작됩니다.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scene.physicsEngine </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> physicsEngine;</span></span></code></pre></div><p>기본적으로 초당 60회(60FPS)의 고정된 간격으로 물리 연산이 수행되어, 주사율이 다른 모니터 환경에서도 일관된 물리 법칙이 적용됩니다.</p><h2 id="_3-물리-바디-body-생성-및-연결" tabindex="-1">3. 물리 바디(Body) 생성 및 연결 <a class="header-anchor" href="#_3-물리-바디-body-생성-및-연결" aria-label="Permalink to &quot;3. 물리 바디(Body) 생성 및 연결&quot;">​</a></h2><p>일반적인 메쉬 객체에 물리적 특성을 부여하려면 <code>createBody()</code>를 사용합니다. RedGPU의 물리 시스템은 생성된 바디의 상태(위치, 회전)를 메쉬의 트랜스폼에 자동으로 동기화합니다.</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> box</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU.Display.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Mesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(redGPUContext, geometry, material);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scene.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(box);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 메쉬에 동적(Dynamic) 물리 특성 부여</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> body</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> physicsEngine.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createBody</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(box, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    type: RedGPU.Physics.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PHYSICS_BODY_TYPE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DYNAMIC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 물리 법칙의 영향을 받음</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    shape: RedGPU.Physics.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PHYSICS_SHAPE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BOX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 박스 형태의 충돌체</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mass: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,                                      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 질량 (kg)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    restitution: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                                // 탄성 (0 ~ 1)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 외부에서 힘(충격량) 적용 예시</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">applyImpulse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span></code></pre></div><h3 id="복합-콜라이더-compound-shapes" tabindex="-1">복합 콜라이더 (Compound Shapes) <a class="header-anchor" href="#복합-콜라이더-compound-shapes" aria-label="Permalink to &quot;복합 콜라이더 (Compound Shapes)&quot;">​</a></h3><p><code>createBody</code> 호출 시 전달된 메쉬에 자식 메쉬들이 포함되어 있다면, RedGPU는 계층 구조를 자동으로 분석하여 모든 자식의 형상을 포함하는 <strong>복합 콜라이더</strong>를 생성합니다.</p><h2 id="_4-전체-상수-및-설정-명세" tabindex="-1">4. 전체 상수 및 설정 명세 <a class="header-anchor" href="#_4-전체-상수-및-설정-명세" aria-label="Permalink to &quot;4. 전체 상수 및 설정 명세&quot;">​</a></h2><h3 id="physics-body-type" tabindex="-1">PHYSICS_BODY_TYPE <a class="header-anchor" href="#physics-body-type" aria-label="Permalink to &quot;PHYSICS_BODY_TYPE&quot;">​</a></h3><p>물체가 월드와 상호작용하는 물리적 성격을 정의합니다.</p><ul><li><code>DYNAMIC</code>: 중력과 충돌에 반응하며 자유롭게 움직입니다.</li><li><code>STATIC</code>: 공간에 고정되어 움직이지 않으며 다른 물체와 충돌만 합니다. (바닥, 벽 등)</li><li><code>KINEMATIC</code>: (기본값) 물리 법칙은 무시하고 코드로 직접 움직임을 제어합니다.</li><li><code>KINEMATIC_POSITION</code>: 위치와 회전값을 직접 지정하여 제어하며, 다른 물체를 밀어낼 수 있습니다.</li><li><code>KINEMATIC_VELOCITY</code>: 속도(Velocity)를 지정하여 움직임을 제어합니다.</li></ul><h3 id="physics-shape" tabindex="-1">PHYSICS_SHAPE <a class="header-anchor" href="#physics-shape" aria-label="Permalink to &quot;PHYSICS_SHAPE&quot;">​</a></h3><p>시뮬레이션에서 사용하는 충돌체의 형상입니다.</p><ul><li><code>BOX</code>: 직육면체 형태.</li><li><code>SPHERE</code>: 구 형태.</li><li><code>CAPSULE</code>: 캡슐 형태.</li><li><code>CYLINDER</code>: 원기둥 형태.</li><li><code>HEIGHTFIELD</code>: 그리드 기반 높이맵 데이터(지형)를 위한 형상.</li><li><code>MESH</code>: 복잡한 메쉬 기하구조를 그대로 사용하는 정밀 콜라이더.</li></ul><h3 id="bodyparams-createbody-설정-옵션" tabindex="-1">BodyParams (createBody 설정 옵션) <a class="header-anchor" href="#bodyparams-createbody-설정-옵션" aria-label="Permalink to &quot;BodyParams (createBody 설정 옵션)&quot;">​</a></h3><p><code>createBody()</code> 호출 시 두 번째 인자로 전달할 수 있는 모든 옵션입니다.</p><ul><li><code>type</code>: 바디 타입 (<code>PHYSICS_BODY_TYPE</code>)</li><li><code>shape</code>: 충돌체 형상 (<code>PHYSICS_SHAPE</code>)</li><li><code>mass</code>: 질량 (기본값: 1.0)</li><li><code>friction</code>: 마찰 계수 (0.0 ~ 1.0)</li><li><code>restitution</code>: 탄성 계수 (0.0 ~ 1.0, 1.0이면 완전 탄성 충돌)</li><li><code>linearDamping</code>: 선형 이동에 대한 공기 저항 등의 감쇠력</li><li><code>angularDamping</code>: 회전에 대한 감쇠력</li><li><code>isSensor</code>: true 설정 시 물리적 충돌 반응 없이 겹침(Overlap) 이벤트만 발생시킵니다.</li><li><code>enableCCD</code>: 연속 충돌 감지 활성화. 매우 빠르게 움직이는 물체가 얇은 벽을 뚫고 나가는 현상을 방지합니다.</li><li><code>heightData</code>: <code>shape</code>가 <code>HEIGHTFIELD</code>일 때 필수인 지형 데이터 객체.</li></ul><hr><h2 id="_5-라이브-예제" tabindex="-1">5. 라이브 예제 <a class="header-anchor" href="#_5-라이브-예제" aria-label="Permalink to &quot;5. 라이브 예제&quot;">​</a></h2><p>분야별 예제를 통해 물리 엔진의 실제 활용법을 확인해 보세요.</p><h3 id="_5-1-기초-및-형상" tabindex="-1">5.1 기초 및 형상 <a class="header-anchor" href="#_5-1-기초-및-형상" aria-label="Permalink to &quot;5.1 기초 및 형상&quot;">​</a></h3><ul><li><a href="https://redcamel.github.io/RedGPU/examples/physics/basic/" target="_blank" rel="noreferrer">기본 시뮬레이션 및 중력 테스트</a></li><li><a href="https://redcamel.github.io/RedGPU/examples/physics/shapes/" target="_blank" rel="noreferrer">다양한 충돌체 형상 (Shapes)</a></li><li><a href="https://redcamel.github.io/RedGPU/examples/physics/heightField/" target="_blank" rel="noreferrer">지형(Heightfield) 시뮬레이션</a></li></ul><h3 id="_5-2-컨트롤러-및-상호작용" tabindex="-1">5.2 컨트롤러 및 상호작용 <a class="header-anchor" href="#_5-2-컨트롤러-및-상호작용" aria-label="Permalink to &quot;5.2 컨트롤러 및 상호작용&quot;">​</a></h3><ul><li><a href="https://redcamel.github.io/RedGPU/examples/physics/characterController/" target="_blank" rel="noreferrer">키네마틱(Kinematic) 캐릭터 제어</a></li><li><a href="https://redcamel.github.io/RedGPU/examples/physics/advancedCharacterController/" target="_blank" rel="noreferrer">고급 캐릭터 컨트롤러 (계단/경사로)</a></li><li><a href="https://redcamel.github.io/RedGPU/examples/physics/raycast/" target="_blank" rel="noreferrer">마우스 클릭 및 레이캐스트 상호작용</a></li></ul><h3 id="_5-3-조인트-및-고급-물리" tabindex="-1">5.3 조인트 및 고급 물리 <a class="header-anchor" href="#_5-3-조인트-및-고급-물리" aria-label="Permalink to &quot;5.3 조인트 및 고급 물리&quot;">​</a></h3><ul><li><a href="https://redcamel.github.io/RedGPU/examples/physics/joints/" target="_blank" rel="noreferrer">기본 조인트 (Joints)</a></li><li><a href="https://redcamel.github.io/RedGPU/examples/physics/revoluteJoint/" target="_blank" rel="noreferrer">회전 조인트 (Revolute)</a></li><li><a href="https://redcamel.github.io/RedGPU/examples/physics/springJoint/" target="_blank" rel="noreferrer">스프링 및 유연한 연결 (Spring)</a></li></ul><hr><h2 id="핵심-요약" tabindex="-1">핵심 요약 <a class="header-anchor" href="#핵심-요약" aria-label="Permalink to &quot;핵심 요약&quot;">​</a></h2><ol><li><code>RapierPhysics</code>를 별도로 임포트하고 <strong>비동기 초기화</strong>가 필요합니다.</li><li><code>scene.physicsEngine</code> 등록 후 렌더 루프에서 <code>step(dt)</code>을 호출해야 시뮬레이션이 동작합니다.</li><li><code>createBody</code>는 메쉬의 계층 구조를 자동으로 물리 월드에 반영합니다.</li></ol>`,40)])])}const g=i(n,[["render",t]]);export{c as __pageData,g as default};
