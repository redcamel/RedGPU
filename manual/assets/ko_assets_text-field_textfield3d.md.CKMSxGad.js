import{f as p,D as e,o as d,c as r,a2 as t,G as n,w as l,k as s,a}from"./chunks/framework.DpNgdNqH.js";const D=JSON.parse('{"title":"TextField3D","description":"","frontmatter":{"title":"TextField3D","order":3},"headers":[],"relativePath":"ko/assets/text-field/textfield3d.md","filePath":"ko/assets/text-field/textfield3d.md","lastUpdated":1770635218000}'),o={name:"ko/assets/text-field/textfield3d.md"};function E(g,i,c,y,F,u){const h=e("CodePen"),k=e("ClientOnly");return d(),r("div",null,[i[1]||(i[1]=t(`<h1 id="textfield3d" tabindex="-1">TextField3D <a class="header-anchor" href="#textfield3d" aria-label="Permalink to &quot;TextField3D&quot;">​</a></h1><p><strong>TextField3D</strong> 는 3D 공간 상의 실제 좌표(<code>x, y, z</code>)에 배치되는 텍스트 객체입니다. 월드 내의 표지판, 캐릭터 머리 위의 이름표, 또는 특정 객체에 부착된 설명문 등을 만들 때 유용합니다.</p><h2 id="_1-기본-사용법" tabindex="-1">1. 기본 사용법 <a class="header-anchor" href="#_1-기본-사용법" aria-label="Permalink to &quot;1. 기본 사용법&quot;">​</a></h2><p><code>TextField3D</code> 는 일반적인 <strong>Mesh</strong> 와 동일하게 다루어지며, 3D 공간 내에 물리적으로 위치합니다.</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> textField</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU.Display.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TextField3D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(redGPUContext, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;3D World Text&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">textField.y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 공중에 배치</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scene.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(textField);</span></span></code></pre></div><h2 id="_2-빌보드-billboard-및-크기-제어" tabindex="-1">2. 빌보드 (Billboard) 및 크기 제어 <a class="header-anchor" href="#_2-빌보드-billboard-및-크기-제어" aria-label="Permalink to &quot;2. 빌보드 (Billboard) 및 크기 제어&quot;">​</a></h2><p>3D 텍스트는 카메라의 위치에 따라 측면이나 뒷면이 보일 수 있습니다. 텍스트를 항상 정면으로 보이게 하려면 <strong>Billboard</strong> 기능을 활성화하며, 필요에 따라 월드 단위 크기나 고정된 픽셀 크기를 설정할 수 있습니다.</p><h3 id="빌보드-설정" tabindex="-1">빌보드 설정 <a class="header-anchor" href="#빌보드-설정" aria-label="Permalink to &quot;빌보드 설정&quot;">​</a></h3><ul><li><strong><code>useBillboard</code></strong>: 활성화 시 카메라가 회전해도 항상 텍스트가 정면을 향합니다.</li></ul><h3 id="크기-및-렌더링-모드" tabindex="-1">크기 및 렌더링 모드 <a class="header-anchor" href="#크기-및-렌더링-모드" aria-label="Permalink to &quot;크기 및 렌더링 모드&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">속성명</th><th style="text-align:left;">설명</th><th style="text-align:left;">기본값</th></tr></thead><tbody><tr><td style="text-align:left;"><strong><code>worldSize</code></strong></td><td style="text-align:left;">월드 공간에서의 세로 크기 (Unit 단위). 가로 크기는 텍스트 길이에 맞춰 자동 조절됩니다.</td><td style="text-align:left;"><code>1</code></td></tr><tr><td style="text-align:left;"><strong><code>usePixelSize</code></strong></td><td style="text-align:left;">고정 픽셀 크기 모드 사용 여부. <code>true</code>일 경우 거리에 관계없이 렌더링된 물리 픽셀 크기로 표시됩니다.</td><td style="text-align:left;"><code>false</code></td></tr></tbody></table><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. 월드 단위 크기 설정 (거리에 따라 작아짐)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">textField.worldSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. 고정 픽셀 크기 설정 (거리에 관계없이 가독성 유지)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">textField.usePixelSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h2 id="_3-월드-사이즈와-픽셀-사이즈-폰트-의-관계" tabindex="-1">3. 월드 사이즈와 픽셀 사이즈(폰트)의 관계 <a class="header-anchor" href="#_3-월드-사이즈와-픽셀-사이즈-폰트-의-관계" aria-label="Permalink to &quot;3. 월드 사이즈와 픽셀 사이즈(폰트)의 관계&quot;">​</a></h2><p><code>TextField3D</code>에서 텍스트의 크기와 선명도를 결정하는 세 가지 핵심 속성의 관계를 이해하는 것이 중요합니다.</p><h3 id="_3-1-폰트-사이즈-fontsize" tabindex="-1">3.1 폰트 사이즈 (<code>fontSize</code>) <a class="header-anchor" href="#_3-1-폰트-사이즈-fontsize" aria-label="Permalink to &quot;3.1 폰트 사이즈 (\`fontSize\`)&quot;">​</a></h3><ul><li><strong>역할</strong>: 내부적으로 텍스트를 비트맵으로 그릴 때의 **해상도(품질)**를 결정합니다.</li><li><strong>특징</strong>: <code>fontSize</code>가 클수록 더 크고 선명한 원본 텍스처가 생성됩니다. 3D 공간에서의 물리적 크기를 직접 결정하기보다는, 출력물의 &#39;화질&#39;을 결정하는 요소로 이해해야 합니다.</li></ul><h3 id="_3-2-월드-사이즈-worldsize" tabindex="-1">3.2 월드 사이즈 (<code>worldSize</code>) <a class="header-anchor" href="#_3-2-월드-사이즈-worldsize" aria-label="Permalink to &quot;3.2 월드 사이즈 (\`worldSize\`)&quot;">​</a></h3><ul><li><strong>역할</strong>: 3D 월드 공간 내에서의 <strong>물리적 세로 높이</strong>(Unit 단위)를 결정합니다.</li><li><strong>동작</strong>: <code>usePixelSize</code>가 <code>false</code>일 때 작동하며, 카메라와의 거리에 따라 원근감이 적용되어 크기가 변합니다.</li></ul><h3 id="_3-3-고정-픽셀-모드-usepixelsize" tabindex="-1">3.3 고정 픽셀 모드 (<code>usePixelSize</code>) <a class="header-anchor" href="#_3-3-고정-픽셀-모드-usepixelsize" aria-label="Permalink to &quot;3.3 고정 픽셀 모드 (\`usePixelSize\`)&quot;">​</a></h3><ul><li><strong>역할</strong>: 3D 공간에 위치하지만, 화면에는 <strong>실제 렌더링된 픽셀 크기</strong> 그대로 표시합니다.</li><li><strong>폰트와의 관계</strong>: 이 모드가 활성화되면 <code>worldSize</code>는 무시되고, <code>fontSize</code>에 의해 생성된 실제 텍스처의 높이가 화면상의 출력 크기가 됩니다. 따라서 아이콘이나 이름표처럼 거리에 상관없이 일정한 가독성을 유지해야 할 때 매우 유용합니다.</li></ul><div class="tip custom-block"><p class="custom-block-title">[최적화 팁]</p><p><code>usePixelSize</code>를 사용할 때 텍스트가 너무 크거나 작게 보인다면 <code>worldSize</code>가 아닌 <code>fontSize</code>를 조절하십시오. 반대로 일반적인 3D 오브젝트처럼 동작해야 한다면 <code>fontSize</code>는 텍스처의 선명도를 위해 적절히 높은 값(예: 24~48)으로 두고, 실제 크기는 <code>worldSize</code>로 조절하는 것이 좋습니다.</p></div><h2 id="_4-실습-예제-3d-텍스트-구성" tabindex="-1">4. 실습 예제: 3D 텍스트 구성 <a class="header-anchor" href="#_4-실습-예제-3d-텍스트-구성" aria-label="Permalink to &quot;4. 실습 예제: 3D 텍스트 구성&quot;">​</a></h2><p>GLTF 모델과 함께 배치된 3D 텍스트를 구성해 봅니다.</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;https://redcamel.github.io/RedGPU/dist/index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RedGPU.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(canvas, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">redGPUContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> scene</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU.Display.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Scene</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 1. 3D 텍스트 생성 및 배치</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> text3D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU.Display.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TextField3D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(redGPUContext, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Damaged Helmet&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    text3D.y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    text3D.fontSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    text3D.background </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;rgba(0, 204, 153, 0.8)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    text3D.padding </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    text3D.useBillboard </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 카메라를 따라 회전</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    text3D.worldSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 월드 크기 설정</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    scene.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text3D);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 2. 모델 및 환경 설정</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ibl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU.Resource.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IBL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(redGPUContext, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;https://redcamel.github.io/RedGPU/examples/assets/hdr/2k/the_sky_is_on_fire_2k.hdr&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> controller</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU.Camera.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OrbitController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(redGPUContext);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    controller.distance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> view</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU.Display.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View3D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(redGPUContext, scene, controller);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    view.ibl </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ibl;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    redGPUContext.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(view);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GLTFLoader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(redGPUContext, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/DamagedHelmet/glTF-Binary/DamagedHelmet.glb&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">loader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        scene.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loader.resultMesh);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Renderer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(redGPUContext);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="라이브-데모" tabindex="-1">라이브 데모 <a class="header-anchor" href="#라이브-데모" aria-label="Permalink to &quot;라이브 데모&quot;">​</a></h3><p>아래 예제에서 설정 조합에 따른 텍스트 필드의 차이를 확인해 보세요.</p>`,26)),n(k,null,{default:l(()=>[n(h,{title:"RedGPU Basics - TextField3D Showcase",slugHash:"textfield3d-showcase"},{default:l(()=>[...i[0]||(i[0]=[s("pre",{"data-lang":"html"},`<canvas id="redgpu-canvas"></canvas>
`,-1),s("pre",{"data-lang":"css"},`body { margin: 0; overflow: hidden; background: #000; }
canvas { display: block; width: 100vw; height: 100vh; }
`,-1),s("pre",{"data-lang":"js"},[a(`import * as RedGPU from "https://redcamel.github.io/RedGPU/dist/index.js";
`),s("p",null,'const canvas = document.getElementById("redgpu-canvas");'),a(`
`),s("p",null,`RedGPU.init(canvas, (redGPUContext) => {
const scene = new RedGPU.Display.Scene();`),a(`
`),s("pre",null,[s("code",null,`// IBL Setup
const ibl = new RedGPU.Resource.IBL(
    redGPUContext, 
    'https://redcamel.github.io/RedGPU/examples/assets/hdr/2k/the_sky_is_on_fire_2k.hdr'
);

// 헬멧 및 텍스트 필드 그룹 생성을 위한 헬퍼 함수
const createCase = (x, label, color, useBB, usePS) => {
    // 1. 모델 로딩
    new RedGPU.GLTFLoader(
        redGPUContext,
        'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/DamagedHelmet/glTF-Binary/DamagedHelmet.glb',
        (loader) => {
            const mesh = loader.resultMesh;
            mesh.x = x;
            scene.addChild(mesh);
        }
    );

    // 2. 텍스트 필드 생성
    const text = new RedGPU.Display.TextField3D(redGPUContext, label);
    text.x = x; text.y = 1.5;
    text.background = color;
    text.padding = 15;
    text.useBillboard = useBB;
    text.usePixelSize = usePS;
    scene.addChild(text);
};

// 케이스 배치
createCase(-3, "Billboard: OFF", "rgba(255, 0, 0, 0.8)", false, false);
createCase(0, "World Size", "rgba(0, 204, 153, 0.8)", true, false);
createCase(3, "Pixel Size", "rgba(0, 102, 255, 0.8)", true, true);

const controller = new RedGPU.Camera.OrbitController(redGPUContext);
controller.distance = 10;
const view = new RedGPU.Display.View3D(redGPUContext, scene, controller);
view.ibl = ibl;
view.skybox = new RedGPU.Display.SkyBox(redGPUContext, ibl.environmentTexture);
redGPUContext.addView(view);

const renderer = new RedGPU.Renderer();
renderer.start(redGPUContext);
`)]),a(`
`),s("p",null,"});"),a(`
`)],-1)])]),_:1})]),_:1}),i[2]||(i[2]=t('<h2 id="핵심-요약" tabindex="-1">핵심 요약 <a class="header-anchor" href="#핵심-요약" aria-label="Permalink to &quot;핵심 요약&quot;">​</a></h2><ul><li><strong>TextField3D</strong> : 월드 공간 내 실제 좌표에 배치되는 텍스트 객체입니다.</li><li><strong>CSS 스타일</strong>: 색상, 배경, 보더 등 웹 표준 스타일을 그대로 적용할 수 있습니다.</li><li><strong>Billboard</strong> : 3D 텍스트가 항상 카메라를 바라보게 설정하여 가독성을 높일 수 있습니다.</li></ul><hr><h2 id="다음-단계" tabindex="-1">다음 단계 <a class="header-anchor" href="#다음-단계" aria-label="Permalink to &quot;다음 단계&quot;">​</a></h2><p>사용자의 입력에 반응하는 역동적인 콘텐츠를 만들기 위해 인터렉션 시스템을 알아봅니다.</p><ul><li><strong><a href="./../../interaction/">인터렉션</a></strong></li></ul>',6))])}const C=p(o,[["render",E]]);export{D as __pageData,C as default};
