import{f as t,o as n,c as a,a2 as o}from"./chunks/framework.DpNgdNqH.js";const m=JSON.parse('{"title":"View System","description":"","frontmatter":{"title":"View System","order":3},"headers":[],"relativePath":"en/view-system/index.md","filePath":"en/view-system/index.md","lastUpdated":1770635218000}'),r={name:"en/view-system/index.md"};function s(i,e,l,d,g,c){return n(),a("div",null,[...e[0]||(e[0]=[o('<h1 id="view-system" tabindex="-1">View System <a class="header-anchor" href="#view-system" aria-label="Permalink to &quot;View System&quot;">​</a></h1><p>If <strong>RedGPUContext</strong>—learned previously—is the &#39;environment&#39; where the engine runs, the <strong>View System</strong> is the &#39;frame&#39; that determines how actual content will be displayed within that environment.</p><p>RedGPU&#39;s <strong>View System</strong> is the core architecture of the engine and performs the following roles:</p><ul><li><strong>Scene Composition</strong>: Defining the hierarchical placement of objects and lights within 3D space.</li><li><strong>Pipeline Control</strong>: Managing the rendering process and data flow.</li><li><strong>Screen Output</strong>: Displaying the final results on the browser screen.</li></ul><h2 id="core-components" tabindex="-1">Core Components <a class="header-anchor" href="#core-components" aria-label="Permalink to &quot;Core Components&quot;">​</a></h2><p>The four core modules that make up RedGPU&#39;s rendering pipeline are as follows. Each module performs an independent role and is organically combined.</p><table tabindex="0"><thead><tr><th style="text-align:left;">Component</th><th style="text-align:left;">Class Name</th><th style="text-align:left;">Role and Function</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>View3D</strong></td><td style="text-align:left;"><code>RedGPU.Display.View3D</code></td><td style="text-align:left;">Specifies the screen output area (Viewport/Scissor), applies skyboxes and post-effects, and manages debugging tools.</td></tr><tr><td style="text-align:left;"><strong>Scene</strong></td><td style="text-align:left;"><code>RedGPU.Display.Scene</code></td><td style="text-align:left;">Manages the hierarchical structure of objects to be rendered, as well as lighting data and the scene background color.</td></tr><tr><td style="text-align:left;"><strong>Camera</strong></td><td style="text-align:left;"><code>RedGPU.Camera.*</code></td><td style="text-align:left;">Calculates the projection and view matrices that convert 3D space to a 2D screen, and provides frustum information.</td></tr><tr><td style="text-align:left;"><strong>Controller</strong></td><td style="text-align:left;"><code>RedGPU.Camera.*Controller</code></td><td style="text-align:left;">Detects mouse, touch, and keyboard input, and updates the camera transform in real-time.</td></tr></tbody></table><h2 id="understanding-relationships" tabindex="-1">Understanding Relationships <a class="header-anchor" href="#understanding-relationships" aria-label="Permalink to &quot;Understanding Relationships&quot;">​</a></h2><p>Before learning more, it&#39;s important to understand how these elements are connected to each other.</p><ol><li><strong>RedGPUContext</strong> has one or more <strong>View3D</strong> instances (e.g., a game screen and a minimap).</li><li>Each <strong>View3D</strong> links what to show (<strong>Scene</strong>) and where to see it from (<strong>Camera</strong>).</li><li>A <strong>Controller</strong> receives user input and moves the <strong>Camera</strong>.</li></ol><p>Thanks to this structure, a single <strong>Scene</strong> can be observed from different angles simultaneously through multiple windows (<strong>View3D</strong>).</p><hr><h2 id="learning-roadmap" tabindex="-1">Learning Roadmap <a class="header-anchor" href="#learning-roadmap" aria-label="Permalink to &quot;Learning Roadmap&quot;">​</a></h2><p>It is recommended to learn the detailed usage and configuration methods of each module in the following order:</p><ol><li><strong><a href="./view3d.html">View3D</a></strong>: The basic unit of screen rendering and layout configuration methods.</li><li><strong><a href="./scene.html">Scene</a></strong>: The container for composing the stage and managing lighting.</li><li><strong><a href="./camera.html">Camera</a></strong>: Understanding viewpoints that convert 3D coordinates to screen coordinates.</li><li><strong><a href="./controller.html">Controller</a></strong>: Interactive camera manipulation through mouse and touch.</li></ol>',15)])])}const p=t(r,[["render",s]]);export{m as __pageData,p as default};
