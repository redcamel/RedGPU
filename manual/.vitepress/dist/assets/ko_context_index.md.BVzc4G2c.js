import{D as i,o as h,c as p,a2 as a,G as t,w as k}from"./chunks/framework.DpNgdNqH.js";const g=JSON.parse('{"title":"RedGPU Context","description":"RedGPU 엔진의 시작점이자 리소스 관리자인 RedGPUContext에 대해 알아봅니다.","frontmatter":{"title":"RedGPU Context","description":"RedGPU 엔진의 시작점이자 리소스 관리자인 RedGPUContext에 대해 알아봅니다.","order":2},"headers":[],"relativePath":"ko/context/index.md","filePath":"ko/context/index.md","lastUpdated":1769835435000}'),d={name:"ko/context/index.md"},c=Object.assign(d,{setup(r){const n=`
    graph LR
        Init["RedGPU.init() 호출"] -->|비동기| Callback["onSuccess 콜백"]
        Callback -->|인스턴스 획득| Setup["씬 및 뷰 설정"]
        Setup -->|루프 시작| Render["Renderer.start()"]
        
        %% 커스텀 클래스 적용
        class Init,Render mermaid-system;
        class Callback mermaid-main;
`;return(o,s)=>{const e=i("MermaidResponsive"),l=i("ClientOnly");return h(),p("div",null,[s[0]||(s[0]=a('<h1 id="redgpucontext" tabindex="-1">RedGPUContext <a class="header-anchor" href="#redgpucontext" aria-label="Permalink to &quot;RedGPUContext&quot;">​</a></h1><p><strong>RedGPUContext</strong> 는 RedGPU 엔진이 동작하는 기반이 되는 객체입니다. 복잡한 WebGPU 초기화 과정을 대신 처리하며, 텍스처나 모델과 같은 각종 리소스를 생성하고 관리하는 중심 역할을 수행합니다.</p><h2 id="_1-역할과-주요-기능" tabindex="-1">1. 역할과 주요 기능 <a class="header-anchor" href="#_1-역할과-주요-기능" aria-label="Permalink to &quot;1. 역할과 주요 기능&quot;">​</a></h2><p>RedGPUContext는 엔진의 전반적인 상태를 관리하며 다음과 같은 기능을 제공합니다.</p><ul><li><strong>디바이스 관리</strong>: 브라우저와 GPU 하드웨어 간의 연결을 유지하고 통신을 담당합니다.</li><li><strong>리소스 생성</strong>: 메시, 텍스처, 재질 등 모든 3D 객체는 이 컨텍스트를 거쳐 생성됩니다.</li><li><strong>출력 제어</strong>: HTML 캔버스 요소와 연결되어 렌더링된 결과물을 화면에 표시합니다.</li></ul><h2 id="_2-초기화-프로세스" tabindex="-1">2. 초기화 프로세스 <a class="header-anchor" href="#_2-초기화-프로세스" aria-label="Permalink to &quot;2. 초기화 프로세스&quot;">​</a></h2><p>WebGPU 환경을 구축하기 위해 <code>RedGPU.init</code> 함수를 호출하여 비동기적으로 컨텍스트를 생성합니다.</p>',7)),t(l,null,{default:k(()=>[t(e,{definition:n})]),_:1}),s[1]||(s[1]=a(`<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;dist/index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> canvas</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;redgpu-canvas&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// RedGPU 초기화 요청</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RedGPU.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    canvas,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">redGPUContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 초기화 성공 시 redGPUContext 인스턴스를 획득합니다.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;RedGPUContext 준비 완료:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, redGPUContext);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 예: 씬 생성 (context 주입 필요)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> scene</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU.Display.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Scene</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">failReason</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 초기화 실패 시 (WebGPU 미지원 등) 처리</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;초기화 실패:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, failReason);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="_3-핵심-인터페이스" tabindex="-1">3. 핵심 인터페이스 <a class="header-anchor" href="#_3-핵심-인터페이스" aria-label="Permalink to &quot;3. 핵심 인터페이스&quot;">​</a></h2><h3 id="_3-1-뷰-등록과-관리" tabindex="-1">3.1 뷰 등록과 관리 <a class="header-anchor" href="#_3-1-뷰-등록과-관리" aria-label="Permalink to &quot;3.1 뷰 등록과 관리&quot;">​</a></h3><p>화면에 무엇을 그릴지 결정하는 <strong>뷰</strong>(View3D) 목록을 관리합니다. 생성된 뷰를 컨텍스트에 등록해야만 실제 렌더링 파이프라인에 포함됩니다.</p><table tabindex="0"><thead><tr><th style="text-align:left;">메서드</th><th style="text-align:left;">설명</th></tr></thead><tbody><tr><td style="text-align:left;"><code>addView(view)</code></td><td style="text-align:left;">렌더링할 뷰를 등록합니다.</td></tr><tr><td style="text-align:left;"><code>removeView(view)</code></td><td style="text-align:left;">등록된 뷰를 제거합니다.</td></tr><tr><td style="text-align:left;"><code>viewList</code></td><td style="text-align:left;">현재 등록된 모든 뷰의 목록을 반환합니다.</td></tr></tbody></table><h3 id="_3-2-캔버스-크기-자동-최적화" tabindex="-1">3.2 캔버스 크기 자동 최적화 <a class="header-anchor" href="#_3-2-캔버스-크기-자동-최적화" aria-label="Permalink to &quot;3.2 캔버스 크기 자동 최적화&quot;">​</a></h3><p>RedGPU는 캔버스 요소의 <strong>표시 크기</strong>(Layout Size) 변화를 실시간으로 감지합니다. 브라우저 창의 크기가 바뀌거나 CSS 레이아웃에 의해 캔버스가 차지하는 영역이 변경되면, 엔진은 이에 맞춰 렌더링 해상도를 자동으로 재설정합니다.</p><p>이 과정에서 <code>onResize</code> 콜백을 정의하면, 크기 변경 시점에 맞춘 추가적인 로직을 실행할 수 있습니다.</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 크기 변경 시 호출될 콜백 정의</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">redGPUContext.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onResize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`캔버스 크기 변경: \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">width</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}x\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">height</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // UI 재배치나 카메라 속성 조정 등을 수행합니다.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h2 id="_4-컨텍스트-주입의-필요성" tabindex="-1">4. 컨텍스트 주입의 필요성 <a class="header-anchor" href="#_4-컨텍스트-주입의-필요성" aria-label="Permalink to &quot;4. 컨텍스트 주입의 필요성&quot;">​</a></h2><p>RedGPU의 거의 모든 객체는 생성 시 첫 번째 인자로 <code>redGPUContext</code> 를 요구합니다.</p><p>이는 각 객체가 GPU 메모리를 사용하기 위해 **&quot;어느 GPU 디바이스에 데이터를 생성해야 하는지&quot;**를 알아야 하기 때문입니다. 컨텍스트를 전달함으로써 엔진은 객체와 실제 하드웨어 리소스를 올바르게 연결할 수 있습니다.</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [O] 올바른 방법: 생성 시 컨텍스트를 전달합니다.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> material</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU.Material.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ColorMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(redGPUContext);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [X] 잘못된 방법: 컨텍스트 누락 시 에러가 발생합니다.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// const material = new RedGPU.Material.ColorMaterial();</span></span></code></pre></div><h2 id="핵심-요약" tabindex="-1">핵심 요약 <a class="header-anchor" href="#핵심-요약" aria-label="Permalink to &quot;핵심 요약&quot;">​</a></h2><ul><li><strong>엔진의 시작점</strong>: <code>RedGPU.init</code> 을 통해 비동기적으로 생성되는 필수 객체입니다.</li><li><strong>필수 인자</strong>: 메시나 재질 등 모든 그래픽 객체 생성 시 반드시 주입해야 합니다.</li><li><strong>통합 관리자</strong>: GPU 디바이스, 캔버스, 렌더링 뷰를 하나로 묶어 관리합니다.</li></ul><h2 id="다음-단계" tabindex="-1">다음 단계 <a class="header-anchor" href="#다음-단계" aria-label="Permalink to &quot;다음 단계&quot;">​</a></h2><p>RedGPUContext를 통해 엔진을 구동할 준비를 마쳤습니다. 하지만 아직 화면은 비어있습니다.</p><p>이제 빈 캔버스 위에 <strong>카메라</strong>(Camera) 를 배치하고, 물체를 담을 <strong>공간</strong>(Scene) 을 정의하여 실제 3D 세계를 구성하는 방법을 알아볼 차례입니다.</p><ul><li><strong><a href="./../view-system/">화면 구성</a></strong></li></ul>`,19))])}}});export{g as __pageData,c as default};
