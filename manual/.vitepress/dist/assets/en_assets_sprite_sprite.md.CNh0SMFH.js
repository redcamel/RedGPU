import{f as d,D as s,o as p,c as h,a2 as a,G as n,w as l,k as e,a as i}from"./chunks/framework.DpNgdNqH.js";const f=JSON.parse('{"title":"Sprite3D","description":"","frontmatter":{"title":"Sprite3D","order":2},"headers":[],"relativePath":"en/assets/sprite/sprite.md","filePath":"en/assets/sprite/sprite.md","lastUpdated":1770637469000}'),c={name:"en/assets/sprite/sprite.md"};function g(k,t,u,y,x,m){const r=s("CodePen"),o=s("ClientOnly");return p(),h("div",null,[t[1]||(t[1]=a(`<h1 id="sprite3d" tabindex="-1">Sprite3D <a class="header-anchor" href="#sprite3d" aria-label="Permalink to &quot;Sprite3D&quot;">​</a></h1><p><strong>Sprite3D</strong> is a 2D plane object placed within 3D space. Unlike general meshes, it has a built-in <strong>Billboard</strong> feature, making it optimized for implementing elements that must always face the front regardless of the camera&#39;s rotation (icons, name tags, special effects, etc.).</p><h2 id="_1-key-features" tabindex="-1">1. Key Features <a class="header-anchor" href="#_1-key-features" aria-label="Permalink to &quot;1. Key Features&quot;">​</a></h2><ul><li><strong>Billboard</strong>: Supports the function to always face the camera by default.</li><li><strong>Automatic Aspect Ratio</strong>: Automatically calculates the aspect ratio of the assigned texture to adjust the size of the plane.</li><li><strong>UI Friendly</strong>: Combines position in 3D space (World Position) with 2D expression methods to provide UI elements with a sense of space.</li></ul><h2 id="_2-basic-usage" tabindex="-1">2. Basic Usage <a class="header-anchor" href="#_2-basic-usage" aria-label="Permalink to &quot;2. Basic Usage&quot;">​</a></h2><p><code>Sprite3D</code> internally uses <strong>Plane</strong> geometry and is used with <strong>BitmapMaterial</strong> to output images.</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;https://redcamel.github.io/RedGPU/dist/index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. Create Texture and Material</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> texture</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU.Resource.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BitmapTexture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(redGPUContext, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;https://redcamel.github.io/RedGPU/examples/assets/texture/crate.png&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> material</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU.Material.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BitmapMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(redGPUContext, texture);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. Create and Add Sprite</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sprite</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU.Display.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Sprite3D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(redGPUContext, material);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scene.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sprite);</span></span></code></pre></div><h2 id="_3-key-property-control" tabindex="-1">3. Key Property Control <a class="header-anchor" href="#_3-key-property-control" aria-label="Permalink to &quot;3. Key Property Control&quot;">​</a></h2><p>Key properties controlling the sprite&#39;s billboard behavior and visual representation.</p><h3 id="billboard-setup" tabindex="-1">Billboard Setup <a class="header-anchor" href="#billboard-setup" aria-label="Permalink to &quot;Billboard Setup&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">Property Name</th><th style="text-align:left;">Description</th><th style="text-align:left;">Default Value</th></tr></thead><tbody><tr><td style="text-align:left;"><strong><code>useBillboard</code></strong></td><td style="text-align:left;">Whether to always face the camera</td><td style="text-align:left;"><code>true</code></td></tr></tbody></table><h3 id="size-and-rendering-mode" tabindex="-1">Size and Rendering Mode <a class="header-anchor" href="#size-and-rendering-mode" aria-label="Permalink to &quot;Size and Rendering Mode&quot;">​</a></h3><p><code>Sprite3D</code> provides options to render in world units or fixed pixel sizes.</p><table tabindex="0"><thead><tr><th style="text-align:left;">Property Name</th><th style="text-align:left;">Description</th><th style="text-align:left;">Default Value</th></tr></thead><tbody><tr><td style="text-align:left;"><strong><code>worldSize</code></strong></td><td style="text-align:left;">Vertical size in world space (Unit). Horizontal size is automatically adjusted.</td><td style="text-align:left;"><code>1</code></td></tr><tr><td style="text-align:left;"><strong><code>usePixelSize</code></strong></td><td style="text-align:left;">Whether to use fixed pixel size mode. If <code>true</code>, it renders at a constant pixel size regardless of distance.</td><td style="text-align:left;"><code>false</code></td></tr><tr><td style="text-align:left;"><strong><code>pixelSize</code></strong></td><td style="text-align:left;">Fixed pixel size value (in <code>px</code>). Only applied when <code>usePixelSize</code> is <code>true</code>.</td><td style="text-align:left;"><code>0</code></td></tr></tbody></table><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. Set world unit size (shrinks with distance)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sprite.worldSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. Set fixed pixel size (UI style, size remains constant regardless of distance)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sprite.usePixelSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sprite.pixelSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="_3-3-relationship-between-world-size-and-pixel-size" tabindex="-1">3.3 Relationship between World Size and Pixel Size <a class="header-anchor" href="#_3-3-relationship-between-world-size-and-pixel-size" aria-label="Permalink to &quot;3.3 Relationship between World Size and Pixel Size&quot;">​</a></h3><p>Understanding the relationship between the key factors that determine size and clarity in <code>Sprite3D</code> allows for optimal presentation suited to each situation.</p><h4 id="_3-3-1-texture-resolution" tabindex="-1">3.3.1 Texture Resolution <a class="header-anchor" href="#_3-3-1-texture-resolution" aria-label="Permalink to &quot;3.3.1 Texture Resolution&quot;">​</a></h4><ul><li><strong>Role</strong>: The size of the original image determines the <strong>maximum clarity</strong> of the sprite.</li><li><strong>Feature</strong>: When using <code>usePixelSize</code> mode, setting <code>pixelSize</code> larger than the original resolution may result in a blurry image.</li></ul><h4 id="_3-3-2-world-size-worldsize" tabindex="-1">3.3.2 World Size (<code>worldSize</code>) <a class="header-anchor" href="#_3-3-2-world-size-worldsize" aria-label="Permalink to &quot;3.3.2 World Size (\`worldSize\`)&quot;">​</a></h4><ul><li><strong>Role</strong>: Determines the <strong>physical vertical height</strong> (in Units) within the 3D world space.</li><li><strong>Behavior</strong>: Operates when <code>usePixelSize</code> is <code>false</code>, and perspective is applied based on distance like a general 3D object.</li></ul><h4 id="_3-3-3-fixed-pixel-mode-usepixelsize-pixelsize" tabindex="-1">3.3.3 Fixed Pixel Mode (<code>usePixelSize</code> &amp; <code>pixelSize</code>) <a class="header-anchor" href="#_3-3-3-fixed-pixel-mode-usepixelsize-pixelsize" aria-label="Permalink to &quot;3.3.3 Fixed Pixel Mode (\`usePixelSize\` &amp; \`pixelSize\`)&quot;">​</a></h4><ul><li><strong>Role</strong>: Placed in 3D space, but displayed on the screen at the <strong>specified pixel size</strong>.</li><li><strong>Feature</strong>: When this mode is activated, <code>worldSize</code> is ignored. By default, the <strong>original height</strong> of the texture when loaded is automatically assigned to <code>pixelSize</code>. Use this when constant size and readability must be maintained regardless of distance, such as for icons or markers.</li></ul><div class="tip custom-block"><p class="custom-block-title">[Adjusting Pixel Size]</p><p>If the sprite appears too large or small while <code>usePixelSize</code> is active, adjust the <code>pixelSize</code> property directly instead of <code>worldSize</code>.</p></div><h2 id="_4-practical-example-comparison-by-rendering-mode" tabindex="-1">4. Practical Example: Comparison by Rendering Mode <a class="header-anchor" href="#_4-practical-example-comparison-by-rendering-mode" aria-label="Permalink to &quot;4. Practical Example: Comparison by Rendering Mode&quot;">​</a></h2><p>Let&#39;s place sprites with different settings in 3D space to check the visual differences.</p>`,26)),n(o,null,{default:l(()=>[n(r,{title:"RedGPU - Sprite3D Showcase",slugHash:"sprite3d-showcase"},{default:l(()=>[...t[0]||(t[0]=[e("pre",{"data-lang":"html"},`<canvas id="redgpu-canvas"></canvas>
`,-1),e("pre",{"data-lang":"css"},`body { margin: 0; overflow: hidden; background: #000; }
canvas { display: block; width: 100vw; height: 100vh; }
`,-1),e("pre",{"data-lang":"js"},[i(`import * as RedGPU from "https://redcamel.github.io/RedGPU/dist/index.js";
`),e("p",null,'const canvas = document.getElementById("redgpu-canvas");'),i(`
`),e("p",null,`RedGPU.init(canvas, (redGPUContext) => {
const scene = new RedGPU.Display.Scene();`),i(`
`),e("pre",null,[e("code",null,`// Create shared material
const texture = new RedGPU.Resource.BitmapTexture(redGPUContext, 'https://redcamel.github.io/RedGPU/examples/assets/texture/crate.png');
const material = new RedGPU.Material.BitmapMaterial(redGPUContext, texture);

// 1. Basic World Size
const sprite1 = new RedGPU.Display.Sprite3D(redGPUContext, material);
sprite1.x = -3; sprite1.y = 1;
sprite1.worldSize = 1.5;
scene.addChild(sprite1);

// 2. Fixed Pixel Size - size remains same even when moving away
const sprite2 = new RedGPU.Display.Sprite3D(redGPUContext, material);
sprite2.x = 3; sprite2.y = 1;
sprite2.usePixelSize = true;
sprite2.pixelSize = 100;
scene.addChild(sprite2);

// 3. Option Description Label (TextField3D)
const createLabel = (text, x, y) => {
    const label = new RedGPU.Display.TextField3D(redGPUContext, text);
    label.x = x; label.y = y;
    label.color = '#ffffff';
    label.fontSize = 16;
    label.background = '#ff3333';
    label.padding = 8;
    label.useBillboard = true;
    scene.addChild(label);
};

createLabel('World Size', -3, 2.5);
createLabel('Pixel Size', 3, 2.5);

// 3D View Setup
const controller = new RedGPU.Camera.OrbitController(redGPUContext);
controller.distance = 12;
const view = new RedGPU.Display.View3D(redGPUContext, scene, controller);
view.grid = true;
redGPUContext.addView(view);

// Start Rendering
const renderer = new RedGPU.Renderer();
renderer.start(redGPUContext);
`)]),i(`
`),e("p",null,"});"),i(`
`)],-1)])]),_:1})]),_:1}),t[2]||(t[2]=a('<hr><h2 id="key-summary" tabindex="-1">Key Summary <a class="header-anchor" href="#key-summary" aria-label="Permalink to &quot;Key Summary&quot;">​</a></h2><ul><li><strong>Sprite3D</strong> provides a <strong>Billboard</strong> feature that faces the camera head-on while having a 3D coordinate system.</li><li>You can implement UI-style elements that appear at a constant size regardless of distance via the <code>usePixelSize</code> property.</li><li>Geometry size is automatically adjusted according to the resolution and ratio of the texture, making it convenient to use.</li></ul><hr><h2 id="next-steps" tabindex="-1">Next Steps <a class="header-anchor" href="#next-steps" aria-label="Permalink to &quot;Next Steps&quot;">​</a></h2><p>Learn about animation effects using sprites.</p><ul><li><strong><a href="./../sprite/spritesheet.html">SpriteSheet3D</a></strong></li></ul>',7))])}const P=d(c,[["render",g]]);export{f as __pageData,P as default};
