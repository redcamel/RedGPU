import{f as s,o as e,c as a,a2 as n}from"./chunks/framework.DpNgdNqH.js";const k=JSON.parse('{"title":"Physics (Rapier)","description":"","frontmatter":{"title":"Physics (Rapier)","order":1},"headers":[],"relativePath":"en/plugins/physics.md","filePath":"en/plugins/physics.md","lastUpdated":1770625747000}'),t={name:"en/plugins/physics.md"};function l(o,i,r,h,p,c){return e(),a("div",null,[...i[0]||(i[0]=[n(`<h1 id="physics-plugin-rapier" tabindex="-1">Physics Plugin (Rapier) <a class="header-anchor" href="#physics-plugin-rapier" aria-label="Permalink to &quot;Physics Plugin (Rapier)&quot;">​</a></h1><p>RedGPU supports the high-performance WASM-based physics engine <strong>Rapier</strong> as a plugin. Through this plugin, you can seamlessly integrate rigid body simulation, precise collision detection, and character controllers in 3D space into the engine.</p><div class="warning custom-block"><p class="custom-block-title">Experimental Feature</p><p>The physics engine plugin is currently in the <strong>experimental stage</strong>. Please be aware that API specifications or behaviors may change without notice during development.</p></div><h2 id="_0-design-intent-for-interface-plugin-separation-and-integration" tabindex="-1">0. Design Intent for Interface/Plugin Separation and Integration <a class="header-anchor" href="#_0-design-intent-for-interface-plugin-separation-and-integration" aria-label="Permalink to &quot;0. Design Intent for Interface/Plugin Separation and Integration&quot;">​</a></h2><p>RedGPU&#39;s physics system is designed with a strict separation between the common interface (<code>IPhysicsEngine</code>) and the actual implementation (Plugin) for seamless integration.</p><ol><li><strong>Bundle Size Optimization</strong>: Physics engines (especially WASM-based ones) occupy significant binary space. Since not all projects require physics, excluding it from the main engine bundle optimizes initial loading speed.</li><li><strong>Seamless Integration</strong>: One of the most tedious tasks when using a physics engine is &#39;copying the coordinates of the physics world to 3D meshes every frame.&#39; RedGPU automates this at the engine level, so a single <code>createBody</code> call automatically reflects position, rotation, scale, and even <strong>complex child mesh hierarchies</strong> into the physics world.</li><li><strong>Interchangeability</strong>: User code depends on the established <code>IPhysicsEngine</code> interface. This provides the flexibility to switch to other physics engines (e.g., Cannon, Ammo, etc.) in the future with minimal modifications to existing scene configurations or logic code.</li><li><strong>Asynchronous Initialization Control</strong>: WASM loading is inherently an asynchronous task. By separating it into a plugin, developers can clearly control when the physics engine is ready without interfering with the main engine&#39;s initialization flow.</li></ol><h2 id="_1-initialization-and-setup" tabindex="-1">1. Initialization and Setup <a class="header-anchor" href="#_1-initialization-and-setup" aria-label="Permalink to &quot;1. Initialization and Setup&quot;">​</a></h2><p>The physics engine is separated from the main engine bundle and must be imported separately. Since it involves loading WASM binaries, initialization is performed asynchronously.</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;https://redcamel.github.io/RedGPU/dist/index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { RapierPhysics } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;https://redcamel.github.io/RedGPU/dist/plugins/physics/rapier/index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. Create physics engine instance</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> physicsEngine</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RapierPhysics</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. Initialize engine (Load WASM and create world)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> physicsEngine.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3. Register physics engine to the Scene</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Upon registration, preparation for connecting objects within the scene with physics simulation is completed.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scene.physicsEngine </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> physicsEngine;</span></span></code></pre></div><h2 id="_2-automatic-simulation-integration" tabindex="-1">2. Automatic Simulation Integration <a class="header-anchor" href="#_2-automatic-simulation-integration" aria-label="Permalink to &quot;2. Automatic Simulation Integration&quot;">​</a></h2><p>RedGPU synchronizes the physics engine registered in the Scene with the rendering loop and <strong>updates it automatically</strong>. Therefore, developers do not need to call a separate <code>step()</code> function every frame.</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Automatic simulation starts just by registering the physics engine to the scene.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scene.physicsEngine </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> physicsEngine;</span></span></code></pre></div><p>By default, physics calculations are performed at a fixed interval of 60 times per second (60FPS), ensuring consistent physics laws even in monitor environments with different refresh rates.</p><h2 id="_3-creating-and-connecting-physics-bodies" tabindex="-1">3. Creating and Connecting Physics Bodies <a class="header-anchor" href="#_3-creating-and-connecting-physics-bodies" aria-label="Permalink to &quot;3. Creating and Connecting Physics Bodies&quot;">​</a></h2><p>To grant physical properties to a general mesh object, use <code>createBody()</code>. RedGPU&#39;s physics system automatically synchronizes the state (position, rotation) of the created body to the mesh&#39;s transform.</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> box</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RedGPU.Display.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Mesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(redGPUContext, geometry, material);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scene.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(box);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Grant dynamic physical properties to the mesh</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> body</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> physicsEngine.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createBody</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(box, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    type: RedGPU.Physics.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PHYSICS_BODY_TYPE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DYNAMIC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Affected by physics laws</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    shape: RedGPU.Physics.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PHYSICS_SHAPE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BOX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Box-shaped collider</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mass: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,                                      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Mass (kg)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    restitution: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                                // Restitution (0 ~ 1)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Example of applying force (impulse) from outside</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">applyImpulse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span></code></pre></div><h3 id="compound-colliders" tabindex="-1">Compound Colliders <a class="header-anchor" href="#compound-colliders" aria-label="Permalink to &quot;Compound Colliders&quot;">​</a></h3><p>If the mesh passed when calling <code>createBody</code> includes child meshes, RedGPU automatically analyzes the hierarchy and creates a <strong>compound collider</strong> that includes the shapes of all children.</p><h2 id="_4-full-constants-and-settings-specification" tabindex="-1">4. Full Constants and Settings Specification <a class="header-anchor" href="#_4-full-constants-and-settings-specification" aria-label="Permalink to &quot;4. Full Constants and Settings Specification&quot;">​</a></h2><h3 id="physics-body-type" tabindex="-1">PHYSICS_BODY_TYPE <a class="header-anchor" href="#physics-body-type" aria-label="Permalink to &quot;PHYSICS_BODY_TYPE&quot;">​</a></h3><p>Defines the physical nature of how an object interacts with the world.</p><ul><li><code>DYNAMIC</code>: Reacts to gravity and collisions, moving freely.</li><li><code>STATIC</code>: Fixed in space, does not move, and only participates in collisions. (Floors, walls, etc.)</li><li><code>KINEMATIC</code>: (Default) Ignores physics laws and controls movement directly via code.</li><li><code>KINEMATIC_POSITION</code>: Controlled by directly specifying position and rotation, and can push other objects.</li><li><code>KINEMATIC_VELOCITY</code>: Controls movement by specifying velocity.</li></ul><h3 id="physics-shape" tabindex="-1">PHYSICS_SHAPE <a class="header-anchor" href="#physics-shape" aria-label="Permalink to &quot;PHYSICS_SHAPE&quot;">​</a></h3><p>The shape of the collider used in the simulation.</p><ul><li><code>BOX</code>: Rectangular cuboid shape.</li><li><code>SPHERE</code>: Spherical shape.</li><li><code>CAPSULE</code>: Capsule shape.</li><li><code>CYLINDER</code>: Cylindrical shape.</li><li><code>HEIGHTFIELD</code>: Shape for grid-based heightmap data (terrain).</li><li><code>MESH</code>: Precise collider using complex mesh geometry as is.</li></ul><h3 id="bodyparams-createbody-configuration-options" tabindex="-1">BodyParams (createBody configuration options) <a class="header-anchor" href="#bodyparams-createbody-configuration-options" aria-label="Permalink to &quot;BodyParams (createBody configuration options)&quot;">​</a></h3><p>All options that can be passed as the second argument when calling <code>createBody()</code>.</p><ul><li><code>type</code>: Body type (<code>PHYSICS_BODY_TYPE</code>)</li><li><code>shape</code>: Collider shape (<code>PHYSICS_SHAPE</code>)</li><li><code>mass</code>: Mass (Default: 1.0)</li><li><code>friction</code>: Friction coefficient (0.0 ~ 1.0)</li><li><code>restitution</code>: Restitution coefficient (0.0 ~ 1.0, 1.0 is perfectly elastic collision)</li><li><code>linearDamping</code>: Damping force such as air resistance for linear movement</li><li><code>angularDamping</code>: Damping force for rotation</li><li><code>isSensor</code>: If set to true, only overlap events are generated without physical collision response.</li><li><code>enableCCD</code>: Enables Continuous Collision Detection. Prevents fast-moving objects from passing through thin walls.</li><li><code>heightData</code>: Terrain data object required when <code>shape</code> is <code>HEIGHTFIELD</code>.</li></ul><hr><h2 id="_5-live-examples" tabindex="-1">5. Live Examples <a class="header-anchor" href="#_5-live-examples" aria-label="Permalink to &quot;5. Live Examples&quot;">​</a></h2><p>Explore practical use cases of the physics engine through these categorized examples.</p><h3 id="_5-1-basics-shapes" tabindex="-1">5.1 Basics &amp; Shapes <a class="header-anchor" href="#_5-1-basics-shapes" aria-label="Permalink to &quot;5.1 Basics &amp; Shapes&quot;">​</a></h3><ul><li><a href="https://redcamel.github.io/RedGPU/examples/physics/basic/" target="_blank" rel="noreferrer">Basic Simulation &amp; Gravity Test</a></li><li><a href="https://redcamel.github.io/RedGPU/examples/physics/shapes/" target="_blank" rel="noreferrer">Various Collider Shapes</a></li><li><a href="https://redcamel.github.io/RedGPU/examples/physics/heightField/" target="_blank" rel="noreferrer">Terrain (Heightfield) Simulation</a></li></ul><h3 id="_5-2-controllers-interaction" tabindex="-1">5.2 Controllers &amp; Interaction <a class="header-anchor" href="#_5-2-controllers-interaction" aria-label="Permalink to &quot;5.2 Controllers &amp; Interaction&quot;">​</a></h3><ul><li><a href="https://redcamel.github.io/RedGPU/examples/physics/characterController/" target="_blank" rel="noreferrer">Kinematic Character Control</a></li><li><a href="https://redcamel.github.io/RedGPU/examples/physics/advancedCharacterController/" target="_blank" rel="noreferrer">Advanced Character Controller (Stairs/Slopes)</a></li><li><a href="https://redcamel.github.io/RedGPU/examples/physics/raycast/" target="_blank" rel="noreferrer">Mouse Click &amp; Raycast Interaction</a></li></ul><h3 id="_5-3-joints-advanced-physics" tabindex="-1">5.3 Joints &amp; Advanced Physics <a class="header-anchor" href="#_5-3-joints-advanced-physics" aria-label="Permalink to &quot;5.3 Joints &amp; Advanced Physics&quot;">​</a></h3><ul><li><a href="https://redcamel.github.io/RedGPU/examples/physics/joints/" target="_blank" rel="noreferrer">Basic Joints</a></li><li><a href="https://redcamel.github.io/RedGPU/examples/physics/revoluteJoint/" target="_blank" rel="noreferrer">Revolute Joint</a></li><li><a href="https://redcamel.github.io/RedGPU/examples/physics/springJoint/" target="_blank" rel="noreferrer">Spring &amp; Flexible Connection</a></li></ul><hr><h2 id="key-summary" tabindex="-1">Key Summary <a class="header-anchor" href="#key-summary" aria-label="Permalink to &quot;Key Summary&quot;">​</a></h2><ol><li><code>RapierPhysics</code> must be imported separately and requires <strong>asynchronous initialization</strong>.</li><li>After registering <code>scene.physicsEngine</code>, simulation runs automatically.</li><li><code>createBody</code> automatically reflects the mesh hierarchy in the physics world.</li></ol>`,40)])])}const g=s(t,[["render",l]]);export{k as __pageData,g as default};
