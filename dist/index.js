var e=1e-6,t="undefined"!=typeof Float32Array?Float32Array:Array,r=Math.random;var n=Math.PI/180;Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var i=Object.freeze({__proto__:null,get ARRAY_TYPE(){return t},EPSILON:e,RANDOM:r,equals:function(t,r){return Math.abs(t-r)<=e*Math.max(1,Math.abs(t),Math.abs(r))},setMatrixArrayType:function(e){t=e},toRadian:function(e){return e*n}});function multiply$8(e,t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=r[0],u=r[1],l=r[2],c=r[3];return e[0]=n*o+s*u,e[1]=i*o+a*u,e[2]=n*l+s*c,e[3]=i*l+a*c,e}function subtract$6(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e}var s=multiply$8,a=subtract$6,o=Object.freeze({__proto__:null,LDU:function(e,t,r,n){return e[2]=n[2]/n[0],r[0]=n[0],r[1]=n[1],r[3]=n[3]-e[2]*r[1],[e,t,r]},add:function(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e},adjoint:function(e,t){var r=t[0];return e[0]=t[3],e[1]=-t[1],e[2]=-t[2],e[3]=r,e},clone:function(e){var r=new t(4);return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r},copy:function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e},create:function(){var e=new t(4);return t!=Float32Array&&(e[1]=0,e[2]=0),e[0]=1,e[3]=1,e},determinant:function(e){return e[0]*e[3]-e[2]*e[1]},equals:function(t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=r[0],u=r[1],l=r[2],c=r[3];return Math.abs(n-o)<=e*Math.max(1,Math.abs(n),Math.abs(o))&&Math.abs(i-u)<=e*Math.max(1,Math.abs(i),Math.abs(u))&&Math.abs(s-l)<=e*Math.max(1,Math.abs(s),Math.abs(l))&&Math.abs(a-c)<=e*Math.max(1,Math.abs(a),Math.abs(c))},exactEquals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]},frob:function(e){return Math.hypot(e[0],e[1],e[2],e[3])},fromRotation:function(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=r,e[2]=-r,e[3]=n,e},fromScaling:function(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=t[1],e},fromValues:function(e,r,n,i){var s=new t(4);return s[0]=e,s[1]=r,s[2]=n,s[3]=i,s},identity:function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e},invert:function(e,t){var r=t[0],n=t[1],i=t[2],s=t[3],a=r*s-i*n;return a?(a=1/a,e[0]=s*a,e[1]=-n*a,e[2]=-i*a,e[3]=r*a,e):null},mul:s,multiply:multiply$8,multiplyScalar:function(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e},multiplyScalarAndAdd:function(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e[3]=t[3]+r[3]*n,e},rotate:function(e,t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=Math.sin(r),u=Math.cos(r);return e[0]=n*u+s*o,e[1]=i*u+a*o,e[2]=n*-o+s*u,e[3]=i*-o+a*u,e},scale:function(e,t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=r[0],u=r[1];return e[0]=n*o,e[1]=i*o,e[2]=s*u,e[3]=a*u,e},set:function(e,t,r,n,i){return e[0]=t,e[1]=r,e[2]=n,e[3]=i,e},str:function(e){return"mat2("+e[0]+","+e[1]+","+e[2]+","+e[3]+")"},sub:a,subtract:subtract$6,transpose:function(e,t){if(e===t){var r=t[1];e[1]=t[2],e[2]=r}else e[0]=t[0],e[1]=t[2],e[2]=t[1],e[3]=t[3];return e}});function multiply$7(e,t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=t[4],u=t[5],l=r[0],c=r[1],h=r[2],d=r[3],m=r[4],p=r[5];return e[0]=n*l+s*c,e[1]=i*l+a*c,e[2]=n*h+s*d,e[3]=i*h+a*d,e[4]=n*m+s*p+o,e[5]=i*m+a*p+u,e}function subtract$5(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e[4]=t[4]-r[4],e[5]=t[5]-r[5],e}var u=multiply$7,l=subtract$5,c=Object.freeze({__proto__:null,add:function(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e[4]=t[4]+r[4],e[5]=t[5]+r[5],e},clone:function(e){var r=new t(6);return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[4]=e[4],r[5]=e[5],r},copy:function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e},create:function(){var e=new t(6);return t!=Float32Array&&(e[1]=0,e[2]=0,e[4]=0,e[5]=0),e[0]=1,e[3]=1,e},determinant:function(e){return e[0]*e[3]-e[1]*e[2]},equals:function(t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=t[4],u=t[5],l=r[0],c=r[1],h=r[2],d=r[3],m=r[4],p=r[5];return Math.abs(n-l)<=e*Math.max(1,Math.abs(n),Math.abs(l))&&Math.abs(i-c)<=e*Math.max(1,Math.abs(i),Math.abs(c))&&Math.abs(s-h)<=e*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(a-d)<=e*Math.max(1,Math.abs(a),Math.abs(d))&&Math.abs(o-m)<=e*Math.max(1,Math.abs(o),Math.abs(m))&&Math.abs(u-p)<=e*Math.max(1,Math.abs(u),Math.abs(p))},exactEquals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]},frob:function(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],1)},fromRotation:function(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=r,e[2]=-r,e[3]=n,e[4]=0,e[5]=0,e},fromScaling:function(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=t[1],e[4]=0,e[5]=0,e},fromTranslation:function(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=t[0],e[5]=t[1],e},fromValues:function(e,r,n,i,s,a){var o=new t(6);return o[0]=e,o[1]=r,o[2]=n,o[3]=i,o[4]=s,o[5]=a,o},identity:function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e},invert:function(e,t){var r=t[0],n=t[1],i=t[2],s=t[3],a=t[4],o=t[5],u=r*s-n*i;return u?(u=1/u,e[0]=s*u,e[1]=-n*u,e[2]=-i*u,e[3]=r*u,e[4]=(i*o-s*a)*u,e[5]=(n*a-r*o)*u,e):null},mul:u,multiply:multiply$7,multiplyScalar:function(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*r,e[5]=t[5]*r,e},multiplyScalarAndAdd:function(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e[3]=t[3]+r[3]*n,e[4]=t[4]+r[4]*n,e[5]=t[5]+r[5]*n,e},rotate:function(e,t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=t[4],u=t[5],l=Math.sin(r),c=Math.cos(r);return e[0]=n*c+s*l,e[1]=i*c+a*l,e[2]=n*-l+s*c,e[3]=i*-l+a*c,e[4]=o,e[5]=u,e},scale:function(e,t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=t[4],u=t[5],l=r[0],c=r[1];return e[0]=n*l,e[1]=i*l,e[2]=s*c,e[3]=a*c,e[4]=o,e[5]=u,e},set:function(e,t,r,n,i,s,a){return e[0]=t,e[1]=r,e[2]=n,e[3]=i,e[4]=s,e[5]=a,e},str:function(e){return"mat2d("+e[0]+","+e[1]+","+e[2]+","+e[3]+","+e[4]+","+e[5]+")"},sub:l,subtract:subtract$5,translate:function(e,t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=t[4],u=t[5],l=r[0],c=r[1];return e[0]=n,e[1]=i,e[2]=s,e[3]=a,e[4]=n*l+s*c+o,e[5]=i*l+a*c+u,e}});function create$6(){var e=new t(9);return t!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function multiply$6(e,t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=t[4],u=t[5],l=t[6],c=t[7],h=t[8],d=r[0],m=r[1],p=r[2],f=r[3],g=r[4],_=r[5],x=r[6],v=r[7],T=r[8];return e[0]=d*n+m*a+p*l,e[1]=d*i+m*o+p*c,e[2]=d*s+m*u+p*h,e[3]=f*n+g*a+_*l,e[4]=f*i+g*o+_*c,e[5]=f*s+g*u+_*h,e[6]=x*n+v*a+T*l,e[7]=x*i+v*o+T*c,e[8]=x*s+v*u+T*h,e}function subtract$4(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e[4]=t[4]-r[4],e[5]=t[5]-r[5],e[6]=t[6]-r[6],e[7]=t[7]-r[7],e[8]=t[8]-r[8],e}var h=multiply$6,d=subtract$4,m=Object.freeze({__proto__:null,add:function(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e[4]=t[4]+r[4],e[5]=t[5]+r[5],e[6]=t[6]+r[6],e[7]=t[7]+r[7],e[8]=t[8]+r[8],e},adjoint:function(e,t){var r=t[0],n=t[1],i=t[2],s=t[3],a=t[4],o=t[5],u=t[6],l=t[7],c=t[8];return e[0]=a*c-o*l,e[1]=i*l-n*c,e[2]=n*o-i*a,e[3]=o*u-s*c,e[4]=r*c-i*u,e[5]=i*s-r*o,e[6]=s*l-a*u,e[7]=n*u-r*l,e[8]=r*a-n*s,e},clone:function(e){var r=new t(9);return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[8]=e[8],r},copy:function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e},create:create$6,determinant:function(e){var t=e[0],r=e[1],n=e[2],i=e[3],s=e[4],a=e[5],o=e[6],u=e[7],l=e[8];return t*(l*s-a*u)+r*(-l*i+a*o)+n*(u*i-s*o)},equals:function(t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=t[4],u=t[5],l=t[6],c=t[7],h=t[8],d=r[0],m=r[1],p=r[2],f=r[3],g=r[4],_=r[5],x=r[6],v=r[7],T=r[8];return Math.abs(n-d)<=e*Math.max(1,Math.abs(n),Math.abs(d))&&Math.abs(i-m)<=e*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(s-p)<=e*Math.max(1,Math.abs(s),Math.abs(p))&&Math.abs(a-f)<=e*Math.max(1,Math.abs(a),Math.abs(f))&&Math.abs(o-g)<=e*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(u-_)<=e*Math.max(1,Math.abs(u),Math.abs(_))&&Math.abs(l-x)<=e*Math.max(1,Math.abs(l),Math.abs(x))&&Math.abs(c-v)<=e*Math.max(1,Math.abs(c),Math.abs(v))&&Math.abs(h-T)<=e*Math.max(1,Math.abs(h),Math.abs(T))},exactEquals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]},frob:function(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])},fromMat2d:function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e},fromMat4:function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e},fromQuat:function(e,t){var r=t[0],n=t[1],i=t[2],s=t[3],a=r+r,o=n+n,u=i+i,l=r*a,c=n*a,h=n*o,d=i*a,m=i*o,p=i*u,f=s*a,g=s*o,_=s*u;return e[0]=1-h-p,e[3]=c-_,e[6]=d+g,e[1]=c+_,e[4]=1-l-p,e[7]=m-f,e[2]=d-g,e[5]=m+f,e[8]=1-l-h,e},fromRotation:function(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=r,e[2]=0,e[3]=-r,e[4]=n,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e},fromScaling:function(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e},fromTranslation:function(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e},fromValues:function(e,r,n,i,s,a,o,u,l){var c=new t(9);return c[0]=e,c[1]=r,c[2]=n,c[3]=i,c[4]=s,c[5]=a,c[6]=o,c[7]=u,c[8]=l,c},identity:function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e},invert:function(e,t){var r=t[0],n=t[1],i=t[2],s=t[3],a=t[4],o=t[5],u=t[6],l=t[7],c=t[8],h=c*a-o*l,d=-c*s+o*u,m=l*s-a*u,p=r*h+n*d+i*m;return p?(p=1/p,e[0]=h*p,e[1]=(-c*n+i*l)*p,e[2]=(o*n-i*a)*p,e[3]=d*p,e[4]=(c*r-i*u)*p,e[5]=(-o*r+i*s)*p,e[6]=m*p,e[7]=(-l*r+n*u)*p,e[8]=(a*r-n*s)*p,e):null},mul:h,multiply:multiply$6,multiplyScalar:function(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*r,e[5]=t[5]*r,e[6]=t[6]*r,e[7]=t[7]*r,e[8]=t[8]*r,e},multiplyScalarAndAdd:function(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e[3]=t[3]+r[3]*n,e[4]=t[4]+r[4]*n,e[5]=t[5]+r[5]*n,e[6]=t[6]+r[6]*n,e[7]=t[7]+r[7]*n,e[8]=t[8]+r[8]*n,e},normalFromMat4:function(e,t){var r=t[0],n=t[1],i=t[2],s=t[3],a=t[4],o=t[5],u=t[6],l=t[7],c=t[8],h=t[9],d=t[10],m=t[11],p=t[12],f=t[13],g=t[14],_=t[15],x=r*o-n*a,v=r*u-i*a,T=r*l-s*a,y=n*u-i*o,b=n*l-s*o,S=i*l-s*u,M=c*f-h*p,R=c*g-d*p,w=c*_-m*p,P=h*g-d*f,E=h*_-m*f,k=d*_-m*g,C=x*k-v*E+T*P+y*w-b*R+S*M;return C?(C=1/C,e[0]=(o*k-u*E+l*P)*C,e[1]=(u*w-a*k-l*R)*C,e[2]=(a*E-o*w+l*M)*C,e[3]=(i*E-n*k-s*P)*C,e[4]=(r*k-i*w+s*R)*C,e[5]=(n*w-r*E-s*M)*C,e[6]=(f*S-g*b+_*y)*C,e[7]=(g*T-p*S-_*v)*C,e[8]=(p*b-f*T+_*x)*C,e):null},projection:function(e,t,r){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/r,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e},rotate:function(e,t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=t[4],u=t[5],l=t[6],c=t[7],h=t[8],d=Math.sin(r),m=Math.cos(r);return e[0]=m*n+d*a,e[1]=m*i+d*o,e[2]=m*s+d*u,e[3]=m*a-d*n,e[4]=m*o-d*i,e[5]=m*u-d*s,e[6]=l,e[7]=c,e[8]=h,e},scale:function(e,t,r){var n=r[0],i=r[1];return e[0]=n*t[0],e[1]=n*t[1],e[2]=n*t[2],e[3]=i*t[3],e[4]=i*t[4],e[5]=i*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e},set:function(e,t,r,n,i,s,a,o,u,l){return e[0]=t,e[1]=r,e[2]=n,e[3]=i,e[4]=s,e[5]=a,e[6]=o,e[7]=u,e[8]=l,e},str:function(e){return"mat3("+e[0]+","+e[1]+","+e[2]+","+e[3]+","+e[4]+","+e[5]+","+e[6]+","+e[7]+","+e[8]+")"},sub:d,subtract:subtract$4,translate:function(e,t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=t[4],u=t[5],l=t[6],c=t[7],h=t[8],d=r[0],m=r[1];return e[0]=n,e[1]=i,e[2]=s,e[3]=a,e[4]=o,e[5]=u,e[6]=d*n+m*a+l,e[7]=d*i+m*o+c,e[8]=d*s+m*u+h,e},transpose:function(e,t){if(e===t){var r=t[1],n=t[2],i=t[5];e[1]=t[3],e[2]=t[6],e[3]=r,e[5]=t[7],e[6]=n,e[7]=i}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}});function create$5(){var e=new t(16);return t!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function clone$5(e){var r=new t(16);return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[8]=e[8],r[9]=e[9],r[10]=e[10],r[11]=e[11],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15],r}function copy$5(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function fromValues$5(e,r,n,i,s,a,o,u,l,c,h,d,m,p,f,g){var _=new t(16);return _[0]=e,_[1]=r,_[2]=n,_[3]=i,_[4]=s,_[5]=a,_[6]=o,_[7]=u,_[8]=l,_[9]=c,_[10]=h,_[11]=d,_[12]=m,_[13]=p,_[14]=f,_[15]=g,_}function identity$2(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function invert$2(e,t){var r=t[0],n=t[1],i=t[2],s=t[3],a=t[4],o=t[5],u=t[6],l=t[7],c=t[8],h=t[9],d=t[10],m=t[11],p=t[12],f=t[13],g=t[14],_=t[15],x=r*o-n*a,v=r*u-i*a,T=r*l-s*a,y=n*u-i*o,b=n*l-s*o,S=i*l-s*u,M=c*f-h*p,R=c*g-d*p,w=c*_-m*p,P=h*g-d*f,E=h*_-m*f,k=d*_-m*g,C=x*k-v*E+T*P+y*w-b*R+S*M;return C?(C=1/C,e[0]=(o*k-u*E+l*P)*C,e[1]=(i*E-n*k-s*P)*C,e[2]=(f*S-g*b+_*y)*C,e[3]=(d*b-h*S-m*y)*C,e[4]=(u*w-a*k-l*R)*C,e[5]=(r*k-i*w+s*R)*C,e[6]=(g*T-p*S-_*v)*C,e[7]=(c*S-d*T+m*v)*C,e[8]=(a*E-o*w+l*M)*C,e[9]=(n*w-r*E-s*M)*C,e[10]=(p*b-f*T+_*x)*C,e[11]=(h*T-c*b-m*x)*C,e[12]=(o*R-a*P-u*M)*C,e[13]=(r*P-n*R+i*M)*C,e[14]=(f*v-p*y-g*x)*C,e[15]=(c*y-h*v+d*x)*C,e):null}function multiply$5(e,t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=t[4],u=t[5],l=t[6],c=t[7],h=t[8],d=t[9],m=t[10],p=t[11],f=t[12],g=t[13],_=t[14],x=t[15],v=r[0],T=r[1],y=r[2],b=r[3];return e[0]=v*n+T*o+y*h+b*f,e[1]=v*i+T*u+y*d+b*g,e[2]=v*s+T*l+y*m+b*_,e[3]=v*a+T*c+y*p+b*x,v=r[4],T=r[5],y=r[6],b=r[7],e[4]=v*n+T*o+y*h+b*f,e[5]=v*i+T*u+y*d+b*g,e[6]=v*s+T*l+y*m+b*_,e[7]=v*a+T*c+y*p+b*x,v=r[8],T=r[9],y=r[10],b=r[11],e[8]=v*n+T*o+y*h+b*f,e[9]=v*i+T*u+y*d+b*g,e[10]=v*s+T*l+y*m+b*_,e[11]=v*a+T*c+y*p+b*x,v=r[12],T=r[13],y=r[14],b=r[15],e[12]=v*n+T*o+y*h+b*f,e[13]=v*i+T*u+y*d+b*g,e[14]=v*s+T*l+y*m+b*_,e[15]=v*a+T*c+y*p+b*x,e}function translate$1(e,t,r){var n,i,s,a,o,u,l,c,h,d,m,p,f=r[0],g=r[1],_=r[2];return t===e?(e[12]=t[0]*f+t[4]*g+t[8]*_+t[12],e[13]=t[1]*f+t[5]*g+t[9]*_+t[13],e[14]=t[2]*f+t[6]*g+t[10]*_+t[14],e[15]=t[3]*f+t[7]*g+t[11]*_+t[15]):(n=t[0],i=t[1],s=t[2],a=t[3],o=t[4],u=t[5],l=t[6],c=t[7],h=t[8],d=t[9],m=t[10],p=t[11],e[0]=n,e[1]=i,e[2]=s,e[3]=a,e[4]=o,e[5]=u,e[6]=l,e[7]=c,e[8]=h,e[9]=d,e[10]=m,e[11]=p,e[12]=n*f+o*g+h*_+t[12],e[13]=i*f+u*g+d*_+t[13],e[14]=s*f+l*g+m*_+t[14],e[15]=a*f+c*g+p*_+t[15]),e}function scale$5(e,t,r){var n=r[0],i=r[1],s=r[2];return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*i,e[5]=t[5]*i,e[6]=t[6]*i,e[7]=t[7]*i,e[8]=t[8]*s,e[9]=t[9]*s,e[10]=t[10]*s,e[11]=t[11]*s,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function rotateX$3(e,t,r){var n=Math.sin(r),i=Math.cos(r),s=t[4],a=t[5],o=t[6],u=t[7],l=t[8],c=t[9],h=t[10],d=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=s*i+l*n,e[5]=a*i+c*n,e[6]=o*i+h*n,e[7]=u*i+d*n,e[8]=l*i-s*n,e[9]=c*i-a*n,e[10]=h*i-o*n,e[11]=d*i-u*n,e}function rotateY$3(e,t,r){var n=Math.sin(r),i=Math.cos(r),s=t[0],a=t[1],o=t[2],u=t[3],l=t[8],c=t[9],h=t[10],d=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*i-l*n,e[1]=a*i-c*n,e[2]=o*i-h*n,e[3]=u*i-d*n,e[8]=s*n+l*i,e[9]=a*n+c*i,e[10]=o*n+h*i,e[11]=u*n+d*i,e}function rotateZ$3(e,t,r){var n=Math.sin(r),i=Math.cos(r),s=t[0],a=t[1],o=t[2],u=t[3],l=t[4],c=t[5],h=t[6],d=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*i+l*n,e[1]=a*i+c*n,e[2]=o*i+h*n,e[3]=u*i+d*n,e[4]=l*i-s*n,e[5]=c*i-a*n,e[6]=h*i-o*n,e[7]=d*i-u*n,e}function fromRotationTranslation$1(e,t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=n+n,u=i+i,l=s+s,c=n*o,h=n*u,d=n*l,m=i*u,p=i*l,f=s*l,g=a*o,_=a*u,x=a*l;return e[0]=1-(m+f),e[1]=h+x,e[2]=d-_,e[3]=0,e[4]=h-x,e[5]=1-(c+f),e[6]=p+g,e[7]=0,e[8]=d+_,e[9]=p-g,e[10]=1-(c+m),e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e}function getTranslation$1(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function getScaling(e,t){var r=t[0],n=t[1],i=t[2],s=t[4],a=t[5],o=t[6],u=t[8],l=t[9],c=t[10];return e[0]=Math.hypot(r,n,i),e[1]=Math.hypot(s,a,o),e[2]=Math.hypot(u,l,c),e}function getRotation(e,r){var n=new t(3);getScaling(n,r);var i=1/n[0],s=1/n[1],a=1/n[2],o=r[0]*i,u=r[1]*s,l=r[2]*a,c=r[4]*i,h=r[5]*s,d=r[6]*a,m=r[8]*i,p=r[9]*s,f=r[10]*a,g=o+h+f,_=0;return g>0?(_=2*Math.sqrt(g+1),e[3]=.25*_,e[0]=(d-p)/_,e[1]=(m-l)/_,e[2]=(u-c)/_):o>h&&o>f?(_=2*Math.sqrt(1+o-h-f),e[3]=(d-p)/_,e[0]=.25*_,e[1]=(u+c)/_,e[2]=(m+l)/_):h>f?(_=2*Math.sqrt(1+h-o-f),e[3]=(m-l)/_,e[0]=(u+c)/_,e[1]=.25*_,e[2]=(d+p)/_):(_=2*Math.sqrt(1+f-o-h),e[3]=(u-c)/_,e[0]=(m+l)/_,e[1]=(d+p)/_,e[2]=.25*_),e}function perspectiveNO(e,t,r,n,i){var s,a=1/Math.tan(t/2);return e[0]=a/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=i&&i!==1/0?(s=1/(n-i),e[10]=(i+n)*s,e[14]=2*i*n*s):(e[10]=-1,e[14]=-2*n),e}var p=perspectiveNO;function orthoNO(e,t,r,n,i,s,a){var o=1/(t-r),u=1/(n-i),l=1/(s-a);return e[0]=-2*o,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*u,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*l,e[11]=0,e[12]=(t+r)*o,e[13]=(i+n)*u,e[14]=(a+s)*l,e[15]=1,e}var f=orthoNO;function orthoZO(e,t,r,n,i,s,a){var o=1/(t-r),u=1/(n-i),l=1/(s-a);return e[0]=-2*o,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*u,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=l,e[11]=0,e[12]=(t+r)*o,e[13]=(i+n)*u,e[14]=s*l,e[15]=1,e}function lookAt(t,r,n,i){var s,a,o,u,l,c,h,d,m,p,f=r[0],g=r[1],_=r[2],x=i[0],v=i[1],T=i[2],y=n[0],b=n[1],S=n[2];return Math.abs(f-y)<e&&Math.abs(g-b)<e&&Math.abs(_-S)<e?identity$2(t):(h=f-y,d=g-b,m=_-S,s=v*(m*=p=1/Math.hypot(h,d,m))-T*(d*=p),a=T*(h*=p)-x*m,o=x*d-v*h,(p=Math.hypot(s,a,o))?(s*=p=1/p,a*=p,o*=p):(s=0,a=0,o=0),u=d*o-m*a,l=m*s-h*o,c=h*a-d*s,(p=Math.hypot(u,l,c))?(u*=p=1/p,l*=p,c*=p):(u=0,l=0,c=0),t[0]=s,t[1]=u,t[2]=h,t[3]=0,t[4]=a,t[5]=l,t[6]=d,t[7]=0,t[8]=o,t[9]=c,t[10]=m,t[11]=0,t[12]=-(s*f+a*g+o*_),t[13]=-(u*f+l*g+c*_),t[14]=-(h*f+d*g+m*_),t[15]=1,t)}function subtract$3(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e[4]=t[4]-r[4],e[5]=t[5]-r[5],e[6]=t[6]-r[6],e[7]=t[7]-r[7],e[8]=t[8]-r[8],e[9]=t[9]-r[9],e[10]=t[10]-r[10],e[11]=t[11]-r[11],e[12]=t[12]-r[12],e[13]=t[13]-r[13],e[14]=t[14]-r[14],e[15]=t[15]-r[15],e}var g=multiply$5,_=subtract$3,x=Object.freeze({__proto__:null,add:function(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e[4]=t[4]+r[4],e[5]=t[5]+r[5],e[6]=t[6]+r[6],e[7]=t[7]+r[7],e[8]=t[8]+r[8],e[9]=t[9]+r[9],e[10]=t[10]+r[10],e[11]=t[11]+r[11],e[12]=t[12]+r[12],e[13]=t[13]+r[13],e[14]=t[14]+r[14],e[15]=t[15]+r[15],e},adjoint:function(e,t){var r=t[0],n=t[1],i=t[2],s=t[3],a=t[4],o=t[5],u=t[6],l=t[7],c=t[8],h=t[9],d=t[10],m=t[11],p=t[12],f=t[13],g=t[14],_=t[15];return e[0]=o*(d*_-m*g)-h*(u*_-l*g)+f*(u*m-l*d),e[1]=-(n*(d*_-m*g)-h*(i*_-s*g)+f*(i*m-s*d)),e[2]=n*(u*_-l*g)-o*(i*_-s*g)+f*(i*l-s*u),e[3]=-(n*(u*m-l*d)-o*(i*m-s*d)+h*(i*l-s*u)),e[4]=-(a*(d*_-m*g)-c*(u*_-l*g)+p*(u*m-l*d)),e[5]=r*(d*_-m*g)-c*(i*_-s*g)+p*(i*m-s*d),e[6]=-(r*(u*_-l*g)-a*(i*_-s*g)+p*(i*l-s*u)),e[7]=r*(u*m-l*d)-a*(i*m-s*d)+c*(i*l-s*u),e[8]=a*(h*_-m*f)-c*(o*_-l*f)+p*(o*m-l*h),e[9]=-(r*(h*_-m*f)-c*(n*_-s*f)+p*(n*m-s*h)),e[10]=r*(o*_-l*f)-a*(n*_-s*f)+p*(n*l-s*o),e[11]=-(r*(o*m-l*h)-a*(n*m-s*h)+c*(n*l-s*o)),e[12]=-(a*(h*g-d*f)-c*(o*g-u*f)+p*(o*d-u*h)),e[13]=r*(h*g-d*f)-c*(n*g-i*f)+p*(n*d-i*h),e[14]=-(r*(o*g-u*f)-a*(n*g-i*f)+p*(n*u-i*o)),e[15]=r*(o*d-u*h)-a*(n*d-i*h)+c*(n*u-i*o),e},clone:clone$5,copy:copy$5,create:create$5,determinant:function(e){var t=e[0],r=e[1],n=e[2],i=e[3],s=e[4],a=e[5],o=e[6],u=e[7],l=e[8],c=e[9],h=e[10],d=e[11],m=e[12],p=e[13],f=e[14],g=e[15];return(t*a-r*s)*(h*g-d*f)-(t*o-n*s)*(c*g-d*p)+(t*u-i*s)*(c*f-h*p)+(r*o-n*a)*(l*g-d*m)-(r*u-i*a)*(l*f-h*m)+(n*u-i*o)*(l*p-c*m)},equals:function(t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=t[4],u=t[5],l=t[6],c=t[7],h=t[8],d=t[9],m=t[10],p=t[11],f=t[12],g=t[13],_=t[14],x=t[15],v=r[0],T=r[1],y=r[2],b=r[3],S=r[4],M=r[5],R=r[6],w=r[7],P=r[8],E=r[9],k=r[10],C=r[11],L=r[12],B=r[13],I=r[14],U=r[15];return Math.abs(n-v)<=e*Math.max(1,Math.abs(n),Math.abs(v))&&Math.abs(i-T)<=e*Math.max(1,Math.abs(i),Math.abs(T))&&Math.abs(s-y)<=e*Math.max(1,Math.abs(s),Math.abs(y))&&Math.abs(a-b)<=e*Math.max(1,Math.abs(a),Math.abs(b))&&Math.abs(o-S)<=e*Math.max(1,Math.abs(o),Math.abs(S))&&Math.abs(u-M)<=e*Math.max(1,Math.abs(u),Math.abs(M))&&Math.abs(l-R)<=e*Math.max(1,Math.abs(l),Math.abs(R))&&Math.abs(c-w)<=e*Math.max(1,Math.abs(c),Math.abs(w))&&Math.abs(h-P)<=e*Math.max(1,Math.abs(h),Math.abs(P))&&Math.abs(d-E)<=e*Math.max(1,Math.abs(d),Math.abs(E))&&Math.abs(m-k)<=e*Math.max(1,Math.abs(m),Math.abs(k))&&Math.abs(p-C)<=e*Math.max(1,Math.abs(p),Math.abs(C))&&Math.abs(f-L)<=e*Math.max(1,Math.abs(f),Math.abs(L))&&Math.abs(g-B)<=e*Math.max(1,Math.abs(g),Math.abs(B))&&Math.abs(_-I)<=e*Math.max(1,Math.abs(_),Math.abs(I))&&Math.abs(x-U)<=e*Math.max(1,Math.abs(x),Math.abs(U))},exactEquals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]},frob:function(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])},fromQuat:function(e,t){var r=t[0],n=t[1],i=t[2],s=t[3],a=r+r,o=n+n,u=i+i,l=r*a,c=n*a,h=n*o,d=i*a,m=i*o,p=i*u,f=s*a,g=s*o,_=s*u;return e[0]=1-h-p,e[1]=c+_,e[2]=d-g,e[3]=0,e[4]=c-_,e[5]=1-l-p,e[6]=m+f,e[7]=0,e[8]=d+g,e[9]=m-f,e[10]=1-l-h,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},fromQuat2:function(e,r){var n=new t(3),i=-r[0],s=-r[1],a=-r[2],o=r[3],u=r[4],l=r[5],c=r[6],h=r[7],d=i*i+s*s+a*a+o*o;return d>0?(n[0]=2*(u*o+h*i+l*a-c*s)/d,n[1]=2*(l*o+h*s+c*i-u*a)/d,n[2]=2*(c*o+h*a+u*s-l*i)/d):(n[0]=2*(u*o+h*i+l*a-c*s),n[1]=2*(l*o+h*s+c*i-u*a),n[2]=2*(c*o+h*a+u*s-l*i)),fromRotationTranslation$1(e,r,n),e},fromRotation:function(t,r,n){var i,s,a,o=n[0],u=n[1],l=n[2],c=Math.hypot(o,u,l);return c<e?null:(o*=c=1/c,u*=c,l*=c,i=Math.sin(r),a=1-(s=Math.cos(r)),t[0]=o*o*a+s,t[1]=u*o*a+l*i,t[2]=l*o*a-u*i,t[3]=0,t[4]=o*u*a-l*i,t[5]=u*u*a+s,t[6]=l*u*a+o*i,t[7]=0,t[8]=o*l*a+u*i,t[9]=u*l*a-o*i,t[10]=l*l*a+s,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t)},fromRotationTranslation:fromRotationTranslation$1,fromRotationTranslationScale:function(e,t,r,n){var i=t[0],s=t[1],a=t[2],o=t[3],u=i+i,l=s+s,c=a+a,h=i*u,d=i*l,m=i*c,p=s*l,f=s*c,g=a*c,_=o*u,x=o*l,v=o*c,T=n[0],y=n[1],b=n[2];return e[0]=(1-(p+g))*T,e[1]=(d+v)*T,e[2]=(m-x)*T,e[3]=0,e[4]=(d-v)*y,e[5]=(1-(h+g))*y,e[6]=(f+_)*y,e[7]=0,e[8]=(m+x)*b,e[9]=(f-_)*b,e[10]=(1-(h+p))*b,e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e},fromRotationTranslationScaleOrigin:function(e,t,r,n,i){var s=t[0],a=t[1],o=t[2],u=t[3],l=s+s,c=a+a,h=o+o,d=s*l,m=s*c,p=s*h,f=a*c,g=a*h,_=o*h,x=u*l,v=u*c,T=u*h,y=n[0],b=n[1],S=n[2],M=i[0],R=i[1],w=i[2],P=(1-(f+_))*y,E=(m+T)*y,k=(p-v)*y,C=(m-T)*b,L=(1-(d+_))*b,B=(g+x)*b,I=(p+v)*S,U=(g-x)*S,A=(1-(d+f))*S;return e[0]=P,e[1]=E,e[2]=k,e[3]=0,e[4]=C,e[5]=L,e[6]=B,e[7]=0,e[8]=I,e[9]=U,e[10]=A,e[11]=0,e[12]=r[0]+M-(P*M+C*R+I*w),e[13]=r[1]+R-(E*M+L*R+U*w),e[14]=r[2]+w-(k*M+B*R+A*w),e[15]=1,e},fromScaling:function(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},fromTranslation:function(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e},fromValues:fromValues$5,fromXRotation:function(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=n,e[6]=r,e[7]=0,e[8]=0,e[9]=-r,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},fromYRotation:function(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=0,e[2]=-r,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=r,e[9]=0,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},fromZRotation:function(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=r,e[2]=0,e[3]=0,e[4]=-r,e[5]=n,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e},frustum:function(e,t,r,n,i,s,a){var o=1/(r-t),u=1/(i-n),l=1/(s-a);return e[0]=2*s*o,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*s*u,e[6]=0,e[7]=0,e[8]=(r+t)*o,e[9]=(i+n)*u,e[10]=(a+s)*l,e[11]=-1,e[12]=0,e[13]=0,e[14]=a*s*2*l,e[15]=0,e},getRotation:getRotation,getScaling:getScaling,getTranslation:getTranslation$1,identity:identity$2,invert:invert$2,lookAt:lookAt,mul:g,multiply:multiply$5,multiplyScalar:function(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*r,e[5]=t[5]*r,e[6]=t[6]*r,e[7]=t[7]*r,e[8]=t[8]*r,e[9]=t[9]*r,e[10]=t[10]*r,e[11]=t[11]*r,e[12]=t[12]*r,e[13]=t[13]*r,e[14]=t[14]*r,e[15]=t[15]*r,e},multiplyScalarAndAdd:function(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e[3]=t[3]+r[3]*n,e[4]=t[4]+r[4]*n,e[5]=t[5]+r[5]*n,e[6]=t[6]+r[6]*n,e[7]=t[7]+r[7]*n,e[8]=t[8]+r[8]*n,e[9]=t[9]+r[9]*n,e[10]=t[10]+r[10]*n,e[11]=t[11]+r[11]*n,e[12]=t[12]+r[12]*n,e[13]=t[13]+r[13]*n,e[14]=t[14]+r[14]*n,e[15]=t[15]+r[15]*n,e},ortho:f,orthoNO:orthoNO,orthoZO:orthoZO,perspective:p,perspectiveFromFieldOfView:function(e,t,r,n){var i=Math.tan(t.upDegrees*Math.PI/180),s=Math.tan(t.downDegrees*Math.PI/180),a=Math.tan(t.leftDegrees*Math.PI/180),o=Math.tan(t.rightDegrees*Math.PI/180),u=2/(a+o),l=2/(i+s);return e[0]=u,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=l,e[6]=0,e[7]=0,e[8]=-(a-o)*u*.5,e[9]=(i-s)*l*.5,e[10]=n/(r-n),e[11]=-1,e[12]=0,e[13]=0,e[14]=n*r/(r-n),e[15]=0,e},perspectiveNO:perspectiveNO,perspectiveZO:function(e,t,r,n,i){var s,a=1/Math.tan(t/2);return e[0]=a/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=i&&i!==1/0?(s=1/(n-i),e[10]=i*s,e[14]=i*n*s):(e[10]=-1,e[14]=-n),e},rotate:function(t,r,n,i){var s,a,o,u,l,c,h,d,m,p,f,g,_,x,v,T,y,b,S,M,R,w,P,E,k=i[0],C=i[1],L=i[2],B=Math.hypot(k,C,L);return B<e?null:(k*=B=1/B,C*=B,L*=B,s=Math.sin(n),o=1-(a=Math.cos(n)),u=r[0],l=r[1],c=r[2],h=r[3],d=r[4],m=r[5],p=r[6],f=r[7],g=r[8],_=r[9],x=r[10],v=r[11],T=k*k*o+a,y=C*k*o+L*s,b=L*k*o-C*s,S=k*C*o-L*s,M=C*C*o+a,R=L*C*o+k*s,w=k*L*o+C*s,P=C*L*o-k*s,E=L*L*o+a,t[0]=u*T+d*y+g*b,t[1]=l*T+m*y+_*b,t[2]=c*T+p*y+x*b,t[3]=h*T+f*y+v*b,t[4]=u*S+d*M+g*R,t[5]=l*S+m*M+_*R,t[6]=c*S+p*M+x*R,t[7]=h*S+f*M+v*R,t[8]=u*w+d*P+g*E,t[9]=l*w+m*P+_*E,t[10]=c*w+p*P+x*E,t[11]=h*w+f*P+v*E,r!==t&&(t[12]=r[12],t[13]=r[13],t[14]=r[14],t[15]=r[15]),t)},rotateX:rotateX$3,rotateY:rotateY$3,rotateZ:rotateZ$3,scale:scale$5,set:function(e,t,r,n,i,s,a,o,u,l,c,h,d,m,p,f,g){return e[0]=t,e[1]=r,e[2]=n,e[3]=i,e[4]=s,e[5]=a,e[6]=o,e[7]=u,e[8]=l,e[9]=c,e[10]=h,e[11]=d,e[12]=m,e[13]=p,e[14]=f,e[15]=g,e},str:function(e){return"mat4("+e[0]+","+e[1]+","+e[2]+","+e[3]+","+e[4]+","+e[5]+","+e[6]+","+e[7]+","+e[8]+","+e[9]+","+e[10]+","+e[11]+","+e[12]+","+e[13]+","+e[14]+","+e[15]+")"},sub:_,subtract:subtract$3,targetTo:function(e,t,r,n){var i=t[0],s=t[1],a=t[2],o=n[0],u=n[1],l=n[2],c=i-r[0],h=s-r[1],d=a-r[2],m=c*c+h*h+d*d;m>0&&(c*=m=1/Math.sqrt(m),h*=m,d*=m);var p=u*d-l*h,f=l*c-o*d,g=o*h-u*c;return(m=p*p+f*f+g*g)>0&&(p*=m=1/Math.sqrt(m),f*=m,g*=m),e[0]=p,e[1]=f,e[2]=g,e[3]=0,e[4]=h*g-d*f,e[5]=d*p-c*g,e[6]=c*f-h*p,e[7]=0,e[8]=c,e[9]=h,e[10]=d,e[11]=0,e[12]=i,e[13]=s,e[14]=a,e[15]=1,e},translate:translate$1,transpose:function(e,t){if(e===t){var r=t[1],n=t[2],i=t[3],s=t[6],a=t[7],o=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=r,e[6]=t[9],e[7]=t[13],e[8]=n,e[9]=s,e[11]=t[14],e[12]=i,e[13]=a,e[14]=o}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}});function create$4(){var e=new t(3);return t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function length$4(e){var t=e[0],r=e[1],n=e[2];return Math.hypot(t,r,n)}function fromValues$4(e,r,n){var i=new t(3);return i[0]=e,i[1]=r,i[2]=n,i}function set$4(e,t,r,n){return e[0]=t,e[1]=r,e[2]=n,e}function subtract$2(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e}function multiply$4(e,t,r){return e[0]=t[0]*r[0],e[1]=t[1]*r[1],e[2]=t[2]*r[2],e}function divide$2(e,t,r){return e[0]=t[0]/r[0],e[1]=t[1]/r[1],e[2]=t[2]/r[2],e}function distance$2(e,t){var r=t[0]-e[0],n=t[1]-e[1],i=t[2]-e[2];return Math.hypot(r,n,i)}function squaredDistance$2(e,t){var r=t[0]-e[0],n=t[1]-e[1],i=t[2]-e[2];return r*r+n*n+i*i}function squaredLength$4(e){var t=e[0],r=e[1],n=e[2];return t*t+r*r+n*n}function normalize$4(e,t){var r=t[0],n=t[1],i=t[2],s=r*r+n*n+i*i;return s>0&&(s=1/Math.sqrt(s)),e[0]=t[0]*s,e[1]=t[1]*s,e[2]=t[2]*s,e}function dot$4(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function cross$2(e,t,r){var n=t[0],i=t[1],s=t[2],a=r[0],o=r[1],u=r[2];return e[0]=i*u-s*o,e[1]=s*a-n*u,e[2]=n*o-i*a,e}function lerp$4(e,t,r,n){var i=t[0],s=t[1],a=t[2];return e[0]=i+n*(r[0]-i),e[1]=s+n*(r[1]-s),e[2]=a+n*(r[2]-a),e}var v,T=subtract$2,y=multiply$4,b=divide$2,S=distance$2,M=squaredDistance$2,R=length$4,w=squaredLength$4,P=(v=create$4(),function(e,t,r,n,i,s){var a,o;for(t||(t=3),r||(r=0),o=n?Math.min(n*t+r,e.length):e.length,a=r;a<o;a+=t)v[0]=e[a],v[1]=e[a+1],v[2]=e[a+2],i(v,v,s),e[a]=v[0],e[a+1]=v[1],e[a+2]=v[2];return e}),E=Object.freeze({__proto__:null,add:function(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e},angle:function(e,t){var r=e[0],n=e[1],i=e[2],s=t[0],a=t[1],o=t[2],u=Math.sqrt(r*r+n*n+i*i)*Math.sqrt(s*s+a*a+o*o),l=u&&dot$4(e,t)/u;return Math.acos(Math.min(Math.max(l,-1),1))},bezier:function(e,t,r,n,i,s){var a=1-s,o=a*a,u=s*s,l=o*a,c=3*s*o,h=3*u*a,d=u*s;return e[0]=t[0]*l+r[0]*c+n[0]*h+i[0]*d,e[1]=t[1]*l+r[1]*c+n[1]*h+i[1]*d,e[2]=t[2]*l+r[2]*c+n[2]*h+i[2]*d,e},ceil:function(e,t){return e[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e[2]=Math.ceil(t[2]),e},clone:function(e){var r=new t(3);return r[0]=e[0],r[1]=e[1],r[2]=e[2],r},copy:function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e},create:create$4,cross:cross$2,dist:S,distance:distance$2,div:b,divide:divide$2,dot:dot$4,equals:function(t,r){var n=t[0],i=t[1],s=t[2],a=r[0],o=r[1],u=r[2];return Math.abs(n-a)<=e*Math.max(1,Math.abs(n),Math.abs(a))&&Math.abs(i-o)<=e*Math.max(1,Math.abs(i),Math.abs(o))&&Math.abs(s-u)<=e*Math.max(1,Math.abs(s),Math.abs(u))},exactEquals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]},floor:function(e,t){return e[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e[2]=Math.floor(t[2]),e},forEach:P,fromValues:fromValues$4,hermite:function(e,t,r,n,i,s){var a=s*s,o=a*(2*s-3)+1,u=a*(s-2)+s,l=a*(s-1),c=a*(3-2*s);return e[0]=t[0]*o+r[0]*u+n[0]*l+i[0]*c,e[1]=t[1]*o+r[1]*u+n[1]*l+i[1]*c,e[2]=t[2]*o+r[2]*u+n[2]*l+i[2]*c,e},inverse:function(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e},len:R,length:length$4,lerp:lerp$4,max:function(e,t,r){return e[0]=Math.max(t[0],r[0]),e[1]=Math.max(t[1],r[1]),e[2]=Math.max(t[2],r[2]),e},min:function(e,t,r){return e[0]=Math.min(t[0],r[0]),e[1]=Math.min(t[1],r[1]),e[2]=Math.min(t[2],r[2]),e},mul:y,multiply:multiply$4,negate:function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e},normalize:normalize$4,random:function(e,t){t=t||1;var n=2*r()*Math.PI,i=2*r()-1,s=Math.sqrt(1-i*i)*t;return e[0]=Math.cos(n)*s,e[1]=Math.sin(n)*s,e[2]=i*t,e},rotateX:function(e,t,r,n){var i=[],s=[];return i[0]=t[0]-r[0],i[1]=t[1]-r[1],i[2]=t[2]-r[2],s[0]=i[0],s[1]=i[1]*Math.cos(n)-i[2]*Math.sin(n),s[2]=i[1]*Math.sin(n)+i[2]*Math.cos(n),e[0]=s[0]+r[0],e[1]=s[1]+r[1],e[2]=s[2]+r[2],e},rotateY:function(e,t,r,n){var i=[],s=[];return i[0]=t[0]-r[0],i[1]=t[1]-r[1],i[2]=t[2]-r[2],s[0]=i[2]*Math.sin(n)+i[0]*Math.cos(n),s[1]=i[1],s[2]=i[2]*Math.cos(n)-i[0]*Math.sin(n),e[0]=s[0]+r[0],e[1]=s[1]+r[1],e[2]=s[2]+r[2],e},rotateZ:function(e,t,r,n){var i=[],s=[];return i[0]=t[0]-r[0],i[1]=t[1]-r[1],i[2]=t[2]-r[2],s[0]=i[0]*Math.cos(n)-i[1]*Math.sin(n),s[1]=i[0]*Math.sin(n)+i[1]*Math.cos(n),s[2]=i[2],e[0]=s[0]+r[0],e[1]=s[1]+r[1],e[2]=s[2]+r[2],e},round:function(e,t){return e[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e[2]=Math.round(t[2]),e},scale:function(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e},scaleAndAdd:function(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e},set:set$4,sqrDist:M,sqrLen:w,squaredDistance:squaredDistance$2,squaredLength:squaredLength$4,str:function(e){return"vec3("+e[0]+","+e[1]+","+e[2]+")"},sub:T,subtract:subtract$2,transformMat3:function(e,t,r){var n=t[0],i=t[1],s=t[2];return e[0]=n*r[0]+i*r[3]+s*r[6],e[1]=n*r[1]+i*r[4]+s*r[7],e[2]=n*r[2]+i*r[5]+s*r[8],e},transformMat4:function(e,t,r){var n=t[0],i=t[1],s=t[2],a=r[3]*n+r[7]*i+r[11]*s+r[15];return a=a||1,e[0]=(r[0]*n+r[4]*i+r[8]*s+r[12])/a,e[1]=(r[1]*n+r[5]*i+r[9]*s+r[13])/a,e[2]=(r[2]*n+r[6]*i+r[10]*s+r[14])/a,e},transformQuat:function(e,t,r){var n=r[0],i=r[1],s=r[2],a=r[3],o=t[0],u=t[1],l=t[2],c=i*l-s*u,h=s*o-n*l,d=n*u-i*o,m=i*d-s*h,p=s*c-n*d,f=n*h-i*c,g=2*a;return c*=g,h*=g,d*=g,m*=2,p*=2,f*=2,e[0]=o+c+m,e[1]=u+h+p,e[2]=l+d+f,e},zero:function(e){return e[0]=0,e[1]=0,e[2]=0,e}});function create$3(){var e=new t(4);return t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e}function clone$3(e){var r=new t(4);return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r}function fromValues$3(e,r,n,i){var s=new t(4);return s[0]=e,s[1]=r,s[2]=n,s[3]=i,s}function copy$3(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}function set$3(e,t,r,n,i){return e[0]=t,e[1]=r,e[2]=n,e[3]=i,e}function add$3(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e}function subtract$1(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e}function multiply$3(e,t,r){return e[0]=t[0]*r[0],e[1]=t[1]*r[1],e[2]=t[2]*r[2],e[3]=t[3]*r[3],e}function divide$1(e,t,r){return e[0]=t[0]/r[0],e[1]=t[1]/r[1],e[2]=t[2]/r[2],e[3]=t[3]/r[3],e}function scale$3(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e}function distance$1(e,t){var r=t[0]-e[0],n=t[1]-e[1],i=t[2]-e[2],s=t[3]-e[3];return Math.hypot(r,n,i,s)}function squaredDistance$1(e,t){var r=t[0]-e[0],n=t[1]-e[1],i=t[2]-e[2],s=t[3]-e[3];return r*r+n*n+i*i+s*s}function length$3(e){var t=e[0],r=e[1],n=e[2],i=e[3];return Math.hypot(t,r,n,i)}function squaredLength$3(e){var t=e[0],r=e[1],n=e[2],i=e[3];return t*t+r*r+n*n+i*i}function normalize$3(e,t){var r=t[0],n=t[1],i=t[2],s=t[3],a=r*r+n*n+i*i+s*s;return a>0&&(a=1/Math.sqrt(a)),e[0]=r*a,e[1]=n*a,e[2]=i*a,e[3]=s*a,e}function dot$3(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]}function lerp$3(e,t,r,n){var i=t[0],s=t[1],a=t[2],o=t[3];return e[0]=i+n*(r[0]-i),e[1]=s+n*(r[1]-s),e[2]=a+n*(r[2]-a),e[3]=o+n*(r[3]-o),e}function exactEquals$3(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]}function equals$3(t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=r[0],u=r[1],l=r[2],c=r[3];return Math.abs(n-o)<=e*Math.max(1,Math.abs(n),Math.abs(o))&&Math.abs(i-u)<=e*Math.max(1,Math.abs(i),Math.abs(u))&&Math.abs(s-l)<=e*Math.max(1,Math.abs(s),Math.abs(l))&&Math.abs(a-c)<=e*Math.max(1,Math.abs(a),Math.abs(c))}var k=subtract$1,C=multiply$3,L=divide$1,B=distance$1,I=squaredDistance$1,U=length$3,A=squaredLength$3,D=function(){var e=create$3();return function(t,r,n,i,s,a){var o,u;for(r||(r=4),n||(n=0),u=i?Math.min(i*r+n,t.length):t.length,o=n;o<u;o+=r)e[0]=t[o],e[1]=t[o+1],e[2]=t[o+2],e[3]=t[o+3],s(e,e,a),t[o]=e[0],t[o+1]=e[1],t[o+2]=e[2],t[o+3]=e[3];return t}}(),N=Object.freeze({__proto__:null,add:add$3,ceil:function(e,t){return e[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e[2]=Math.ceil(t[2]),e[3]=Math.ceil(t[3]),e},clone:clone$3,copy:copy$3,create:create$3,cross:function(e,t,r,n){var i=r[0]*n[1]-r[1]*n[0],s=r[0]*n[2]-r[2]*n[0],a=r[0]*n[3]-r[3]*n[0],o=r[1]*n[2]-r[2]*n[1],u=r[1]*n[3]-r[3]*n[1],l=r[2]*n[3]-r[3]*n[2],c=t[0],h=t[1],d=t[2],m=t[3];return e[0]=h*l-d*u+m*o,e[1]=-c*l+d*a-m*s,e[2]=c*u-h*a+m*i,e[3]=-c*o+h*s-d*i,e},dist:B,distance:distance$1,div:L,divide:divide$1,dot:dot$3,equals:equals$3,exactEquals:exactEquals$3,floor:function(e,t){return e[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e[2]=Math.floor(t[2]),e[3]=Math.floor(t[3]),e},forEach:D,fromValues:fromValues$3,inverse:function(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e[3]=1/t[3],e},len:U,length:length$3,lerp:lerp$3,max:function(e,t,r){return e[0]=Math.max(t[0],r[0]),e[1]=Math.max(t[1],r[1]),e[2]=Math.max(t[2],r[2]),e[3]=Math.max(t[3],r[3]),e},min:function(e,t,r){return e[0]=Math.min(t[0],r[0]),e[1]=Math.min(t[1],r[1]),e[2]=Math.min(t[2],r[2]),e[3]=Math.min(t[3],r[3]),e},mul:C,multiply:multiply$3,negate:function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e},normalize:normalize$3,random:function(e,t){var n,i,s,a,o,u;t=t||1;do{o=(n=2*r()-1)*n+(i=2*r()-1)*i}while(o>=1);do{u=(s=2*r()-1)*s+(a=2*r()-1)*a}while(u>=1);var l=Math.sqrt((1-o)/u);return e[0]=t*n,e[1]=t*i,e[2]=t*s*l,e[3]=t*a*l,e},round:function(e,t){return e[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e[2]=Math.round(t[2]),e[3]=Math.round(t[3]),e},scale:scale$3,scaleAndAdd:function(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e[3]=t[3]+r[3]*n,e},set:set$3,sqrDist:I,sqrLen:A,squaredDistance:squaredDistance$1,squaredLength:squaredLength$3,str:function(e){return"vec4("+e[0]+","+e[1]+","+e[2]+","+e[3]+")"},sub:k,subtract:subtract$1,transformMat4:function(e,t,r){var n=t[0],i=t[1],s=t[2],a=t[3];return e[0]=r[0]*n+r[4]*i+r[8]*s+r[12]*a,e[1]=r[1]*n+r[5]*i+r[9]*s+r[13]*a,e[2]=r[2]*n+r[6]*i+r[10]*s+r[14]*a,e[3]=r[3]*n+r[7]*i+r[11]*s+r[15]*a,e},transformQuat:function(e,t,r){var n=t[0],i=t[1],s=t[2],a=r[0],o=r[1],u=r[2],l=r[3],c=l*n+o*s-u*i,h=l*i+u*n-a*s,d=l*s+a*i-o*n,m=-a*n-o*i-u*s;return e[0]=c*l+m*-a+h*-u-d*-o,e[1]=h*l+m*-o+d*-a-c*-u,e[2]=d*l+m*-u+c*-o-h*-a,e[3]=t[3],e},zero:function(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=0,e}});function create$2(){var e=new t(4);return t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function setAxisAngle(e,t,r){r*=.5;var n=Math.sin(r);return e[0]=n*t[0],e[1]=n*t[1],e[2]=n*t[2],e[3]=Math.cos(r),e}function multiply$2(e,t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=r[0],u=r[1],l=r[2],c=r[3];return e[0]=n*c+a*o+i*l-s*u,e[1]=i*c+a*u+s*o-n*l,e[2]=s*c+a*l+n*u-i*o,e[3]=a*c-n*o-i*u-s*l,e}function rotateX$1(e,t,r){r*=.5;var n=t[0],i=t[1],s=t[2],a=t[3],o=Math.sin(r),u=Math.cos(r);return e[0]=n*u+a*o,e[1]=i*u+s*o,e[2]=s*u-i*o,e[3]=a*u-n*o,e}function rotateY$1(e,t,r){r*=.5;var n=t[0],i=t[1],s=t[2],a=t[3],o=Math.sin(r),u=Math.cos(r);return e[0]=n*u-s*o,e[1]=i*u+a*o,e[2]=s*u+n*o,e[3]=a*u-i*o,e}function rotateZ$1(e,t,r){r*=.5;var n=t[0],i=t[1],s=t[2],a=t[3],o=Math.sin(r),u=Math.cos(r);return e[0]=n*u+i*o,e[1]=i*u-n*o,e[2]=s*u+a*o,e[3]=a*u-s*o,e}function exp(e,t){var r=t[0],n=t[1],i=t[2],s=t[3],a=Math.sqrt(r*r+n*n+i*i),o=Math.exp(s),u=a>0?o*Math.sin(a)/a:0;return e[0]=r*u,e[1]=n*u,e[2]=i*u,e[3]=o*Math.cos(a),e}function ln(e,t){var r=t[0],n=t[1],i=t[2],s=t[3],a=Math.sqrt(r*r+n*n+i*i),o=a>0?Math.atan2(a,s)/a:0;return e[0]=r*o,e[1]=n*o,e[2]=i*o,e[3]=.5*Math.log(r*r+n*n+i*i+s*s),e}function slerp(t,r,n,i){var s,a,o,u,l,c=r[0],h=r[1],d=r[2],m=r[3],p=n[0],f=n[1],g=n[2],_=n[3];return(a=c*p+h*f+d*g+m*_)<0&&(a=-a,p=-p,f=-f,g=-g,_=-_),1-a>e?(s=Math.acos(a),o=Math.sin(s),u=Math.sin((1-i)*s)/o,l=Math.sin(i*s)/o):(u=1-i,l=i),t[0]=u*c+l*p,t[1]=u*h+l*f,t[2]=u*d+l*g,t[3]=u*m+l*_,t}function fromMat3(e,t){var r,n=t[0]+t[4]+t[8];if(n>0)r=Math.sqrt(n+1),e[3]=.5*r,r=.5/r,e[0]=(t[5]-t[7])*r,e[1]=(t[6]-t[2])*r,e[2]=(t[1]-t[3])*r;else{var i=0;t[4]>t[0]&&(i=1),t[8]>t[3*i+i]&&(i=2);var s=(i+1)%3,a=(i+2)%3;r=Math.sqrt(t[3*i+i]-t[3*s+s]-t[3*a+a]+1),e[i]=.5*r,r=.5/r,e[3]=(t[3*s+a]-t[3*a+s])*r,e[s]=(t[3*s+i]+t[3*i+s])*r,e[a]=(t[3*a+i]+t[3*i+a])*r}return e}var O,G,V,F,H=clone$3,z=fromValues$3,K=copy$3,$=set$3,X=add$3,j=multiply$2,Y=scale$3,Z=dot$3,q=lerp$3,W=length$3,J=W,Q=squaredLength$3,ee=Q,te=normalize$3,re=exactEquals$3,ne=equals$3,ie=(O=create$4(),G=fromValues$4(1,0,0),V=fromValues$4(0,1,0),function(e,t,r){var n=dot$4(t,r);return n<-.999999?(cross$2(O,G,t),R(O)<1e-6&&cross$2(O,V,t),normalize$4(O,O),setAxisAngle(e,O,Math.PI),e):n>.999999?(e[0]=0,e[1]=0,e[2]=0,e[3]=1,e):(cross$2(O,t,r),e[0]=O[0],e[1]=O[1],e[2]=O[2],e[3]=1+n,te(e,e))}),se=function(){var e=create$2(),t=create$2();return function(r,n,i,s,a,o){return slerp(e,n,a,o),slerp(t,i,s,o),slerp(r,e,t,2*o*(1-o)),r}}(),ae=(F=create$6(),function(e,t,r,n){return F[0]=r[0],F[3]=r[1],F[6]=r[2],F[1]=n[0],F[4]=n[1],F[7]=n[2],F[2]=-t[0],F[5]=-t[1],F[8]=-t[2],te(e,fromMat3(e,F))}),oe=Object.freeze({__proto__:null,add:X,calculateW:function(e,t){var r=t[0],n=t[1],i=t[2];return e[0]=r,e[1]=n,e[2]=i,e[3]=Math.sqrt(Math.abs(1-r*r-n*n-i*i)),e},clone:H,conjugate:function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=t[3],e},copy:K,create:create$2,dot:Z,equals:ne,exactEquals:re,exp:exp,fromEuler:function(e,t,r,n){var i=.5*Math.PI/180;t*=i,r*=i,n*=i;var s=Math.sin(t),a=Math.cos(t),o=Math.sin(r),u=Math.cos(r),l=Math.sin(n),c=Math.cos(n);return e[0]=s*u*c-a*o*l,e[1]=a*o*c+s*u*l,e[2]=a*u*l-s*o*c,e[3]=a*u*c+s*o*l,e},fromMat3:fromMat3,fromValues:z,getAngle:function(e,t){var r=Z(e,t);return Math.acos(2*r*r-1)},getAxisAngle:function(t,r){var n=2*Math.acos(r[3]),i=Math.sin(n/2);return i>e?(t[0]=r[0]/i,t[1]=r[1]/i,t[2]=r[2]/i):(t[0]=1,t[1]=0,t[2]=0),n},identity:function(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e},invert:function(e,t){var r=t[0],n=t[1],i=t[2],s=t[3],a=r*r+n*n+i*i+s*s,o=a?1/a:0;return e[0]=-r*o,e[1]=-n*o,e[2]=-i*o,e[3]=s*o,e},len:J,length:W,lerp:q,ln:ln,mul:j,multiply:multiply$2,normalize:te,pow:function(e,t,r){return ln(e,t),Y(e,e,r),exp(e,e),e},random:function(e){var t=r(),n=r(),i=r(),s=Math.sqrt(1-t),a=Math.sqrt(t);return e[0]=s*Math.sin(2*Math.PI*n),e[1]=s*Math.cos(2*Math.PI*n),e[2]=a*Math.sin(2*Math.PI*i),e[3]=a*Math.cos(2*Math.PI*i),e},rotateX:rotateX$1,rotateY:rotateY$1,rotateZ:rotateZ$1,rotationTo:ie,scale:Y,set:$,setAxes:ae,setAxisAngle:setAxisAngle,slerp:slerp,sqlerp:se,sqrLen:ee,squaredLength:Q,str:function(e){return"quat("+e[0]+","+e[1]+","+e[2]+","+e[3]+")"}});function fromRotationTranslation(e,t,r){var n=.5*r[0],i=.5*r[1],s=.5*r[2],a=t[0],o=t[1],u=t[2],l=t[3];return e[0]=a,e[1]=o,e[2]=u,e[3]=l,e[4]=n*l+i*u-s*o,e[5]=i*l+s*a-n*u,e[6]=s*l+n*o-i*a,e[7]=-n*a-i*o-s*u,e}function copy$1(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e}var ue=K;var le=K;function multiply$1(e,t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=r[4],u=r[5],l=r[6],c=r[7],h=t[4],d=t[5],m=t[6],p=t[7],f=r[0],g=r[1],_=r[2],x=r[3];return e[0]=n*x+a*f+i*_-s*g,e[1]=i*x+a*g+s*f-n*_,e[2]=s*x+a*_+n*g-i*f,e[3]=a*x-n*f-i*g-s*_,e[4]=n*c+a*o+i*l-s*u+h*x+p*f+d*_-m*g,e[5]=i*c+a*u+s*o-n*l+d*x+p*g+m*f-h*_,e[6]=s*c+a*l+n*u-i*o+m*x+p*_+h*g-d*f,e[7]=a*c-n*o-i*u-s*l+p*x-h*f-d*g-m*_,e}var ce=multiply$1;var he=Z;var de=W,me=de,pe=Q,fe=pe;var ge=Object.freeze({__proto__:null,add:function(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e[4]=t[4]+r[4],e[5]=t[5]+r[5],e[6]=t[6]+r[6],e[7]=t[7]+r[7],e},clone:function(e){var r=new t(8);return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r},conjugate:function(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=t[3],e[4]=-t[4],e[5]=-t[5],e[6]=-t[6],e[7]=t[7],e},copy:copy$1,create:function(){var e=new t(8);return t!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[4]=0,e[5]=0,e[6]=0,e[7]=0),e[3]=1,e},dot:he,equals:function(t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=t[4],u=t[5],l=t[6],c=t[7],h=r[0],d=r[1],m=r[2],p=r[3],f=r[4],g=r[5],_=r[6],x=r[7];return Math.abs(n-h)<=e*Math.max(1,Math.abs(n),Math.abs(h))&&Math.abs(i-d)<=e*Math.max(1,Math.abs(i),Math.abs(d))&&Math.abs(s-m)<=e*Math.max(1,Math.abs(s),Math.abs(m))&&Math.abs(a-p)<=e*Math.max(1,Math.abs(a),Math.abs(p))&&Math.abs(o-f)<=e*Math.max(1,Math.abs(o),Math.abs(f))&&Math.abs(u-g)<=e*Math.max(1,Math.abs(u),Math.abs(g))&&Math.abs(l-_)<=e*Math.max(1,Math.abs(l),Math.abs(_))&&Math.abs(c-x)<=e*Math.max(1,Math.abs(c),Math.abs(x))},exactEquals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]},fromMat4:function(e,r){var n=create$2();getRotation(n,r);var i=new t(3);return getTranslation$1(i,r),fromRotationTranslation(e,n,i),e},fromRotation:function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=0,e[5]=0,e[6]=0,e[7]=0,e},fromRotationTranslation:fromRotationTranslation,fromRotationTranslationValues:function(e,r,n,i,s,a,o){var u=new t(8);u[0]=e,u[1]=r,u[2]=n,u[3]=i;var l=.5*s,c=.5*a,h=.5*o;return u[4]=l*i+c*n-h*r,u[5]=c*i+h*e-l*n,u[6]=h*i+l*r-c*e,u[7]=-l*e-c*r-h*n,u},fromTranslation:function(e,t){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e[4]=.5*t[0],e[5]=.5*t[1],e[6]=.5*t[2],e[7]=0,e},fromValues:function(e,r,n,i,s,a,o,u){var l=new t(8);return l[0]=e,l[1]=r,l[2]=n,l[3]=i,l[4]=s,l[5]=a,l[6]=o,l[7]=u,l},getDual:function(e,t){return e[0]=t[4],e[1]=t[5],e[2]=t[6],e[3]=t[7],e},getReal:ue,getTranslation:function(e,t){var r=t[4],n=t[5],i=t[6],s=t[7],a=-t[0],o=-t[1],u=-t[2],l=t[3];return e[0]=2*(r*l+s*a+n*u-i*o),e[1]=2*(n*l+s*o+i*a-r*u),e[2]=2*(i*l+s*u+r*o-n*a),e},identity:function(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e},invert:function(e,t){var r=pe(t);return e[0]=-t[0]/r,e[1]=-t[1]/r,e[2]=-t[2]/r,e[3]=t[3]/r,e[4]=-t[4]/r,e[5]=-t[5]/r,e[6]=-t[6]/r,e[7]=t[7]/r,e},len:me,length:de,lerp:function(e,t,r,n){var i=1-n;return he(t,r)<0&&(n=-n),e[0]=t[0]*i+r[0]*n,e[1]=t[1]*i+r[1]*n,e[2]=t[2]*i+r[2]*n,e[3]=t[3]*i+r[3]*n,e[4]=t[4]*i+r[4]*n,e[5]=t[5]*i+r[5]*n,e[6]=t[6]*i+r[6]*n,e[7]=t[7]*i+r[7]*n,e},mul:ce,multiply:multiply$1,normalize:function(e,t){var r=pe(t);if(r>0){r=Math.sqrt(r);var n=t[0]/r,i=t[1]/r,s=t[2]/r,a=t[3]/r,o=t[4],u=t[5],l=t[6],c=t[7],h=n*o+i*u+s*l+a*c;e[0]=n,e[1]=i,e[2]=s,e[3]=a,e[4]=(o-n*h)/r,e[5]=(u-i*h)/r,e[6]=(l-s*h)/r,e[7]=(c-a*h)/r}return e},rotateAroundAxis:function(t,r,n,i){if(Math.abs(i)<e)return copy$1(t,r);var s=Math.hypot(n[0],n[1],n[2]);i*=.5;var a=Math.sin(i),o=a*n[0]/s,u=a*n[1]/s,l=a*n[2]/s,c=Math.cos(i),h=r[0],d=r[1],m=r[2],p=r[3];t[0]=h*c+p*o+d*l-m*u,t[1]=d*c+p*u+m*o-h*l,t[2]=m*c+p*l+h*u-d*o,t[3]=p*c-h*o-d*u-m*l;var f=r[4],g=r[5],_=r[6],x=r[7];return t[4]=f*c+x*o+g*l-_*u,t[5]=g*c+x*u+_*o-f*l,t[6]=_*c+x*l+f*u-g*o,t[7]=x*c-f*o-g*u-_*l,t},rotateByQuatAppend:function(e,t,r){var n=r[0],i=r[1],s=r[2],a=r[3],o=t[0],u=t[1],l=t[2],c=t[3];return e[0]=o*a+c*n+u*s-l*i,e[1]=u*a+c*i+l*n-o*s,e[2]=l*a+c*s+o*i-u*n,e[3]=c*a-o*n-u*i-l*s,o=t[4],u=t[5],l=t[6],c=t[7],e[4]=o*a+c*n+u*s-l*i,e[5]=u*a+c*i+l*n-o*s,e[6]=l*a+c*s+o*i-u*n,e[7]=c*a-o*n-u*i-l*s,e},rotateByQuatPrepend:function(e,t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=r[0],u=r[1],l=r[2],c=r[3];return e[0]=n*c+a*o+i*l-s*u,e[1]=i*c+a*u+s*o-n*l,e[2]=s*c+a*l+n*u-i*o,e[3]=a*c-n*o-i*u-s*l,o=r[4],u=r[5],l=r[6],c=r[7],e[4]=n*c+a*o+i*l-s*u,e[5]=i*c+a*u+s*o-n*l,e[6]=s*c+a*l+n*u-i*o,e[7]=a*c-n*o-i*u-s*l,e},rotateX:function(e,t,r){var n=-t[0],i=-t[1],s=-t[2],a=t[3],o=t[4],u=t[5],l=t[6],c=t[7],h=o*a+c*n+u*s-l*i,d=u*a+c*i+l*n-o*s,m=l*a+c*s+o*i-u*n,p=c*a-o*n-u*i-l*s;return rotateX$1(e,t,r),n=e[0],i=e[1],s=e[2],a=e[3],e[4]=h*a+p*n+d*s-m*i,e[5]=d*a+p*i+m*n-h*s,e[6]=m*a+p*s+h*i-d*n,e[7]=p*a-h*n-d*i-m*s,e},rotateY:function(e,t,r){var n=-t[0],i=-t[1],s=-t[2],a=t[3],o=t[4],u=t[5],l=t[6],c=t[7],h=o*a+c*n+u*s-l*i,d=u*a+c*i+l*n-o*s,m=l*a+c*s+o*i-u*n,p=c*a-o*n-u*i-l*s;return rotateY$1(e,t,r),n=e[0],i=e[1],s=e[2],a=e[3],e[4]=h*a+p*n+d*s-m*i,e[5]=d*a+p*i+m*n-h*s,e[6]=m*a+p*s+h*i-d*n,e[7]=p*a-h*n-d*i-m*s,e},rotateZ:function(e,t,r){var n=-t[0],i=-t[1],s=-t[2],a=t[3],o=t[4],u=t[5],l=t[6],c=t[7],h=o*a+c*n+u*s-l*i,d=u*a+c*i+l*n-o*s,m=l*a+c*s+o*i-u*n,p=c*a-o*n-u*i-l*s;return rotateZ$1(e,t,r),n=e[0],i=e[1],s=e[2],a=e[3],e[4]=h*a+p*n+d*s-m*i,e[5]=d*a+p*i+m*n-h*s,e[6]=m*a+p*s+h*i-d*n,e[7]=p*a-h*n-d*i-m*s,e},scale:function(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*r,e[5]=t[5]*r,e[6]=t[6]*r,e[7]=t[7]*r,e},set:function(e,t,r,n,i,s,a,o,u){return e[0]=t,e[1]=r,e[2]=n,e[3]=i,e[4]=s,e[5]=a,e[6]=o,e[7]=u,e},setDual:function(e,t){return e[4]=t[0],e[5]=t[1],e[6]=t[2],e[7]=t[3],e},setReal:le,sqrLen:fe,squaredLength:pe,str:function(e){return"quat2("+e[0]+","+e[1]+","+e[2]+","+e[3]+","+e[4]+","+e[5]+","+e[6]+","+e[7]+")"},translate:function(e,t,r){var n=t[0],i=t[1],s=t[2],a=t[3],o=.5*r[0],u=.5*r[1],l=.5*r[2],c=t[4],h=t[5],d=t[6],m=t[7];return e[0]=n,e[1]=i,e[2]=s,e[3]=a,e[4]=a*o+i*l-s*u+c,e[5]=a*u+s*o-n*l+h,e[6]=a*l+n*u-i*o+d,e[7]=-n*o-i*u-s*l+m,e}});function create(){var e=new t(2);return t!=Float32Array&&(e[0]=0,e[1]=0),e}function subtract(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e}function multiply(e,t,r){return e[0]=t[0]*r[0],e[1]=t[1]*r[1],e}function divide(e,t,r){return e[0]=t[0]/r[0],e[1]=t[1]/r[1],e}function distance(e,t){var r=t[0]-e[0],n=t[1]-e[1];return Math.hypot(r,n)}function squaredDistance(e,t){var r=t[0]-e[0],n=t[1]-e[1];return r*r+n*n}function length(e){var t=e[0],r=e[1];return Math.hypot(t,r)}function squaredLength(e){var t=e[0],r=e[1];return t*t+r*r}function lerp(e,t,r,n){var i=t[0],s=t[1];return e[0]=i+n*(r[0]-i),e[1]=s+n*(r[1]-s),e}var _e=length,xe=subtract,ve=multiply,Te=divide,ye=distance,be=squaredDistance,Se=squaredLength,Me=function(){var e=create();return function(t,r,n,i,s,a){var o,u;for(r||(r=2),n||(n=0),u=i?Math.min(i*r+n,t.length):t.length,o=n;o<u;o+=r)e[0]=t[o],e[1]=t[o+1],s(e,e,a),t[o]=e[0],t[o+1]=e[1];return t}}(),Re=Object.freeze({__proto__:null,add:function(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e},angle:function(e,t){var r=e[0],n=e[1],i=t[0],s=t[1],a=Math.sqrt(r*r+n*n)*Math.sqrt(i*i+s*s),o=a&&(r*i+n*s)/a;return Math.acos(Math.min(Math.max(o,-1),1))},ceil:function(e,t){return e[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e},clone:function(e){var r=new t(2);return r[0]=e[0],r[1]=e[1],r},copy:function(e,t){return e[0]=t[0],e[1]=t[1],e},create:create,cross:function(e,t,r){var n=t[0]*r[1]-t[1]*r[0];return e[0]=e[1]=0,e[2]=n,e},dist:ye,distance:distance,div:Te,divide:divide,dot:function(e,t){return e[0]*t[0]+e[1]*t[1]},equals:function(t,r){var n=t[0],i=t[1],s=r[0],a=r[1];return Math.abs(n-s)<=e*Math.max(1,Math.abs(n),Math.abs(s))&&Math.abs(i-a)<=e*Math.max(1,Math.abs(i),Math.abs(a))},exactEquals:function(e,t){return e[0]===t[0]&&e[1]===t[1]},floor:function(e,t){return e[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e},forEach:Me,fromValues:function(e,r){var n=new t(2);return n[0]=e,n[1]=r,n},inverse:function(e,t){return e[0]=1/t[0],e[1]=1/t[1],e},len:_e,length:length,lerp:lerp,max:function(e,t,r){return e[0]=Math.max(t[0],r[0]),e[1]=Math.max(t[1],r[1]),e},min:function(e,t,r){return e[0]=Math.min(t[0],r[0]),e[1]=Math.min(t[1],r[1]),e},mul:ve,multiply:multiply,negate:function(e,t){return e[0]=-t[0],e[1]=-t[1],e},normalize:function(e,t){var r=t[0],n=t[1],i=r*r+n*n;return i>0&&(i=1/Math.sqrt(i)),e[0]=t[0]*i,e[1]=t[1]*i,e},random:function(e,t){t=t||1;var n=2*r()*Math.PI;return e[0]=Math.cos(n)*t,e[1]=Math.sin(n)*t,e},rotate:function(e,t,r,n){var i=t[0]-r[0],s=t[1]-r[1],a=Math.sin(n),o=Math.cos(n);return e[0]=i*o-s*a+r[0],e[1]=i*a+s*o+r[1],e},round:function(e,t){return e[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e},scale:function(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e},scaleAndAdd:function(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e},set:function(e,t,r){return e[0]=t,e[1]=r,e},sqrDist:be,sqrLen:Se,squaredDistance:squaredDistance,squaredLength:squaredLength,str:function(e){return"vec2("+e[0]+","+e[1]+")"},sub:xe,subtract:subtract,transformMat2:function(e,t,r){var n=t[0],i=t[1];return e[0]=r[0]*n+r[2]*i,e[1]=r[1]*n+r[3]*i,e},transformMat2d:function(e,t,r){var n=t[0],i=t[1];return e[0]=r[0]*n+r[2]*i+r[4],e[1]=r[1]*n+r[3]*i+r[5],e},transformMat3:function(e,t,r){var n=t[0],i=t[1];return e[0]=r[0]*n+r[3]*i+r[6],e[1]=r[1]*n+r[4]*i+r[7],e},transformMat4:function(e,t,r){var n=t[0],i=t[1];return e[0]=r[0]*n+r[4]*i+r[12],e[1]=r[1]*n+r[5]*i+r[13],e},zero:function(e){return e[0]=0,e[1]=0,e}}),we=Object.freeze({__proto__:null,glMatrix:i,mat2:o,mat2d:c,mat3:m,mat4:x,quat:oe,quat2:ge,vec2:Re,vec3:E,vec4:N});class InstanceIdGenerator{static idMaps=new Map;static getNextId(e){let t=this.idMaps.get(e)||0;return this.idMaps.set(e,t+1),t}}Object.freeze(InstanceIdGenerator);class Camera2D{#e;#t=create$5();#r=0;#n=0;#i=0;#s;constructor(){}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#s||`${this.constructor.name} Instance ${this.#e}`}set name(e){this.#s=e}get modelMatrix(){return this.#t}get z(){return this.#i}get x(){return this.#r}set x(e){this.#r=e,this.#t[12]=e}get y(){return this.#n}set y(e){this.#n=e,this.#t[13]=e}get position(){return[this.#r,this.#n]}setPosition(e,t){Array.isArray(e)?[this.#r,this.#n]=e:(this.#r=e,this.#n=t),[this.#t[12],this.#t[13],this.#t[14]]=[this.#r,this.#n,0]}}const consoleAndThrowError=(...e)=>{const t=Array.prototype.slice.call(e).join(" ");throw new Error(t)},validateNumber=e=>"number"==typeof e||(consoleAndThrowError("Only numbers allowed."),!1);class PerspectiveCamera{#e;#a=new Float32Array([0,1,0]);#t=create$5();#r=0;#i=0;#n=0;#o=0;#u=0;#l=0;#c=60;#h=.01;#d=1e4;#s;constructor(){}get rotationX(){return this.#o}set rotationX(e){this.#o=e}get rotationY(){return this.#u}set rotationY(e){this.#u=e}get rotationZ(){return this.#l}set rotationZ(e){this.#l=e}get fieldOfView(){return this.#c}set fieldOfView(e){validateNumber(e),this.#c=e}get nearClipping(){return this.#h}set nearClipping(e){validateNumber(e),this.#h=e}get farClipping(){return this.#d}set farClipping(e){validateNumber(e),this.#d=e}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#s||`${this.constructor.name} Instance ${this.#e}`}set name(e){this.#s=e}get modelMatrix(){return this.#t}get x(){return this.#r}set x(e){this.#r=e,this.#t[12]=e}get y(){return this.#n}set y(e){this.#n=e,this.#t[13]=e}get z(){return this.#i}set z(e){this.#i=e,this.#t[14]=e}get position(){return[this.#r,this.#n,this.#i]}setPosition(e,t,r){Array.isArray(e)?[this.#r,this.#n,this.#i]=e:(this.#r=e,this.#n=t,this.#i=r),[this.#t[12],this.#t[13],this.#t[14]]=[this.#r,this.#n,this.#i]}lookAt(e,t,r){lookAt(this.#t,[this.#r,this.#n,this.#i],[e,t,r],this.#a)}}class OrthographicCamera extends PerspectiveCamera{#e;#s;#m=1;#p=-1;#f=-1;#g=1;constructor(){super(),this.nearClipping=.01,this.farClipping=2e3}get top(){return this.#m}set top(e){validateNumber(e),this.#m=e}get bottom(){return this.#p}set bottom(e){validateNumber(e),this.#p=e}get left(){return this.#f}set left(e){validateNumber(e),this.#f=e}get right(){return this.#g}set right(e){validateNumber(e),this.#g=e}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#s||`${this.constructor.name} Instance ${this.#e}`}set name(e){this.#s=e}}const gltfAnimationLooper_rotation=(t,r,n,i,s,a,o,u,l,c,h)=>{let d,m,p,f,g,_,x,v,T,y,b,S,M,R,w,P,E,k,C,L,B,I,U,A,D,N,O=!0;if("CUBICSPLINE"==t)a!=i-1?(N=12*a,B=n[N+4],I=n[N+5],U=n[N+6],A=n[N+7],D=B*B+I*I+U*U+A*A,D>0&&(D=1/Math.sqrt(D)),T=B*D,y=I*D,b=U*D,S=A*D,B=n[N+8],I=n[N+9],U=n[N+10],A=n[N+11],D=B*B+I*I+U*U+A*A,D>0&&(D=1/Math.sqrt(D)),M=B*D,R=I*D,w=U*D,P=A*D,B=n[N],I=n[N+1],U=n[N+2],A=n[N+3],D=B*B+I*I+U*U+A*A,D>0&&(D=1/Math.sqrt(D)),g=B*D,_=I*D,x=U*D,v=A*D,N=12*o,B=n[N+4],I=n[N+5],U=n[N+6],A=n[N+7],D=B*B+I*I+U*U+A*A,D>0&&(D=1/Math.sqrt(D)),d=B*D,m=I*D,p=U*D,f=A*D,E=T,k=M*s,C=d,L=g*s,B=u*E+l*k+c*C+h*L,E=y,k=R*s,C=m,L=_*s,I=u*E+l*k+c*C+h*L,E=b,k=w*s,C=p,L=x*s,U=u*E+l*k+c*C+h*L,E=S,k=P*s,C=f,L=v*s,A=u*E+l*k+c*C+h*L):O=!1;else{let t,r,i,u,l;N=4*a,B=n[N],I=n[N+1],U=n[N+2],A=n[N+3],D=B*B+I*I+U*U+A*A,D>0&&(D=1/Math.sqrt(D)),T=B*D,y=I*D,b=U*D,S=A*D,N=4*o,B=n[N],I=n[N+1],U=n[N+2],A=n[N+3],D=B*B+I*I+U*U+A*A,D>0&&(D=1/Math.sqrt(D)),d=B*D,m=I*D,p=U*D,f=A*D,r=T*d+y*m+b*p+S*f,r<0&&(r=-r,d=-d,m=-m,p=-p,f=-f),1-r>e?(t=Math.acos(r),i=Math.sin(t),u=Math.sin((1-s)*t)/i,l=Math.sin(s*t)/i):(u=1-s,l=s),B=u*T+l*d,I=u*y+l*m,U=u*b+l*p,A=u*S+l*f}if(O){let e=[],t=[0,0,0],n=B+B,i=I+I,s=U+U,a=B*n,o=B*i,u=B*s,l=I*i,c=I*s,h=U*s,d=A*n,m=A*i,p=A*s;e[0]=1-(l+h),e[4]=o-p,e[8]=u+m,e[1]=o+p,e[5]=1-(a+h),e[9]=c-d,e[2]=u-m,e[6]=c+d,e[10]=1-(a+l),e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1;let f=e[0],g=e[4],_=e[8],x=e[5],v=e[9],T=e[6],y=e[10];t[1]=Math.asin(Math.max(-1,Math.min(1,_))),Math.abs(_)<.99999?(t[0]=Math.atan2(-v,y),t[2]=Math.atan2(-g,f)):(t[0]=Math.atan2(T,x),t[2]=0),t[0]=-180*t[0]/Math.PI,t[1]=-180*t[1]/Math.PI,t[2]=-180*t[2]/Math.PI,r.rotationX=t[0],r.rotationY=t[1],r.rotationZ=t[2]}},gltfAnimationLooper_scale=(e,t,r,n,i,s,a,o,u,l,c)=>{let h,d,m,p,f,g,_,x,v,T,y,b,S,M,R,w,P;"CUBICSPLINE"==e?s!=n-1&&(P=9*s,h=r[P+3],d=r[P+4],m=r[P+5],T=r[P+6],y=r[P+7],b=r[P+8],P=9*a,p=r[P+0],f=r[P+1],g=r[P+2],_=r[P+3],x=r[P+4],v=r[P+5],S=_,M=T*i,R=h,w=p*i,t.scaleX=o*S+u*M+l*R+c*w,S=x,M=y*i,R=d,w=f*i,t.scaleY=o*S+u*M+l*R+c*w,S=v,M=b*i,R=m,w=g*i,t.scaleZ=o*S+u*M+l*R+c*w):(P=3*a,h=r[P],d=r[P+1],m=r[P+2],P=3*s,_=r[P],x=r[P+1],v=r[P+2],t.scaleX=_+i*(h-_),t.scaleY=x+i*(d-x),t.scaleZ=v+i*(m-v))},gltfAnimationLooper_transition=(e,t,r,n,i,s,a,o,u,l,c)=>{let h,d,m,p,f,g,_,x,v,T,y,b,S,M,R,w,P;"CUBICSPLINE"==e?s!=n-1&&(P=9*s,h=r[P+3],d=r[P+4],m=r[P+5],T=r[P+6],y=r[P+7],b=r[P+8],P=9*a,p=r[P+0],f=r[P+1],g=r[P+2],_=r[P+3],x=r[P+4],v=r[P+5],S=_,M=T*i,R=h,w=p*i,t.x=o*S+u*M+l*R+c*w,S=x,M=y*i,R=d,w=f*i,t.y=o*S+u*M+l*R+c*w,S=v,M=b*i,R=m,w=g*i,t.z=o*S+u*M+l*R+c*w):(P=3*a,h=r[P],d=r[P+1],m=r[P+2],P=3*s,_=r[P],x=r[P+1],v=r[P+2],t.x=_+i*(h-_),t.y=x+i*(d-x),t.z=v+i*(m-v))},gltfAnimationLooper_weight=(e,t,r,n,i)=>{let s,a,o,u,l,c,h,d,m,p,f,g,_,x,v,T,y,b,S,M,R,w;const P=9999991;for(s=e.length;s--;){let E;for(a=e[s],o=a.geometry.vertexBuffer.data,l=a.geometry.vertexBuffer.stride,h=o.length/l,T=a.animationInfo.morphInfo,u=T.origin,y=T.morphInfoDataList,v=y.length,c=0;c<h;c++){x=c*l;let e=x*P+n*P+i;if(w=T.cacheData[e],w)[d,m,p,f,g,_]=w;else{for(d=u[x],m=u[x],p=u[x+1],f=u[x+1],g=u[x+2],_=u[x+2],b=v;b--;)S=t[n*v+b],M=t[i*v+b],R=y[b].interleaveData,E=R[x],d+=S*E,m+=M*E,E=R[x+1],p+=S*E,f+=M*E,E=R[x+2],g+=S*E,_+=M*E;T.cacheData[e]=[d,m,p,f,g,_]}o[x]=d+r*(m-d),o[x+1]=p+r*(f-p),o[x+2]=g+r*(_-g)}a.geometry.vertexBuffer.updateAllData(o)}};class VertexGPURenderInfo{vertexShaderModule;vertexStructInfo;vertexUniformInfo;vertexBindGroupLayout;vertexUniformBindGroup;vertexUniformBuffer;pipeline;shadowPipeline;pickingPipeline;constructor(e,t,r,n,i,s,a,o){this.vertexShaderModule=e,this.vertexUniformInfo=t,this.vertexBindGroupLayout=r,this.vertexUniformBindGroup=i,this.vertexUniformBuffer=n,this.pipeline=s,this.shadowPipeline=a,this.pickingPipeline=o}}Object.freeze(VertexGPURenderInfo);const defineProperty=(e,t,r,n,...i)=>{Object.defineProperty(e.prototype,t,r(t,n,...i))},defineProperties=e=>(t,r)=>{r.forEach((r=>{if(Array.isArray(r)){const[n,i,...s]=r;defineProperty(t,n,e,i,...s)}else defineProperty(t,r,e)}))},createDefineByPreset=e=>{const t={};return Object.keys(e).forEach((r=>{const[n,i]=e[r];Object.assign(t,(e=>t=>t.reduce(((t,r)=>({...t,[r]:e})),{}))(n)(Object.values(i)))})),{defineByPreset:(e,r)=>((e,t,r)=>{t.forEach((t=>{if(Array.isArray(t)){const[n,i,...s]=t,a=r[n];a||consoleAndThrowError(n,"is a key not defined in Define Preset."),defineProperty(e,n,a,i,...s)}else{const n=r[t];n||consoleAndThrowError(t,"is a key not defined in Define Preset."),defineProperty(e,t,n)}}))})(e,r,t)}},Pe={enumerable:!0,configurable:!1};function createSetter$5(e,t,r){return function(n){this[t]=n;const{gpuRenderInfo:i}=this;if(r){const{fragmentUniformInfo:t,fragmentUniformBuffer:r}=i;r.writeBuffer(t.members[e],n?1:0)}else if(i){const{vertexUniformInfo:t,vertexUniformBuffer:r}=i;r.writeBuffer(t.members[e],n?1:0)}}}function defineBoolean(e,t=!1,r=!0){const n=Symbol(e);return{get:function(){return void 0===this[n]&&(this[n]=t),this[n]},set:createSetter$5(e,n,r),...Pe}}Object.freeze(Pe),Object.freeze(defineBoolean);const validatePositiveNumberRange=(e,t=0,r=Number.MAX_VALUE)=>("number"!=typeof e&&consoleAndThrowError("Only numbers allowed."),"number"!=typeof t&&consoleAndThrowError("Only numbers allowed."),"number"!=typeof r&&consoleAndThrowError("Only numbers allowed."),(t<0||e<0||e<t||e>r)&&consoleAndThrowError(`Only numbers within the range of [${t},${r}] are allowed.`),!0);function createSetter$4(e,t,r,n=0,i){return function(s){void 0!==n&&s<n&&(console.warn(`Value for ${e} is below the minimum (${n}). Received:${s}. Adjusted to ${n}.`),s=n),void 0!==i&&s>i&&(console.warn(`Value for ${e} exceeds the maximum (${i}). Received:${s}. Adjusted to ${i}.`),s=i),validatePositiveNumberRange(s),this[t]=s;const{gpuRenderInfo:a}=this;if(r){const{fragmentUniformInfo:r,fragmentUniformBuffer:n}=a;n.writeBuffer(r.members[e],this[t])}else if(a){const{vertexUniformInfo:r,vertexUniformBuffer:n}=a;n.writeBuffer(r.members[e],this[t])}}}function definePositiveNumberRange(e,t=1,r=!0,n=0,i){const s=Symbol(e);return{get:function(){return void 0===this[s]&&(this[s]=t),this[s]},set:createSetter$4(e,s,r,n,i),...Pe}}Object.freeze(definePositiveNumberRange);const isUint=e=>Number.isInteger(e)&&e>=0,validateUintRange=(e,t=0,r=4503599627370496)=>{const n=isUint(e),i=isUint(t),s=isUint(r),a="is not Uint!/value:",o=`(check range:${t}u ~ ${r}u)`;return n||consoleAndThrowError(`value ${a}${e}/${o}`),i||consoleAndThrowError(`min ${a}${t}/${o}`),s||consoleAndThrowError(`max ${a}${r}/${o}`),t>=r&&consoleAndThrowError(`maximum value is bigger than minimum value./${o}`),t>e&&consoleAndThrowError(`value is smaller than minimum value./value:${e}/${o}`),r<e&&consoleAndThrowError(`value is bigger than maximum value./value:${e}/${o}`),!0};function createSetter$3(e,t,r,n=0,i){return function(s){validateUintRange(s),void 0!==n&&s<n&&(console.warn(`Value for ${e} is below the minimum (${n}). Received:${s}. Adjusted to ${n}.`),s=n),void 0!==i&&s>i&&(console.warn(`Value for ${e} exceeds the maximum (${i}). Received:${s}. Adjusted to ${i}.`),s=i),this[t]=s;const{gpuRenderInfo:a}=this;if(r){const{fragmentUniformInfo:r,fragmentUniformBuffer:n}=a;n.writeBuffer(r.members[e],this[t])}else if(a){const{vertexUniformInfo:r,vertexUniformBuffer:n}=a;n.writeBuffer(r.members[e],this[t])}}}function defineUintRange(e,t=0,r=!0,n=0,i){const s=Symbol(e);return{get:function(){return void 0===this[s]&&(this[s]=t),this[s]},set:createSetter$3(e,s,r,n,i),...Pe}}function defineProperty_boolean(e,t=!1){return defineBoolean(e,t,!1)}function defineProperty_uintRange(e,t=0,r,n){return defineUintRange(e,t,!1,r,n)}function defineProperty_PositiveNumberRange(e,t=0,r,n){return definePositiveNumberRange(e,t,!1,r,n)}Object.freeze(defineUintRange);const Ee={USE_BILLBOARD_PERSPECTIVE:"useBillboardPerspective",USE_BILLBOARD:"useBillboard",RECEIVE_SHADOW:"receiveShadow"},ke={BILLBOARD_FIXED_SCALE:"billboardFixedScale"},Ce={},Le={...createDefineByPreset({defineBoolean:[defineProperty_boolean,Ee],defineUint:[defineProperty_uintRange,Ce],definePositiveNumber:[defineProperty_PositiveNumberRange,ke]}),defineBoolean:defineProperties(defineProperty_boolean),defineUint:defineProperties(defineProperty_uintRange),definePositiveNumber:defineProperties(defineProperty_PositiveNumberRange),PRESET_BOOLEAN:Ee,PRESET_POSITIVE_NUMBER:ke,PRESET_UINT:Ce,PRESET_SAMPLER:{},PRESET_TEXTURE:{},PRESET_CUBE_TEXTURE:{},PRESET_VEC2:{},PRESET_VEC3:{},PRESET_VEC4:{},PRESET_COLOR_RGB:{}};Object.freeze(Le);const uuidToUint=e=>{const t=e.replace(/-/g,"").substring(0,8);return parseInt(t,16)};class ResourceStateBitmapTexture{texture;src;cacheKey;useNum=0;uuid;constructor(e){this.texture=e,this.src=e.src,this.cacheKey=e.cacheKey,this.useNum=0,this.uuid=e.uuid}}class ResourceStateCubeTexture{texture;srcList;cacheKey;useNum=0;uuid;constructor(e){this.texture=e,this.srcList=e.srcList,this.cacheKey=e.cacheKey,this.useNum=0,this.uuid=e.uuid}}const basicRegisterResource=(e,t)=>{const{uuid:r,targetResourceManagedState:n}=e,i=t instanceof ResourceStateCubeTexture||t instanceof ResourceStateBitmapTexture;try{n.table[r]&&consoleAndThrowError(`Buffer with UUID ${r} is already registered.`),n.table[r]=t,n.length++,i||(n.videoMemory+=e.size)}catch(e){consoleAndThrowError(e.message)}};class ResourceStateUniformBuffer{static dirtyList=[];buffer;uuid;#_=0;constructor(e){this.buffer=e,this.uuid=e.uuid}get useNum(){return this.#_}set useNum(e){this.#_=e,ResourceStateUniformBuffer.dirtyList.push(this)}}const basicUnregisterResource=e=>{const{uuid:t,targetResourceManagedState:r}=e,{table:n}=r;n[t]&&(r.videoMemory-=e.size,delete n[t],r.length--)},validateRedGPUContext=e=>{if("RedGPUContext"!==e?.constructor?.name){return consoleAndThrowError(`from ${e?.constructor?.name}:requires a RedGPUContext instance,but received:${e}`),!1}return!0},createUUID=()=>{const e="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");let t,r=0,n=["","","","","-","","","","-","4","","","-","","","","-","","","","","","-","","","","","","","","","","","",""];for(;r<36;)""===n[r]&&(t=16*Math.random()|0,n[r]=e[19===r?3&t|8:15&t]),r++;return n.join("")};class ResourceBase{#x=createUUID();#v;#T;#s="";#e;#y=[];constructor(e){validateRedGPUContext(e),this.#v=e,this.#T=e.gpuDevice}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#s||`${this.constructor.name} Instance ${this.#e}`}set name(e){this.#s=e}get uuid(){return this.#x}get gpuDevice(){return this.#T}get redGPUContext(){return this.#v}__addDirtyPipelineListener(e){this.#b(!0),this.#y.push(e)}__removeDirtyPipelineListener(e){const t=this.#y.indexOf(e);t>-1&&(this.#y.splice(t,1),this.#b(!1))}__fireListenerList(e=!1){for(const e of this.#y)e(this);e&&(this.#y.length=0)}#b(e){const{resourceManager:t}=this.#v;if(t){const r=t[`managed${this.constructor.name}State`]?.table?.[this.#x];r&&(e?r.useNum++:r.useNum--)}}}class ManagedResourceBase extends ResourceBase{#S;constructor(e,t){super(e),this.#S=e.resourceManager[t]}get targetResourceManagedState(){return this.#S}}class ABaseBuffer extends ManagedResourceBase{#M;constructor(e,t,r){super(e,t),this.#M=r}get usage(){return this.#M}}class AUniformBaseBuffer extends ABaseBuffer{#R;#w;#P;#E;constructor(e,t,r,n,i=""){super(e,t,r),this.#w=n.byteLength,this.#R={size:this.#w,usage:this.usage,label:i};try{this.#E=e.gpuDevice.createBuffer(this.#R)}catch(e){console.error("GPU   :",e)}e.gpuDevice.queue.writeBuffer(this.#E,0,n)}get gpuBuffer(){return this.#E}get data(){return this.#P}get size(){return this.#w}get uniformBufferDescriptor(){return this.#R}destroy(){const e=this.#E;e&&(this.#E=null,this.__fireListenerList(!0),basicUnregisterResource(this),e&&e.destroy())}writeBuffers(e){const{gpuDevice:t}=this.redGPUContext;let r=e.length;for(;r--;){const[n,i]=e[r];t.queue.writeBuffer(this.gpuBuffer,n.uniformOffset,new n.View("number"==typeof i?[i]:i))}}writeBuffer(e,t){this.redGPUContext.gpuDevice.queue.writeBuffer(this.gpuBuffer,e.uniformOffset,new e.View("number"==typeof t?[t]:t))}}const getCacheBufferFromResourceState=(e,t)=>{const{targetResourceManagedState:r}=e,n=((e,t)=>{if(!t)return;let r;const n=e.table;for(const e in n)if(n[e].label===t){r=n[e];break}return r})(r,t);return n?r.table[e.uuid].buffer:null};class UniformBuffer extends AUniformBaseBuffer{constructor(e,t,r="",n=""){super(e,"managedUniformBufferState",GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,t,r);const i=getCacheBufferFromResourceState(this,n);if(i)return i;n&&(this.name=n),basicRegisterResource(this,new ResourceStateUniformBuffer(this))}}Object.freeze(UniformBuffer);const Be={CLAMP_TO_EDGE:"clamp-to-edge",REPEAT:"repeat",MIRRORED_REPEAT:"mirror-repeat"};Object.freeze(Be);const Ie={NEAREST:"nearest",LINEAR:"linear"};Object.freeze(Ie);const Ue={NEAREST:"nearest",LINEAR:"linear"};Object.freeze(Ue);const Ae=new Map,De=Object.values(Ie),Ne=Object.values(Be),Oe=Object.values(Ue);class Sampler extends ResourceBase{#k;#C=Ie.LINEAR;#L=Ie.LINEAR;#B=Ue.LINEAR;#I=Be.REPEAT;#U=Be.REPEAT;#A=Be.REPEAT;#D;#N;#O;#G=1;constructor(e,t){super(e),this.#V(t)}get addressModeU(){return this.#I}set addressModeU(e){this.#F(e,"addressModeU")}get addressModeV(){return this.#U}set addressModeV(e){this.#F(e,"addressModeV")}get addressModeW(){return this.#A}set addressModeW(e){this.#F(e,"addressModeW")}get mipmapFilter(){return this.#B}set mipmapFilter(e){this.#H(e,Oe,"mipmapFilter")}get gpuSampler(){return this.#k}get magFilter(){return this.#C}set magFilter(e){this.#H(e,De,"magFilter")}get minFilter(){return this.#L}set minFilter(e){this.#H(e,De,"minFilter")}get maxAnisotropy(){return this.#G}set maxAnisotropy(e){validateUintRange(e,1,16),this.#G=e,this.#V()}get isAnisotropyValid(){return!this.#G||"linear"===this.#C&&"linear"===this.#L&&"linear"===this.#B}#z(){this.__fireListenerList()}#F(e,t){if(Ne.includes(e)){switch(t){case"addressModeU":this.#I=e;break;case"addressModeV":this.#U=e;break;case"addressModeW":this.#A=e}this.#V()}else consoleAndThrowError(`Invalid ${t} value. Must be one of ${Ne.join(",")},but received:${e}.`)}#H(e,t,r){if(t.includes(e)||null===e){switch(r){case"mipmapFilter":this.#B=e;break;case"magFilter":this.#C=e;break;case"minFilter":this.#L=e}this.#V()}else consoleAndThrowError(`Invalid ${r} value. Must be one of ${t.join(",")},but received:${e}.`)}#K(){return`${this.#C}:${this.#L}:${this.#B}:${this.#I}:${this.#U}:${this.#A}:${this.#D}:${this.#N}:${this.#O}:${this.#G}`}#V(e){e&&(e.magFilter&&(this.#C=e.magFilter),e.minFilter&&(this.#L=e.minFilter),e.mipmapFilter&&(this.#B=e.mipmapFilter),e.addressModeU&&(this.#I=e.addressModeU),e.addressModeV&&(this.#U=e.addressModeV),e.addressModeW&&(this.#A=e.addressModeW),void 0!==e.lodMinClamp&&(this.#D=e.lodMinClamp),void 0!==e.lodMaxClamp&&(this.#N=e.lodMaxClamp),e.compare&&(this.#O=e.compare),e.maxAnisotropy&&(this.#G=e.maxAnisotropy)),this.isAnisotropyValid||1===this.#G||(console.warn(`Invalid maxAnisotropy setting (${this.#G}) detected:magFilter(${this.#C}),minFilter(${this.#L}),mipmapFilter(${this.#B}) must all be set to 'linear' for anisotropic filtering to work. Falling back to default (1).`),this.#G=1);const t=this.#K();if(!Ae.has(t)){let e={};this.#C&&(e.magFilter=this.#C),this.#L&&(e.minFilter=this.#L),this.#B&&(e.mipmapFilter=this.#B),this.#I&&(e.addressModeU=this.#I),this.#U&&(e.addressModeV=this.#U),this.#A&&(e.addressModeW=this.#A),void 0!==this.#D&&(e.lodMinClamp=this.#D),void 0!==this.#N&&(e.lodMaxClamp=this.#N),this.#O&&(e.compare=this.#O),this.#G&&(e.maxAnisotropy=this.#G),Ae.set(t,this.redGPUContext.gpuDevice.createSampler(e))}this.#k=Ae.get(t),this.#z()}}function calculateTextureByteSize(e){return function(e){switch(e){case"r8unorm":case"r8snorm":case"r8uint":case"r8sint":return 1;case"r16uint":case"r16sint":case"r16float":case"rg8unorm":case"rg8snorm":case"rg8uint":case"rg8sint":case"depth16unorm":return 2;case"r32uint":case"r32sint":case"r32float":case"rg16uint":case"rg16sint":case"rg16float":case"rgba8unorm":case"rgba8unorm-srgb":case"rgba8snorm":case"rgba8uint":case"rgba8sint":case"bgra8unorm":case"bgra8unorm-srgb":case"depth24plus":case"depth32float":return 4;case"rg32uint":case"rg32sint":case"rg32float":case"rgba16uint":case"rgba16sint":case"rgba16float":return 8;case"rgba32uint":case"rgba32sint":case"rgba32float":return 16;default:throw new Error(`Unrecognized texture format:${e}`)}}(e.format)*(e.size[0]*e.size[1]*(e.size[2]||1))*(e.sampleCount?e.sampleCount:1)}Object.freeze(Sampler);const getMipLevelCount=(e,t)=>Math.floor(Math.log2(Math.max(e,t)))+1,imageBitmapToGPUTexture=(e,t,r,n=!0)=>{const i=e.createTexture(r);for(let s=0;s<t.length;s++){const a=t[s],o={source:a},u={texture:i,origin:[0,0,s],premultipliedAlpha:n};r.format.includes("srgb")&&(u.colorSpace="srgb");const l=[a.width,a.height];e.queue.copyExternalImageToTexture(o,u,l)}return i};async function loadAndCreateBitmapImage(e,t="none",r="premultiply"){const n=await fetch(e),i=await n.blob();return createImageBitmap(i,{colorSpaceConversion:t,premultiplyAlpha:r})}class BitmapTexture extends ManagedResourceBase{#$;#X;#j;#Y;#Z;#q;#W=0;#J=!0;#Q;#ee;#te;constructor(e,t,r=!0,n,i,s,a=!0){if(super(e,"managedBitmapTextureState"),this.#ee=n,this.#te=i,this.#J=a,this.#Z=r,this.#Q=s||navigator.gpu.getPreferredCanvasFormat(),t){this.#X=t?.src||t,this.#j=t?.cacheKey||t||this.uuid;const{table:e}=this.targetResourceManagedState;let r;for(const t in e)if(e[t].cacheKey===this.#j){r=e[t];break}if(r)return this.#ee?.(this),e[r.uuid].texture;this.src=t,this.#re()}}get usePremultiplyAlpha(){return this.#J}get cacheKey(){return this.#j}get videoMemorySize(){return this.#W}get gpuTexture(){return this.#$}get mipLevelCount(){return this.#Y}get src(){return this.#X}set src(e){this.#X=e?.src||e,this.#j=e?.cacheKey||e||this.uuid,this.#X&&this.#ne(this.#X)}get useMipmap(){return this.#Z}set useMipmap(e){this.#Z=e,this.#ie()}destroy(){const e=this.#$;this.#se(null),this.__fireListenerList(!0),this.#X=null,this.#j=null,this.#ae(),e&&e.destroy()}#se(e){this.#$=e,e||(this.#q=null),this.__fireListenerList()}#re(){basicRegisterResource(this,new ResourceStateBitmapTexture(this))}#ae(){basicUnregisterResource(this)}#ie(){const{gpuDevice:e,resourceManager:t}=this.redGPUContext,{mipmapGenerator:r}=t;this.#$&&(this.#$.destroy(),this.#$=null),this.targetResourceManagedState.videoMemory-=this.#W,this.#W=0;const{width:n,height:i}=this.#q;this.#Y=1;const s={size:[n,i],format:this.#Q,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST};this.#Z&&(this.#Y=getMipLevelCount(n,i),s.mipLevelCount=this.#Y,s.usage|=GPUTextureUsage.RENDER_ATTACHMENT);const a=imageBitmapToGPUTexture(e,[this.#q],s,this.#J);this.#W=calculateTextureByteSize(s),this.targetResourceManagedState.videoMemory+=this.#W,this.#Z&&r.generateMipmap(a,s),this.#se(a)}async#oe(e){return new Promise(((t,r)=>{const n=new Image;n.src=e,n.onload=()=>{const e=document.createElement("canvas");e.width=n.width||512,e.height=n.height||512;const i=e.getContext("2d");i?(i.fillStyle="rgba(0,0,0,0)",i.fillRect(0,0,e.width,e.height),i.drawImage(n,0,0,e.width,e.height),createImageBitmap(e,{colorSpaceConversion:"none",premultiplyAlpha:this.#J?"premultiply":"none"}).then(t).catch(r)):r(new Error("Canvas context could not be created."))},n.onerror=e=>{r(new Error(`Failed to load SVG:${e}`))}}))}async#ne(e){try{e.endsWith(".svg")?this.#q=await this.#oe(e):this.#q=await loadAndCreateBitmapImage(e,"none",this.#J?"premultiply":"none"),this.#ie(),this.#ee?.(this)}catch(e){console.error(e),this.#te?.(e)}}}Object.freeze(BitmapTexture);const Ge={LOAD:"load",CLEAR:"clear"};Object.freeze(Ge);const Ve={STORE:"store",DISCARD:"discard"};Object.freeze(Ve);class MipmapGenerator{#v;#ue;#le;#ce;#he;#de;constructor(e){this.#v=e,this.#ue=new Sampler(e,{minFilter:"linear"}).gpuSampler,this.#ce={}}getMipmapPipeline(e){const{gpuDevice:t,resourceManager:r}=this.#v;let n=this.#ce[e];return n||(this.#de||(this.#de=r.createGPUShaderModule("MODULE_MIP_MAP",{code:"\r\nvar<private> pos:array<vec2<f32>,3>=array<vec2<f32>,3>(\rvec2<f32>(-1.0,-1.0),\rvec2<f32>(-1.0,3.0),\rvec2<f32>(3.0,-1.0)\r\n);\r\n\r\n\r\nstruct VertexOutput {\r@builtin(position)\rposition:vec4<f32>,\r\n\r@location(0)\rtexCoord:vec2<f32>,\r\n};\r\n\r\n\r\n@vertex\r\nfn vertexMain(@builtin(vertex_index) vertexIndex:u32) -> VertexOutput {\rvar output:VertexOutput;\routput.texCoord=pos[vertexIndex] * vec2<f32>(0.5,-0.5) + vec2<f32>(0.5);\routput.position=vec4<f32>(pos[vertexIndex],0.0,1.0);\rreturn output;\r\n}\r\n\r\n\r\n@group(0) @binding(0)\r\nvar imgSampler:sampler;\r\n\r\n@group(0) @binding(1)\r\nvar img:texture_2d<f32>;\r\n\r\n\r\n@fragment\r\nfn fragmentMain(@location(0) texCoord:vec2<f32>) -> @location(0) vec4<f32> {\rreturn textureSample(img,imgSampler,texCoord);\r\n}\r\n"}),this.#he=r.createBindGroupLayout("FRAGMENT_BIND_GROUP_LAYOUT_NAME_MIP_MAP",{entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}}]}),this.#le=r.createGPUPipelineLayout("PIPELINE_DESCRIPTOR_FINAL_MIP_MAP",{bindGroupLayouts:[this.#he]})),n=t.createRenderPipeline({layout:this.#le,vertex:{module:this.#de,entryPoint:"vertexMain"},fragment:{module:this.#de,entryPoint:"fragmentMain",targets:[{format:e}]}}),this.#ce[e]=n),n}generateMipmap(e,t){const{gpuDevice:r}=this.#v,n=this.getMipmapPipeline(t.format);if("3d"==t.dimension||"1d"==t.dimension)throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");let i=e;const s=t.size[0],a=t.size[1],o=t.size[2]||1,u=t.usage&GPUTextureUsage.RENDER_ATTACHMENT;if(!u){const e={size:{width:Math.max(1,s>>>1),height:Math.max(1,a>>>1),depthOrArrayLayers:o},format:t.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:t.mipLevelCount-1};i=r.createTexture(e)}const l=r.createCommandEncoder({});for(let s=0;s<o;++s){let a=e.createView({baseMipLevel:0,mipLevelCount:1,dimension:"2d",baseArrayLayer:s,arrayLayerCount:1}),o=u?1:0;for(let e=1;e<t.mipLevelCount;++e){const e=i.createView({baseMipLevel:o++,mipLevelCount:1,dimension:"2d",baseArrayLayer:s,arrayLayerCount:1}),t=l.beginRenderPass({colorAttachments:[{view:e,clearValue:{r:0,g:0,b:0,a:0},loadOp:Ge.CLEAR,storeOp:Ve.STORE}]}),u=r.createBindGroup({layout:this.#he,entries:[{binding:0,resource:this.#ue},{binding:1,resource:a}]});t.setPipeline(n),t.setBindGroup(0,u),t.draw(3,1,0,0),t.end(),a=e}}if(!u){const r={width:Math.max(1,s>>>1),height:Math.max(1,a>>>1),depthOrArrayLayers:o};for(let n=1;n<t.mipLevelCount;++n)l.copyTextureToTexture({texture:i,mipLevel:n-1},{texture:e,mipLevel:n},r),r.width=Math.max(1,r.width>>>1),r.height=Math.max(1,r.height>>>1)}return r.queue.submit([l.finish()]),u||i.destroy(),e}}Object.freeze(MipmapGenerator);class CubeTexture extends ManagedResourceBase{static defaultViewDescriptor={dimension:"cube",aspect:"all",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:0,arrayLayerCount:6};#$;#me;#j;#Y;#Z;#pe;#W=0;get viewDescriptor(){return{...CubeTexture.defaultViewDescriptor,mipLevelCount:this.#Y}}#Q;#ee;#te;constructor(e,t,r=!0,n,i,s){super(e,"managedCubeTextureState"),this.#ee=n,this.#te=i,this.#Z=r,this.#Q=s||navigator.gpu.getPreferredCanvasFormat(),this.#me=t,this.#j=t?.toString();const{table:a}=this.targetResourceManagedState;let o;for(const e in a)if(a[e].cacheKey===this.#j){o=a[e];break}if(o)return this.#ee?.(this),a[o.uuid].texture;this.srcList=t,this.#re()}get cacheKey(){return this.#j}get videoMemorySize(){return this.#W}get gpuTexture(){return this.#$}get mipLevelCount(){return this.#Y}get srcList(){return this.#me}set srcList(e){this.#me=e,this.#j=e?.toString(),this.#me&&this.#ne(this.#me)}get useMipmap(){return this.#Z}set useMipmap(e){this.#Z=e,this.#ie()}destroy(){const e=this.#$;this.#se(null),this.__fireListenerList(!0),this.#me=null,this.#j=null,this.#ae(),e&&e.destroy()}#se(e){this.#$=e,e||(this.#pe=null),this.__fireListenerList()}#re(){basicRegisterResource(this,new ResourceStateCubeTexture(this))}#ae(){basicUnregisterResource(this)}#ie(){const{gpuDevice:e,resourceManager:t}=this.redGPUContext,{mipmapGenerator:r}=t;this.#$&&(this.#$.destroy(),this.#$=null),this.#Y=1;{const t=this.#pe,n=t[0],{width:i,height:s}=n,a={size:[i,s,6],format:this.#Q,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST};this.#Z&&(this.#Y=getMipLevelCount(i,s),a.mipLevelCount=this.#Y,a.usage|=GPUTextureUsage.RENDER_ATTACHMENT);const o=imageBitmapToGPUTexture(e,t,a);this.targetResourceManagedState.videoMemory-=this.#W,this.#W=calculateTextureByteSize(a),this.targetResourceManagedState.videoMemory+=this.#W,this.#Z&&r.generateMipmap(o,a),this.#se(o)}}async#ne(e){this.#pe=await async function(e){const t=e.map((e=>loadAndCreateBitmapImage(e)));return await Promise.all(t)}(e);try{this.#ie(),this.#ee?.(this)}catch(e){console.error(e),this.#te?.(e)}}}Object.freeze(CubeTexture);const Fe={TILE_COUNT_X:32,TILE_COUNT_Y:32,TILE_COUNT_Z:48,WORKGROUP_SIZE_X:8,WORKGROUP_SIZE_Y:4,WORKGROUP_SIZE_Z:8,MAX_POINT_LIGHTS_PER_CLUSTER:100,MAX_POINT_LIGHTS:1024,getTotalTileSize:()=>Fe.TILE_COUNT_X*Fe.TILE_COUNT_Y*Fe.TILE_COUNT_Z,getPointLight_ClusterLightsBufferSize:()=>{const e=Fe.getTotalTileSize();return 8*e+8*Fe.MAX_POINT_LIGHTS_PER_CLUSTER*e+4},getDispatchSize:()=>[Math.ceil(Fe.TILE_COUNT_X/Fe.WORKGROUP_SIZE_X),Math.ceil(Fe.TILE_COUNT_Y/Fe.WORKGROUP_SIZE_Y),Math.ceil(Fe.TILE_COUNT_Z/Fe.WORKGROUP_SIZE_Z)]};Object.freeze(Fe);const He=Object.freeze({SYSTEM_UNIFORM:"struct DirectionalLight {\r\n\t direction:vec3<f32>,\r\n\t color:vec3<f32>,\r\n\t intensity:f32,\r\n};\r\nstruct AmbientLight {\r\n\t color:vec3<f32>,\r\n\t intensity:f32\r\n};\r\n\r\nstruct Camera {\r\n\t cameraMatrix:mat4x4<f32>,\r\n\t cameraPosition:vec3<f32>,\r\n\t nearClipping:f32,\rfarClipping:f32\r\n};\r\n\r\nstruct SystemUniform {\r\n\t projectionMatrix:mat4x4<f32>,\r\n\t inverseProjectionMatrix:mat4x4<f32>,\r\n\t projectionCameraMatrix:mat4x4<f32>,\r\n\t camera:Camera,\r\n\t resolution:vec2<f32>,\r\n\t viewPosition:vec2<f32>,\r\n\t \r\n\t directionalLightCount:u32,\r\n\t directionalLights:array<DirectionalLight,3>,\r\n\t \r\n\t directionalLightProjectionViewMatrix:mat4x4<f32>,\r\n\t directionalLightProjectionMatrix:mat4x4<f32>,\r\n\t directionalLightViewMatrix:mat4x4<f32>,\r\n\t \r\n\t directionalLightShadowDepthTextureSize:u32,\r\n\t directionalLightShadowBias:f32,\r\n\t \r\n\t ambientLight:AmbientLight,\r\n\r\n\t time:f32,\r\n\t \r\n\t useIblTexture:u32,\r\n\t isView3D:u32\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> systemUniforms:SystemUniform;\r\n@group(0) @binding(1) var directionalShadowMapSampler:sampler_comparison;\r\n@group(0) @binding(2) var directionalShadowMap:texture_depth_2d;\r\n@group(0) @binding(3) var iblTextureSampler:sampler;\r\n@group(0) @binding(4) var iblTexture:texture_cube<f32>;\r\n@group(0) @binding(7) var renderPath1ResultTextureSampler:sampler;\r\n@group(0) @binding(8) var renderPath1ResultTexture:texture_2d<f32>;\r\n@group(0) @binding(9) var packedTextureSampler:sampler;\r\n\r\nconst pointLight_indicesLength:u32=u32(REDGPU_DEFINE_MAX_LIGHTS_PER_CLUSTERu * REDGPU_DEFINE_TOTAL_TILESu);\r\nconst pointLight_tileCount=vec3<u32>(REDGPU_DEFINE_TILE_COUNT_Xu,REDGPU_DEFINE_TILE_COUNT_Yu,REDGPU_DEFINE_TILE_COUNT_Zu);\r\n\r\nstruct PointLight_ClusterLights {\roffset:u32,\rcount:u32\r\n};\r\nstruct PointLight_ClusterLightsGroup {\roffset:atomic<u32>,\rlights:array<PointLight_ClusterLights,REDGPU_DEFINE_TOTAL_TILES>,\rindices:array<u32,pointLight_indicesLength>\r\n};\r\nstruct PointLight_ClusterCube {\rminAABB:vec4<f32>,\rmaxAABB:vec4<f32>\r};\r\nstruct PointLight_Clusters {\rcubeList:array<PointLight_ClusterCube,REDGPU_DEFINE_TOTAL_TILES>\r\n};\r\n\r\nfn linearDepth(depthSample:f32) -> f32 {\rreturn systemUniforms.camera.farClipping*systemUniforms.camera.nearClipping/fma(depthSample,systemUniforms.camera.nearClipping-systemUniforms.camera.farClipping,systemUniforms.camera.farClipping);\r\n}\r\nfn getPointLightClusterIndex(fragCoord:vec4<f32>) -> u32 {\rlet tile=getPointLightTile(fragCoord);\rreturn tile.x +\rtile.y * pointLight_tileCount.x +\rtile.z * pointLight_tileCount.x * pointLight_tileCount.y;\r\n\r\n}\r\nfn getPointLightTile(fragCoord:vec4<f32>) -> vec3<u32> {\r\rlet sliceScale=f32(pointLight_tileCount.z)/log2(systemUniforms.camera.farClipping/systemUniforms.camera.nearClipping);\rlet sliceBias=-(f32(pointLight_tileCount.z) * log2(systemUniforms.camera.nearClipping)/log2(systemUniforms.camera.farClipping/systemUniforms.camera.nearClipping));\rlet zTile=u32(max(log2(linearDepth(fragCoord.z)) * sliceScale + sliceBias,0.0));\rreturn vec3<u32>(u32(fragCoord.x/(systemUniforms.resolution.x/f32(pointLight_tileCount.x))),\ru32(fragCoord.y/(systemUniforms.resolution.y/f32(pointLight_tileCount.y))),\rzTile);\r\n}\r\n\r\nstruct PointLight {\rposition:vec3<f32>,\rradius:f32,\rcolor:vec3<f32>,\rintensity:f32\r\n};\r\nstruct PointLightList {\rcount:vec4<f32>,\rlights:array<PointLight>\r\n};\r\n@group(0) @binding(5) var<storage> pointLightList:PointLightList;\r\n@group(0) @binding(6) var<storage,read_write> pointLight_clusterLightGroup:PointLight_ClusterLightsGroup;\r\n",calcTintBlendMode:"fn calcTintBlendMode(baseColor:vec4<f32>,tintBlendMode:u32,tint:vec4<f32>) -> vec4<f32> {\rvar tintedColor:vec3<f32>;\rswitch (tintBlendMode) {\rcase 0u:{ \rreturn vec4<f32>(mix(baseColor.rgb,tint.rgb,tint.a),baseColor.a);\r}\rcase 1u:{ \rtintedColor=baseColor.rgb * tint.rgb;\r}\rcase 2u:{ \rtintedColor=max(baseColor.rgb,tint.rgb);\r}\rcase 3u:{ \rtintedColor=1.0 - (1.0 - baseColor.rgb) * (1.0 - tint.rgb);\r}\rcase 4u:{ \rtintedColor=clamp(baseColor.rgb + tint.rgb,vec3<f32>(0.0),vec3<f32>(1.0));\r}\rcase 5u:{ \rtintedColor=clamp(baseColor.rgb - tint.rgb,vec3<f32>(0.0),vec3<f32>(1.0));\r}\rcase 6u:{ \rtintedColor=min(baseColor.rgb,tint.rgb);\r}\rcase 7u:{ \rtintedColor=mix(\r2.0 * baseColor.rgb * tint.rgb,\r1.0 - 2.0 * (1.0 - baseColor.rgb) * (1.0 - tint.rgb),\rstep(vec3<f32>(0.5),baseColor.rgb)\r);\r}\rcase 8u:{ \rtintedColor=clamp(baseColor.rgb/(1.0 - tint.rgb),vec3<f32>(0.0),vec3<f32>(1.0));\r}\rcase 9u:{ \rtintedColor=1.0 - clamp((1.0 - baseColor.rgb)/tint.rgb,vec3<f32>(0.0),vec3<f32>(1.0));\r}\rcase 10u:{ \rtintedColor=mix(\r2.0 * baseColor.rgb * tint.rgb,\r1.0 - 2.0 * (1.0 - baseColor.rgb) * (1.0 - tint.rgb),\rstep(vec3<f32>(0.5),tint.rgb)\r);\r}\rcase 11u:{ \rtintedColor=mix(\rbaseColor.rgb * (tint.rgb + tint.rgb - vec3<f32>(1.0)),\rbaseColor.rgb + tint.rgb - baseColor.rgb * tint.rgb,\rstep(vec3<f32>(0.5),tint.rgb)\r);\r}\rcase 12u:{ \rtintedColor=abs(baseColor.rgb - tint.rgb);\r}\rcase 13u:{ \rtintedColor=baseColor.rgb + tint.rgb - 2.0 * baseColor.rgb * tint.rgb;\r}\rcase 14u:{ \rtintedColor=clamp(baseColor.rgb/tint.rgb,vec3<f32>(0.0),vec3<f32>(1.0));\r}\rcase 15u:{ \rtintedColor=mix(\rclamp(baseColor.rgb/(1.0 - (tint.rgb - vec3<f32>(0.5)) * 2.0),vec3<f32>(0.0),vec3<f32>(1.0)),\r1.0 - clamp((1.0 - baseColor.rgb)/(tint.rgb * 2.0),vec3<f32>(0.0),vec3<f32>(1.0)),\rstep(vec3<f32>(0.5),tint.rgb)\r);\r}\rcase 16u:{ \rtintedColor=clamp(baseColor.rgb + tint.rgb - vec3<f32>(1.0),vec3<f32>(0.0),vec3<f32>(1.0));\r}\rcase 17u:{ \rtintedColor=mix(\rmin(baseColor.rgb,2.0 * tint.rgb),\rmax(baseColor.rgb,2.0 * tint.rgb - vec3<f32>(1.0)),\rstep(vec3<f32>(0.5),tint.rgb)\r);\r}\rcase 18u:{ \rlet baseHsl=rgbToHsl(baseColor.rgb);\rlet tintHsl=rgbToHsl(tint.rgb);\rtintedColor=hslToRgb(vec3<f32>(baseHsl.x,tintHsl.y,baseHsl.z));\r}\rcase 19u:{ \rlet baseHsl=rgbToHsl(baseColor.rgb);\rlet tintHsl=rgbToHsl(tint.rgb);\rtintedColor=hslToRgb(vec3<f32>(tintHsl.x,baseHsl.y,baseHsl.z));\r}\rcase 20u:{ \rlet baseHsl=rgbToHsl(baseColor.rgb);\rlet tintHsl=rgbToHsl(tint.rgb);\rtintedColor=hslToRgb(vec3<f32>(baseHsl.x,baseHsl.y,tintHsl.z));\r}\rcase 21u:{ \rlet baseHsl=rgbToHsl(baseColor.rgb);\rlet tintHsl=rgbToHsl(tint.rgb);\rtintedColor=hslToRgb(vec3<f32>(tintHsl.x,tintHsl.y,baseHsl.z));\r}\rcase 22u:{ \rtintedColor=1.0 - abs(1.0 - baseColor.rgb - tint.rgb);\r}\rdefault:{\rtintedColor=baseColor.rgb;\r}\r}\r\n\rreturn vec4<f32>(tintedColor,baseColor.a * tint.a);\r\n}\r\n\r\n\r\nfn rgbToHsl(rgb:vec3<f32>) -> vec3<f32> {\rlet maxVal:f32=max(max(rgb.r,rgb.g),rgb.b);\rlet minVal:f32=min(min(rgb.r,rgb.g),rgb.b);\rlet delta:f32=maxVal - minVal;\r\n\rlet lightness:f32=(maxVal + minVal) * 0.5;\r\n\rif (delta==0.0) {\rreturn vec3<f32>(0.0,0.0,lightness);\r}\r\n\r\rvar saturation:f32;\rif (lightness < 0.5) {\rsaturation=delta/(maxVal + minVal);\r} else {\rsaturation=delta/(2.0 - maxVal - minVal);\r}\r\n\r\rvar hue:f32=0.0;\rif (rgb.r==maxVal) {\rhue=(rgb.g - rgb.b)/delta;\rif (rgb.g < rgb.b) {\rhue +=6.0;\r}\r} else if (rgb.g==maxVal) {\rhue=(rgb.b - rgb.r)/delta + 2.0;\r} else { \rhue=(rgb.r - rgb.g)/delta + 4.0;\r}\r\n\rhue=hue/6.0;\r\n\rreturn vec3<f32>(hue,saturation,lightness);\r\n}\r\n\r\nfn hslToRgb(hsl:vec3<f32>) -> vec3<f32> {\rlet h=hsl.x;\rlet s=hsl.y;\rlet l=hsl.z;\r\n\rif (s==0.0) {\r\rreturn vec3<f32>(l,l,l);\r}\r\n\r\rvar q:f32;\rif (l < 0.5) {\rq=l * (1.0 + s);\r} else {\rq=l + s - l * s;\r}\r\n\rlet p=2.0 * l - q;\r\n\r\rvar r:f32;\rvar g:f32;\rvar b:f32;\r\n\rfor (var i:i32=0;i < 3;i=i + 1) {\rvar t:f32;\rif (i==0) {\rt=h + 1.0/3.0;\r} else if (i==1) {\rt=h;\r} else {\rt=h - 1.0/3.0;\r}\r\n\rif (t < 0.0) {\rt=t + 1.0;\r}\rif (t > 1.0) {\rt=t - 1.0;\r}\r\n\rvar color:f32;\rif (t < 1.0/6.0) {\rcolor=p + (q - p) * 6.0 * t;\r} else if (t < 1.0/2.0) {\rcolor=q;\r} else if (t < 2.0/3.0) {\rcolor=p + (q - p) * (2.0/3.0 - t) * 6.0;\r} else {\rcolor=p;\r}\r\n\rif (i==0) {\rr=color;\r} else if (i==1) {\rg=color;\r} else {\rb=color;\r}\r}\r\n\rreturn vec3<f32>(r,g,b);\r\n}",drawDirectionalShadowDepth:"struct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn drawDirectionalShadowDepth( inputData:InputData ) -> OutputShadowData {\rvar output:OutputShadowData;\rlet u_useDisplacementTexture=vertexUniforms.useDisplacementTexture==1u;\r\rlet u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_displacementScale=vertexUniforms.displacementScale;\r\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_uv=inputData.uv;\r\rvar position:vec4<f32>;\rposition=u_modelMatrix * vec4<f32>(input_position,1.0);\r\n\rif (u_useDisplacementTexture) {\rlet distance=distance(position.xyz,u_cameraPosition);\rlet mipLevel=(distance/maxDistance) * maxMipLevel;\rlet displacementSample=textureSampleLevel(displacementTexture,displacementTextureSampler,input_uv,mipLevel).r;\rlet scaledDisplacement=displacementSample * u_displacementScale;\rlet displacedPosition=input_position + input_vertexNormal * scaledDisplacement;\rposition=u_modelMatrix * vec4<f32>(displacedPosition,1.0);\r}\routput.position=u_directionalLightProjectionViewMatrix * position;\rreturn output;\r\n}\r\n",getBillboardMatrix:"fn getBillboardMatrix(cameraMatrix:mat4x4<f32>,modelMatrix:mat4x4<f32>) -> mat4x4<f32> {\r\rlet scaleX=length(vec3<f32>(modelMatrix[0].xyz));\rlet scaleY=length(vec3<f32>(modelMatrix[1].xyz));\rlet scaleZ=length(vec3<f32>(modelMatrix[2].xyz));\r\n\r\rlet scaleMatrix=mat4x4<f32>(\rvec4<f32>(scaleX,0.0,0.0,0.0),\rvec4<f32>(0.0,scaleY,0.0,0.0),\rvec4<f32>(0.0,0.0,scaleZ,0.0),\rvec4<f32>(0.0,0.0,0.0,1.0)\r);\r\n\r\rvar resultMatrix=cameraMatrix * modelMatrix;\rresultMatrix[0][0]=1.0;resultMatrix[0][1]=0.0;resultMatrix[0][2]=0.0;\rresultMatrix[1][0]=0.0;resultMatrix[1][1]=1.0;resultMatrix[1][2]=0.0;\rresultMatrix[2][0]=0.0;resultMatrix[2][1]=0.0;resultMatrix[2][2]=1.0;\r\n\r\rreturn resultMatrix * scaleMatrix;\r\n}\r\nfn getBillboardMatrixNoScaleRatio( cameraMatrix:mat4x4<f32>, modelMatrix:mat4x4<f32>)-> mat4x4<f32>{\rvar resultMatrix=cameraMatrix * modelMatrix;\rresultMatrix[0][0]=modelMatrix[0][0];resultMatrix[0][1]=0.0;resultMatrix[0][2]=0.0;\rresultMatrix[1][0]=0.0;resultMatrix[1][1]=modelMatrix[1][1];resultMatrix[1][2]=0.0;\rresultMatrix[2][0]=0.0;resultMatrix[2][1]=0.0;resultMatrix[2][2]=modelMatrix[2][2];\r\n\rreturn resultMatrix;\r\n}\r\n",extractScaleAndTranslation:"fn extractScaleAndTranslation(modelMatrix:mat4x4<f32>) -> mat4x4<f32> {\r\rlet scaleX=length(vec3<f32>(modelMatrix[0].xyz));\rlet scaleY=length(vec3<f32>(modelMatrix[1].xyz));\rlet scaleZ=length(vec3<f32>(modelMatrix[2].xyz));\r\n\r\rlet scaleMatrix=mat4x4<f32>(\rvec4<f32>(scaleX,0.0,0.0,0.0),\rvec4<f32>(0.0,scaleY,0.0,0.0),\rvec4<f32>(0.0,0.0,scaleZ,0.0),\rvec4<f32>(0.0,0.0,0.0,1.0)\r);\r\n\r\rreturn mat4x4<f32>(\rscaleMatrix[0],\rscaleMatrix[1],\rscaleMatrix[2],\rmodelMatrix[3] \r);\r\n}",calcDirectionalShadowVisibility:"fn calcDirectionalShadowVisibility(\rdirectionalShadowMap:texture_depth_2d,\rdirectionalShadowMapSampler:sampler_comparison,\rdirectionalLightShadowDepthTextureSize:u32,\rdirectionalLightShadowBias:f32,\rshadowPos:vec3<f32>\r\n) -> f32 {\rlet oneOverShadowDepthTextureSize=1.0/f32(directionalLightShadowDepthTextureSize);\rlet shadowDepth=clamp(shadowPos.z,0.0,1.0);\rvar visibility:f32=0.0;\rfor (var y=-1;y <=1;y++) {\rfor (var x=-1;x <=1;x++) {\rlet offset=vec2f(vec2(x,y)) * oneOverShadowDepthTextureSize;\rvar tUV:vec2<f32>=shadowPos.xy + offset;\rvar sampleVisibility=textureSampleCompare(\rdirectionalShadowMap,\rdirectionalShadowMapSampler,\rtUV,\rshadowDepth - directionalLightShadowBias\r);\r\n\rif (tUV.x < 0.0 || tUV.x > 1.0 || tUV.y < 0.0 || tUV.y > 1.0) {\rvisibility +=1.0;\r} else {\rvisibility +=sampleVisibility;\r}\r}\r}\rvisibility/=9.0;\rreturn visibility;\r\n}\r\n",drawPicking:"\r\n@fragment\r\nfn picking(inputData:InputData) -> @location(0) vec4<f32> {\rvar finalColor:vec4<f32>=inputData.pickingId;\rreturn finalColor;\r\n}\r\n",normalFunctions:"\r\nfn cotangent_frame( N:vec3<f32>, p:vec3<f32>, uv:vec2<f32>) -> mat3x3<f32>{\rlet dp1:vec3<f32>=dpdx( p );\rlet dp2:vec3<f32>=dpdy( p );\rlet duv1:vec2<f32>=dpdx( uv );\rlet duv2:vec2<f32>=dpdy( uv );\r\n\rlet dp2perp:vec3<f32>=cross( dp2,N );\rlet dp1perp:vec3<f32>=cross( N,dp1 );\rlet T:vec3<f32>=dp2perp * duv1.x + dp1perp * duv2.x;\rlet B:vec3<f32>=dp2perp * duv1.y + dp1perp * duv2.y;\rlet invmax:f32=inverseSqrt( max( dot(T,T),dot(B,B) ) );\rreturn mat3x3<f32>( T * invmax,B * invmax,N );\r\n}\r\nfn perturb_normal( N:vec3<f32>, V:vec3<f32>, texcoord:vec2<f32>, normalColor:vec3<f32>,normalPower:f32 ) -> vec3<f32> {\rvar map:vec3<f32>=normalColor;\rmap= map * 255./127. - 128./127.;\rmap=vec3<f32>(map.xy * -normalPower,map.z);\rlet TBN:mat3x3<f32>=cotangent_frame(N,V,texcoord);\rreturn normalize(TBN * map);\r\n}\r\n"});Object.freeze(He);const ze=Object.keys(He).join("|"),Ke=new RegExp(`#redgpu_include (${ze})`,"g"),parseIncludeWGSL=e=>e.replace(Ke,((e,t)=>He[t]||e)).replace(/REDGPU_DEFINE_TILE_COUNT_X/g,Fe.TILE_COUNT_X.toString()).replace(/REDGPU_DEFINE_TILE_COUNT_Y/g,Fe.TILE_COUNT_Y.toString()).replace(/REDGPU_DEFINE_TILE_COUNT_Z/g,Fe.TILE_COUNT_Z.toString()).replace(/REDGPU_DEFINE_TOTAL_TILES/g,Fe.getTotalTileSize().toString()).replace(/REDGPU_DEFINE_WORKGROUP_SIZE_X/g,Fe.WORKGROUP_SIZE_X.toString()).replace(/REDGPU_DEFINE_WORKGROUP_SIZE_Y/g,Fe.WORKGROUP_SIZE_Y.toString()).replace(/REDGPU_DEFINE_WORKGROUP_SIZE_Z/g,Fe.WORKGROUP_SIZE_Z.toString()).replace(/REDGPU_DEFINE_WORKGROUP_SIZE_Z/g,Fe.WORKGROUP_SIZE_Z.toString()).replace(/REDGPU_DEFINE_MAX_LIGHTS_PER_CLUSTER/g,Fe.MAX_POINT_LIGHTS_PER_CLUSTER.toString());class ResourceState{table={};videoMemory=0;length=0;constructor(){}}var $e;Object.freeze(ResourceState),function(e){e.GPUShaderModule="GPUShaderModule",e.GPUBindGroupLayout="GPUBindGroupLayout",e.GPUPipelineLayout="GPUPipelineLayout"}($e||($e={}));class ResourceManager extends ResourceBase{static PRESET_GPUBindGroupLayout_System="PRESET_GPUBindGroupLayout_System";static PRESET_VERTEX_GPUBindGroupLayout_Instancing="PRESET_VERTEX_GPUBindGroupLayout_Instancing";static PRESET_VERTEX_GPUBindGroupLayout="PRESET_VERTEX_GPUBindGroupLayout";static PRESET_VERTEX_GPUBindGroupLayout_SKIN="PRESET_VERTEX_GPUBindGroupLayout_SKIN";#fe=new ImmutableKeyMap([[$e.GPUShaderModule,new Map],[$e.GPUBindGroupLayout,new Map],[$e.GPUPipelineLayout,new Map]]);#ge=new ResourceState;#_e=new ResourceState;#xe=new ResourceState;#ve=new ResourceState;#Te=new ResourceState;#ye=new ResourceState;#be=new ResourceState;#Se={};#Me;#Re;#we;#Pe;constructor(e){super(e),this.#we=new MipmapGenerator(e),this.#Ee()}get basicSampler(){return this.#Pe}get mipmapGenerator(){return this.#we}get cachedBufferState(){return this.#Se}get emptyBitmapTextureView(){return this.#Me}get emptyCubeTextureView(){return this.#Re}get managedBitmapTextureState(){return this.#ge}get managedCubeTextureState(){return this.#_e}get managedUniformBufferState(){return this.#ve}get managedVertexBufferState(){return this.#Te}get managedIndexBufferState(){return this.#ye}get managedStorageBufferState(){return this.#be}get resources(){return this.#fe}createGPUShaderModule(e,t){return this.#ke(e,t,(t=>this.#Ce(e,t)),$e.GPUShaderModule)}getGPUShaderModule(e){return this.#Le(e,$e.GPUShaderModule)}deleteGPUShaderModule(e){this.#Be(e,$e.GPUShaderModule)}createBindGroupLayout(e,t){return this.#ke(e,t,(t=>(t.label||(t.label=e),this.redGPUContext.gpuDevice.createBindGroupLayout(t))),$e.GPUBindGroupLayout)}getGPUBindGroupLayout(e){return this.#Le(e,$e.GPUBindGroupLayout)}deleteGPUBindGroupLayout(e){this.#Be(e,$e.GPUBindGroupLayout)}createGPUPipelineLayout(e,t){return this.#ke(e,t,(t=>(t.label||(t.label=e),this.redGPUContext.gpuDevice.createPipelineLayout(t))),$e.GPUPipelineLayout)}getGPUPipelineLayout(e){return this.#Le(e,$e.GPUPipelineLayout)}deleteGPUPipelineLayout(e){this.#Be(e,$e.GPUPipelineLayout)}#Ee(){const{gpuDevice:e}=this.redGPUContext;{const t=e.createTexture({size:{width:1,height:1,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,label:"emptyBitmapTexture"});this.#Me=t.createView();const r=new Uint8Array([0,0,0,0]);e.queue.writeTexture({texture:t},r,{bytesPerRow:4,rowsPerImage:1},{width:1,height:1,depthOrArrayLayers:1});const n=e.createTexture({size:{width:1,height:1,depthOrArrayLayers:6},format:"rgba8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,label:"emptyCubeTexture"});this.#Re=n.createView(CubeTexture.defaultViewDescriptor);const i=new Uint8Array([0,0,0,0]);for(let t=0;t<6;t++)e.queue.writeTexture({texture:n,origin:{x:0,y:0,z:t}},i,{bytesPerRow:4,rowsPerImage:1},{width:1,height:1,depthOrArrayLayers:1});this.#Pe=new Sampler(this.redGPUContext)}this.createBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System,{entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{type:"comparison"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"depth"}},{binding:3,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:4,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube"}},{binding:5,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:6,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:7,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:8,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:9,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}}]}),this.createBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout,{entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX,sampler:{type:"filtering"}},{binding:2,visibility:GPUShaderStage.VERTEX,texture:{}}]}),this.createBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_SKIN,{entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX,sampler:{type:"filtering"}},{binding:2,visibility:GPUShaderStage.VERTEX,texture:{}},{binding:3,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}}]}),this.createBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_Instancing,{entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.VERTEX,sampler:{type:"filtering"}},{binding:2,visibility:GPUShaderStage.VERTEX,texture:{}}]})}#Ie(e){return this.#fe.get(e)}#Ce(e,t){const{code:r}=t,n=parseIncludeWGSL(r),i=this.redGPUContext.gpuDevice.createShaderModule({...t,code:n});return this.#Ie($e.GPUShaderModule).set(e,i),i}#Ue(e,t){if(!e)throw new Error("Name is required");return this.#Ie(t)}#ke(e,t,r,n){const i=this.#Ue(e,n);if(i.has(e))return i.get(e);t.label||(t.label=e);const s=r(t);return i.set(e,s),s}#Le(e,t){return this.#Ue(e,t).get(e)}#Be(e,t){const r=this.#Ue(e,t);if(!r.has(e))throw new Error(`${t} with name ${e} doesn't exist.`);r.delete(e)}}Object.freeze(BitmapTexture);class ImmutableKeyMap extends Map{constructor(e=[]){super(),e?.forEach((([e,t])=>super.set(e,t)))}set(e,t){if(this.has(e))throw new Error("Cannot change the value of an existing key");return super.set(e,t)}}const createMeshVertexUniformBuffers=(e,t=!1)=>{const{gpuRenderInfo:r,redGPUContext:n}=e,{resourceManager:i}=n,s=i.getGPUBindGroupLayout(t?ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_SKIN:ResourceManager.PRESET_VERTEX_GPUBindGroupLayout),a=new ArrayBuffer(r.vertexUniformInfo.arrayBufferByteLength),o=new UniformBuffer(n,a,e.name);r.vertexBindGroupLayout=s,r.vertexUniformBuffer=o},isHexColor=e=>{const t=/^([A-Fa-f0-9]{3}){1,2}$/;return e.startsWith("#")?t.test(e.substring(1)):!!e.startsWith("0x")&&t.test(e.substring(2))},convertHexToRgb=(e,t=!1)=>{if("number"==typeof e&&(e=`#${e.toString(16)}`),isHexColor(e)){"#"===e.charAt(0)&&(e=e.substring(1)),3===e.length&&(e=e.charAt(0)+e.charAt(0)+e.charAt(1)+e.charAt(1)+e.charAt(2)+e.charAt(2));const r=parseInt("0x"+e),n=r>>16&255,i=r>>8&255,s=255&r;return t?[n,i,s]:{r:n,g:i,b:s}}throw Error(`from ${convertHexToRgb.constructor.name}:input value - ${e}/Only hex string allowed`)},convertRgbToHex=(e,t,r)=>{validateUintRange(e,0,255),validateUintRange(t,0,255),validateUintRange(r,0,255);return`#${e.toString(16).padStart(2,"0").toUpperCase()}${t.toString(16).padStart(2,"0").toUpperCase()}${r.toString(16).padStart(2,"0").toUpperCase()}`};class ColorRGB{#Ae;#De;#Ne;#Oe;constructor(e=255,t=255,r=255,n=void 0){this.#Ge(e,t,r),this.#Ve(e,t,r),n&&(this.#Oe=n)}get r(){return this.#Ae}set r(e){validateUintRange(e,0,255),this.#Ae=e,this.#Oe?.()}get g(){return this.#De}set g(e){validateUintRange(e,0,255),this.#De=e,this.#Oe?.()}get b(){return this.#Ne}set b(e){validateUintRange(e,0,255),this.#Ne=e,this.#Oe?.()}get rgb(){return[this.#Ae,this.#De,this.#Ne]}get rgbNormal(){return[this.#Ae/255,this.#De/255,this.#Ne/255]}get hex(){return convertRgbToHex(this.#Ae,this.#De,this.#Ne)}setColorByRGB(e,t,r){this.#Ge(e,t,r),this.#Ve(e,t,r)}setColorByHEX(e){const{r:t,g:r,b:n}=convertHexToRgb(e);this.#Ve(t,r,n)}setColorByRGBString(e){const t=/rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(e);t||consoleAndThrowError(`Invalid rgb color value:${e}`);const[,r,n,i]=t.map(Number);this.#Ge(r,n,i),this.#Ve(r,n,i)}#Ve(e,t,r){this.#Ae=e,this.#De=t,this.#Ne=r,this.#Oe?.()}#Ge(e,t,r){validateUintRange(e,0,255),validateUintRange(t,0,255),validateUintRange(r,0,255)}}function defineColorRGB(e,t="#fff",r=!0){const n=Symbol(e);return{get:function(){if(void 0===this[n]){let i=255,s=255,a=255;if(isHexColor(t)){const e=convertHexToRgb(t);i=e.r,s=e.g,a=e.b}this[n]=new ColorRGB(i,s,a,(()=>{const{gpuRenderInfo:t}=this;if(t)if(r){const{fragmentUniformInfo:r,fragmentUniformBuffer:i}=t;i.writeBuffer(r.members[e],this[n].rgbNormal)}else{const{vertexUniformInfo:r,vertexUniformBuffer:i}=t;i.writeBuffer(r.members[e],this[n].rgbNormal)}}))}return this[n]},...Pe}}Object.freeze(defineColorRGB);class ColorRGBA extends ColorRGB{#Fe;#Oe;constructor(e=255,t=255,r=255,n=1,i=void 0){super(e,t,r,i),validatePositiveNumberRange(n,0,1),this.#Fe=n,i&&(this.#Oe=i)}get a(){return this.#Fe}set a(e){validatePositiveNumberRange(e,0,1),this.#Fe=e,this.#Oe?.()}get rgba(){return[this.r,this.g,this.b,this.#Fe]}get rgbaNormal(){return[this.r/255,this.g/255,this.b/255,this.#Fe]}setColorByRGBA(e,t,r,n){this.#He(e,t,r,n),this.r=e,this.g=t,this.b=r,this.#Fe=n,this.#Oe?.()}setColorByRGBAString(e){const t=/rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d*(?:\.\d+)?)\s*\)/.exec(e);if(!t)throw new Error(`Invalid rgba color value:${e}`);const[,r,n,i,s]=t.map(Number);this.#He(r,n,i,s),this.r=r,this.g=n,this.b=i,this.#Fe=s,this.#Oe?.()}#He(e,t,r,n){validateUintRange(e,0,255),validateUintRange(t,0,255),validateUintRange(r,0,255),validatePositiveNumberRange(n,0,1)}}function defineColorRGBA(e,t="#fff",r=!0){const n=Symbol(e);return{get:function(){if(void 0===this[n]){let i=255,s=255,a=255,o=1;if(isHexColor(t)){const e=convertHexToRgb(t);i=e.r,s=e.g,a=e.b}this[n]=new ColorRGBA(i,s,a,o,(()=>{const{gpuRenderInfo:t}=this;if(t)if(r){const{fragmentUniformInfo:r,fragmentUniformBuffer:i}=t;i.writeBuffer(r.members[e],this[n].rgbaNormal)}else{const{vertexUniformInfo:r,vertexUniformBuffer:i}=t;i.writeBuffer(r.members[e],this[n].rgbaNormal)}}))}return this[n]},...Pe}}function createSetter$2(e,t,r){const n=`use${e.charAt(0).toUpperCase()}${e.substring(1)}`;return function(e){const i=this[t];this[t]=e,this.updateTexture(i,e);const{gpuRenderInfo:s}=this;if(r){const{fragmentUniformInfo:t,fragmentUniformBuffer:r}=s;t.members[n]&&r.writeBuffer(t.members[n],e?1:0)}else if(s){const{vertexUniformInfo:t,vertexUniformBuffer:r}=s;t.members[n]&&r.writeBuffer(r.members[n],e?1:0)}}}function defineCubeTexture(e,t=!0){const r=Symbol(e);return{get:function(){return this[r]},set:createSetter$2(e,r,t),...Pe}}function defineSampler(e){const t=Symbol(e);return{get:function(){return this[t]},set:function(e){const r=this[t];this[t]=e,this.updateSampler(r,e)},...Pe}}function createSetter$1(e,t,r){const n=`use${e.charAt(0).toUpperCase()}${e.substring(1)}`,i=`premultiply${e.charAt(0).toUpperCase()}${e.substring(1)}`;return function(e){const s=this[t];this[t]=e,this.updateTexture(s,e);const{gpuRenderInfo:a}=this;if(r){const{fragmentUniformInfo:t,fragmentUniformBuffer:r}=a;t.members[n]&&r.writeBuffer(t.members[n],e?1:0),t.members[i]&&r.writeBuffer(t.members[i],e?.usePremultiplyAlpha?1:0)}else if(a){const{vertexUniformInfo:t,vertexUniformBuffer:r}=a;t.members[n]&&r.writeBuffer(r.members[n],e?1:0)}}}function defineTexture$1(e,t=!0){const r=Symbol(e);return{get:function(){return this[r]},set:createSetter$1(e,r,t),...Pe}}function createSetter(e,t,r){return function(n){this[t]=n;const{gpuRenderInfo:i}=this;if(r){const{fragmentUniformInfo:t,fragmentUniformBuffer:r}=i;r.writeBuffer(t.members[e],n)}else if(i){const{vertexUniformInfo:t,vertexUniformBuffer:r}=i;r.writeBuffer(t.members[e],n)}}}function defineVector(e,t,r=!0){const n=Symbol(e);return{get:function(){return void 0===this[n]&&(this[n]=t),this[n]},set:createSetter(e,n,r),...Pe}}function defineProperty_vec4(e,t=[0,0,0,0]){return defineVector(e,t)}function defineProperty_vec3(e,t=[0,0,0]){return defineVector(e,t)}function defineProperty_vec2(e,t=[0,0]){return defineVector(e,t)}Object.freeze(defineColorRGBA),Object.freeze(defineCubeTexture),Object.freeze(defineSampler),Object.freeze(defineTexture$1),Object.freeze(defineVector);const Xe={},je={AO_STRENGTH:"aoStrength",SPECULAR_STRENGTH:"specularStrength",EMISSIVE_STRENGTH:"emissiveStrength",OPACITY:"opacity",SHININESS:"shininess",NORMAL_SCALE:"normalScale"},Ye={},Ze={ALPHA_TEXTURE_SAMPLER:"alphaTextureSampler",AO_TEXTURE_SAMPLER:"aoTextureSampler",DIFFUSE_TEXTURE_SAMPLER:"diffuseTextureSampler",EMISSIVE_TEXTURE_SAMPLER:"emissiveTextureSampler",ENVIRONMENT_TEXTURE_SAMPLER:"environmentTextureSampler",NORMAL_TEXTURE_SAMPLER:"normalTextureSampler",SPECULAR_TEXTURE_SAMPLER:"specularTextureSampler"},qe={ENVIRONMENT_TEXTURE:"environmentTexture"},We={},Je={},Qe={},et={ALPHA_TEXTURE:"alphaTexture",AO_TEXTURE:"aoTexture",DIFFUSE_TEXTURE:"diffuseTexture",EMISSIVE_TEXTURE:"emissiveTexture",NORMAL_TEXTURE:"normalTexture",SPECULAR_TEXTURE:"specularTexture"},tt={COLOR:"color",EMISSIVE_COLOR:"emissiveColor",SPECULAR_COLOR:"specularColor"},rt={...createDefineByPreset({defineBoolean:[defineBoolean,Xe],definePositiveNumber:[definePositiveNumberRange,je],defineUint:[defineUintRange,Ye],defineVec2:[defineProperty_vec2,We],defineVec3:[defineProperty_vec3,Je],defineVec4:[defineProperty_vec4,Qe],defineColorRGB:[defineColorRGB,tt],defineSampler:[defineSampler,Ze],defineTexture:[defineTexture$1,et],defineCubeTexture:[defineCubeTexture,qe]}),defineBoolean:defineProperties(defineBoolean),definePositiveNumber:defineProperties(definePositiveNumberRange),defineUint:defineProperties(defineUintRange),defineVec2:defineProperties(defineProperty_vec2),defineVec3:defineProperties(defineProperty_vec3),defineVec4:defineProperties(defineProperty_vec4),defineColorRGB:defineProperties(defineColorRGB),defineColorRGBA:defineProperties(defineColorRGBA),defineSampler:defineProperties(defineSampler),defineTexture:defineProperties(defineTexture$1),defineCubeTexture:defineProperties(defineCubeTexture),PRESET_BOOLEAN:Xe,PRESET_POSITIVE_NUMBER:je,PRESET_UINT:Ye,PRESET_SAMPLER:Ze,PRESET_TEXTURE:et,PRESET_CUBE_TEXTURE:qe,PRESET_VEC2:We,PRESET_VEC3:Je,PRESET_VEC4:Qe,PRESET_COLOR_RGB:tt};Object.freeze(rt);class PackedTexture{get gpuTexture(){return this.#$}#v;#ze;#ue;#$;#T;constructor(e){this.#v=e,this.#T=e.gpuDevice,this.#ze=this.#Ke(),this.#ue=this.#$e()}#Ke(){const e="\n\tstruct VertexOut {@builtin(position) position:vec4<f32>,@location(0) uv:vec2<f32>,\n\t};\n\n\t@vertex\n\tfn vertexMain(@builtin(vertex_index) VertexIndex:u32) -> VertexOut {var pos=array<vec2<f32>,6>(vec2(-1.0,-1.0),vec2( 1.0,-1.0),vec2(-1.0, 1.0),vec2(-1.0, 1.0),vec2( 1.0,-1.0),vec2( 1.0, 1.0));\nvar uv=array<vec2<f32>,6>(vec2(0.0,1.0),vec2(1.0,1.0),vec2(0.0,0.0),vec2(0.0,0.0),vec2(1.0,1.0),vec2(1.0,0.0));\nvar output:VertexOut;output.position=vec4(pos[VertexIndex],0.0,1.0);output.uv=uv[VertexIndex];return output;\n\t}\n\n\n\t@group(0) @binding(0) var textureR:texture_2d<f32>;\n\t@group(0) @binding(1) var textureG:texture_2d<f32>;\n\t@group(0) @binding(2) var textureB:texture_2d<f32>;\n\t@group(0) @binding(3) var textureA:texture_2d<f32>;\n\t@group(0) @binding(4) var sampler0:sampler;\n\n\t@fragment\n\tfn main(input:VertexOut) -> @location(0) vec4<f32> {let r=textureSample(textureR,sampler0,input.uv).r;let g=textureSample(textureG,sampler0,input.uv).g;let b=textureSample(textureB,sampler0,input.uv).b;let a=textureSample(textureA,sampler0,input.uv).a;\nreturn vec4(r,g,b,a);\n\t}\n\t";return this.#T.createRenderPipeline({layout:"auto",vertex:{module:this.#T.createShaderModule({code:e}),entryPoint:"vertexMain"},fragment:{module:this.#T.createShaderModule({code:e}),entryPoint:"main",targets:[{format:"rgba8unorm"}]},primitive:{topology:"triangle-list"}})}#$e(){return this.#T.createSampler({magFilter:"linear",minFilter:"linear"})}async packing(e,t,r){const n={size:[t,r,1],format:"rgba8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC};this.#$&&(this.#$.destroy(),this.#$=null);const i=this.#T.createTexture(n),s=[{binding:0,resource:e.r?e.r.createView():this.#v.resourceManager.emptyBitmapTextureView},{binding:1,resource:e.g?e.g.createView():this.#v.resourceManager.emptyBitmapTextureView},{binding:2,resource:e.b?e.b.createView():this.#v.resourceManager.emptyBitmapTextureView},{binding:3,resource:e.a?e.a.createView():this.#v.resourceManager.emptyBitmapTextureView},{binding:4,resource:this.#ue}],a=this.#T.createBindGroup({layout:this.#ze.getBindGroupLayout(0),entries:s}),o=this.#T.createCommandEncoder(),u=o.beginRenderPass({colorAttachments:[{view:i.createView(),loadOp:"clear",storeOp:"store",clearValue:[0,0,0,0]}]});u.setPipeline(this.#ze),u.setBindGroup(0,a),u.draw(6,1,0,0),u.end(),this.#T.queue.submit([o.finish()]),this.#$=i}}class ParseContext{constructor(){this.constants=new Map,this.aliases=new Map,this.structs=new Map}}class Node{constructor(){}get isAstNode(){return!0}get astNodeType(){return""}evaluate(e){throw new Error("Cannot evaluate node")}evaluateString(e){return this.evaluate(e).toString()}search(e){}searchBlock(e,t){if(e){t(_BlockStart.instance);for(const r of e)r instanceof Array?this.searchBlock(r,t):r.search(t);t(_BlockEnd.instance)}}}class _BlockStart extends Node{}_BlockStart.instance=new _BlockStart;class _BlockEnd extends Node{}_BlockEnd.instance=new _BlockEnd;class Statement extends Node{constructor(){super()}}let nt=class extends Statement{constructor(e,t,r,n,i,s){super(),this.calls=new Set,this.name=e,this.args=t,this.returnType=r,this.body=n,this.startLine=i,this.endLine=s}get astNodeType(){return"function"}search(e){this.searchBlock(this.body,e)}};class StaticAssert extends Statement{constructor(e){super(),this.expression=e}get astNodeType(){return"staticAssert"}search(e){this.expression.search(e)}}class While extends Statement{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"while"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class Continuing extends Statement{constructor(e){super(),this.body=e}get astNodeType(){return"continuing"}search(e){this.searchBlock(this.body,e)}}class For extends Statement{constructor(e,t,r,n){super(),this.init=e,this.condition=t,this.increment=r,this.body=n}get astNodeType(){return"for"}search(e){var t,r,n;null===(t=this.init)||void 0===t||t.search(e),null===(r=this.condition)||void 0===r||r.search(e),null===(n=this.increment)||void 0===n||n.search(e),this.searchBlock(this.body,e)}}class Var extends Statement{constructor(e,t,r,n,i){super(),this.name=e,this.type=t,this.storage=r,this.access=n,this.value=i}get astNodeType(){return"var"}search(e){var t;e(this),null===(t=this.value)||void 0===t||t.search(e)}}class Override extends Statement{constructor(e,t,r){super(),this.name=e,this.type=t,this.value=r}get astNodeType(){return"override"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class Let extends Statement{constructor(e,t,r,n,i){super(),this.name=e,this.type=t,this.storage=r,this.access=n,this.value=i}get astNodeType(){return"let"}search(e){var t;e(this),null===(t=this.value)||void 0===t||t.search(e)}}class Const extends Statement{constructor(e,t,r,n,i){super(),this.name=e,this.type=t,this.storage=r,this.access=n,this.value=i}get astNodeType(){return"const"}evaluate(e){return this.value.evaluate(e)}search(e){var t;e(this),null===(t=this.value)||void 0===t||t.search(e)}}var it,st,at,ot,ut;!function(e){e.increment="++",e.decrement="--"}(it||(it={})),function(e){e.parse=function(t){const r=t;if("parse"==r)throw new Error("Invalid value for IncrementOperator");return e[r]}}(it||(it={}));class Increment extends Statement{constructor(e,t){super(),this.operator=e,this.variable=t}get astNodeType(){return"increment"}search(e){this.variable.search(e)}}!function(e){e.assign="=",e.addAssign="+=",e.subtractAssin="-=",e.multiplyAssign="*=",e.divideAssign="/=",e.moduloAssign="%=",e.andAssign="&=",e.orAssign="|=",e.xorAssign="^=",e.shiftLeftAssign="<<=",e.shiftRightAssign=">>="}(st||(st={})),function(e){e.parse=function(e){const t=e;if("parse"==t)throw new Error("Invalid value for AssignOperator");return t}}(st||(st={}));class Assign extends Statement{constructor(e,t,r){super(),this.operator=e,this.variable=t,this.value=r}get astNodeType(){return"assign"}search(e){this.variable.search(e),this.value.search(e)}}class Call extends Statement{constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return"call"}search(e){for(const t of this.args)t.search(e);e(this)}}class Loop extends Statement{constructor(e,t){super(),this.body=e,this.continuing=t}get astNodeType(){return"loop"}}class Switch extends Statement{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"body"}}class If extends Statement{constructor(e,t,r,n){super(),this.condition=e,this.body=t,this.elseif=r,this.else=n}get astNodeType(){return"if"}search(e){this.condition.search(e),this.searchBlock(this.body,e),this.searchBlock(this.elseif,e),this.searchBlock(this.else,e)}}class Return extends Statement{constructor(e){super(),this.value=e}get astNodeType(){return"return"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class Enable extends Statement{constructor(e){super(),this.name=e}get astNodeType(){return"enable"}}class Requires extends Statement{constructor(e){super(),this.extensions=e}get astNodeType(){return"requires"}}class Diagnostic extends Statement{constructor(e,t){super(),this.severity=e,this.rule=t}get astNodeType(){return"diagnostic"}}class Alias extends Statement{constructor(e,t){super(),this.name=e,this.type=t}get astNodeType(){return"alias"}}class Discard extends Statement{constructor(){super()}get astNodeType(){return"discard"}}class Break extends Statement{constructor(){super()}get astNodeType(){return"break"}}class Continue extends Statement{constructor(){super()}get astNodeType(){return"continue"}}class Type extends Statement{constructor(e){super(),this.name=e}get astNodeType(){return"type"}get isStruct(){return!1}get isArray(){return!1}}class Struct extends Type{constructor(e,t,r,n){super(e),this.members=t,this.startLine=r,this.endLine=n}get astNodeType(){return"struct"}get isStruct(){return!0}getMemberIndex(e){for(let t=0;t<this.members.length;t++)if(this.members[t].name==e)return t;return-1}}class TemplateType extends Type{constructor(e,t,r){super(e),this.format=t,this.access=r}get astNodeType(){return"template"}}class PointerType extends Type{constructor(e,t,r,n){super(e),this.storage=t,this.type=r,this.access=n}get astNodeType(){return"pointer"}}class ArrayType extends Type{constructor(e,t,r,n){super(e),this.attributes=t,this.format=r,this.count=n}get astNodeType(){return"array"}get isArray(){return!0}}class SamplerType extends Type{constructor(e,t,r){super(e),this.format=t,this.access=r}get astNodeType(){return"sampler"}}class Expression extends Node{constructor(){super()}}class StringExpr extends Expression{constructor(e){super(),this.value=e}get astNodeType(){return"stringExpr"}toString(){return this.value}evaluateString(){return this.value}}class CreateExpr extends Expression{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return"createExpr"}search(e){if(e(this),this.args)for(const t of this.args)t.search(e)}evaluate(e){return this.args[0].evaluate(e)}}class CallExpr extends Expression{constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return"callExpr"}evaluate(e){switch(this.name){case"abs":return Math.abs(this.args[0].evaluate(e));case"acos":return Math.acos(this.args[0].evaluate(e));case"acosh":return Math.acosh(this.args[0].evaluate(e));case"asin":return Math.asin(this.args[0].evaluate(e));case"asinh":return Math.asinh(this.args[0].evaluate(e));case"atan":return Math.atan(this.args[0].evaluate(e));case"atan2":return Math.atan2(this.args[0].evaluate(e),this.args[1].evaluate(e));case"atanh":return Math.atanh(this.args[0].evaluate(e));case"ceil":return Math.ceil(this.args[0].evaluate(e));case"clamp":return Math.min(Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e)),this.args[2].evaluate(e));case"cos":return Math.cos(this.args[0].evaluate(e));case"degrees":return 180*this.args[0].evaluate(e)/Math.PI;case"distance":return Math.sqrt(Math.pow(this.args[0].evaluate(e)-this.args[1].evaluate(e),2));case"dot":case"exp":return Math.exp(this.args[0].evaluate(e));case"exp2":return Math.pow(2,this.args[0].evaluate(e));case"floor":return Math.floor(this.args[0].evaluate(e));case"fma":return this.args[0].evaluate(e)*this.args[1].evaluate(e)+this.args[2].evaluate(e);case"fract":case"modf":return this.args[0].evaluate(e)-Math.floor(this.args[0].evaluate(e));case"inverseSqrt":return 1/Math.sqrt(this.args[0].evaluate(e));case"log":return Math.log(this.args[0].evaluate(e));case"log2":return Math.log2(this.args[0].evaluate(e));case"max":return Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e));case"min":return Math.min(this.args[0].evaluate(e),this.args[1].evaluate(e));case"mix":return this.args[0].evaluate(e)*(1-this.args[2].evaluate(e))+this.args[1].evaluate(e)*this.args[2].evaluate(e);case"pow":return Math.pow(this.args[0].evaluate(e),this.args[1].evaluate(e));case"radians":return this.args[0].evaluate(e)*Math.PI/180;case"round":return Math.round(this.args[0].evaluate(e));case"sign":return Math.sign(this.args[0].evaluate(e));case"sin":return Math.sin(this.args[0].evaluate(e));case"sinh":return Math.sinh(this.args[0].evaluate(e));case"saturate":return Math.min(Math.max(this.args[0].evaluate(e),0),1);case"smoothstep":return this.args[0].evaluate(e)*this.args[0].evaluate(e)*(3-2*this.args[0].evaluate(e));case"sqrt":return Math.sqrt(this.args[0].evaluate(e));case"step":return this.args[0].evaluate(e)<this.args[1].evaluate(e)?0:1;case"tan":return Math.tan(this.args[0].evaluate(e));case"tanh":return Math.tanh(this.args[0].evaluate(e));case"trunc":return Math.trunc(this.args[0].evaluate(e));default:throw new Error("Non const function:"+this.name)}}search(e){for(const t of this.args)t.search(e);e(this)}}class VariableExpr extends Expression{constructor(e){super(),this.name=e}get astNodeType(){return"varExpr"}search(e){e(this),this.postfix&&this.postfix.search(e)}evaluate(e){const t=e.constants.get(this.name);if(!t)throw new Error("Cannot evaluate node");return t.evaluate(e)}}class ConstExpr extends Expression{constructor(e,t){super(),this.name=e,this.initializer=t}get astNodeType(){return"constExpr"}evaluate(e){var t,r;if(this.initializer instanceof CreateExpr){const n=null===(t=this.postfix)||void 0===t?void 0:t.evaluateString(e),i=null===(r=this.initializer.type)||void 0===r?void 0:r.name,s=e.structs.get(i),a=null==s?void 0:s.getMemberIndex(n);if(void 0!==a&&-1!=a){return this.initializer.args[a].evaluate(e)}return this.initializer.evaluate(e)}return this.initializer.evaluate(e)}search(e){this.initializer.search(e)}}class LiteralExpr extends Expression{constructor(e){super(),this.value=e}get astNodeType(){return"literalExpr"}evaluate(){return this.value}}class BitcastExpr extends Expression{constructor(e,t){super(),this.type=e,this.value=t}get astNodeType(){return"bitcastExpr"}search(e){this.value.search(e)}}class GroupingExpr extends Expression{constructor(e){super(),this.contents=e}get astNodeType(){return"groupExpr"}evaluate(e){return this.contents[0].evaluate(e)}search(e){this.searchBlock(this.contents,e)}}class ArrayIndex extends Expression{constructor(e){super(),this.index=e}search(e){this.index.search(e)}}class Operator extends Expression{constructor(){super()}}class UnaryOperator extends Operator{constructor(e,t){super(),this.operator=e,this.right=t}get astNodeType(){return"unaryOp"}evaluate(e){switch(this.operator){case"+":return this.right.evaluate(e);case"-":return-this.right.evaluate(e);case"!":return this.right.evaluate(e)?0:1;case"~":return~this.right.evaluate(e);default:throw new Error("Unknown unary operator:"+this.operator)}}search(e){this.right.search(e)}}class BinaryOperator extends Operator{constructor(e,t,r){super(),this.operator=e,this.left=t,this.right=r}get astNodeType(){return"binaryOp"}evaluate(e){switch(this.operator){case"+":return this.left.evaluate(e)+this.right.evaluate(e);case"-":return this.left.evaluate(e)-this.right.evaluate(e);case"*":return this.left.evaluate(e)*this.right.evaluate(e);case"/":return this.left.evaluate(e)/this.right.evaluate(e);case"%":return this.left.evaluate(e)%this.right.evaluate(e);case"==":return this.left.evaluate(e)==this.right.evaluate(e)?1:0;case"!=":return this.left.evaluate(e)!=this.right.evaluate(e)?1:0;case"<":return this.left.evaluate(e)<this.right.evaluate(e)?1:0;case">":return this.left.evaluate(e)>this.right.evaluate(e)?1:0;case"<=":return this.left.evaluate(e)<=this.right.evaluate(e)?1:0;case">=":return this.left.evaluate(e)>=this.right.evaluate(e)?1:0;case"&&":return this.left.evaluate(e)&&this.right.evaluate(e)?1:0;case"||":return this.left.evaluate(e)||this.right.evaluate(e)?1:0;default:throw new Error(`Unknown operator ${this.operator}`)}}search(e){this.left.search(e),this.right.search(e)}}class SwitchCase extends Node{constructor(){super()}}class Case extends SwitchCase{constructor(e,t){super(),this.selector=e,this.body=t}get astNodeType(){return"case"}search(e){this.searchBlock(this.body,e)}}class Default extends SwitchCase{constructor(e){super(),this.body=e}get astNodeType(){return"default"}search(e){this.searchBlock(this.body,e)}}class Argument extends Node{constructor(e,t,r){super(),this.name=e,this.type=t,this.attributes=r}get astNodeType(){return"argument"}}class ElseIf extends Node{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"elseif"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class Member extends Node{constructor(e,t,r){super(),this.name=e,this.type=t,this.attributes=r}get astNodeType(){return"member"}}class Attribute extends Node{constructor(e,t){super(),this.name=e,this.value=t}get astNodeType(){return"attribute"}}!function(e){e[e.token=0]="token",e[e.keyword=1]="keyword",e[e.reserved=2]="reserved"}(ot||(ot={}));class TokenType{constructor(e,t,r){this.name=e,this.type=t,this.rule=r}toString(){return this.name}}class TokenTypes{}at=TokenTypes,TokenTypes.none=new TokenType("",ot.reserved,""),TokenTypes.eof=new TokenType("EOF",ot.token,""),TokenTypes.reserved={asm:new TokenType("asm",ot.reserved,"asm"),bf16:new TokenType("bf16",ot.reserved,"bf16"),do:new TokenType("do",ot.reserved,"do"),enum:new TokenType("enum",ot.reserved,"enum"),f16:new TokenType("f16",ot.reserved,"f16"),f64:new TokenType("f64",ot.reserved,"f64"),handle:new TokenType("handle",ot.reserved,"handle"),i8:new TokenType("i8",ot.reserved,"i8"),i16:new TokenType("i16",ot.reserved,"i16"),i64:new TokenType("i64",ot.reserved,"i64"),mat:new TokenType("mat",ot.reserved,"mat"),premerge:new TokenType("premerge",ot.reserved,"premerge"),regardless:new TokenType("regardless",ot.reserved,"regardless"),typedef:new TokenType("typedef",ot.reserved,"typedef"),u8:new TokenType("u8",ot.reserved,"u8"),u16:new TokenType("u16",ot.reserved,"u16"),u64:new TokenType("u64",ot.reserved,"u64"),unless:new TokenType("unless",ot.reserved,"unless"),using:new TokenType("using",ot.reserved,"using"),vec:new TokenType("vec",ot.reserved,"vec"),void:new TokenType("void",ot.reserved,"void")},TokenTypes.keywords={array:new TokenType("array",ot.keyword,"array"),atomic:new TokenType("atomic",ot.keyword,"atomic"),bool:new TokenType("bool",ot.keyword,"bool"),f32:new TokenType("f32",ot.keyword,"f32"),i32:new TokenType("i32",ot.keyword,"i32"),mat2x2:new TokenType("mat2x2",ot.keyword,"mat2x2"),mat2x3:new TokenType("mat2x3",ot.keyword,"mat2x3"),mat2x4:new TokenType("mat2x4",ot.keyword,"mat2x4"),mat3x2:new TokenType("mat3x2",ot.keyword,"mat3x2"),mat3x3:new TokenType("mat3x3",ot.keyword,"mat3x3"),mat3x4:new TokenType("mat3x4",ot.keyword,"mat3x4"),mat4x2:new TokenType("mat4x2",ot.keyword,"mat4x2"),mat4x3:new TokenType("mat4x3",ot.keyword,"mat4x3"),mat4x4:new TokenType("mat4x4",ot.keyword,"mat4x4"),ptr:new TokenType("ptr",ot.keyword,"ptr"),sampler:new TokenType("sampler",ot.keyword,"sampler"),sampler_comparison:new TokenType("sampler_comparison",ot.keyword,"sampler_comparison"),struct:new TokenType("struct",ot.keyword,"struct"),texture_1d:new TokenType("texture_1d",ot.keyword,"texture_1d"),texture_2d:new TokenType("texture_2d",ot.keyword,"texture_2d"),texture_2d_array:new TokenType("texture_2d_array",ot.keyword,"texture_2d_array"),texture_3d:new TokenType("texture_3d",ot.keyword,"texture_3d"),texture_cube:new TokenType("texture_cube",ot.keyword,"texture_cube"),texture_cube_array:new TokenType("texture_cube_array",ot.keyword,"texture_cube_array"),texture_multisampled_2d:new TokenType("texture_multisampled_2d",ot.keyword,"texture_multisampled_2d"),texture_storage_1d:new TokenType("texture_storage_1d",ot.keyword,"texture_storage_1d"),texture_storage_2d:new TokenType("texture_storage_2d",ot.keyword,"texture_storage_2d"),texture_storage_2d_array:new TokenType("texture_storage_2d_array",ot.keyword,"texture_storage_2d_array"),texture_storage_3d:new TokenType("texture_storage_3d",ot.keyword,"texture_storage_3d"),texture_depth_2d:new TokenType("texture_depth_2d",ot.keyword,"texture_depth_2d"),texture_depth_2d_array:new TokenType("texture_depth_2d_array",ot.keyword,"texture_depth_2d_array"),texture_depth_cube:new TokenType("texture_depth_cube",ot.keyword,"texture_depth_cube"),texture_depth_cube_array:new TokenType("texture_depth_cube_array",ot.keyword,"texture_depth_cube_array"),texture_depth_multisampled_2d:new TokenType("texture_depth_multisampled_2d",ot.keyword,"texture_depth_multisampled_2d"),texture_external:new TokenType("texture_external",ot.keyword,"texture_external"),u32:new TokenType("u32",ot.keyword,"u32"),vec2:new TokenType("vec2",ot.keyword,"vec2"),vec3:new TokenType("vec3",ot.keyword,"vec3"),vec4:new TokenType("vec4",ot.keyword,"vec4"),bitcast:new TokenType("bitcast",ot.keyword,"bitcast"),block:new TokenType("block",ot.keyword,"block"),break:new TokenType("break",ot.keyword,"break"),case:new TokenType("case",ot.keyword,"case"),continue:new TokenType("continue",ot.keyword,"continue"),continuing:new TokenType("continuing",ot.keyword,"continuing"),default:new TokenType("default",ot.keyword,"default"),diagnostic:new TokenType("diagnostic",ot.keyword,"diagnostic"),discard:new TokenType("discard",ot.keyword,"discard"),else:new TokenType("else",ot.keyword,"else"),enable:new TokenType("enable",ot.keyword,"enable"),fallthrough:new TokenType("fallthrough",ot.keyword,"fallthrough"),false:new TokenType("false",ot.keyword,"false"),fn:new TokenType("fn",ot.keyword,"fn"),for:new TokenType("for",ot.keyword,"for"),function:new TokenType("function",ot.keyword,"function"),if:new TokenType("if",ot.keyword,"if"),let:new TokenType("let",ot.keyword,"let"),const:new TokenType("const",ot.keyword,"const"),loop:new TokenType("loop",ot.keyword,"loop"),while:new TokenType("while",ot.keyword,"while"),private:new TokenType("private",ot.keyword,"private"),read:new TokenType("read",ot.keyword,"read"),read_write:new TokenType("read_write",ot.keyword,"read_write"),return:new TokenType("return",ot.keyword,"return"),requires:new TokenType("requires",ot.keyword,"requires"),storage:new TokenType("storage",ot.keyword,"storage"),switch:new TokenType("switch",ot.keyword,"switch"),true:new TokenType("true",ot.keyword,"true"),alias:new TokenType("alias",ot.keyword,"alias"),type:new TokenType("type",ot.keyword,"type"),uniform:new TokenType("uniform",ot.keyword,"uniform"),var:new TokenType("var",ot.keyword,"var"),override:new TokenType("override",ot.keyword,"override"),workgroup:new TokenType("workgroup",ot.keyword,"workgroup"),write:new TokenType("write",ot.keyword,"write"),r8unorm:new TokenType("r8unorm",ot.keyword,"r8unorm"),r8snorm:new TokenType("r8snorm",ot.keyword,"r8snorm"),r8uint:new TokenType("r8uint",ot.keyword,"r8uint"),r8sint:new TokenType("r8sint",ot.keyword,"r8sint"),r16uint:new TokenType("r16uint",ot.keyword,"r16uint"),r16sint:new TokenType("r16sint",ot.keyword,"r16sint"),r16float:new TokenType("r16float",ot.keyword,"r16float"),rg8unorm:new TokenType("rg8unorm",ot.keyword,"rg8unorm"),rg8snorm:new TokenType("rg8snorm",ot.keyword,"rg8snorm"),rg8uint:new TokenType("rg8uint",ot.keyword,"rg8uint"),rg8sint:new TokenType("rg8sint",ot.keyword,"rg8sint"),r32uint:new TokenType("r32uint",ot.keyword,"r32uint"),r32sint:new TokenType("r32sint",ot.keyword,"r32sint"),r32float:new TokenType("r32float",ot.keyword,"r32float"),rg16uint:new TokenType("rg16uint",ot.keyword,"rg16uint"),rg16sint:new TokenType("rg16sint",ot.keyword,"rg16sint"),rg16float:new TokenType("rg16float",ot.keyword,"rg16float"),rgba8unorm:new TokenType("rgba8unorm",ot.keyword,"rgba8unorm"),rgba8unorm_srgb:new TokenType("rgba8unorm_srgb",ot.keyword,"rgba8unorm_srgb"),rgba8snorm:new TokenType("rgba8snorm",ot.keyword,"rgba8snorm"),rgba8uint:new TokenType("rgba8uint",ot.keyword,"rgba8uint"),rgba8sint:new TokenType("rgba8sint",ot.keyword,"rgba8sint"),bgra8unorm:new TokenType("bgra8unorm",ot.keyword,"bgra8unorm"),bgra8unorm_srgb:new TokenType("bgra8unorm_srgb",ot.keyword,"bgra8unorm_srgb"),rgb10a2unorm:new TokenType("rgb10a2unorm",ot.keyword,"rgb10a2unorm"),rg11b10float:new TokenType("rg11b10float",ot.keyword,"rg11b10float"),rg32uint:new TokenType("rg32uint",ot.keyword,"rg32uint"),rg32sint:new TokenType("rg32sint",ot.keyword,"rg32sint"),rg32float:new TokenType("rg32float",ot.keyword,"rg32float"),rgba16uint:new TokenType("rgba16uint",ot.keyword,"rgba16uint"),rgba16sint:new TokenType("rgba16sint",ot.keyword,"rgba16sint"),rgba16float:new TokenType("rgba16float",ot.keyword,"rgba16float"),rgba32uint:new TokenType("rgba32uint",ot.keyword,"rgba32uint"),rgba32sint:new TokenType("rgba32sint",ot.keyword,"rgba32sint"),rgba32float:new TokenType("rgba32float",ot.keyword,"rgba32float"),static_assert:new TokenType("static_assert",ot.keyword,"static_assert")},TokenTypes.tokens={decimal_float_literal:new TokenType("decimal_float_literal",ot.token,/((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),hex_float_literal:new TokenType("hex_float_literal",ot.token,/-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),int_literal:new TokenType("int_literal",ot.token,/-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),uint_literal:new TokenType("uint_literal",ot.token,/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),ident:new TokenType("ident",ot.token,/[_a-zA-Z][0-9a-zA-Z_]*/),and:new TokenType("and",ot.token,"&"),and_and:new TokenType("and_and",ot.token,"&&"),arrow:new TokenType("arrow ",ot.token,"->"),attr:new TokenType("attr",ot.token,"@"),forward_slash:new TokenType("forward_slash",ot.token,"/"),bang:new TokenType("bang",ot.token,"!"),bracket_left:new TokenType("bracket_left",ot.token,"["),bracket_right:new TokenType("bracket_right",ot.token,"]"),brace_left:new TokenType("brace_left",ot.token,"{"),brace_right:new TokenType("brace_right",ot.token,"}"),colon:new TokenType("colon",ot.token,":"),comma:new TokenType("comma",ot.token,","),equal:new TokenType("equal",ot.token,"="),equal_equal:new TokenType("equal_equal",ot.token,"=="),not_equal:new TokenType("not_equal",ot.token,"!="),greater_than:new TokenType("greater_than",ot.token,">"),greater_than_equal:new TokenType("greater_than_equal",ot.token,">="),shift_right:new TokenType("shift_right",ot.token,">>"),less_than:new TokenType("less_than",ot.token,"<"),less_than_equal:new TokenType("less_than_equal",ot.token,"<="),shift_left:new TokenType("shift_left",ot.token,"<<"),modulo:new TokenType("modulo",ot.token,"%"),minus:new TokenType("minus",ot.token,"-"),minus_minus:new TokenType("minus_minus",ot.token,"--"),period:new TokenType("period",ot.token,"."),plus:new TokenType("plus",ot.token,"+"),plus_plus:new TokenType("plus_plus",ot.token,"++"),or:new TokenType("or",ot.token,"|"),or_or:new TokenType("or_or",ot.token,"||"),paren_left:new TokenType("paren_left",ot.token,"("),paren_right:new TokenType("paren_right",ot.token,")"),semicolon:new TokenType("semicolon",ot.token,";"),star:new TokenType("star",ot.token,"*"),tilde:new TokenType("tilde",ot.token,"~"),underscore:new TokenType("underscore",ot.token,"_"),xor:new TokenType("xor",ot.token,"^"),plus_equal:new TokenType("plus_equal",ot.token,"+="),minus_equal:new TokenType("minus_equal",ot.token,"-="),times_equal:new TokenType("times_equal",ot.token,"*="),division_equal:new TokenType("division_equal",ot.token,"/="),modulo_equal:new TokenType("modulo_equal",ot.token,"%="),and_equal:new TokenType("and_equal",ot.token,"&="),or_equal:new TokenType("or_equal",ot.token,"|="),xor_equal:new TokenType("xor_equal",ot.token,"^="),shift_right_equal:new TokenType("shift_right_equal",ot.token,">>="),shift_left_equal:new TokenType("shift_left_equal",ot.token,"<<=")},TokenTypes.simpleTokens={"@":at.tokens.attr,"{":at.tokens.brace_left,"}":at.tokens.brace_right,":":at.tokens.colon,",":at.tokens.comma,"(":at.tokens.paren_left,")":at.tokens.paren_right,";":at.tokens.semicolon},TokenTypes.literalTokens={"&":at.tokens.and,"&&":at.tokens.and_and,"->":at.tokens.arrow,"/":at.tokens.forward_slash,"!":at.tokens.bang,"[":at.tokens.bracket_left,"]":at.tokens.bracket_right,"=":at.tokens.equal,"==":at.tokens.equal_equal,"!=":at.tokens.not_equal,">":at.tokens.greater_than,">=":at.tokens.greater_than_equal,">>":at.tokens.shift_right,"<":at.tokens.less_than,"<=":at.tokens.less_than_equal,"<<":at.tokens.shift_left,"%":at.tokens.modulo,"-":at.tokens.minus,"--":at.tokens.minus_minus,".":at.tokens.period,"+":at.tokens.plus,"++":at.tokens.plus_plus,"|":at.tokens.or,"||":at.tokens.or_or,"*":at.tokens.star,"~":at.tokens.tilde,_:at.tokens.underscore,"^":at.tokens.xor,"+=":at.tokens.plus_equal,"-=":at.tokens.minus_equal,"*=":at.tokens.times_equal,"/=":at.tokens.division_equal,"%=":at.tokens.modulo_equal,"&=":at.tokens.and_equal,"|=":at.tokens.or_equal,"^=":at.tokens.xor_equal,">>=":at.tokens.shift_right_equal,"<<=":at.tokens.shift_left_equal},TokenTypes.regexTokens={decimal_float_literal:at.tokens.decimal_float_literal,hex_float_literal:at.tokens.hex_float_literal,int_literal:at.tokens.int_literal,uint_literal:at.tokens.uint_literal,ident:at.tokens.ident},TokenTypes.storage_class=[at.keywords.function,at.keywords.private,at.keywords.workgroup,at.keywords.uniform,at.keywords.storage],TokenTypes.access_mode=[at.keywords.read,at.keywords.write,at.keywords.read_write],TokenTypes.sampler_type=[at.keywords.sampler,at.keywords.sampler_comparison],TokenTypes.sampled_texture_type=[at.keywords.texture_1d,at.keywords.texture_2d,at.keywords.texture_2d_array,at.keywords.texture_3d,at.keywords.texture_cube,at.keywords.texture_cube_array],TokenTypes.multisampled_texture_type=[at.keywords.texture_multisampled_2d],TokenTypes.storage_texture_type=[at.keywords.texture_storage_1d,at.keywords.texture_storage_2d,at.keywords.texture_storage_2d_array,at.keywords.texture_storage_3d],TokenTypes.depth_texture_type=[at.keywords.texture_depth_2d,at.keywords.texture_depth_2d_array,at.keywords.texture_depth_cube,at.keywords.texture_depth_cube_array,at.keywords.texture_depth_multisampled_2d],TokenTypes.texture_external_type=[at.keywords.texture_external],TokenTypes.any_texture_type=[...at.sampled_texture_type,...at.multisampled_texture_type,...at.storage_texture_type,...at.depth_texture_type,...at.texture_external_type],TokenTypes.texel_format=[at.keywords.r8unorm,at.keywords.r8snorm,at.keywords.r8uint,at.keywords.r8sint,at.keywords.r16uint,at.keywords.r16sint,at.keywords.r16float,at.keywords.rg8unorm,at.keywords.rg8snorm,at.keywords.rg8uint,at.keywords.rg8sint,at.keywords.r32uint,at.keywords.r32sint,at.keywords.r32float,at.keywords.rg16uint,at.keywords.rg16sint,at.keywords.rg16float,at.keywords.rgba8unorm,at.keywords.rgba8unorm_srgb,at.keywords.rgba8snorm,at.keywords.rgba8uint,at.keywords.rgba8sint,at.keywords.bgra8unorm,at.keywords.bgra8unorm_srgb,at.keywords.rgb10a2unorm,at.keywords.rg11b10float,at.keywords.rg32uint,at.keywords.rg32sint,at.keywords.rg32float,at.keywords.rgba16uint,at.keywords.rgba16sint,at.keywords.rgba16float,at.keywords.rgba32uint,at.keywords.rgba32sint,at.keywords.rgba32float],TokenTypes.const_literal=[at.tokens.int_literal,at.tokens.uint_literal,at.tokens.decimal_float_literal,at.tokens.hex_float_literal,at.keywords.true,at.keywords.false],TokenTypes.literal_or_ident=[at.tokens.ident,at.tokens.int_literal,at.tokens.uint_literal,at.tokens.decimal_float_literal,at.tokens.hex_float_literal],TokenTypes.element_count_expression=[at.tokens.int_literal,at.tokens.uint_literal,at.tokens.ident],TokenTypes.template_types=[at.keywords.vec2,at.keywords.vec3,at.keywords.vec4,at.keywords.mat2x2,at.keywords.mat2x3,at.keywords.mat2x4,at.keywords.mat3x2,at.keywords.mat3x3,at.keywords.mat3x4,at.keywords.mat4x2,at.keywords.mat4x3,at.keywords.mat4x4,at.keywords.atomic,at.keywords.bitcast,...at.any_texture_type],TokenTypes.attribute_name=[at.tokens.ident,at.keywords.block,at.keywords.diagnostic],TokenTypes.assignment_operators=[at.tokens.equal,at.tokens.plus_equal,at.tokens.minus_equal,at.tokens.times_equal,at.tokens.division_equal,at.tokens.modulo_equal,at.tokens.and_equal,at.tokens.or_equal,at.tokens.xor_equal,at.tokens.shift_right_equal,at.tokens.shift_left_equal],TokenTypes.increment_operators=[at.tokens.plus_plus,at.tokens.minus_minus];class Token{constructor(e,t,r){this.type=e,this.lexeme=t,this.line=r}toString(){return this.lexeme}isTemplateType(){return-1!=TokenTypes.template_types.indexOf(this.type)}isArrayType(){return this.type==TokenTypes.keywords.array}isArrayOrTemplateType(){return this.isArrayType()||this.isTemplateType()}}class WgslScanner{constructor(e){this._tokens=[],this._start=0,this._current=0,this._line=1,this._source=null!=e?e:""}scanTokens(){for(;!this._isAtEnd();)if(this._start=this._current,!this.scanToken())throw`Invalid syntax at line ${this._line}`;return this._tokens.push(new Token(TokenTypes.eof,"",this._line)),this._tokens}scanToken(){let e=this._advance();if("\n"==e)return this._line++,!0;if(this._isWhitespace(e))return!0;if("/"==e){if("/"==this._peekAhead()){for(;"\n"!=e;){if(this._isAtEnd())return!0;e=this._advance()}return this._line++,!0}if("*"==this._peekAhead()){this._advance();let t=1;for(;t>0;){if(this._isAtEnd())return!0;if(e=this._advance(),"\n"==e)this._line++;else if("*"==e){if("/"==this._peekAhead()&&(this._advance(),t--,0==t))return!0}else"/"==e&&"*"==this._peekAhead()&&(this._advance(),t++)}return!0}}const t=TokenTypes.simpleTokens[e];if(t)return this._addToken(t),!0;let r=TokenTypes.none;const n=this._isAlpha(e),i="_"===e;if(this._isAlphaNumeric(e)){let t=this._peekAhead();for(;this._isAlphaNumeric(t);)e+=this._advance(),t=this._peekAhead()}if(n){const t=TokenTypes.keywords[e];if(t)return this._addToken(t),!0}if(n||i)return this._addToken(TokenTypes.tokens.ident),!0;for(;;){let t=this._findType(e);const n=this._peekAhead();if("-"==e&&this._tokens.length>0){if("="==n)return this._current++,e+=n,this._addToken(TokenTypes.tokens.minus_equal),!0;if("-"==n)return this._current++,e+=n,this._addToken(TokenTypes.tokens.minus_minus),!0;const r=this._tokens.length-1;if((-1!=TokenTypes.literal_or_ident.indexOf(this._tokens[r].type)||this._tokens[r].type==TokenTypes.tokens.paren_right)&&">"!=n)return this._addToken(t),!0}if(">"==e&&(">"==n||"="==n)){let e=!1,r=this._tokens.length-1;for(let t=0;t<5&&r>=0&&-1===TokenTypes.assignment_operators.indexOf(this._tokens[r].type);++t,--r)if(this._tokens[r].type===TokenTypes.tokens.less_than){r>0&&this._tokens[r-1].isArrayOrTemplateType()&&(e=!0);break}if(e)return this._addToken(t),!0}if(t===TokenTypes.none){let n=e,i=0;const s=2;for(let e=0;e<s;++e)if(n+=this._peekAhead(e),t=this._findType(n),t!==TokenTypes.none){i=e;break}if(t===TokenTypes.none)return r!==TokenTypes.none&&(this._current--,this._addToken(r),!0);e=n,this._current+=i+1}if(r=t,this._isAtEnd())break;e+=this._advance()}return r!==TokenTypes.none&&(this._addToken(r),!0)}_findType(e){for(const t in TokenTypes.regexTokens){const r=TokenTypes.regexTokens[t];if(this._match(e,r.rule))return r}const t=TokenTypes.literalTokens[e];return t||TokenTypes.none}_match(e,t){const r=t.exec(e);return r&&0==r.index&&r[0]==e}_isAtEnd(){return this._current>=this._source.length}_isAlpha(e){return e>="a"&&e<="z"||e>="A"&&e<="Z"}_isAlphaNumeric(e){return e>="a"&&e<="z"||e>="A"&&e<="Z"||"_"==e||e>="0"&&e<="9"}_isWhitespace(e){return" "==e||"\t"==e||"\r"==e}_advance(e=0){let t=this._source[this._current];return e=e||0,e++,this._current+=e,t}_peekAhead(e=0){return e=e||0,this._current+e>=this._source.length?"\0":this._source[this._current+e]}_addToken(e){const t=this._source.substring(this._start,this._current);this._tokens.push(new Token(e,t,this._line))}}class WgslParser{constructor(){this._tokens=[],this._current=0,this._currentLine=0,this._context=new ParseContext,this._deferArrayCountEval=[]}parse(e){this._initialize(e),this._deferArrayCountEval.length=0;const t=[];for(;!this._isAtEnd();){const e=this._global_decl_or_directive();if(!e)break;t.push(e)}if(this._deferArrayCountEval.length>0){for(const e of this._deferArrayCountEval){const t=e.arrayType,r=e.countNode;if(r instanceof VariableExpr){const e=r.name,n=this._context.constants.get(e);if(n)try{const e=n.evaluate(this._context);t.count=e}catch(e){}}}this._deferArrayCountEval.length=0}return t}_initialize(e){if(e)if("string"==typeof e){const t=new WgslScanner(e);this._tokens=t.scanTokens()}else this._tokens=e;else this._tokens=[];this._current=0}_error(e,t){return{token:e,message:t,toString:function(){return`${t}`}}}_isAtEnd(){return this._current>=this._tokens.length||this._peek().type==TokenTypes.eof}_match(e){if(e instanceof TokenType)return!!this._check(e)&&(this._advance(),!0);for(let t=0,r=e.length;t<r;++t){const r=e[t];if(this._check(r))return this._advance(),!0}return!1}_consume(e,t){if(this._check(e))return this._advance();throw this._error(this._peek(),t)}_check(e){if(this._isAtEnd())return!1;const t=this._peek();if(e instanceof Array){const r=t.type;return-1!=e.indexOf(r)}return t.type==e}_advance(){var e,t;return this._currentLine=null!==(t=null===(e=this._peek())||void 0===e?void 0:e.line)&&void 0!==t?t:-1,this._isAtEnd()||this._current++,this._previous()}_peek(){return this._tokens[this._current]}_previous(){return this._tokens[this._current-1]}_global_decl_or_directive(){for(;this._match(TokenTypes.tokens.semicolon)&&!this._isAtEnd(););if(this._match(TokenTypes.keywords.alias)){const e=this._type_alias();return this._consume(TokenTypes.tokens.semicolon,"Expected ';'"),e}if(this._match(TokenTypes.keywords.diagnostic)){const e=this._diagnostic();return this._consume(TokenTypes.tokens.semicolon,"Expected ';'"),e}if(this._match(TokenTypes.keywords.requires)){const e=this._requires_directive();return this._consume(TokenTypes.tokens.semicolon,"Expected ';'"),e}if(this._match(TokenTypes.keywords.enable)){const e=this._enable_directive();return this._consume(TokenTypes.tokens.semicolon,"Expected ';'"),e}const e=this._attribute();if(this._check(TokenTypes.keywords.var)){const t=this._global_variable_decl();return null!=t&&(t.attributes=e),this._consume(TokenTypes.tokens.semicolon,"Expected ';'."),t}if(this._check(TokenTypes.keywords.override)){const t=this._override_variable_decl();return null!=t&&(t.attributes=e),this._consume(TokenTypes.tokens.semicolon,"Expected ';'."),t}if(this._check(TokenTypes.keywords.let)){const t=this._global_let_decl();return null!=t&&(t.attributes=e),this._consume(TokenTypes.tokens.semicolon,"Expected ';'."),t}if(this._check(TokenTypes.keywords.const)){const t=this._global_const_decl();return null!=t&&(t.attributes=e),this._consume(TokenTypes.tokens.semicolon,"Expected ';'."),t}if(this._check(TokenTypes.keywords.struct)){const t=this._struct_decl();return null!=t&&(t.attributes=e),t}if(this._check(TokenTypes.keywords.fn)){const t=this._function_decl();return null!=t&&(t.attributes=e),t}return null}_function_decl(){if(!this._match(TokenTypes.keywords.fn))return null;const e=this._currentLine,t=this._consume(TokenTypes.tokens.ident,"Expected function name.").toString();this._consume(TokenTypes.tokens.paren_left,"Expected '(' for function arguments.");const r=[];if(!this._check(TokenTypes.tokens.paren_right))do{if(this._check(TokenTypes.tokens.paren_right))break;const e=this._attribute(),t=this._consume(TokenTypes.tokens.ident,"Expected argument name.").toString();this._consume(TokenTypes.tokens.colon,"Expected ':' for argument type.");const n=this._attribute(),i=this._type_decl();null!=i&&(i.attributes=n,r.push(new Argument(t,i,e)))}while(this._match(TokenTypes.tokens.comma));this._consume(TokenTypes.tokens.paren_right,"Expected ')' after function arguments.");let n=null;if(this._match(TokenTypes.tokens.arrow)){const e=this._attribute();n=this._type_decl(),null!=n&&(n.attributes=e)}const i=this._compound_statement(),s=this._currentLine;return new nt(t,r,n,i,e,s)}_compound_statement(){const e=[];for(this._consume(TokenTypes.tokens.brace_left,"Expected '{' for block.");!this._check(TokenTypes.tokens.brace_right);){const t=this._statement();null!==t&&e.push(t)}return this._consume(TokenTypes.tokens.brace_right,"Expected '}' for block."),e}_statement(){for(;this._match(TokenTypes.tokens.semicolon)&&!this._isAtEnd(););if(this._check(TokenTypes.tokens.attr)&&this._attribute(),this._check(TokenTypes.keywords.if))return this._if_statement();if(this._check(TokenTypes.keywords.switch))return this._switch_statement();if(this._check(TokenTypes.keywords.loop))return this._loop_statement();if(this._check(TokenTypes.keywords.for))return this._for_statement();if(this._check(TokenTypes.keywords.while))return this._while_statement();if(this._check(TokenTypes.keywords.continuing))return this._continuing_statement();if(this._check(TokenTypes.keywords.static_assert))return this._static_assert_statement();if(this._check(TokenTypes.tokens.brace_left))return this._compound_statement();let e=null;return e=this._check(TokenTypes.keywords.return)?this._return_statement():this._check([TokenTypes.keywords.var,TokenTypes.keywords.let,TokenTypes.keywords.const])?this._variable_statement():this._match(TokenTypes.keywords.discard)?new Discard:this._match(TokenTypes.keywords.break)?new Break:this._match(TokenTypes.keywords.continue)?new Continue:this._increment_decrement_statement()||this._func_call_statement()||this._assignment_statement(),null!=e&&this._consume(TokenTypes.tokens.semicolon,"Expected ';' after statement."),e}_static_assert_statement(){if(!this._match(TokenTypes.keywords.static_assert))return null;const e=this._optional_paren_expression();return new StaticAssert(e)}_while_statement(){if(!this._match(TokenTypes.keywords.while))return null;const e=this._optional_paren_expression();this._check(TokenTypes.tokens.attr)&&this._attribute();const t=this._compound_statement();return new While(e,t)}_continuing_statement(){if(!this._match(TokenTypes.keywords.continuing))return null;const e=this._compound_statement();return new Continuing(e)}_for_statement(){if(!this._match(TokenTypes.keywords.for))return null;this._consume(TokenTypes.tokens.paren_left,"Expected '('.");const e=this._check(TokenTypes.tokens.semicolon)?null:this._for_init();this._consume(TokenTypes.tokens.semicolon,"Expected ';'.");const t=this._check(TokenTypes.tokens.semicolon)?null:this._short_circuit_or_expression();this._consume(TokenTypes.tokens.semicolon,"Expected ';'.");const r=this._check(TokenTypes.tokens.paren_right)?null:this._for_increment();this._consume(TokenTypes.tokens.paren_right,"Expected ')'."),this._check(TokenTypes.tokens.attr)&&this._attribute();const n=this._compound_statement();return new For(e,t,r,n)}_for_init(){return this._variable_statement()||this._func_call_statement()||this._assignment_statement()}_for_increment(){return this._func_call_statement()||this._increment_decrement_statement()||this._assignment_statement()}_variable_statement(){if(this._check(TokenTypes.keywords.var)){const e=this._variable_decl();if(null===e)throw this._error(this._peek(),"Variable declaration expected.");let t=null;return this._match(TokenTypes.tokens.equal)&&(t=this._short_circuit_or_expression()),new Var(e.name,e.type,e.storage,e.access,t)}if(this._match(TokenTypes.keywords.let)){const e=this._consume(TokenTypes.tokens.ident,"Expected name for let.").toString();let t=null;if(this._match(TokenTypes.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}this._consume(TokenTypes.tokens.equal,"Expected '=' for let.");const r=this._short_circuit_or_expression();return new Let(e,t,null,null,r)}if(this._match(TokenTypes.keywords.const)){const e=this._consume(TokenTypes.tokens.ident,"Expected name for const.").toString();let t=null;if(this._match(TokenTypes.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}this._consume(TokenTypes.tokens.equal,"Expected '=' for const.");const r=this._short_circuit_or_expression();return new Const(e,t,null,null,r)}return null}_increment_decrement_statement(){const e=this._current,t=this._unary_expression();if(null==t)return null;if(!this._check(TokenTypes.increment_operators))return this._current=e,null;const r=this._consume(TokenTypes.increment_operators,"Expected increment operator");return new Increment(r.type===TokenTypes.tokens.plus_plus?it.increment:it.decrement,t)}_assignment_statement(){let e=null;if(this._check(TokenTypes.tokens.brace_right))return null;let t=this._match(TokenTypes.tokens.underscore);if(t||(e=this._unary_expression()),!t&&null==e)return null;const r=this._consume(TokenTypes.assignment_operators,"Expected assignment operator."),n=this._short_circuit_or_expression();return new Assign(st.parse(r.lexeme),e,n)}_func_call_statement(){if(!this._check(TokenTypes.tokens.ident))return null;const e=this._current,t=this._consume(TokenTypes.tokens.ident,"Expected function name."),r=this._argument_expression_list();return null===r?(this._current=e,null):new Call(t.lexeme,r)}_loop_statement(){if(!this._match(TokenTypes.keywords.loop))return null;this._check(TokenTypes.tokens.attr)&&this._attribute(),this._consume(TokenTypes.tokens.brace_left,"Expected '{' for loop.");const e=[];let t=this._statement();for(;null!==t;){if(Array.isArray(t))for(let r of t)e.push(r);else e.push(t);t=this._statement()}let r=null;return this._match(TokenTypes.keywords.continuing)&&(r=this._compound_statement()),this._consume(TokenTypes.tokens.brace_right,"Expected '}' for loop."),new Loop(e,r)}_switch_statement(){if(!this._match(TokenTypes.keywords.switch))return null;const e=this._optional_paren_expression();this._check(TokenTypes.tokens.attr)&&this._attribute(),this._consume(TokenTypes.tokens.brace_left,"Expected '{' for switch.");const t=this._switch_body();if(null==t||0==t.length)throw this._error(this._previous(),"Expected 'case' or 'default'.");return this._consume(TokenTypes.tokens.brace_right,"Expected '}' for switch."),new Switch(e,t)}_switch_body(){const e=[];if(this._match(TokenTypes.keywords.case)){const t=this._case_selectors();this._match(TokenTypes.tokens.colon),this._check(TokenTypes.tokens.attr)&&this._attribute(),this._consume(TokenTypes.tokens.brace_left,"Exected '{' for switch case.");const r=this._case_body();this._consume(TokenTypes.tokens.brace_right,"Exected '}' for switch case."),e.push(new Case(t,r))}if(this._match(TokenTypes.keywords.default)){this._match(TokenTypes.tokens.colon),this._check(TokenTypes.tokens.attr)&&this._attribute(),this._consume(TokenTypes.tokens.brace_left,"Exected '{' for switch default.");const t=this._case_body();this._consume(TokenTypes.tokens.brace_right,"Exected '}' for switch default."),e.push(new Default(t))}if(this._check([TokenTypes.keywords.default,TokenTypes.keywords.case])){const t=this._switch_body();e.push(t[0])}return e}_case_selectors(){const e=[this._shift_expression()];for(;this._match(TokenTypes.tokens.comma);)e.push(this._shift_expression());return e}_case_body(){if(this._match(TokenTypes.keywords.fallthrough))return this._consume(TokenTypes.tokens.semicolon,"Expected ';'"),[];let e=this._statement();if(null==e)return[];e instanceof Array||(e=[e]);const t=this._case_body();return 0==t.length?e:[...e,t[0]]}_if_statement(){if(!this._match(TokenTypes.keywords.if))return null;const e=this._optional_paren_expression();this._check(TokenTypes.tokens.attr)&&this._attribute();const t=this._compound_statement();let r=[];this._match_elseif()&&(this._check(TokenTypes.tokens.attr)&&this._attribute(),r=this._elseif_statement(r));let n=null;return this._match(TokenTypes.keywords.else)&&(this._check(TokenTypes.tokens.attr)&&this._attribute(),n=this._compound_statement()),new If(e,t,r,n)}_match_elseif(){return this._tokens[this._current].type===TokenTypes.keywords.else&&this._tokens[this._current+1].type===TokenTypes.keywords.if&&(this._advance(),this._advance(),!0)}_elseif_statement(e=[]){const t=this._optional_paren_expression(),r=this._compound_statement();return e.push(new ElseIf(t,r)),this._match_elseif()&&(this._check(TokenTypes.tokens.attr)&&this._attribute(),this._elseif_statement(e)),e}_return_statement(){if(!this._match(TokenTypes.keywords.return))return null;const e=this._short_circuit_or_expression();return new Return(e)}_short_circuit_or_expression(){let e=this._short_circuit_and_expr();for(;this._match(TokenTypes.tokens.or_or);)e=new BinaryOperator(this._previous().toString(),e,this._short_circuit_and_expr());return e}_short_circuit_and_expr(){let e=this._inclusive_or_expression();for(;this._match(TokenTypes.tokens.and_and);)e=new BinaryOperator(this._previous().toString(),e,this._inclusive_or_expression());return e}_inclusive_or_expression(){let e=this._exclusive_or_expression();for(;this._match(TokenTypes.tokens.or);)e=new BinaryOperator(this._previous().toString(),e,this._exclusive_or_expression());return e}_exclusive_or_expression(){let e=this._and_expression();for(;this._match(TokenTypes.tokens.xor);)e=new BinaryOperator(this._previous().toString(),e,this._and_expression());return e}_and_expression(){let e=this._equality_expression();for(;this._match(TokenTypes.tokens.and);)e=new BinaryOperator(this._previous().toString(),e,this._equality_expression());return e}_equality_expression(){const e=this._relational_expression();return this._match([TokenTypes.tokens.equal_equal,TokenTypes.tokens.not_equal])?new BinaryOperator(this._previous().toString(),e,this._relational_expression()):e}_relational_expression(){let e=this._shift_expression();for(;this._match([TokenTypes.tokens.less_than,TokenTypes.tokens.greater_than,TokenTypes.tokens.less_than_equal,TokenTypes.tokens.greater_than_equal]);)e=new BinaryOperator(this._previous().toString(),e,this._shift_expression());return e}_shift_expression(){let e=this._additive_expression();for(;this._match([TokenTypes.tokens.shift_left,TokenTypes.tokens.shift_right]);)e=new BinaryOperator(this._previous().toString(),e,this._additive_expression());return e}_additive_expression(){let e=this._multiplicative_expression();for(;this._match([TokenTypes.tokens.plus,TokenTypes.tokens.minus]);)e=new BinaryOperator(this._previous().toString(),e,this._multiplicative_expression());return e}_multiplicative_expression(){let e=this._unary_expression();for(;this._match([TokenTypes.tokens.star,TokenTypes.tokens.forward_slash,TokenTypes.tokens.modulo]);)e=new BinaryOperator(this._previous().toString(),e,this._unary_expression());return e}_unary_expression(){return this._match([TokenTypes.tokens.minus,TokenTypes.tokens.bang,TokenTypes.tokens.tilde,TokenTypes.tokens.star,TokenTypes.tokens.and])?new UnaryOperator(this._previous().toString(),this._unary_expression()):this._singular_expression()}_singular_expression(){const e=this._primary_expression(),t=this._postfix_expression();return t&&(e.postfix=t),e}_postfix_expression(){if(this._match(TokenTypes.tokens.bracket_left)){const e=this._short_circuit_or_expression();this._consume(TokenTypes.tokens.bracket_right,"Expected ']'.");const t=new ArrayIndex(e),r=this._postfix_expression();return r&&(t.postfix=r),t}if(this._match(TokenTypes.tokens.period)){const e=this._consume(TokenTypes.tokens.ident,"Expected member name."),t=this._postfix_expression(),r=new StringExpr(e.lexeme);return t&&(r.postfix=t),r}return null}_getStruct(e){if(this._context.aliases.has(e)){return this._context.aliases.get(e).type}if(this._context.structs.has(e)){return this._context.structs.get(e)}return null}_primary_expression(){if(this._match(TokenTypes.tokens.ident)){const e=this._previous().toString();if(this._check(TokenTypes.tokens.paren_left)){const t=this._argument_expression_list(),r=this._getStruct(e);return null!=r?new CreateExpr(r,t):new CallExpr(e,t)}if(this._context.constants.has(e)){const t=this._context.constants.get(e);return new ConstExpr(e,t.value)}return new VariableExpr(e)}if(this._match(TokenTypes.const_literal))return new LiteralExpr(parseFloat(this._previous().toString()));if(this._check(TokenTypes.tokens.paren_left))return this._paren_expression();if(this._match(TokenTypes.keywords.bitcast)){this._consume(TokenTypes.tokens.less_than,"Expected '<'.");const e=this._type_decl();this._consume(TokenTypes.tokens.greater_than,"Expected '>'.");const t=this._paren_expression();return new BitcastExpr(e,t)}const e=this._type_decl(),t=this._argument_expression_list();return new CreateExpr(e,t)}_argument_expression_list(){if(!this._match(TokenTypes.tokens.paren_left))return null;const e=[];do{if(this._check(TokenTypes.tokens.paren_right))break;const t=this._short_circuit_or_expression();e.push(t)}while(this._match(TokenTypes.tokens.comma));return this._consume(TokenTypes.tokens.paren_right,"Expected ')' for agument list"),e}_optional_paren_expression(){this._match(TokenTypes.tokens.paren_left);const e=this._short_circuit_or_expression();return this._match(TokenTypes.tokens.paren_right),new GroupingExpr([e])}_paren_expression(){this._consume(TokenTypes.tokens.paren_left,"Expected '('.");const e=this._short_circuit_or_expression();return this._consume(TokenTypes.tokens.paren_right,"Expected ')'."),new GroupingExpr([e])}_struct_decl(){if(!this._match(TokenTypes.keywords.struct))return null;const e=this._currentLine,t=this._consume(TokenTypes.tokens.ident,"Expected name for struct.").toString();this._consume(TokenTypes.tokens.brace_left,"Expected '{' for struct body.");const r=[];for(;!this._check(TokenTypes.tokens.brace_right);){const e=this._attribute(),t=this._consume(TokenTypes.tokens.ident,"Expected variable name.").toString();this._consume(TokenTypes.tokens.colon,"Expected ':' for struct member type.");const n=this._attribute(),i=this._type_decl();null!=i&&(i.attributes=n),this._check(TokenTypes.tokens.brace_right)?this._match(TokenTypes.tokens.comma):this._consume(TokenTypes.tokens.comma,"Expected ',' for struct member."),r.push(new Member(t,i,e))}this._consume(TokenTypes.tokens.brace_right,"Expected '}' after struct body.");const n=this._currentLine,i=new Struct(t,r,e,n);return this._context.structs.set(t,i),i}_global_variable_decl(){const e=this._variable_decl();return e&&this._match(TokenTypes.tokens.equal)&&(e.value=this._const_expression()),e}_override_variable_decl(){const e=this._override_decl();return e&&this._match(TokenTypes.tokens.equal)&&(e.value=this._const_expression()),e}_global_const_decl(){if(!this._match(TokenTypes.keywords.const))return null;const e=this._consume(TokenTypes.tokens.ident,"Expected variable name");let t=null;if(this._match(TokenTypes.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}let r=null;if(this._match(TokenTypes.tokens.equal)){const e=this._short_circuit_or_expression();if(e instanceof CreateExpr)r=e;else if(e instanceof ConstExpr&&e.initializer instanceof CreateExpr)r=e.initializer;else try{const t=e.evaluate(this._context);r=new LiteralExpr(t)}catch(t){r=e}}const n=new Const(e.toString(),t,"","",r);return this._context.constants.set(n.name,n),n}_global_let_decl(){if(!this._match(TokenTypes.keywords.let))return null;const e=this._consume(TokenTypes.tokens.ident,"Expected variable name");let t=null;if(this._match(TokenTypes.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}let r=null;return this._match(TokenTypes.tokens.equal)&&(r=this._const_expression()),new Let(e.toString(),t,"","",r)}_const_expression(){return this._short_circuit_or_expression()}_variable_decl(){if(!this._match(TokenTypes.keywords.var))return null;let e="",t="";this._match(TokenTypes.tokens.less_than)&&(e=this._consume(TokenTypes.storage_class,"Expected storage_class.").toString(),this._match(TokenTypes.tokens.comma)&&(t=this._consume(TokenTypes.access_mode,"Expected access_mode.").toString()),this._consume(TokenTypes.tokens.greater_than,"Expected '>'."));const r=this._consume(TokenTypes.tokens.ident,"Expected variable name");let n=null;if(this._match(TokenTypes.tokens.colon)){const e=this._attribute();n=this._type_decl(),null!=n&&(n.attributes=e)}return new Var(r.toString(),n,e,t,null)}_override_decl(){if(!this._match(TokenTypes.keywords.override))return null;const e=this._consume(TokenTypes.tokens.ident,"Expected variable name");let t=null;if(this._match(TokenTypes.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}return new Override(e.toString(),t,null)}_diagnostic(){this._consume(TokenTypes.tokens.paren_left,"Expected '('");const e=this._consume(TokenTypes.tokens.ident,"Expected severity control name.");this._consume(TokenTypes.tokens.comma,"Expected ','");const t=this._consume(TokenTypes.tokens.ident,"Expected diagnostic rule name.");return this._consume(TokenTypes.tokens.paren_right,"Expected ')'"),new Diagnostic(e.toString(),t.toString())}_enable_directive(){const e=this._consume(TokenTypes.tokens.ident,"identity expected.");return new Enable(e.toString())}_requires_directive(){const e=[this._consume(TokenTypes.tokens.ident,"identity expected.").toString()];for(;this._match(TokenTypes.tokens.comma);){const t=this._consume(TokenTypes.tokens.ident,"identity expected.");e.push(t.toString())}return new Requires(e)}_type_alias(){const e=this._consume(TokenTypes.tokens.ident,"identity expected.");this._consume(TokenTypes.tokens.equal,"Expected '=' for type alias.");let t=this._type_decl();if(null===t)throw this._error(this._peek(),"Expected Type for Alias.");this._context.aliases.has(t.name)&&(t=this._context.aliases.get(t.name).type);const r=new Alias(e.toString(),t);return this._context.aliases.set(r.name,r),r}_type_decl(){if(this._check([TokenTypes.tokens.ident,...TokenTypes.texel_format,TokenTypes.keywords.bool,TokenTypes.keywords.f32,TokenTypes.keywords.i32,TokenTypes.keywords.u32])){const e=this._advance(),t=e.toString();return this._context.structs.has(t)?this._context.structs.get(t):this._context.aliases.has(t)?this._context.aliases.get(t).type:new Type(e.toString())}let e=this._texture_sampler_types();if(e)return e;if(this._check(TokenTypes.template_types)){let e=this._advance().toString(),t=null,r=null;return this._match(TokenTypes.tokens.less_than)&&(t=this._type_decl(),r=null,this._match(TokenTypes.tokens.comma)&&(r=this._consume(TokenTypes.access_mode,"Expected access_mode for pointer").toString()),this._consume(TokenTypes.tokens.greater_than,"Expected '>' for type.")),new TemplateType(e,t,r)}if(this._match(TokenTypes.keywords.ptr)){let e=this._previous().toString();this._consume(TokenTypes.tokens.less_than,"Expected '<' for pointer.");const t=this._consume(TokenTypes.storage_class,"Expected storage_class for pointer");this._consume(TokenTypes.tokens.comma,"Expected ',' for pointer.");const r=this._type_decl();let n=null;return this._match(TokenTypes.tokens.comma)&&(n=this._consume(TokenTypes.access_mode,"Expected access_mode for pointer").toString()),this._consume(TokenTypes.tokens.greater_than,"Expected '>' for pointer."),new PointerType(e,t.toString(),r,n)}const t=this._attribute();if(this._match(TokenTypes.keywords.array)){let e=null,r=-1;const n=this._previous();let i=null;if(this._match(TokenTypes.tokens.less_than)){e=this._type_decl(),this._context.aliases.has(e.name)&&(e=this._context.aliases.get(e.name).type);let t="";if(this._match(TokenTypes.tokens.comma)){i=this._shift_expression();try{t=i.evaluate(this._context).toString(),i=null}catch(e){t="1"}}this._consume(TokenTypes.tokens.greater_than,"Expected '>' for array."),r=t?parseInt(t):0}const s=new ArrayType(n.toString(),t,e,r);return i&&this._deferArrayCountEval.push({arrayType:s,countNode:i}),s}return null}_texture_sampler_types(){if(this._match(TokenTypes.sampler_type))return new SamplerType(this._previous().toString(),null,null);if(this._match(TokenTypes.depth_texture_type))return new SamplerType(this._previous().toString(),null,null);if(this._match(TokenTypes.sampled_texture_type)||this._match(TokenTypes.multisampled_texture_type)){const e=this._previous();this._consume(TokenTypes.tokens.less_than,"Expected '<' for sampler type.");const t=this._type_decl();return this._consume(TokenTypes.tokens.greater_than,"Expected '>' for sampler type."),new SamplerType(e.toString(),t,null)}if(this._match(TokenTypes.storage_texture_type)){const e=this._previous();this._consume(TokenTypes.tokens.less_than,"Expected '<' for sampler type.");const t=this._consume(TokenTypes.texel_format,"Invalid texel format.").toString();this._consume(TokenTypes.tokens.comma,"Expected ',' after texel format.");const r=this._consume(TokenTypes.access_mode,"Expected access mode for storage texture type.").toString();return this._consume(TokenTypes.tokens.greater_than,"Expected '>' for sampler type."),new SamplerType(e.toString(),t,r)}return null}_attribute(){let e=[];for(;this._match(TokenTypes.tokens.attr);){const t=this._consume(TokenTypes.attribute_name,"Expected attribute name"),r=new Attribute(t.toString(),null);if(this._match(TokenTypes.tokens.paren_left)){if(r.value=this._consume(TokenTypes.literal_or_ident,"Expected attribute value").toString(),this._check(TokenTypes.tokens.comma)){this._advance();do{const e=this._consume(TokenTypes.literal_or_ident,"Expected attribute value").toString();r.value instanceof Array||(r.value=[r.value]),r.value.push(e)}while(this._match(TokenTypes.tokens.comma))}this._consume(TokenTypes.tokens.paren_right,"Expected ')'")}e.push(r)}return 0==e.length?null:e}}class TypeInfo{constructor(e,t){this.name=e,this.attributes=t,this.size=0}get isArray(){return!1}get isStruct(){return!1}get isTemplate(){return!1}}class MemberInfo{constructor(e,t,r){this.name=e,this.type=t,this.attributes=r,this.offset=0,this.size=0}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class StructInfo extends TypeInfo{constructor(e,t){super(e,t),this.members=[],this.align=0,this.startLine=-1,this.endLine=-1,this.inUse=!1}get isStruct(){return!0}}class ArrayInfo extends TypeInfo{constructor(e,t){super(e,t),this.count=0,this.stride=0}get isArray(){return!0}}class TemplateInfo extends TypeInfo{constructor(e,t,r,n){super(e,r),this.format=t,this.access=n}get isTemplate(){return!0}}!function(e){e[e.Uniform=0]="Uniform",e[e.Storage=1]="Storage",e[e.Texture=2]="Texture",e[e.Sampler=3]="Sampler",e[e.StorageTexture=4]="StorageTexture"}(ut||(ut={}));class VariableInfo{constructor(e,t,r,n,i,s,a){this.name=e,this.type=t,this.group=r,this.binding=n,this.attributes=i,this.resourceType=s,this.access=a}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get size(){return this.type.size}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class AliasInfo{constructor(e,t){this.name=e,this.type=t}}class _TypeSize{constructor(e,t){this.align=e,this.size=t}}class InputInfo{constructor(e,t,r,n){this.name=e,this.type=t,this.locationType=r,this.location=n,this.interpolation=null}}class OutputInfo{constructor(e,t,r,n){this.name=e,this.type=t,this.locationType=r,this.location=n}}class OverrideInfo{constructor(e,t,r,n){this.name=e,this.type=t,this.attributes=r,this.id=n}}class ArgumentInfo{constructor(e,t){this.name=e,this.type=t}}class FunctionInfo{constructor(e,t=null){this.stage=null,this.inputs=[],this.outputs=[],this.arguments=[],this.returnType=null,this.resources=[],this.overrides=[],this.startLine=-1,this.endLine=-1,this.inUse=!1,this.calls=new Set,this.name=e,this.stage=t}}class EntryFunctions{constructor(){this.vertex=[],this.fragment=[],this.compute=[]}}class _FunctionResources{constructor(e){this.resources=null,this.inUse=!1,this.info=null,this.node=e}}class WgslReflect{constructor(e){this.uniforms=[],this.storage=[],this.textures=[],this.samplers=[],this.aliases=[],this.overrides=[],this.structs=[],this.entry=new EntryFunctions,this.functions=[],this._types=new Map,this._functions=new Map,e&&this.update(e)}_isStorageTexture(e){return"texture_storage_1d"==e.name||"texture_storage_2d"==e.name||"texture_storage_2d_array"==e.name||"texture_storage_3d"==e.name}update(e){const t=(new WgslParser).parse(e);for(const e of t)e instanceof nt&&this._functions.set(e.name,new _FunctionResources(e));for(const e of t)if(e instanceof Struct){const t=this._getTypeInfo(e,null);t instanceof StructInfo&&this.structs.push(t)}for(const e of t)if(e instanceof Alias)this.aliases.push(this._getAliasInfo(e));else if(e instanceof Override){const t=e,r=this._getAttributeNum(t.attributes,"id",0),n=null!=t.type?this._getTypeInfo(t.type,t.attributes):null;this.overrides.push(new OverrideInfo(t.name,n,t.attributes,r))}else if(this._isUniformVar(e)){const t=e,r=this._getAttributeNum(t.attributes,"group",0),n=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=new VariableInfo(t.name,i,r,n,t.attributes,ut.Uniform,t.access);this.uniforms.push(s)}else if(this._isStorageVar(e)){const t=e,r=this._getAttributeNum(t.attributes,"group",0),n=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=this._isStorageTexture(i),a=new VariableInfo(t.name,i,r,n,t.attributes,s?ut.StorageTexture:ut.Storage,t.access);this.storage.push(a)}else if(this._isTextureVar(e)){const t=e,r=this._getAttributeNum(t.attributes,"group",0),n=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=this._isStorageTexture(i),a=new VariableInfo(t.name,i,r,n,t.attributes,s?ut.StorageTexture:ut.Texture,t.access);s?this.storage.push(a):this.textures.push(a)}else if(this._isSamplerVar(e)){const t=e,r=this._getAttributeNum(t.attributes,"group",0),n=this._getAttributeNum(t.attributes,"binding",0),i=this._getTypeInfo(t.type,t.attributes),s=new VariableInfo(t.name,i,r,n,t.attributes,ut.Sampler,t.access);this.samplers.push(s)}else if(e instanceof nt){const t=this._getAttribute(e,"vertex"),r=this._getAttribute(e,"fragment"),n=this._getAttribute(e,"compute"),i=t||r||n,s=new FunctionInfo(e.name,null==i?void 0:i.name);s.startLine=e.startLine,s.endLine=e.endLine,this.functions.push(s),this._functions.get(e.name).info=s,i?(this._functions.get(e.name).inUse=!0,s.inUse=!0,s.resources=this._findResources(e,!!i),s.inputs=this._getInputs(e.args),s.outputs=this._getOutputs(e.returnType),this.entry[i.name].push(s)):(s.arguments=e.args.map((e=>new ArgumentInfo(e.name,this._getTypeInfo(e.type,e.attributes)))),s.returnType=e.returnType?this._getTypeInfo(e.returnType,e.attributes):null)}else;for(const e of this._functions.values())e.info&&(e.info.inUse=e.inUse,this._addCalls(e.node,e.info.calls));for(const e of this._functions.values())e.node.search((t=>{var r;if("varExpr"===t.astNodeType){const n=t;for(const t of this.overrides)n.name==t.name&&(null===(r=e.info)||void 0===r||r.overrides.push(t))}}));for(const e of this.uniforms)this._markStructsInUse(e.type);for(const e of this.storage)this._markStructsInUse(e.type)}_markStructsInUse(e){if(e)if(e.isStruct){if(e.inUse=!0,e.members)for(const t of e.members)this._markStructsInUse(t.type)}else if(e.isArray)this._markStructsInUse(e.format);else if(e.isTemplate)e.format&&this._markStructsInUse(e.format);else{const t=this._getAlias(e.name);t&&this._markStructsInUse(t)}}_addCalls(e,t){var r;for(const n of e.calls){const e=null===(r=this._functions.get(n.name))||void 0===r?void 0:r.info;e&&t.add(e)}}findResource(e,t){for(const r of this.uniforms)if(r.group==e&&r.binding==t)return r;for(const r of this.storage)if(r.group==e&&r.binding==t)return r;for(const r of this.textures)if(r.group==e&&r.binding==t)return r;for(const r of this.samplers)if(r.group==e&&r.binding==t)return r;return null}_findResource(e){for(const t of this.uniforms)if(t.name==e)return t;for(const t of this.storage)if(t.name==e)return t;for(const t of this.textures)if(t.name==e)return t;for(const t of this.samplers)if(t.name==e)return t;return null}_markStructsFromAST(e){const t=this._getTypeInfo(e,null);this._markStructsInUse(t)}_findResources(e,t){const r=[],n=this,i=[];return e.search((s=>{if(s instanceof _BlockStart)i.push({});else if(s instanceof _BlockEnd)i.pop();else if(s instanceof Var){const e=s;t&&null!==e.type&&this._markStructsFromAST(e.type),i.length>0&&(i[i.length-1][e.name]=e)}else if(s instanceof CreateExpr){const e=s;t&&null!==e.type&&this._markStructsFromAST(e.type)}else if(s instanceof Let){const e=s;t&&null!==e.type&&this._markStructsFromAST(e.type),i.length>0&&(i[i.length-1][e.name]=e)}else if(s instanceof VariableExpr){const e=s;if(i.length>0){if(i[i.length-1][e.name])return}const t=n._findResource(e.name);t&&r.push(t)}else if(s instanceof CallExpr){const i=s,a=n._functions.get(i.name);a&&(t&&(a.inUse=!0),e.calls.add(a.node),null===a.resources&&(a.resources=n._findResources(a.node,t)),r.push(...a.resources))}else if(s instanceof Call){const i=s,a=n._functions.get(i.name);a&&(t&&(a.inUse=!0),e.calls.add(a.node),null===a.resources&&(a.resources=n._findResources(a.node,t)),r.push(...a.resources))}})),[...new Map(r.map((e=>[e.name,e]))).values()]}getBindGroups(){const e=[];function _makeRoom(t,r){t>=e.length&&(e.length=t+1),void 0===e[t]&&(e[t]=[]),r>=e[t].length&&(e[t].length=r+1)}for(const t of this.uniforms){_makeRoom(t.group,t.binding);e[t.group][t.binding]=t}for(const t of this.storage){_makeRoom(t.group,t.binding);e[t.group][t.binding]=t}for(const t of this.textures){_makeRoom(t.group,t.binding);e[t.group][t.binding]=t}for(const t of this.samplers){_makeRoom(t.group,t.binding);e[t.group][t.binding]=t}return e}_getOutputs(e,t=void 0){if(void 0===t&&(t=[]),e instanceof Struct)this._getStructOutputs(e,t);else{const r=this._getOutputInfo(e);null!==r&&t.push(r)}return t}_getStructOutputs(e,t){for(const r of e.members)if(r.type instanceof Struct)this._getStructOutputs(r.type,t);else{const e=this._getAttribute(r,"location")||this._getAttribute(r,"builtin");if(null!==e){const n=this._getTypeInfo(r.type,r.type.attributes),i=this._parseInt(e.value),s=new OutputInfo(r.name,n,e.name,i);t.push(s)}}}_getOutputInfo(e){const t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(null!==t){const r=this._getTypeInfo(e,e.attributes),n=this._parseInt(t.value);return new OutputInfo("",r,t.name,n)}return null}_getInputs(e,t=void 0){void 0===t&&(t=[]);for(const r of e)if(r.type instanceof Struct)this._getStructInputs(r.type,t);else{const e=this._getInputInfo(r);null!==e&&t.push(e)}return t}_getStructInputs(e,t){for(const r of e.members)if(r.type instanceof Struct)this._getStructInputs(r.type,t);else{const e=this._getInputInfo(r);null!==e&&t.push(e)}}_getInputInfo(e){const t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(null!==t){const r=this._getAttribute(e,"interpolation"),n=this._getTypeInfo(e.type,e.attributes),i=this._parseInt(t.value),s=new InputInfo(e.name,n,t.name,i);return null!==r&&(s.interpolation=this._parseString(r.value)),s}return null}_parseString(e){return e instanceof Array&&(e=e[0]),e}_parseInt(e){e instanceof Array&&(e=e[0]);const t=parseInt(e);return isNaN(t)?e:t}_getAlias(e){for(const t of this.aliases)if(t.name==e)return t.type;return null}_getAliasInfo(e){return new AliasInfo(e.name,this._getTypeInfo(e.type,null))}_getTypeInfo(e,t){if(this._types.has(e))return this._types.get(e);if(e instanceof ArrayType){const r=e,n=r.format?this._getTypeInfo(r.format,r.attributes):null,i=new ArrayInfo(r.name,t);return i.format=n,i.count=r.count,this._types.set(e,i),this._updateTypeInfo(i),i}if(e instanceof Struct){const r=e,n=new StructInfo(r.name,t);n.startLine=r.startLine,n.endLine=r.endLine;for(const e of r.members){const t=this._getTypeInfo(e.type,e.attributes);n.members.push(new MemberInfo(e.name,t,e.attributes))}return this._types.set(e,n),this._updateTypeInfo(n),n}if(e instanceof SamplerType){const r=e,n=r.format instanceof Type,i=r.format?n?this._getTypeInfo(r.format,null):new TypeInfo(r.format,null):null,s=new TemplateInfo(r.name,i,t,r.access);return this._types.set(e,s),this._updateTypeInfo(s),s}if(e instanceof TemplateType){const r=e,n=r.format?this._getTypeInfo(r.format,null):null,i=new TemplateInfo(r.name,n,t,r.access);return this._types.set(e,i),this._updateTypeInfo(i),i}const r=new TypeInfo(e.name,t);return this._types.set(e,r),this._updateTypeInfo(r),r}_updateTypeInfo(e){var t,r;const n=this._getTypeSize(e);if(e.size=null!==(t=null==n?void 0:n.size)&&void 0!==t?t:0,e instanceof ArrayInfo&&e.format){const t=this._getTypeSize(e.format);e.stride=null!==(r=null==t?void 0:t.size)&&void 0!==r?r:0,this._updateTypeInfo(e.format)}e instanceof StructInfo&&this._updateStructInfo(e)}_updateStructInfo(e){var t;let r=0,n=0,i=0,s=0;for(let a=0,o=e.members.length;a<o;++a){const o=e.members[a],u=this._getTypeSize(o);if(!u)continue;null!==(t=this._getAlias(o.type.name))&&void 0!==t||o.type;const l=u.align,c=u.size;r=this._roundUp(l,r+n),n=c,i=r,s=Math.max(s,l),o.offset=r,o.size=c,this._updateTypeInfo(o.type)}e.size=this._roundUp(s,i+n),e.align=s}_getTypeSize(e){var t,r;if(null==e)return null;const n=this._getAttributeNum(e.attributes,"size",0),i=this._getAttributeNum(e.attributes,"align",0);if(e instanceof MemberInfo&&(e=e.type),e instanceof TypeInfo){const t=this._getAlias(e.name);null!==t&&(e=t)}{const r=WgslReflect._typeInfo[e.name];if(void 0!==r){const s="f16"===(null===(t=e.format)||void 0===t?void 0:t.name)?2:1;return new _TypeSize(Math.max(i,r.align/s),Math.max(n,r.size/s))}}{const t=WgslReflect._typeInfo[e.name.substring(0,e.name.length-1)];if(t){const r="h"===e.name[e.name.length-1]?2:1;return new _TypeSize(Math.max(i,t.align/r),Math.max(n,t.size/r))}}if(e instanceof ArrayInfo){let t=e,s=8,a=8;const o=this._getTypeSize(t.format);null!==o&&(a=o.size,s=o.align);return a=t.count*this._getAttributeNum(null!==(r=null==e?void 0:e.attributes)&&void 0!==r?r:null,"stride",this._roundUp(s,a)),n&&(a=n),new _TypeSize(Math.max(i,s),Math.max(n,a))}if(e instanceof StructInfo){let t=0,r=0,s=0,a=0,o=0;for(const r of e.members){const e=this._getTypeSize(r.type);null!==e&&(t=Math.max(e.align,t),s=this._roundUp(e.align,s+a),a=e.size,o=s)}return r=this._roundUp(t,o+a),new _TypeSize(Math.max(i,t),Math.max(n,r))}return null}_isUniformVar(e){return e instanceof Var&&"uniform"==e.storage}_isStorageVar(e){return e instanceof Var&&"storage"==e.storage}_isTextureVar(e){return e instanceof Var&&null!==e.type&&-1!=WgslReflect._textureTypes.indexOf(e.type.name)}_isSamplerVar(e){return e instanceof Var&&null!==e.type&&-1!=WgslReflect._samplerTypes.indexOf(e.type.name)}_getAttribute(e,t){const r=e;if(!r||!r.attributes)return null;const n=r.attributes;for(let e of n)if(e.name==t)return e;return null}_getAttributeNum(e,t,r){if(null===e)return r;for(let n of e)if(n.name==t){let e=null!==n&&null!==n.value?n.value:r;return e instanceof Array&&(e=e[0]),"number"==typeof e?e:"string"==typeof e?parseInt(e):r}return r}_roundUp(e,t){return Math.ceil(t/e)*e}}WgslReflect._typeInfo={f16:{align:2,size:2},i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},atomic:{align:4,size:4},vec2:{align:8,size:8},vec3:{align:16,size:12},vec4:{align:16,size:16},mat2x2:{align:8,size:16},mat3x2:{align:8,size:24},mat4x2:{align:8,size:32},mat2x3:{align:16,size:32},mat3x3:{align:16,size:48},mat4x3:{align:16,size:64},mat2x4:{align:16,size:32},mat3x4:{align:16,size:48},mat4x4:{align:16,size:64}},WgslReflect._textureTypes=TokenTypes.any_texture_type.map((e=>e.name)),WgslReflect._samplerTypes=TokenTypes.sampler_type.map((e=>e.name));class UniformType{static get i32(){return{numElements:1,align:4,size:4,type:"i32",wgslType:"i32",View:Int32Array}}static get u32(){return{numElements:1,align:4,size:4,type:"u32",wgslType:"u32",View:Uint32Array}}static get f32(){return{numElements:1,align:4,size:4,type:"f32",wgslType:"f32",View:Float32Array}}static get f16(){return{numElements:1,align:2,size:2,type:"f16",wgslType:"f16",View:Uint16Array}}static get vec2f32(){return{numElements:2,align:8,size:8,type:"f32",wgslType:"vec2<f32>",View:Float32Array}}static get vec2i32(){return{numElements:2,align:8,size:8,type:"i32",wgslType:"vec2<i32>",View:Int32Array}}static get vec2u32(){return{numElements:2,align:8,size:8,type:"u32",wgslType:"vec2<u32>",View:Uint32Array}}static get vec2u16(){return{numElements:2,align:4,size:4,type:"u16",wgslType:"vec2<u16>",View:Uint16Array}}static get vec3i32(){return{numElements:3,align:16,size:12,type:"i32",wgslType:"vec3<i32>",View:Int32Array}}static get vec3u32(){return{numElements:3,align:16,size:12,type:"u32",wgslType:"vec3<u32>",View:Uint32Array}}static get vec3f32(){return{numElements:3,align:16,size:12,type:"f32",wgslType:"vec3<f32>",View:Float32Array}}static get vec3u16(){return{numElements:3,align:8,size:6,type:"u16",wgslType:"vec3<u16>",View:Uint16Array}}static get vec4i32(){return{numElements:4,align:16,size:16,type:"i32",wgslType:"vec4<i32>",View:Int32Array}}static get vec4u32(){return{numElements:4,align:16,size:16,type:"u32",wgslType:"vec4<u32>",View:Uint32Array}}static get vec4f32(){return{numElements:4,align:16,size:16,type:"f32",wgslType:"vec4<f32>",View:Float32Array}}static get vec4u16(){return{numElements:4,align:8,size:8,type:"u16",wgslType:"vec4<u16>",View:Uint16Array}}static get mat2x2f32(){return{numElements:4,align:8,size:16,type:"f32",wgslType:"mat2x2<f32>",View:Float32Array}}static get mat2x2u16(){return{numElements:4,align:4,size:8,type:"u16",wgslType:"mat2x2<u16>",View:Uint16Array}}static get mat3x2f32(){return{numElements:6,align:8,size:24,type:"f32",wgslType:"mat3x2<f32>",View:Float32Array}}static get mat3x2u16(){return{numElements:6,align:4,size:12,type:"u16",wgslType:"mat3x2<u16>",View:Uint16Array}}static get mat3x3f32(){return{numElements:16,align:16,size:64,type:"f32",wgslType:"mat3x3<f32>",View:Float32Array}}static get mat4x2f32(){return{numElements:8,align:8,size:32,type:"f32",wgslType:"mat4x2<f32>",View:Float32Array}}static get mat4x2u16(){return{numElements:8,align:4,size:16,type:"u16",wgslType:"mat4x2<u16>",View:Uint16Array}}static get mat2x3f32(){return{numElements:8,align:16,size:32,type:"f32",wgslType:"mat2x3<f32>",View:Float32Array}}static get mat2x3u16(){return{numElements:8,align:8,size:16,type:"u16",wgslType:"mat2x3<u16>",View:Uint16Array}}static get mat4x4f32(){return{numElements:16,align:16,size:64,type:"f32",wgslType:"mat4x4<f32>",View:Float32Array}}static get mat4x4u16(){return{numElements:16,align:8,size:32,type:"u16",wgslType:"mat4x4<u16>",View:Uint16Array}}}Object.freeze(UniformType);const processMembers=(e,t=0,r=0)=>{let n=0,i=r;const s=e?.reduce(((e,r,s)=>{const{type:a,offset:o,size:u,stride:l,count:c,isArray:h}=r,{format:d}=a,m="array"===a.name?`${d.name}${d.format?`${d.format.name}`:""}`:`${a.name}${d?`${d.name}`:""}`;if(0===s&&(n=o),i=o+u,e[r.name]=((e,t,r)=>{const n=UniformType[r];return{uniformOffset:e.offset+t,stride:e.stride,isArray:e.isArray,typeInfo:n,View:n?.View}})(r,t,m),h&&d.members){const t=processMembers(d.members).members;e[r.name].memberList=Array.from({length:c},((e,r)=>{const n={};for(const e in t){const i=n[e]={...t[e]};i.uniformOffset=i.uniformOffset+o+l*r}return n}))}else a.members&&(e[r.name]=processMembers(a.members,o+t,i));return e}),{});return{members:s,startOffset:n,endOffset:i}},parseWGSL=e=>{const t=parseIncludeWGSL(e),r=new WgslReflect(t);return{uniforms:{...(i=r.uniforms,i.reduce(((e,t)=>(e[t.name]={name:t.name,...processMembers(t.members),arrayBufferByteLength:t.size,stride:t.stride},t.attributes?.forEach((r=>e[t.name][r.name]=+r.value)),e)),{}))},storage:{...(n=r.storage,n.reduce(((e,t)=>(e[t.name]={name:t.name,...processMembers(t.members),arrayBufferByteLength:t.size,stride:t.stride,acccess:t.access,type:t.type},t.attributes?.forEach((r=>e[t.name][r.name]=+r.value)),e)),{}))},samplers:r.samplers,textures:r.textures,vertexEntries:r.entry.vertex.map((e=>e.name)),fragmentEntries:r.entry.fragment.map((e=>e.name)),computeEntries:r.entry.compute.map((e=>e.name)),shaderSource:t};var n,i},lt={ZERO:"zero",ONE:"one",SRC:"src",ONE_MINUS_SRC:"one-minus-src",SRC_ALPHA:"src-alpha",ONE_MINUS_SRC_ALPHA:"one-minus-src-alpha",DST:"dst",ONE_MINUS_DST:"one-minus-dst",DST_ALPHA:"dst-alpha",ONE_MINUS_DST_ALPHA:"one-minus-dst-alpha",SRC_ALPHA_SATURATED:"src-alpha-saturated",CONSTANT:"constant",ONE_MINUS_CONSTANT:"one-minus-constant",SRC1:"src1",ONE_MINUS_SRC1:"one-minus-src1",SRC1_ALPHA:"src1-alpha",ONE_MINUS_SRC1_ALPHA:"one-minus-src1-alpha"};Object.freeze(lt);const ct={ADD:"add",SUBTRACT:"subtract",REVERSE_SUBTRACT:"reverse-subtract",MIN:"min",MAX:"max"};Object.freeze(ct);class FragmentGPURenderInfo{fragmentShaderModule;fragmentUniformInfo;fragmentBindGroupLayout;fragmentUniformBuffer;fragmentUniformBindGroup;fragmentState;constructor(e,t,r,n,i,s){this.fragmentShaderModule=e,this.fragmentUniformInfo=t,this.fragmentBindGroupLayout=r,this.fragmentUniformBuffer=n,this.fragmentUniformBindGroup=i,this.fragmentState=s}}Object.freeze(FragmentGPURenderInfo);const ht=Object.values(lt),dt=Object.values(ct);class BlendState{state;#Xe;#je;#Ye;#Ze;constructor(e,t,r,n){this.#Ze=e,this.srcFactor=t,this.dstFactor=r,this.operation=n}get operation(){return this.#Ye}set operation(e){dt.includes(e)||consoleAndThrowError(`Invalid GPUBlendOperation:${e}. Valid operations are ${dt.join(",")}`),this.#Ye=e,this.#qe()}get srcFactor(){return this.#Xe}set srcFactor(e){ht.includes(e)||consoleAndThrowError(`Invalid GPUBlendFactor:${e}. Valid srcFactor factors are ${ht.join(",")}`),this.#Xe=e,this.#qe()}get dstFactor(){return this.#je}set dstFactor(e){ht.includes(e)||consoleAndThrowError(`Invalid GPUBlendFactor:${e}. Valid dstFactor factors are ${ht.join(",")}`),this.#je=e,this.#qe()}#qe(){const e=this.#Ye?{operation:this.#Ye}:{},t=this.#Xe?{srcFactor:this.#Xe}:{},r=this.#je?{dstFactor:this.#je}:{};this.state={...e,...t,...r},this.#Ze.dirtyPipeline=!0}}const mt={NORMAL:0,MULTIPLY:1,LIGHTEN:2,SCREEN:3,LINEAR_DODGE:4,SUBTRACT:5,DARKEN:6,OVERLAY:7,COLOR_DODGE:8,COLOR_BURN:9,HARD_LIGHT:10,SOFT_LIGHT:11,DIFFERENCE:12,EXCLUSION:13,DIVIDE:14,VIVID_LIGHT:15,LINEAR_BURN:16,PIN_LIGHT:17,SATURATION:18,HUE:19,LUMINOSITY:20,COLOR:21,NEGATION:22},getBindGroupLayoutDescriptorFromShaderInfo=(e,t,r)=>{const{textures:n,samplers:i,uniforms:s,storage:a}=e,o=[];for(const e in a){const n=a[e],{binding:i,name:s,group:u,type:l}=n;if(n.access){const e={write:"write-only-storage",read:"read-only-storage",read_write:"read-write-storage"}[n.access];t===u&&o.push({binding:i,visibility:r,buffer:{type:e}})}else if(t===u){const{access:e,format:t}=l,n={write:"write-only",read:"read-only",read_write:"read-write"}[e],s=t.name;o.push({binding:i,visibility:r,storageTexture:{access:n,format:s}})}}for(const e in n){const i=n[e],{binding:s,name:a,group:u,type:l}=i,{name:c}=l;t===u&&o.push({binding:s,visibility:r,texture:"texture_cube"===c?{viewDimension:"cube"}:{}})}for(const e in i){const n=i[e],{binding:s,name:a,group:u}=n;t===u&&o.push({binding:s,visibility:r,sampler:{type:"filtering"}})}for(const e in s){const n=s[e],{binding:i,name:a,group:u}=n;t===u&&o.push({binding:i,visibility:r,buffer:{type:"uniform"}})}return{entries:o}},getFragmentBindGroupLayoutDescriptorFromShaderInfo=(e,t)=>getBindGroupLayoutDescriptorFromShaderInfo(e,t,GPUShaderStage.FRAGMENT),getVertexBindGroupLayoutDescriptorFromShaderInfo=(e,t)=>getBindGroupLayoutDescriptorFromShaderInfo(e,t,GPUShaderStage.VERTEX),getComputeBindGroupLayoutDescriptorFromShaderInfo=(e,t)=>getBindGroupLayoutDescriptorFromShaderInfo(e,t,GPUShaderStage.COMPUTE);class ABaseMaterial extends ResourceBase{gpuRenderInfo;dirtyPipeline=!1;transparent=!1;#We=GPUColorWrite.ALL;#Je;#Qe;#et;#tt;#rt;#Re;#nt;#it;#st;#at;#ot;#ut;#lt;#ct;#ht;#he;#dt=mt.MULTIPLY;constructor(e,t,r,n){super(e),this.#ht=t,this.#nt=`FRAGMENT_MODULE_${this.#ht}`,this.#it=`FRAGMENT_BIND_GROUP_DESCRIPTOR_${t}`,this.#st=`FRAGMENT_BIND_GROUP_LAYOUT_${t}`,this.#at=r,this.#ot=r?.storage,this.#ut=r?.uniforms.uniforms,this.#lt=r?.textures,this.#ct=r?.samplers,this.#he=e.resourceManager.getGPUBindGroupLayout(this.#st)||e.resourceManager.createBindGroupLayout(this.#st,getFragmentBindGroupLayoutDescriptorFromShaderInfo(r,n)),this.#Je=new BlendState(this,lt.ONE,lt.ONE_MINUS_SRC_ALPHA,ct.ADD),this.#Qe=new BlendState(this,lt.ONE,lt.ONE_MINUS_SRC_ALPHA,ct.ADD),this.#et=e.resourceManager,this.#tt=this.#et.basicSampler.gpuSampler,this.#rt=this.#et.emptyBitmapTextureView,this.#Re=this.#et.emptyCubeTextureView}get tintBlendMode(){const e=Object.entries(mt).find((([,e])=>e===this.#dt));if(!e)throw new Error(`Invalid tint mode value:${this.#dt}`);return e[0]}set tintBlendMode(e){const{fragmentUniformInfo:t,fragmentUniformBuffer:r}=this.gpuRenderInfo;let n;if("string"==typeof e){if(!(e in mt))throw new Error(`Invalid tint mode key:${e}`);n=mt[e]}else{if("number"!=typeof e||!Object.values(mt).includes(e))throw new Error(`Invalid tint mode:${e}`);n=e}r.writeBuffer(t.members.tintBlendMode,n),this.#dt=n}get MODULE_NAME(){return this.#ht}get FRAGMENT_SHADER_MODULE_NAME(){return this.#nt}get FRAGMENT_BIND_GROUP_DESCRIPTOR_NAME(){return this.#it}get STORAGE_STRUCT(){return this.#ot}get UNIFORM_STRUCT(){return this.#ut}get blendColorState(){return this.#Je}get blendAlphaState(){return this.#Qe}get writeMaskState(){return this.#We}set writeMaskState(e){this.#We=e}initGPURenderInfos(){const{redGPUContext:e}=this,{resourceManager:t}=e,r=t.createGPUShaderModule(this.#nt,{code:this.#at.shaderSource}),n=new ArrayBuffer(Math.max(this.#ut.arrayBufferByteLength,16)),i=new UniformBuffer(e,n,`UniformBuffer_${this.#ht}_${this.uuid}`);this.gpuRenderInfo=new FragmentGPURenderInfo(r,this.#ut,this.#he,i,null,null),this._updateBaseProperty(),this._updateFragmentState()}_updateFragmentState(){const{gpuDevice:e}=this.redGPUContext,t=[];for(const e in this.#lt){const r=this.#lt[e],{binding:n,name:i,group:s,type:a}=r,{name:o}=a;let u;u="texture_cube"===o?this.getGPUResourceCubeTextureView(this[i]):this[i]instanceof PackedTexture?this[i].gpuTexture?this[i].gpuTexture.createView({}):this.#rt:this.getGPUResourceBitmapTextureView(this[i])||this.#rt,2===s&&t.push({binding:n,resource:u})}for(const e in this.#ct){const r=this.#ct[e],{binding:n,name:i,group:s}=r;2===s&&t.push({binding:n,resource:this.getGPUResourceSampler(this[i])})}this.#ut&&t.push({binding:this.#ut.binding,resource:{buffer:this.gpuRenderInfo.fragmentUniformBuffer.gpuBuffer,offset:0,size:this.gpuRenderInfo.fragmentUniformBuffer.size}});const r={layout:this.gpuRenderInfo.fragmentBindGroupLayout,label:this.#it,entries:t},n=e.createBindGroup(r);this.gpuRenderInfo.fragmentState=this.getFragmentRenderState(),this.gpuRenderInfo.fragmentUniformBindGroup=n}getFragmentRenderState(e="main"){return{module:this.gpuRenderInfo.fragmentShaderModule,entryPoint:e,targets:[{format:navigator.gpu.getPreferredCanvasFormat(),blend:{color:this.blendColorState.state,alpha:this.blendAlphaState.state},writeMask:this.writeMaskState}]}}_updateBaseProperty(){const{fragmentUniformInfo:e,fragmentUniformBuffer:t}=this.gpuRenderInfo,{members:r}=e;for(const n in r){const r=this[n];r instanceof ColorRGBA?t.writeBuffer(e.members[n],r.rgbaNormal):r instanceof ColorRGB?t.writeBuffer(e.members[n],r.rgbNormal):pt.test(n)||(this[n]=r)}}getGPUResourceBitmapTextureView(e){return e?.gpuTexture?.createView({label:e.src})||this.#rt}getGPUResourceCubeTextureView(e,t){return e?.gpuTexture?.createView(t||e.viewDescriptor||CubeTexture.defaultViewDescriptor)||this.#Re}getGPUResourceSampler(e){return e?.gpuSampler||this.#tt}}const pt=/^use\w+Texture$/;rt.defineByPreset(ABaseMaterial,[rt.PRESET_POSITIVE_NUMBER.OPACITY]),rt.defineBoolean(ABaseMaterial,[["useTint",!1]]),rt.defineColorRGBA(ABaseMaterial,["tint","#ff0000"]),Object.freeze(ABaseMaterial);class ABitmapBaseMaterial extends ABaseMaterial{__packingList;constructor(e,t,r,n){super(e,t,r,n)}updateTexture(e,t){e&&e.__removeDirtyPipelineListener(this.#mt),t&&t.__addDirtyPipelineListener(this.#mt),this.#mt()}updateSampler(e,t){e&&e.__removeDirtyPipelineListener(this.#mt),t&&t.__addDirtyPipelineListener(this.#mt),this.#mt()}#mt=()=>{this.dirtyPipeline=!0;{let e=(this.__packingList||[]).length;for(;e--;)this.__packingList[e]()}this.gpuRenderInfo?.fragmentShaderModule?this._updateFragmentState():this.initGPURenderInfos()}}Object.freeze(ABitmapBaseMaterial);const ft=[{textureList:["baseColorTexture"],vec4List:[["baseColorFactor",[1,1,1,1]]]},{textureList:["normalTexture"]},{textureList:["metallicRoughnessTexture"],positiveNumberList:["metallicFactor","roughnessFactor"]},{textureList:["emissiveTexture"],vec3List:["emissiveFactor"]},{textureList:["occlusionTexture"],positiveNumberList:["occlusionStrength"]},{extensionName:"KHR_materials_clearcoat",textureList:["KHR_clearcoatTexture","KHR_clearcoatNormalTexture","KHR_clearcoatRoughnessTexture"],positiveNumberList:[["KHR_clearcoatFactor",0],["KHR_clearcoatRoughnessFactor",0],"KHR_clearcoatNormalScale"]},{extensionName:"KHR_materials_sheen",textureList:["KHR_sheenColorTexture","KHR_sheenRoughnessTexture"],positiveNumberList:[["KHR_sheenRoughnessFactor",0]],vec3List:[["KHR_sheenColorFactor",[0,0,0]]]},{extensionName:"KHR_materials_specular",textureList:["KHR_specularTexture","KHR_specularColorTexture"],positiveNumberList:["KHR_specularFactor"],vec3List:[["KHR_specularColorFactor",[1,1,1]]]},{extensionName:"KHR_materials_transmission",textureList:["KHR_transmissionTexture"],positiveNumberList:[["KHR_transmissionFactor",0]]},{extensionName:"KHR_materials_volume",textureList:["KHR_thicknessTexture"],positiveNumberList:[["KHR_thicknessFactor",0],["KHR_attenuationDistance",1]],vec3List:[["KHR_attenuationColor",[1,1,1]]]},{extensionName:"KHR_materials_diffuse_transmission",textureList:["KHR_diffuseTransmissionTexture","KHR_diffuseTransmissionColorTexture"],positiveNumberList:[["KHR_diffuseTransmissionFactor",0]],vec3List:[["KHR_diffuseTransmissionColorFactor",[1,1,1]]]},{extensionName:"KHR_materials_anisotropy",textureList:["KHR_anisotropyTexture"],positiveNumberList:[["KHR_anisotropyStrength",0],["KHR_anisotropyRotation",0]]},{extensionName:"KHR_materials_iridescence",textureList:["KHR_iridescenceTexture","KHR_iridescenceThicknessTexture"],positiveNumberList:[["KHR_iridescenceFactor",0],["KHR_iridescenceIor",1.3],["KHR_iridescenceThicknessMinimum",100],["KHR_iridescenceThicknessMaximum",400]]}],gt=parseWGSL((e=>{const t=ft.map((e=>{const{textureList:t,positiveNumberList:r}=e,n=t?.map((e=>`use${e.charAt(0).toUpperCase()+e.slice(1)}:u32,${e}_texCoord_index:u32,use_${e}_KHR_texture_transform:u32,${e}_KHR_texture_transform_offset:vec2<f32>,${e}_KHR_texture_transform_scale:vec2<f32>,${e}_KHR_texture_transform_rotation:f32,`)).join("");return[n].join("\n")})).join("");return e.replace(/#redgpu_include KHR_texture_transform/g,t)})("#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include calcDirectionalShadowVisibility;\r\n#redgpu_include calcTintBlendMode;\r\n#redgpu_include normalFunctions;\r\n#redgpu_include drawPicking;\r\nstruct Uniforms {\ruseVertexColor:u32,\ruseCutOff:u32,\rcutOff:f32,\ralphaBlend:u32,\r\n\r\rdoubleSided:u32,\ruseVertexTangent:u32,\r\n\r\ropacity:f32,\ruseTint:u32,\rtint:vec4<f32>,\rtintBlendMode:u32,\r\n\r\rbaseColorFactor:vec4<f32>,\r\remissiveFactor:vec3<f32>,\remissiveStrength:f32,\r\rocclusionStrength:f32,\r\rmetallicFactor:f32,\rroughnessFactor:f32,\r\rnormalScale:f32,\r\n\r\r\ruseKHR_materials_unlit:u32,\r\rKHR_materials_ior:f32,\r\r\ruseKHR_materials_transmission:u32,\rKHR_transmissionFactor:f32,\r\n\r\ruseKHR_materials_diffuse_transmission:u32,\rKHR_diffuseTransmissionFactor:f32,\rKHR_diffuseTransmissionColorFactor:vec3<f32>,\r\n\r\rKHR_dispersion:f32,\r\ruseKHR_materials_volume:u32,\rKHR_thicknessFactor:f32,\rKHR_attenuationDistance:f32,\rKHR_attenuationColor:vec3<f32>,\r\n\r\ruseKHR_materials_specular:u32,\rKHR_specularFactor:f32,\rKHR_specularColorFactor:vec3<f32>,\r\n\r\ruseKHR_materials_anisotropy:u32,\rKHR_anisotropyStrength:f32,\rKHR_anisotropyRotation:f32,\r\n\r\ruseKHR_materials_iridescence:u32,\rKHR_iridescenceFactor:f32,\rKHR_iridescenceIor:f32,\rKHR_iridescenceThicknessMinimum:f32,\rKHR_iridescenceThicknessMaximum:f32,\r\n\r\ruseKHR_materials_sheen:u32,\rKHR_sheenColorFactor:vec3<f32>,\rKHR_sheenRoughnessFactor:f32,\r\n\r\ruseKHR_materials_clearcoat:u32,\rKHR_clearcoatFactor:f32,\rKHR_clearcoatRoughnessFactor:f32,\rKHR_clearcoatNormalScale:f32,\r\r#redgpu_include KHR_texture_transform\r\n\r\n};\r\n\r\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\r\n\r\n\r\n@group(2) @binding(1) var baseColorTextureSampler:sampler;\r\n@group(2) @binding(2) var baseColorTexture:texture_2d<f32>;\r\n\r\n\r\n@group(2) @binding(3) var emissiveTextureSampler:sampler;\r\n@group(2) @binding(4) var emissiveTexture:texture_2d<f32>;\r\n\r\n\r\n@group(2) @binding(5) var normalTextureSampler:sampler;\r\n@group(2) @binding(6) var normalTexture:texture_2d<f32>;\r\n\r\n\r\n\r\n@group(2) @binding(7) var packedORMTexture:texture_2d<f32>;\r\n\r\n\r\n@group(2) @binding(8) var KHR_specularTextureSampler:sampler;\r\n@group(2) @binding(9) var KHR_specularTexture:texture_2d<f32>;\r\n@group(2) @binding(10) var KHR_specularColorTextureSampler:sampler;\r\n@group(2) @binding(11) var KHR_specularColorTexture:texture_2d<f32>;\r\n\r\n\r\n@group(2) @binding(12) var packedKHR_clearcoatTexture:texture_2d<f32>;\r\n\r\n\r\n@group(2) @binding(13) var KHR_clearcoatNormalTexture:texture_2d<f32>;\r\n\r\n@group(2) @binding(14) var packedKHR_transmission:texture_2d<f32>;\r\n\r\n@group(2) @binding(15) var packedKHR_diffuse_transmission:texture_2d<f32>;\r\n\r\n@group(2) @binding(16) var packedKHR_sheen:texture_2d<f32>;\r\n\r\n@group(2) @binding(17) var KHR_anisotropyTexture:texture_2d<f32>;\r\n\r\n@group(2) @binding(18) var packedKHR_iridescence:texture_2d<f32>;\r\n\r\n\r\nstruct InputData {\r\r@builtin(position) position:vec4<f32>,\r\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r\r@location(2) uv:vec2<f32>,\r@location(3) uv1:vec2<f32>,\r\r@location(4) vertexColor_0:vec4<f32>,\r\r@location(5) vertexTangent:vec4<f32>,\r@location(6) shadowPos:vec3<f32>,\r@location(7) receiveShadow:f32,\r@location(8) pickingId:vec4<f32>,\r@location(9) ndcPosition:vec3<f32>,\r@location(10) localNodeScale:f32,\r@location(11) volumeScale:f32,\r\n}\r\n\r\n\r\n@fragment\r\nfn main(inputData:InputData) -> @location(0) vec4<f32> {\r\rlet input_vertexNormal=(inputData.vertexNormal.xyz);\rlet input_vertexPosition=inputData.vertexPosition.xyz;\rlet input_vertexColor_0=inputData.vertexColor_0;\rlet input_vertexTangent=inputData.vertexTangent;\rlet input_ndcPosition=inputData.ndcPosition;\rlet input_uv=inputData.uv;\rlet input_uv1=inputData.uv1;\r\r\rlet u_ambientLight=systemUniforms.ambientLight;\rlet u_ambientLightColor=u_ambientLight.color;\rlet u_ambientLightIntensity=u_ambientLight.intensity;\r\n\r\rlet u_directionalLightCount=systemUniforms.directionalLightCount;\rlet u_directionalLights=systemUniforms.directionalLights;\rlet u_directionalLightShadowDepthTextureSize=systemUniforms.directionalLightShadowDepthTextureSize;\rlet u_directionalLightShadowBias=systemUniforms.directionalLightShadowBias;\r\n\rlet u_useIblTexture=systemUniforms.useIblTexture==1u;\r\rlet receiveShadowYn=inputData.receiveShadow !=.0;\r\n\r\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\n\r\rlet u_opacity=uniforms.opacity;\rlet u_doubleSided=uniforms.doubleSided==1u;\rlet u_useCutOff=uniforms.useCutOff==1u;\rlet u_cutOff=uniforms.cutOff;\rlet u_useVertexColor=uniforms.useVertexColor==1u;\rlet u_useVertexTangent=uniforms.useVertexTangent==1u;\r\n\r\rlet u_baseColorFactor=uniforms.baseColorFactor;\rlet u_useBaseColorTexture=uniforms.useBaseColorTexture==1u;\r\n\r\rlet u_metallicFactor=uniforms.metallicFactor;\rlet u_roughnessFactor=uniforms.roughnessFactor;\rlet u_useMetallicRoughnessTexture=uniforms.useMetallicRoughnessTexture==1u;\r\n\r\rlet u_useNormalTexture=uniforms.useNormalTexture==1u;\rlet u_normalScale=uniforms.normalScale;\r\n\r\rlet u_useOcclusionTexture=uniforms.useOcclusionTexture==1u;\rlet u_occlusionStrength=uniforms.occlusionStrength;\r\n\r\rlet u_useEmissiveTexture=uniforms.useEmissiveTexture==1u;\rlet u_emissiveFactor=uniforms.emissiveFactor;\rlet u_emissiveStrength=uniforms.emissiveStrength;\r\n\r\rlet u_useKHR_materials_unlit=uniforms.useKHR_materials_unlit==1u;\rlet u_KHR_materials_ior=uniforms.KHR_materials_ior;\rlet u_KHR_dispersion=uniforms.KHR_dispersion;\r\n\r\r\rlet u_useKHR_materials_transmission=uniforms.useKHR_materials_transmission==1u;\rlet u_KHR_transmissionFactor=uniforms.KHR_transmissionFactor;\rlet u_useKHR_transmissionTexture=uniforms.useKHR_transmissionTexture==1u;\r\n\r\rvar u_useKHR_materials_volume=uniforms.useKHR_materials_volume==1u;\rvar u_KHR_thicknessFactor=uniforms.KHR_thicknessFactor;\rvar u_KHR_attenuationColor=uniforms.KHR_attenuationColor;\rvar u_KHR_attenuationDistance=uniforms.KHR_attenuationDistance;\rvar u_useKHR_thicknessTexture=uniforms.useKHR_thicknessTexture==1u;\r\n\r\rlet u_useKHR_materials_diffuse_transmission=uniforms.useKHR_materials_diffuse_transmission==1u;\rlet u_KHR_diffuseTransmissionFactor=uniforms.KHR_diffuseTransmissionFactor;\rlet u_KHR_diffuseTransmissionColorFactor=uniforms.KHR_diffuseTransmissionColorFactor;\rlet u_useKHR_diffuseTransmissionTexture=uniforms.useKHR_diffuseTransmissionTexture==1u;\rlet u_useKHR_diffuseTransmissionColorTexture=uniforms.useKHR_diffuseTransmissionColorTexture==1u;\r\n\r\rlet u_useKHR_materials_specular=uniforms.useKHR_materials_specular==1u;\rlet u_KHR_specularFactor=uniforms.KHR_specularFactor;\rlet u_KHR_specularColorFactor=uniforms.KHR_specularColorFactor;\rlet u_useKHR_specularTexture=uniforms.useKHR_specularTexture==1u;\rlet u_useKHR_specularColorTexture=uniforms.useKHR_specularColorTexture==1u;\r\n\r\rlet u_useKHR_materials_anisotropy=uniforms.useKHR_materials_anisotropy==1u;\rlet u_KHR_anisotropyStrength=uniforms.KHR_anisotropyStrength;\rlet u_KHR_anisotropyRotation=uniforms.KHR_anisotropyRotation;\rlet u_useKHR_anisotropyTexture=uniforms.useKHR_anisotropyTexture==1u;\r\n\r\rlet u_useKHR_materials_sheen=uniforms.useKHR_materials_sheen==1u;\rlet u_useKHR_sheenColorTexture=uniforms.useKHR_sheenColorTexture==1u;\rlet u_useKHR_sheenRoughnessTexture=uniforms.useKHR_sheenRoughnessTexture==1u;\rlet u_KHR_sheenColorFactor=uniforms.KHR_sheenColorFactor;\rlet u_KHR_sheenRoughnessFactor=uniforms.KHR_sheenRoughnessFactor;\r\n\r\rlet u_useKHR_materials_iridescence=uniforms.useKHR_materials_iridescence==1u;\rlet u_useKHR_iridescenceTexture=uniforms.useKHR_iridescenceTexture==1u;\rlet u_useKHR_iridescenceThicknessTexture=uniforms.useKHR_iridescenceThicknessTexture==1u;\rlet u_KHR_iridescenceFactor=uniforms.KHR_iridescenceFactor;\rlet u_KHR_iridescenceIor=uniforms.KHR_iridescenceIor;\rlet u_KHR_iridescenceThicknessMinimum=uniforms.KHR_iridescenceThicknessMinimum;\rlet u_KHR_iridescenceThicknessMaximum=uniforms.KHR_iridescenceThicknessMaximum;\r\n\r\rlet u_useKHR_materials_clearcoat=uniforms.useKHR_materials_clearcoat==1u;\rlet u_KHR_clearcoatFactor=uniforms.KHR_clearcoatFactor;\rlet u_useKHR_clearcoatTexture=uniforms.useKHR_clearcoatTexture==1u;\rlet u_KHR_clearcoatRoughnessFactor=uniforms.KHR_clearcoatRoughnessFactor;\rlet u_useKHR_clearcoatRoughnessTexture=uniforms.useKHR_clearcoatRoughnessTexture==1u;\rlet u_useKHR_clearcoatNormalTexture=uniforms.useKHR_clearcoatNormalTexture==1u;\rlet u_KHR_clearcoatNormalScale=uniforms.KHR_clearcoatNormalScale;\r\n\r\n\r\r\n\r\rlet diffuseUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.baseColorTexture_texCoord_index,\runiforms.use_baseColorTexture_KHR_texture_transform,\runiforms.baseColorTexture_KHR_texture_transform_offset,\runiforms.baseColorTexture_KHR_texture_transform_rotation,\runiforms.baseColorTexture_KHR_texture_transform_scale\r);\r\n\rlet emissiveUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.emissiveTexture_texCoord_index,\runiforms.use_emissiveTexture_KHR_texture_transform,\runiforms.emissiveTexture_KHR_texture_transform_offset,\runiforms.emissiveTexture_KHR_texture_transform_rotation,\runiforms.emissiveTexture_KHR_texture_transform_scale\r);\r\n\rlet occlusionUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.occlusionTexture_texCoord_index,\runiforms.use_occlusionTexture_KHR_texture_transform,\runiforms.occlusionTexture_KHR_texture_transform_offset,\runiforms.occlusionTexture_KHR_texture_transform_rotation,\runiforms.occlusionTexture_KHR_texture_transform_scale\r);\r\n\rlet metallicRoughnessUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.metallicRoughnessTexture_texCoord_index,\runiforms.use_metallicRoughnessTexture_KHR_texture_transform,\runiforms.metallicRoughnessTexture_KHR_texture_transform_offset,\runiforms.metallicRoughnessTexture_KHR_texture_transform_rotation,\runiforms.metallicRoughnessTexture_KHR_texture_transform_scale\r);\r\n\rlet normalUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.normalTexture_texCoord_index,\runiforms.use_normalTexture_KHR_texture_transform,\runiforms.normalTexture_KHR_texture_transform_offset,\runiforms.normalTexture_KHR_texture_transform_rotation,\runiforms.normalTexture_KHR_texture_transform_scale\r);\r\n\r\rlet KHR_clearcoatUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_clearcoatTexture_texCoord_index,\runiforms.use_KHR_clearcoatTexture_KHR_texture_transform,\runiforms.KHR_clearcoatTexture_KHR_texture_transform_offset,\runiforms.KHR_clearcoatTexture_KHR_texture_transform_rotation,\runiforms.KHR_clearcoatTexture_KHR_texture_transform_scale\r);\r\n\rlet KHR_clearcoatNormalUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_clearcoatNormalTexture_texCoord_index,\runiforms.use_KHR_clearcoatNormalTexture_KHR_texture_transform,\runiforms.KHR_clearcoatNormalTexture_KHR_texture_transform_offset,\runiforms.KHR_clearcoatNormalTexture_KHR_texture_transform_rotation,\runiforms.KHR_clearcoatNormalTexture_KHR_texture_transform_scale\r);\r\n\rlet KHR_clearcoatRoughnessUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_clearcoatRoughnessTexture_texCoord_index,\runiforms.use_KHR_clearcoatRoughnessTexture_KHR_texture_transform,\runiforms.KHR_clearcoatRoughnessTexture_KHR_texture_transform_offset,\runiforms.KHR_clearcoatRoughnessTexture_KHR_texture_transform_rotation,\runiforms.KHR_clearcoatRoughnessTexture_KHR_texture_transform_scale\r);\r\n\r\rlet KHR_sheenColorUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_sheenColorTexture_texCoord_index,\runiforms.use_KHR_sheenColorTexture_KHR_texture_transform,\runiforms.KHR_sheenColorTexture_KHR_texture_transform_offset,\runiforms.KHR_sheenColorTexture_KHR_texture_transform_rotation,\runiforms.KHR_sheenColorTexture_KHR_texture_transform_scale\r);\r\n\rlet KHR_sheenRoughnessUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_sheenRoughnessTexture_texCoord_index,\runiforms.use_KHR_sheenRoughnessTexture_KHR_texture_transform,\runiforms.KHR_sheenRoughnessTexture_KHR_texture_transform_offset,\runiforms.KHR_sheenRoughnessTexture_KHR_texture_transform_rotation,\runiforms.KHR_sheenRoughnessTexture_KHR_texture_transform_scale\r);\r\n\r\rlet KHR_specularTextureUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_specularTexture_texCoord_index,\runiforms.use_KHR_specularTexture_KHR_texture_transform,\runiforms.KHR_specularTexture_KHR_texture_transform_offset,\runiforms.KHR_specularTexture_KHR_texture_transform_rotation,\runiforms.KHR_specularTexture_KHR_texture_transform_scale\r);\r\n\rlet KHR_specularColorTextureUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_specularColorTexture_texCoord_index,\runiforms.use_KHR_specularColorTexture_KHR_texture_transform,\runiforms.KHR_specularColorTexture_KHR_texture_transform_offset,\runiforms.KHR_specularColorTexture_KHR_texture_transform_rotation,\runiforms.KHR_specularColorTexture_KHR_texture_transform_scale\r);\r\n\r\rlet KHR_iridescenceTextureUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_iridescenceTexture_texCoord_index,\runiforms.use_KHR_iridescenceTexture_KHR_texture_transform,\runiforms.KHR_iridescenceTexture_KHR_texture_transform_offset,\runiforms.KHR_iridescenceTexture_KHR_texture_transform_rotation,\runiforms.KHR_iridescenceTexture_KHR_texture_transform_scale\r);\r\n\rlet KHR_iridescenceThicknessTextureUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_iridescenceThicknessTexture_texCoord_index,\runiforms.use_KHR_iridescenceThicknessTexture_KHR_texture_transform,\runiforms.KHR_iridescenceThicknessTexture_KHR_texture_transform_offset,\runiforms.KHR_iridescenceThicknessTexture_KHR_texture_transform_rotation,\runiforms.KHR_iridescenceThicknessTexture_KHR_texture_transform_scale\r);\r\n\r\rlet KHR_transmissionUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_transmissionTexture_texCoord_index,\runiforms.use_KHR_transmissionTexture_KHR_texture_transform,\runiforms.KHR_transmissionTexture_KHR_texture_transform_offset,\runiforms.KHR_transmissionTexture_KHR_texture_transform_rotation,\runiforms.KHR_transmissionTexture_KHR_texture_transform_scale\r);\r\n\rlet KHR_diffuseTransmissionUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_diffuseTransmissionTexture_texCoord_index,\runiforms.use_KHR_diffuseTransmissionTexture_KHR_texture_transform,\runiforms.KHR_diffuseTransmissionTexture_KHR_texture_transform_offset,\runiforms.KHR_diffuseTransmissionTexture_KHR_texture_transform_rotation,\runiforms.KHR_diffuseTransmissionTexture_KHR_texture_transform_scale\r);\r\n\rlet KHR_diffuseTransmissionColorUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_diffuseTransmissionColorTexture_texCoord_index,\runiforms.use_KHR_diffuseTransmissionColorTexture_KHR_texture_transform,\runiforms.KHR_diffuseTransmissionColorTexture_KHR_texture_transform_offset,\runiforms.KHR_diffuseTransmissionColorTexture_KHR_texture_transform_rotation,\runiforms.KHR_diffuseTransmissionColorTexture_KHR_texture_transform_scale\r);\r\n\rlet KHR_anisotropyUV=get_transformed_uv(\rinput_uv,input_uv1,\runiforms.KHR_anisotropyTexture_texCoord_index,\runiforms.use_KHR_anisotropyTexture_KHR_texture_transform,\runiforms.KHR_anisotropyTexture_KHR_texture_transform_offset,\runiforms.KHR_anisotropyTexture_KHR_texture_transform_rotation,\runiforms.KHR_anisotropyTexture_KHR_texture_transform_scale\r);\r\n\r\n\r\r\rvar N:vec3<f32>=normalize(input_vertexNormal.xyz);\rvar backFaceYn:bool=false;\rif(u_doubleSided) {\rvar fdx:vec3<f32>=dpdx(input_vertexPosition);\rvar fdy:vec3<f32>=dpdy(input_vertexPosition);\rvar faceNormal:vec3<f32>=normalize(cross(fdy,fdx));\rif (dot(N,faceNormal) < 0.0) {\rN=-N;\rbackFaceYn=true;\r};\r}\rlet N2=N;\rif(u_useNormalTexture){\rvar targetUv=select(normalUV,1.0 - normalUV,backFaceYn);\rlet normalSamplerColor=textureSample(normalTexture,normalTextureSampler,normalUV).rgb;\rN=perturb_normal(\rN,\rinput_vertexPosition,\rtargetUv,\rvec3<f32>(normalSamplerColor.r,1.0 - normalSamplerColor.g,normalSamplerColor.b),\ru_normalScale\r);\rN=select(N,select(N,-N,backFaceYn),u_useVertexTangent);\r}else{\rN=N * u_normalScale;\r}\r\r\rlet V:vec3<f32>=normalize(u_cameraPosition - input_vertexPosition);\rlet NdotV=max(dot(N,V),0.04);\rlet VdotN=max(dot(V,N),0.0);\r\r\n\rvar visibility:f32=1.0;\rvisibility=calcDirectionalShadowVisibility(\rdirectionalShadowMap,\rdirectionalShadowMapSampler,\ru_directionalLightShadowDepthTextureSize,\ru_directionalLightShadowBias,\rinputData.shadowPos\r);\r\n\rif(!receiveShadowYn){\rvisibility=1.0;\r}\r\r\n\r\rvar finalColor:vec4<f32>;\rvar ior:f32=u_KHR_materials_ior;\rvar baseColor=u_baseColorFactor;\rvar resultAlpha:f32=u_opacity * baseColor.a;\r\rbaseColor *=select(vec4<f32>(1.0),input_vertexColor_0,u_useVertexColor);\r\rif(u_useBaseColorTexture){\rlet diffuseSampleColor= (textureSample(baseColorTexture,baseColorTextureSampler,diffuseUV));\rbaseColor *=diffuseSampleColor;\rresultAlpha *=diffuseSampleColor.a;\r}\rlet albedo:vec3<f32>=baseColor.rgb;\r\n\r\rif(u_useKHR_materials_unlit){\rreturn baseColor;\r}\r\n\r\rvar occlusionParameter:f32=1;\rif(u_useOcclusionTexture){\rocclusionParameter=textureSample(packedORMTexture,packedTextureSampler,occlusionUV).r * u_occlusionStrength;\r}\r\n\r\rvar metallicParameter:f32=u_metallicFactor;\rvar roughnessParameter:f32=u_roughnessFactor;\rif (u_useMetallicRoughnessTexture) {\rlet metallicRoughnessSample=(textureSample(packedORMTexture,packedTextureSampler,metallicRoughnessUV));\rmetallicParameter=metallicRoughnessSample.b * metallicParameter;\rroughnessParameter=metallicRoughnessSample.g * roughnessParameter;\r}\rroughnessParameter=max(roughnessParameter,0.045);\rif (abs(ior - 1.0) < 0.0001) {\rroughnessParameter=0;\r}\r\n\r\rvar clearcoatParameter=u_KHR_clearcoatFactor;\rvar clearcoatRoughnessParameter=u_KHR_clearcoatRoughnessFactor;\rvar clearcoatNormal:vec3<f32>=N;\rif(u_useKHR_materials_clearcoat){\rif(clearcoatParameter==0.0){\r}else{\rif(u_useKHR_clearcoatTexture){\rlet clearcoatSample= textureSample(packedKHR_clearcoatTexture,packedTextureSampler,KHR_clearcoatUV);\rclearcoatParameter *=clearcoatSample.r;\r}\r\n\rif(u_useKHR_clearcoatRoughnessTexture){\rlet clearcoatRoughnesstSample= textureSample(packedKHR_clearcoatTexture,packedTextureSampler,KHR_clearcoatRoughnessUV);\rclearcoatRoughnessParameter *=clearcoatRoughnesstSample.g;\r}\r\n\rvar clearcoatNormalSampler= textureSample(KHR_clearcoatNormalTexture,baseColorTextureSampler,KHR_clearcoatNormalUV);\rif(u_useKHR_clearcoatNormalTexture){\rvar targetUv=KHR_clearcoatNormalUV;\rif(backFaceYn){\rtargetUv=1.0 - targetUv;\r}\rclearcoatNormal=clearcoatNormalSampler.rgb;\rclearcoatNormal=perturb_normal(\rN,\rinput_vertexPosition,\rtargetUv,\rclearcoatNormal,\ru_normalScale\r);\rif(u_useVertexTangent){\rif(backFaceYn ){ clearcoatNormal=-clearcoatNormal;}\r}\rclearcoatNormal=normalize(clearcoatNormal);\r}\r}\r}\r\n\r\rvar specularParameter=u_KHR_specularFactor;\rvar specularColor=u_KHR_specularColorFactor;\r\n\rif(u_useKHR_materials_specular){\rif(u_useKHR_specularColorTexture){\rlet specularColorTextureSample=textureSample(\rKHR_specularColorTexture,\rKHR_specularColorTextureSampler,\rKHR_specularColorTextureUV\r);\rspecularColor *=specularColorTextureSample.rgb;\r};\r\n\rif(u_useKHR_specularTexture){\rlet specularTextureSample=textureSample(\rKHR_specularTexture,\rKHR_specularTextureSampler,\rKHR_specularTextureUV\r);\rspecularParameter *=specularTextureSample.a;\r};\r}\r\rvar transmissionParameter:f32=u_KHR_transmissionFactor;\rif (u_useKHR_transmissionTexture) {\r\rlet transmissionSample:vec4<f32>=textureSample(\rpackedKHR_transmission,\rpackedTextureSampler,\rKHR_transmissionUV\r);\rtransmissionParameter *=transmissionSample.r;\r}\r\rvar thicknessParameter:f32=u_KHR_thicknessFactor;\rif (u_useKHR_thicknessTexture) {\rlet thicknessSample:vec4<f32>=textureSample(\rpackedKHR_transmission,\rpackedTextureSampler,\rKHR_transmissionUV\r);\rthicknessParameter *=thicknessSample.g;\r}\r\rvar diffuseTransmissionColor:vec3<f32>=u_KHR_diffuseTransmissionColorFactor;\rvar diffuseTransmissionParameter:f32=u_KHR_diffuseTransmissionFactor;\rif(u_useKHR_materials_diffuse_transmission){\rif(u_useKHR_diffuseTransmissionTexture){\rlet transmissionSample= textureSample(\rpackedKHR_diffuse_transmission,\rpackedTextureSampler,\rKHR_diffuseTransmissionUV\r);\rdiffuseTransmissionParameter *=transmissionSample.a;\r}\rif(u_useKHR_diffuseTransmissionColorTexture){\rlet transmissionSample= textureSample(\rpackedKHR_diffuse_transmission,\rpackedTextureSampler,\rKHR_diffuseTransmissionColorUV\r);\rdiffuseTransmissionColor *=transmissionSample.rgb;\r}\r}\r\n\r\rvar sheenColor=u_KHR_sheenColorFactor;\rvar sheenRoughnessParameter=u_KHR_sheenRoughnessFactor;\rif(u_useKHR_materials_sheen){\rif(u_useKHR_sheenColorTexture){\rlet sheenColorSample=(textureSample(packedKHR_sheen,packedTextureSampler,KHR_sheenColorUV));\rsheenColor *=sheenColorSample.rgb;\r}\rif(u_useKHR_sheenRoughnessTexture){\rlet sheenRoughnessSample=(textureSample(packedKHR_sheen,packedTextureSampler,KHR_sheenRoughnessUV));\rsheenRoughnessParameter *=sheenRoughnessSample.a;\r}\r}\r\rvar iridescenceParameter=u_KHR_iridescenceFactor;\rvar iridescenceThickness=u_KHR_iridescenceThicknessMaximum;\rif(u_useKHR_materials_iridescence){\rif (u_useKHR_iridescenceTexture) {\rlet iridescenceTextureSample:vec4<f32>=textureSample(\rpackedKHR_iridescence,\rpackedTextureSampler,\rKHR_iridescenceTextureUV\r);\riridescenceParameter *=iridescenceTextureSample.r;\r}\rif(u_useKHR_iridescenceThicknessTexture){\rlet iridescenceTextureSample:vec4<f32>=textureSample(\rpackedKHR_iridescence,\rpackedTextureSampler,\rKHR_iridescenceThicknessTextureUV\r);\riridescenceThickness= mix(u_KHR_iridescenceThicknessMinimum,u_KHR_iridescenceThicknessMaximum,iridescenceTextureSample.g);\r}\r}\r\rvar anisotropy:f32=u_KHR_anisotropyStrength;\rvar anisotropicT:vec3<f32>;\rvar anisotropicB:vec3<f32>;\r\n\rif (u_useKHR_materials_anisotropy) {\rvar anisotropicDirection:vec2<f32>=vec2<f32>(1.0,0.0);\rif(u_useKHR_anisotropyTexture){\rlet anisotropyTex=textureSample(KHR_anisotropyTexture,baseColorTextureSampler,KHR_anisotropyUV).rgb;\ranisotropicDirection=anisotropyTex.rg * 2.0 - vec2<f32>(1.0,1.0);\rvar anisotropyRotation:vec2<f32>;\rif(u_KHR_anisotropyRotation < 0.0001){\ranisotropyRotation=vec2<f32>(1.0,0.0);\r}else{\ranisotropyRotation=vec2<f32>( cos(u_KHR_anisotropyRotation),sin(u_KHR_anisotropyRotation) );\r}\r\n\rlet rotationMtx:mat2x2<f32>=mat2x2<f32>(\ranisotropyRotation.x,anisotropyRotation.y,\r-anisotropyRotation.y,anisotropyRotation.x\r);\r\n\ranisotropicDirection=rotationMtx * normalize(anisotropicDirection);\ranisotropy *=anisotropyTex.b;\r}\rvar T:vec3<f32>;\rvar B:vec3<f32>;\rif (u_useVertexTangent) {\rif (length(input_vertexTangent.xyz) > 0.0) {\rT=normalize(input_vertexTangent.xyz);\rB=normalize(cross(T,N) * input_vertexTangent.w);\r} else {\rT=vec3<f32>(1.0,0.0,0.0);\rB=normalize(cross(T,N) * 1.0);\r}\r} else {\rT=vec3<f32>(1.0,0.0,0.0);\rB=normalize(cross(T,N) * 1.0);\r}\r\rlet TBN:mat3x3<f32>=mat3x3<f32>(T,B,N);\ranisotropicT=normalize(TBN * vec3<f32>(anisotropicDirection,0.0));\ranisotropicB=normalize(cross(N,anisotropicT));\r}\r\n\r\rvar prePathBackground=vec3<f32>(0.0);\rif(u_useKHR_materials_transmission) {\rprePathBackground=calcPrePathBackground(\ru_useKHR_materials_volume,thicknessParameter * inputData.volumeScale,u_KHR_dispersion,u_KHR_attenuationDistance,u_KHR_attenuationColor,\rior,roughnessParameter,albedo,\rsystemUniforms.projectionCameraMatrix,input_vertexPosition,input_ndcPosition,\rV,N,\rrenderPath1ResultTexture,renderPath1ResultTextureSampler\r);\r}\r\rlet F0_dielectric:vec3<f32>= vec3(pow((1.0 - ior)/(1.0 + ior),2.0));\rlet F0_metal=baseColor.rgb;\rvar F0=mix(F0_dielectric,F0_metal,metallicParameter);\rif(u_useKHR_materials_iridescence){\rF0=mix(\riridescent_fresnel( 1.0,u_KHR_iridescenceIor,F0_dielectric,iridescenceThickness,iridescenceParameter,NdotV),\riridescent_fresnel( 1.0,u_KHR_iridescenceIor,F0_metal,iridescenceThickness,iridescenceParameter,NdotV),\rmetallicParameter\r);\r}\r\n\r\rvar totalDirectLighting=vec3<f32>(0.0);\rfor (var i=0u;i < u_directionalLightCount;i++) {\rtotalDirectLighting +=calcLight(\ru_directionalLights[i].color,u_directionalLights[i].intensity,\rN,V,-normalize(u_directionalLights[i].direction),\rVdotN,\rroughnessParameter,metallicParameter,albedo,\rF0,ior,\rprePathBackground,\rspecularColor,specularParameter,\ru_useKHR_materials_diffuse_transmission,diffuseTransmissionParameter,diffuseTransmissionColor,\rtransmissionParameter,\rsheenColor,sheenRoughnessParameter,\ranisotropy,anisotropicT,anisotropicB,\rclearcoatParameter,clearcoatRoughnessParameter,clearcoatNormal\r);\r}\r\n\r\r{\rlet clusterIndex=getPointLightClusterIndex(inputData.position);\rlet lightOffset =pointLight_clusterLightGroup.lights[clusterIndex].offset;\rlet lightCount:u32 =pointLight_clusterLightGroup.lights[clusterIndex].count;\rfor (var lightIndex=0u;lightIndex < lightCount;lightIndex=lightIndex + 1u) {\rlet i=pointLight_clusterLightGroup.indices[lightOffset + lightIndex];\rlet targetLight=pointLightList.lights[i];\rlet u_pointLightPosition=targetLight.position;\rlet u_pointLightRadius=targetLight.radius;\rlet lightDistance=length(u_pointLightPosition - input_vertexPosition);\rlet lightDir=normalize(u_pointLightPosition - input_vertexPosition);\rlet attenuation=clamp(1.0 - (lightDistance * lightDistance)/(u_pointLightRadius * u_pointLightRadius),0.0,1.0);\r\n\rif(lightDistance<=u_pointLightRadius){\rtotalDirectLighting +=calcLight(\rtargetLight.color,targetLight.intensity * attenuation,\rN,V,lightDir,\rVdotN,\rroughnessParameter,metallicParameter,albedo,\rF0,ior,\rprePathBackground,\rspecularColor,specularParameter,\ru_useKHR_materials_diffuse_transmission,diffuseTransmissionParameter,diffuseTransmissionColor,\rtransmissionParameter,\rsheenColor,sheenRoughnessParameter,\ranisotropy,anisotropicT,anisotropicB,\rclearcoatParameter,clearcoatRoughnessParameter,clearcoatNormal\r);\r}\r}\r}\r\n\r\rif (u_useIblTexture) {\rlet R=normalize(reflect(-V,N));\rlet NdotV=max(dot(N,V),0.04);\rlet NdotV_fresnel=max(dot(N,V),0.04);\r\n\r\n\r\n\r\rlet F_IBL_dielectric=F0_dielectric + (vec3<f32>(1.0) - F0_dielectric) * pow(1.0 - NdotV_fresnel,5.0);\rlet F_IBL_metal=F0_metal + (vec3<f32>(1.0) - F0_metal) * pow(1.0 - NdotV_fresnel,5.0);\rvar F_IBL=F0 + (vec3<f32>(1.0) - F0) * pow(1.0 - NdotV_fresnel,5.0);\rvar F_IBL_iridescence=F_IBL;\rvar F_metal_iridescent=vec3<f32>(1.0);\rif (iridescenceParameter > 0.0) {\r\rlet F_iridescent=iridescent_fresnel(\r1.0, \ru_KHR_iridescenceIor, \rF0_dielectric, \riridescenceThickness, \riridescenceParameter, \rNdotV \r);\rlet F_metal_iridescent=iridescent_fresnel(\r1.0, \ru_KHR_iridescenceIor, \rbaseColor.rgb, \riridescenceThickness, \riridescenceParameter, \rNdotV \r);\rF_IBL=mix(F_iridescent,F_metal_iridescent,metallicParameter);\r}\r\n\rlet K=(roughnessParameter + 1.0) * (roughnessParameter + 1.0)/8.0;\rlet G=NdotV/(NdotV * (1.0 - K) + K);\rlet a2=roughnessParameter * roughnessParameter;\rlet G_smith=NdotV/(NdotV * (1.0 - a2) + a2);\r\rlet iblMipmapCount:f32=f32(textureNumLevels(iblTexture) - 1);\r\n\r\n\r\n\r\n\rlet mipLevel=pow(roughnessParameter,0.4) * iblMipmapCount;\r\n\r\n\r\n\r\rvar reflectedColor=textureSampleLevel(iblTexture,iblTextureSampler,R,mipLevel).rgb;\r\n\r\rlet effectiveTransmission=transmissionParameter * (1.0 - metallicParameter);\rvar envIBL_DIFFUSE:vec3<f32>=albedo * (vec3<f32>(1.0) - F_IBL_dielectric) ;\r\n\r\n\r\rif (u_useKHR_materials_diffuse_transmission && diffuseTransmissionParameter > 0.0) {\r\rvar backScatteringColor=textureSampleLevel(iblTexture,iblTextureSampler,-N,mipLevel).rgb;\rlet transmittedIBL=backScatteringColor * diffuseTransmissionColor * (vec3<f32>(1.0) - F_IBL);\r\renvIBL_DIFFUSE=mix(envIBL_DIFFUSE,transmittedIBL,diffuseTransmissionParameter);\r}\r\n\r\rvar envIBL_SPECULAR:vec3<f32>;\rlet specularColorCorrected=max(vec3<f32>(0.16),specularColor);\rif (u_useKHR_materials_anisotropy) {\rvar bentNormal=cross(anisotropicB,V);\rbentNormal=normalize(cross(bentNormal,anisotropicB));\rlet temp=1.0 - anisotropy * (1.0 - roughnessParameter);\rlet tempSquared=temp * temp;\rvar a=tempSquared * tempSquared;\rbentNormal=normalize(mix(bentNormal,N,a));\rvar reflectVec=reflect(-V,bentNormal);\rreflectVec=normalize(mix(reflectVec,bentNormal,roughnessParameter * roughnessParameter));\r\n\rlet roughnessT=roughnessParameter * (1.0 + anisotropy);\rlet roughnessB=roughnessParameter * (1.0 - anisotropy);\r\n\rlet TdotR=dot(anisotropicT,reflectVec);\rlet BdotR=dot(anisotropicB,reflectVec);\r\n\rlet TdotV=dot(anisotropicT,V);\rlet BdotV=dot(anisotropicB,V);\r\n\rlet anisotropicR=normalize(reflectVec - anisotropy * (TdotR * anisotropicT - BdotR * anisotropicB));\r\n\rlet VdotN=max(0.04,dot(V,N));\rlet oneMinusVdotN=1.0 - VdotN;\rlet directionFactor=oneMinusVdotN * oneMinusVdotN * oneMinusVdotN;\r\n\rlet VdotT_abs=abs(TdotV);\rlet VdotB_abs=abs(BdotV);\rlet totalWeight=max(0.0001,VdotT_abs + VdotB_abs);\r\n\rlet weightedRoughness=(roughnessT * VdotT_abs + roughnessB * VdotB_abs)/totalWeight;\r\n\rlet anisotropyFactor=max(0.0,min(1.0,anisotropy));\rlet finalRoughness=mix( roughnessParameter,weightedRoughness,anisotropyFactor * directionFactor );\rlet anistropyMipmap=pow(finalRoughness,0.4) * iblMipmapCount;\rreflectedColor=textureSampleLevel( iblTexture,iblTextureSampler,anisotropicR,anistropyMipmap ).rgb;\r\n\rlet a2=finalRoughness * finalRoughness;\rlet G_smith=NdotV/(NdotV * (1.0 - a2) + a2);\renvIBL_SPECULAR=reflectedColor * G_smith * specularColorCorrected * F_IBL * specularParameter;\r} else {\renvIBL_SPECULAR=reflectedColor * G_smith * specularColorCorrected * F_IBL * specularParameter;\r\n\r}\r\n\r\rvar envIBL_SPECULAR_BTDF=vec3<f32>(0.0);\rif (u_useKHR_materials_transmission) {\rvar refractedDir:vec3<f32>;\rlet eta=1.0/ior;\rif (abs(ior - 1.0) < 0.0001) {\rrefractedDir=V;\r} else {\rrefractedDir=refract(-V,-N,eta);\r}\r\n\rif(length(refractedDir) > 0.0001) {\rlet NdotT=abs(dot(N,normalize(refractedDir)));\rlet F_transmission=vec3<f32>(1.0) - F_IBL_dielectric;\r\n\rvar attenuatedBackground=prePathBackground;\rif (u_useKHR_materials_volume) {\rlet localNodeScale=inputData.localNodeScale;\rlet volumeScale=inputData.volumeScale;\r\n\rlet scaledThickness=thicknessParameter * localNodeScale;\r\rlet safeAttenuationColor=clamp(u_KHR_attenuationColor,vec3<f32>(0.0001),vec3<f32>(1.0));\rlet safeAttenuationDistance=max(u_KHR_attenuationDistance,0.0001);\r\n\r\rlet attenuationCoefficient=-log(safeAttenuationColor)/safeAttenuationDistance;\rlet cosTheta=max(NdotT,0.001);\rlet pathLength=scaledThickness/cosTheta;\rlet transmittance=exp(-attenuationCoefficient * pathLength);\rattenuatedBackground *=transmittance;\r}else{\rattenuatedBackground *=albedo;\r}\r\n\renvIBL_SPECULAR_BTDF=attenuatedBackground * F_transmission * transmissionParameter + reflectedColor * G_smith * F_IBL * NdotT;\r}\r}\r\n\r\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\rlet envIBL_DIELECTRIC=envIBL_DIFFUSE * (1.0-transmissionParameter) + envIBL_SPECULAR_BTDF + envIBL_SPECULAR;\r\n\r\rvar envIBL_SHEEN=vec3<f32>(0.0);\rvar sheen_albedo_scaling:f32=1.0;\rlet maxSheenColor=max(sheenColor.x,max(sheenColor.y,sheenColor.z));\r\n\rif (u_useKHR_materials_sheen) {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\rlet NdotV=max(dot(N,V),0.0001);\rlet sheenRoughnessAlpha=sheenRoughnessParameter * sheenRoughnessParameter;\r\rlet R=reflect(-V,N);\rlet sheenLobe=sheenRoughnessParameter * sheenRoughnessParameter;\rlet sheenSamplingDir=normalize(mix(R,N,sheenLobe));\r\n\rvar sheenMipLevel=log2(sheenRoughnessParameter) * 1.2 + iblMipmapCount - 1.0;\rsheenMipLevel=clamp(sheenMipLevel,0.0,iblMipmapCount - 1.0);\rlet sheenRadiance=textureSampleLevel(iblTexture,iblTextureSampler,sheenSamplingDir,sheenMipLevel).rgb;\r\n\r\r\rlet F0=0.04;\rlet sheenFresnel=F0 + (1.0 - F0) * pow(1.0 - NdotV,5.0);\r\n\r\n\r\rlet E_VdotN=1.0 - pow(1.0 - NdotV,5.0);\rsheen_albedo_scaling=max(1.0 - maxSheenColor * E_VdotN,0.04);\r\n\renvIBL_SHEEN= sheenColor * sheenFresnel;\r\n\r}\r\n\r\rlet envIBL_METAL=select(reflectedColor * max(baseColor.rgb,vec3<f32>(0.04)),reflectedColor * F_IBL,iridescenceParameter>0.0);\r\n\r\n\r\rlet metallicPart=envIBL_METAL * metallicParameter * sheen_albedo_scaling;\rlet dielectricPart=envIBL_DIELECTRIC * (1.0 - metallicParameter);\rvar indirectLighting=metallicPart + dielectricPart + envIBL_SHEEN;\r\n\r\rif (clearcoatParameter > 0.0) {\r\rlet clearcoatR=reflect(-V,clearcoatNormal);\rlet clearcoatNdotV=max(dot(clearcoatNormal,V),0.04);\rlet clearcoatMipLevel=pow(clearcoatRoughnessParameter,0.4) * iblMipmapCount;\rlet clearcoatPrefilteredColor=textureSampleLevel(iblTexture,iblTextureSampler,clearcoatR,clearcoatMipLevel).rgb;\rlet clearcoatF0=F0;\rlet clearcoatF=clearcoatF0 + (vec3<f32>(1.0) - clearcoatF0) * pow(1.0 - clearcoatNdotV,5.0);\rlet clearcoatK=(clearcoatRoughnessParameter + 1.0) * (clearcoatRoughnessParameter + 1.0)/8.0;\rlet clearcoatG=clearcoatNdotV/(clearcoatNdotV * (1.0 - clearcoatK) + clearcoatK);\rlet clearcoatBRDF=clearcoatF * clearcoatG;\rlet clearcoatSpecularIBL=clearcoatPrefilteredColor * clearcoatBRDF * clearcoatParameter;\rlet clearcoatFresnel=clearcoatF;\rindirectLighting=clearcoatSpecularIBL + (vec3<f32>(1.0) - clearcoatFresnel) * indirectLighting;\r}\r\n\r\rlet environmentIntensity=1.0;\rlet surfaceColor=totalDirectLighting + indirectLighting * environmentIntensity * occlusionParameter;\r\n\r\rfinalColor=vec4<f32>(surfaceColor,resultAlpha);\r\n\r} else {\r\rlet ambientContribution=albedo * u_ambientLightColor * u_ambientLightIntensity * occlusionParameter;\rfinalColor=vec4<f32>(totalDirectLighting + ambientContribution,resultAlpha);\r}\r\n\r\rif (u_useEmissiveTexture) {\rlet emissiveSamplerColor:vec4<f32>=(textureSample(emissiveTexture,emissiveTextureSampler,emissiveUV));\rfinalColor +=vec4<f32>( emissiveSamplerColor.rgb * u_emissiveFactor * u_emissiveStrength,0);\r} else {\rfinalColor +=(vec4<f32>(u_emissiveFactor * u_emissiveStrength,0));\r}\r\n\r\rfinalColor=linear_to_srgb(finalColor);\r\n\r\rif (u_useCutOff) {\rif (resultAlpha <=u_cutOff) {\rdiscard;\r}\r}\r\n\rreturn finalColor;\r\n};\r\nfn calcPrePathBackground(\ru_useKHR_materials_volume:bool,thicknessParameter:f32,u_KHR_dispersion:f32,u_KHR_attenuationDistance:f32,u_KHR_attenuationColor:vec3<f32>,\rior:f32,roughnessParameter:f32,albedo:vec3<f32>,\rprojectionCameraMatrix:mat4x4<f32>,input_vertexPosition:vec3<f32>,input_ndcPosition:vec3<f32>,\rV:vec3<f32>,N:vec3<f32>,\rrenderPath1ResultTexture:texture_2d<f32>,renderPath1ResultTextureSampler:sampler\r\n) -> vec3<f32> {\rvar prePathBackground=vec3<f32>(0.0);\rlet transmissionMipLevel:f32=roughnessParameter * f32(textureNumLevels(renderPath1ResultTexture) - 1);\r\n\rif(u_useKHR_materials_volume){\rvar iorR:f32=ior;\rvar iorG:f32=ior;\rvar iorB:f32=ior;\rif(u_KHR_dispersion>0.0){\rlet halfSpread:f32=(ior - 1.0) * 0.025 * u_KHR_dispersion;\riorR=ior + halfSpread;\riorG=ior;\riorB=ior - halfSpread;\r}\rlet refractedVecR:vec3<f32>=refract(-V,N,1.0/iorR);\rlet refractedVecG:vec3<f32>=refract(-V,N,1.0/iorG);\rlet refractedVecB:vec3<f32>=refract(-V,N,1.0/iorB);\r\n\r\rlet worldPosR:vec3<f32>=input_vertexPosition + refractedVecR * thicknessParameter;\rlet worldPosG:vec3<f32>=input_vertexPosition + refractedVecG * thicknessParameter;\rlet worldPosB:vec3<f32>=input_vertexPosition + refractedVecB * thicknessParameter;\r\n\r\rlet clipPosR:vec4<f32>=projectionCameraMatrix * vec4<f32>(worldPosR,1.0);\rlet clipPosG:vec4<f32>=projectionCameraMatrix * vec4<f32>(worldPosG,1.0);\rlet clipPosB:vec4<f32>=projectionCameraMatrix * vec4<f32>(worldPosB,1.0);\r\n\rlet ndcR:vec2<f32>=clipPosR.xy/clipPosR.w * 0.5 + 0.5;\rlet ndcG:vec2<f32>=clipPosG.xy/clipPosG.w * 0.5 + 0.5;\rlet ndcB:vec2<f32>=clipPosB.xy/clipPosB.w * 0.5 + 0.5;\r\n\r\rlet finalUV_R:vec2<f32>=vec2<f32>(ndcR.x,1.0 - ndcR.y);\rlet finalUV_G:vec2<f32>=vec2<f32>(ndcG.x,1.0 - ndcG.y);\rlet finalUV_B:vec2<f32>=vec2<f32>(ndcB.x,1.0 - ndcB.y);\r\n\r\rprePathBackground.r=textureSampleLevel(renderPath1ResultTexture,renderPath1ResultTextureSampler,finalUV_R,transmissionMipLevel).r;\rprePathBackground.g=textureSampleLevel(renderPath1ResultTexture,renderPath1ResultTextureSampler,finalUV_G,transmissionMipLevel).g;\rprePathBackground.b=textureSampleLevel(renderPath1ResultTexture,renderPath1ResultTextureSampler,finalUV_B,transmissionMipLevel).b;\r\n\r} else {\rlet refractedVec:vec3<f32>=refract(-V,N,1.0/ior);\rlet worldPos:vec3<f32>=input_vertexPosition + refractedVec * thicknessParameter;\rlet clipPos:vec4<f32>=projectionCameraMatrix * vec4<f32>(worldPos,1.0);\rlet ndc:vec2<f32>=clipPos.xy/clipPos.w * 0.5 + 0.5;\rlet finalUV:vec2<f32>=vec2<f32>(ndc.x,1.0 - ndc.y);\rprePathBackground=textureSampleLevel(renderPath1ResultTexture,renderPath1ResultTextureSampler,finalUV,transmissionMipLevel).rgb;\r}\r\rprePathBackground *=albedo;\rreturn prePathBackground;\r\n}\r\nfn calcLight(\rlightColor:vec3<f32>,lightIntensity:f32,\rN:vec3<f32>,V:vec3<f32>,L:vec3<f32>,\rVdotN:f32,\rroughnessParameter:f32,metallicParameter:f32,albedo:vec3<f32>,\rF0:vec3<f32>,ior:f32,\r\n\rprePathBackground:vec3<f32>,\rspecularColor:vec3<f32>,specularParameter:f32,\ru_useKHR_materials_diffuse_transmission:bool,diffuseTransmissionParameter:f32,diffuseTransmissionColor:vec3<f32>,\rtransmissionParameter:f32,\rsheenColor:vec3<f32>,sheenRoughnessParameter:f32,\ranisotropy:f32,anisotropicT:vec3<f32>,anisotropicB:vec3<f32>,\rclearcoatParameter:f32,clearcoatRoughnessParameter:f32,clearcoatNormal:vec3<f32>\r\n) -> vec3<f32>{\rlet dLight=lightColor * lightIntensity;\r\n\rlet NdotL=max(dot(N,L),0.04);\rlet NdotV=max(dot(N,V),0.04);\rlet H=normalize(L + V);\rlet LdotH=max(dot(L,H),0.0);\rlet NdotH=max(dot(N,H),0.0);\rlet VdotH=max(dot(V,H),0.0);\r\n\r\n\rvar DIFFUSE_BRDF:vec3<f32>=diffuse_brdf_disney(NdotL,NdotV,LdotH,roughnessParameter,albedo);\rif(u_useKHR_materials_diffuse_transmission && diffuseTransmissionParameter > 0.0){\rDIFFUSE_BRDF=mix(DIFFUSE_BRDF,diffuse_btdf(N,L,diffuseTransmissionColor),diffuseTransmissionParameter);\r}\r\n\rvar SPECULAR_BRDF:vec3<f32>;\rif (anisotropy > 0.0) {\rvar TdotL=dot(anisotropicT,L);\rvar TdotV=dot(anisotropicT,V);\rvar BdotL=dot(anisotropicB,L);\rvar TdotH=dot(anisotropicT,H);\rvar BdotH=dot(anisotropicB,H);\rvar BdotV=dot(anisotropicB,V);\rSPECULAR_BRDF= BRDF_specularAnisotropicGGX(\ralbedo,\rvec3<f32>(1.0),\rroughnessParameter * roughnessParameter,\rVdotH,NdotL,NdotV,NdotH,BdotV,TdotV,TdotL,BdotL,TdotH,BdotH,\ranisotropy\r);\r}else{\rSPECULAR_BRDF=specular_brdf( albedo,roughnessParameter,NdotH,NdotV,NdotL,LdotH);\r}\rlet METAL_BRDF=conductor_fresnel( albedo,SPECULAR_BRDF,VdotH);;\r\n\rlet transmissionWeight=transmissionParameter * (vec3<f32>(1.0) - F0);\rvar SPECULAR_BTDF= vec3<f32>(0.0);\rif(transmissionParameter > 0.0){\rSPECULAR_BTDF=specular_btdf( NdotV,NdotL,NdotH,VdotH,LdotH,roughnessParameter,albedo,ior);\r}\r\rlet DIELECTRIC_BRDF=fresnel_mix(\rF0,\rspecularParameter,\rmix(DIFFUSE_BRDF,SPECULAR_BTDF,transmissionParameter),\rSPECULAR_BRDF,\rVdotH\r);\r\n\r\n\rvar SHEEN_BRDF:vec3<f32>=vec3<f32>(0.0);\rvar sheen_albedo_scaling:f32=1.0;\rlet maxSheenColor=max(sheenColor.x,max(sheenColor.y,sheenColor.z));\rif(sheenRoughnessParameter > 0.0 && maxSheenColor > 0.001 && dot(N,V) > 0) {\rlet NdotV=dot(N,V);\rlet sheenRoughnessAlpha=sheenRoughnessParameter * sheenRoughnessParameter;\rlet invR=1/sheenRoughnessAlpha;\rlet cos2h=NdotH * NdotH;\rlet sin2h=1 - cos2h;\rlet sheenDistribution=(2 + invR) * pow(sin2h,invR * 0.5)/(2 * pi);\rlet sheen_visibility= 1.0/((1.0 + lambda_sheen(NdotV,sheenRoughnessAlpha) + lambda_sheen(NdotL,sheenRoughnessAlpha)) * (4.0 * NdotV * NdotL));\rlet LdotN=max(dot(L,N),0.04);\rlet E_LdotN=1.0 - pow(1.0 - LdotN,5.0);\rlet E_VdotN=1.0 - pow(1.0 - VdotN,5.0);\r\n\r\n\rsheen_albedo_scaling=max(min(1.0 - maxSheenColor * E_VdotN,1.0 - maxSheenColor * E_LdotN),0.04);\r\n\rSHEEN_BRDF=sheenColor * sheenDistribution * sheen_visibility;\r}\r\n\r\r\rlet metallicPart=METAL_BRDF * metallicParameter * sheen_albedo_scaling ;\rlet dielectricPart=DIELECTRIC_BRDF * sheen_albedo_scaling;\r\n\r\n\rlet sheenPart=SHEEN_BRDF;\rvar directLighting=(metallicPart + dielectricPart + sheenPart);\rif(transmissionParameter > 0.0) {\r\r\rdirectLighting=mix(directLighting,prePathBackground,transmissionWeight);\r}\r\rif(clearcoatParameter > 0.0){\rlet clearcoatNdotL=max(dot(clearcoatNormal,L),0.04);\rlet clearcoatNdotV=max(dot(clearcoatNormal,V),0.04);\rlet clearcoatNdotH=max(dot(clearcoatNormal,H),0.0);\rlet CLEARCOAT_BRDF=specular_brdf( F0,clearcoatRoughnessParameter,clearcoatNdotH,clearcoatNdotV,clearcoatNdotL,LdotH);\rdirectLighting=fresnel_coat(clearcoatNdotV,ior,clearcoatParameter,directLighting,CLEARCOAT_BRDF);\r}\rdirectLighting *=dLight;\r\n\rvar lightDirection:f32;\rif (u_useKHR_materials_diffuse_transmission && diffuseTransmissionParameter > 0.0) {\rlightDirection=mix(abs(dot(N,L)),1.0,diffuseTransmissionParameter);\r} else {\r\rlightDirection=NdotL;\r}\r\n\rlet lightContribution=directLighting * lightDirection;\r\rreturn lightContribution;\r\n}\r\nconst pi:f32=3.14159265359;\r\nfn BRDF_specularAnisotropicGGX( f0:vec3<f32>,f90:vec3<f32>,alphaRoughness:f32,VdotH:f32,NdotL:f32,NdotV:f32,NdotH:f32,BdotV:f32,TdotV:f32,TdotL:f32,BdotL:f32,TdotH:f32,BdotH:f32,anisotropy:f32 ) -> vec3<f32> {\rvar at=mix(alphaRoughness,1.0,anisotropy * anisotropy);\rvar ab=alphaRoughness;\rvar F:vec3<f32>=fresnel_schlick(VdotH,f0);\rvar V:f32=V_GGX_anisotropic(NdotL,NdotV,BdotV,TdotV,TdotL,BdotL,at,ab);\rvar D:f32=D_GGX_anisotropic(NdotH,TdotH,BdotH,at,ab);\rreturn F * (V * D);\r\n}\r\nfn D_GGX_anisotropic( NdotH:f32,TdotH:f32,BdotH:f32,at:f32,ab:f32 ) -> f32 {\rlet a2:f32=at * ab;\rlet f:vec3<f32>=vec3<f32>(ab * TdotH,at * BdotH,a2 * NdotH);\rlet denominator:f32=dot(f,f);\r\n\r\n\r\n\rlet w2:f32=a2/denominator;\rreturn a2 * w2 * w2/pi;\r\n}\r\nfn V_GGX_anisotropic( NdotL:f32,NdotV:f32,BdotV:f32,TdotV:f32,TdotL:f32,BdotL:f32,at:f32,ab:f32 ) -> f32 {\rlet GGXV=NdotL * length(vec3<f32>(at * TdotV,ab * BdotV,NdotV));\rlet GGXL=NdotV * length(vec3<f32>(at * TdotL,ab * BdotL,NdotL));\rlet v=0.5/(GGXV + GGXL);\rreturn clamp(v,0.0,1.0);\r\n}\r\nfn iridescent_fresnel(outside_ior:f32,iridescence_ior:f32,base_f0:vec3<f32>,\riridescence_thickness:f32,iridescence_factor:f32,cos_theta1:f32) -> vec3<f32> {\r\rif (iridescence_thickness <=0.0 || iridescence_factor <=0.0) {\rreturn base_f0;\r}\r\n\r\rlet cos_theta1_abs=abs(cos_theta1);\r\n\r\r\r\rlet min_ior=1.01;\rlet safe_iridescence_ior=max(iridescence_ior,min_ior);\r\n\r\rlet sin_theta1=sqrt(max(0.0,1.0 - cos_theta1_abs * cos_theta1_abs));\rlet sin_theta2=(outside_ior/safe_iridescence_ior) * sin_theta1;\r\n\r\rif (sin_theta2 >=1.0) {\rlet total_reflection=vec3<f32>(1.0);\rreturn base_f0 + iridescence_factor * (total_reflection - base_f0);\r\n\r}\r\n\rlet cos_theta2=sqrt(max(0.0,1.0 - sin_theta2 * sin_theta2));\r\n\r\rlet wavelengths=vec3<f32>(650.0,510.0,475.0);\r\n\r\r\rlet min_thickness=10.0;\rlet effective_thickness=max(iridescence_thickness,min_thickness);\r\n\r\r\rlet ior_scale=max(1.0,1.5 - 0.5 * (safe_iridescence_ior/1.5));\rlet optical_thickness=2.0 * effective_thickness * safe_iridescence_ior * cos_theta2 * ior_scale;\r\n\r\rlet phase=(2.0 * 3.14159265359 * optical_thickness)/wavelengths;\r\n\r\r\rlet r12_s=((outside_ior * cos_theta1_abs) - (safe_iridescence_ior * cos_theta2))/\r((outside_ior * cos_theta1_abs) + (safe_iridescence_ior * cos_theta2));\r\n\rlet r12_p=((safe_iridescence_ior * cos_theta1_abs) - (outside_ior * cos_theta2))/\r((safe_iridescence_ior * cos_theta1_abs) + (outside_ior * cos_theta2));\r\n\rlet t12_s=2.0 * outside_ior * cos_theta1_abs/\r((outside_ior * cos_theta1_abs) + (safe_iridescence_ior * cos_theta2));\r\n\rlet t12_p=2.0 * outside_ior * cos_theta1_abs/\r((safe_iridescence_ior * cos_theta1_abs) + (outside_ior * cos_theta2));\r\n\r\r\rlet n3=vec3<f32>(\r(1.0 + sqrt(clamp(base_f0.r,0.01,0.99)))/(1.0 - sqrt(clamp(base_f0.r,0.01,0.99))),\r(1.0 + sqrt(clamp(base_f0.g,0.01,0.99)))/(1.0 - sqrt(clamp(base_f0.g,0.01,0.99))),\r(1.0 + sqrt(clamp(base_f0.b,0.01,0.99)))/(1.0 - sqrt(clamp(base_f0.b,0.01,0.99)))\r);\r\n\r\rlet safe_n3=max(n3,vec3<f32>(1.2));\r\n\rlet r23_s=vec3<f32>(\r((safe_iridescence_ior * cos_theta2) - (safe_n3.r * cos_theta1_abs))/\r((safe_iridescence_ior * cos_theta2) + (safe_n3.r * cos_theta1_abs)),\r((safe_iridescence_ior * cos_theta2) - (safe_n3.g * cos_theta1_abs))/\r((safe_iridescence_ior * cos_theta2) + (safe_n3.g * cos_theta1_abs)),\r((safe_iridescence_ior * cos_theta2) - (safe_n3.b * cos_theta1_abs))/\r((safe_iridescence_ior * cos_theta2) + (safe_n3.b * cos_theta1_abs))\r);\r\n\rlet r23_p=vec3<f32>(\r((safe_n3.r * cos_theta2) - (safe_iridescence_ior * cos_theta1_abs))/\r((safe_n3.r * cos_theta2) + (safe_iridescence_ior * cos_theta1_abs)),\r((safe_n3.g * cos_theta2) - (safe_iridescence_ior * cos_theta1_abs))/\r((safe_n3.g * cos_theta2) + (safe_iridescence_ior * cos_theta1_abs)),\r((safe_n3.b * cos_theta2) - (safe_iridescence_ior * cos_theta1_abs))/\r((safe_n3.b * cos_theta2) + (safe_iridescence_ior * cos_theta1_abs))\r);\r\n\r\rlet cos_phase=vec3<f32>(cos(phase.r),cos(phase.g),cos(phase.b));\rlet sin_phase=vec3<f32>(sin(phase.r),sin(phase.g),sin(phase.b));\r\n\r\r\rlet numerator_s_real=vec3<f32>(\rr12_s + r23_s.r * cos_phase.r,\rr12_s + r23_s.g * cos_phase.g,\rr12_s + r23_s.b * cos_phase.b\r);\r\n\rlet numerator_s_imag=vec3<f32>(\rr23_s.r * sin_phase.r,\rr23_s.g * sin_phase.g,\rr23_s.b * sin_phase.b\r);\r\n\r\rlet denominator_s_real=vec3<f32>(\r1.0 + r12_s * r23_s.r * cos_phase.r,\r1.0 + r12_s * r23_s.g * cos_phase.g,\r1.0 + r12_s * r23_s.b * cos_phase.b\r);\r\n\rlet denominator_s_imag=vec3<f32>(\rr12_s * r23_s.r * sin_phase.r,\rr12_s * r23_s.g * sin_phase.g,\rr12_s * r23_s.b * sin_phase.b\r);\r\n\r\r\rlet denom_s_squared=vec3<f32>(\rdenominator_s_real.r * denominator_s_real.r + denominator_s_imag.r * denominator_s_imag.r,\rdenominator_s_real.g * denominator_s_real.g + denominator_s_imag.g * denominator_s_imag.g,\rdenominator_s_real.b * denominator_s_real.b + denominator_s_imag.b * denominator_s_imag.b\r);\r\n\r\rlet epsilon=0.001;\r\n\r\rlet r_s_real=vec3<f32>(\r(numerator_s_real.r * denominator_s_real.r + numerator_s_imag.r * denominator_s_imag.r)/\r(denom_s_squared.r + epsilon),\r(numerator_s_real.g * denominator_s_real.g + numerator_s_imag.g * denominator_s_imag.g)/\r(denom_s_squared.g + epsilon),\r(numerator_s_real.b * denominator_s_real.b + numerator_s_imag.b * denominator_s_imag.b)/\r(denom_s_squared.b + epsilon)\r);\r\n\r\rlet r_s_imag=vec3<f32>(\r(numerator_s_imag.r * denominator_s_real.r - numerator_s_real.r * denominator_s_imag.r)/\r(denom_s_squared.r + epsilon),\r(numerator_s_imag.g * denominator_s_real.g - numerator_s_real.g * denominator_s_imag.g)/\r(denom_s_squared.g + epsilon),\r(numerator_s_imag.b * denominator_s_real.b - numerator_s_real.b * denominator_s_imag.b)/\r(denom_s_squared.b + epsilon)\r);\r\n\r\r\rlet numerator_p_real=vec3<f32>(\rr12_p + r23_p.r * cos_phase.r,\rr12_p + r23_p.g * cos_phase.g,\rr12_p + r23_p.b * cos_phase.b\r);\r\n\rlet numerator_p_imag=vec3<f32>(\rr23_p.r * sin_phase.r,\rr23_p.g * sin_phase.g,\rr23_p.b * sin_phase.b\r);\r\n\r\rlet denominator_p_real=vec3<f32>(\r1.0 + r12_p * r23_p.r * cos_phase.r,\r1.0 + r12_p * r23_p.g * cos_phase.g,\r1.0 + r12_p * r23_p.b * cos_phase.b\r);\r\n\rlet denominator_p_imag=vec3<f32>(\rr12_p * r23_p.r * sin_phase.r,\rr12_p * r23_p.g * sin_phase.g,\rr12_p * r23_p.b * sin_phase.b\r);\r\n\r\rlet denom_p_squared=vec3<f32>(\rdenominator_p_real.r * denominator_p_real.r + denominator_p_imag.r * denominator_p_imag.r,\rdenominator_p_real.g * denominator_p_real.g + denominator_p_imag.g * denominator_p_imag.g,\rdenominator_p_real.b * denominator_p_real.b + denominator_p_imag.b * denominator_p_imag.b\r);\r\n\r\rlet r_p_real=vec3<f32>(\r(numerator_p_real.r * denominator_p_real.r + numerator_p_imag.r * denominator_p_imag.r)/\r(denom_p_squared.r + epsilon),\r(numerator_p_real.g * denominator_p_real.g + numerator_p_imag.g * denominator_p_imag.g)/\r(denom_p_squared.g + epsilon),\r(numerator_p_real.b * denominator_p_real.b + numerator_p_imag.b * denominator_p_imag.b)/\r(denom_p_squared.b + epsilon)\r);\r\n\r\rlet r_p_imag=vec3<f32>(\r(numerator_p_imag.r * denominator_p_real.r - numerator_p_real.r * denominator_p_imag.r)/\r(denom_p_squared.r + epsilon),\r(numerator_p_imag.g * denominator_p_real.g - numerator_p_real.g * denominator_p_imag.g)/\r(denom_p_squared.g + epsilon),\r(numerator_p_imag.b * denominator_p_real.b - numerator_p_real.b * denominator_p_imag.b)/\r(denom_p_squared.b + epsilon)\r);\r\n\r\rlet Rs=vec3<f32>(\rr_s_real.r * r_s_real.r + r_s_imag.r * r_s_imag.r,\rr_s_real.g * r_s_real.g + r_s_imag.g * r_s_imag.g,\rr_s_real.b * r_s_real.b + r_s_imag.b * r_s_imag.b\r);\r\n\rlet Rp=vec3<f32>(\rr_p_real.r * r_p_real.r + r_p_imag.r * r_p_imag.r,\rr_p_real.g * r_p_real.g + r_p_imag.g * r_p_imag.g,\rr_p_real.b * r_p_real.b + r_p_imag.b * r_p_imag.b\r);\r\n\r\rlet reflectance=0.5 * (Rs + Rp);\r\n\r\r\rlet ior_influence=smoothstep(1.0,2.0,safe_iridescence_ior);\rlet enhanced_reflectance=mix(\r\rpow(reflectance,vec3<f32>(0.8)) * 1.2,\r\rreflectance,\rior_influence\r);\r\n\r\rlet clamped_reflectance=clamp(enhanced_reflectance,vec3<f32>(0.0),vec3<f32>(1.0));\r\n\r\rreturn mix(base_f0,clamped_reflectance,iridescence_factor);\r\n}\r\nfn specular_btdf(\rNdotV:f32,\rNdotL:f32,\rNdotH:f32,\rVdotH:f32,\rLdotH:f32,\rroughness:f32,\rF0:vec3<f32>,\rior:f32\r\n) -> vec3<f32> {\rlet eta:f32=1.0/ior;\r\n\r\r\rlet D_rough:f32=distribution_ggx(NdotH,roughness * roughness);\r\n\r\r\rlet t:f32=clamp((ior - 1.0) * 100.0,0.0,1.0);\rlet D:f32=mix(1.0,D_rough,t);\r\n\r\rlet G:f32=min(1.0,min((2.0 * NdotH * NdotV)/VdotH,(2.0 * NdotH * NdotL)/VdotH));\r\n\r\rlet F:vec3<f32>=fresnel_schlick(VdotH,F0);\r\n\rlet denom:f32=(eta * VdotH + LdotH) * (eta * VdotH + LdotH);\r\n\r\rlet btdf:vec3<f32>=\r(vec3<f32>(1.0) - F) * \rabs(VdotH * LdotH) * \r(eta * eta) * \rD * \rG/ \r(NdotV * denom + 0.001);\r\n\rreturn btdf;\r\n}\r\n\r\nfn lambda_sheen_calc_l(x:f32,alpha_g:f32) -> f32 {\rlet one_minus_alpha_sq=(1.0 - alpha_g) * (1.0 - alpha_g);\r\n\rlet a=mix(21.5473,25.3245,one_minus_alpha_sq);\rlet b=mix(3.82987,3.32435,one_minus_alpha_sq);\rlet c=mix(0.19823,0.16801,one_minus_alpha_sq);\rlet d=mix(-1.97760,-1.27393,one_minus_alpha_sq);\rlet e=mix(-4.32054,-4.85967,one_minus_alpha_sq);\r\n\rreturn a/(1.0 + b * pow(x,c)) + d * x + e;\r\n}\r\nfn lambda_sheen(cos_theta:f32,alpha_g:f32) -> f32 {\rif (abs(cos_theta) < 0.5) {\rreturn exp(lambda_sheen_calc_l(cos_theta,alpha_g));\r} else {\rreturn exp(2.0 * lambda_sheen_calc_l(0.5,alpha_g) - lambda_sheen_calc_l(1.0 - cos_theta,alpha_g));\r}\r\n}\r\n\r\nfn fresnel_coat(NdotV:f32,ior:f32,weight:f32,base:vec3<f32>,layer:vec3<f32>) -> vec3<f32> {\rlet f0:f32=pow((1.0 - ior)/(1.0 + ior),2.0);\rlet fr:f32=f0 + (1.0 - f0) * pow(1.0 - abs(NdotV),5.0);\rreturn mix(base,layer,weight * fr);\r\n}\r\nfn conductor_fresnel(F0:vec3<f32>,bsdf:vec3<f32>,VdotH:f32) -> vec3<f32> {\rlet fresnel=F0 + (vec3<f32>(1.0) - F0) * pow(1.0 - abs(VdotH),5.0);\rreturn bsdf * fresnel;\r\n}\r\nfn fresnel_mix(\rF0:vec3<f32>,\rweight:f32,\rbase:vec3<f32>,\rlayer:vec3<f32>,\rVdotH:f32\r\n) -> vec3<f32> {\rvar f0=F0;\rf0=min(f0,vec3<f32>(1.0));\rlet fr=f0 + (1.0 - f0) * pow(1.0 - abs(VdotH),5.0);\rreturn (1 - weight * max(max(fr.x,fr.y),fr.z)) * base + weight * fr * layer;\r\n}\r\nfn fresnel_mix_ibl(\rF0:vec3<f32>,\rweight:f32,\rbase:vec3<f32>,\rlayer:vec3<f32>,\rNdotV:f32\r\n) -> vec3<f32> {\rvar f0=F0;\rf0=min(f0,vec3<f32>(1.0));\r\rlet fr=f0 + (1.0 - f0) * pow(1.0 - max(NdotV,0.0),5.0);\r\n\r\rreturn base * (1.0 - fr * weight) + layer * fr * weight;\r\n}\r\n\r\nfn diffuse_brdf_disney(NdotL:f32,NdotV:f32,LdotH:f32,roughness:f32,albedo:vec3<f32>) -> vec3<f32> {\rif (NdotL <=0.0) { return vec3<f32>(0.0);}\r\n\r\rlet energyBias=mix(0.0,0.5,roughness);\rlet energyFactor=mix(1.0,1.0/1.51,roughness);\rlet fd90=energyBias + 2.0 * LdotH * LdotH * roughness;\rlet f0=1.0;\rlet lightScatter=f0 + (fd90 - f0) * pow(1.0 - NdotL,5.0);\rlet viewScatter=f0 + (fd90 - f0) * pow(1.0 - NdotV,5.0);\r\n\rreturn albedo * NdotL * lightScatter * viewScatter * energyFactor/pi;\r\n}\r\n\r\nfn diffuse_brdf(NdotL:f32,albedo:vec3<f32>) -> vec3<f32> {\rreturn albedo * NdotL/pi;\r\n}\r\nfn diffuse_btdf(N:vec3<f32>,L:vec3<f32>,Albedo:vec3<f32>) -> vec3<f32> {\r\rlet cos_theta=max(-dot(N,L),0.0);\rreturn Albedo * cos_theta/pi;\r\n}\r\n\r\nfn specular_brdf(\rF0:vec3<f32>,\rroughness:f32,\rNdotH:f32,\rNdotV:f32,\rNdotL:f32,\rLdotH:f32\r\n) -> vec3<f32> {\r\n\r\rlet D=distribution_ggx(NdotH,roughness);\r\n\r\rlet G=geometry_smith(NdotV,NdotL,roughness);\r\n\r\rlet F=fresnel_schlick(LdotH,F0);\r\n\r\rlet numerator=D * G * F;\rlet denominator=4.0 * NdotV * NdotL + 0.04;\r\n\rreturn (numerator/denominator);\r\n}\r\n\r\n\r\nfn distribution_ggx(NdotH:f32,roughness:f32) -> f32 {\rlet alpha=roughness * roughness;\rlet alpha2=alpha * alpha;\rlet NdotH2=NdotH * NdotH;\r\n\rlet nom=alpha2;\rlet denom=(NdotH2 * (alpha2 - 1.0) + 1.0);\rlet denom_squared=denom * denom;\r\n\rreturn nom/(denom_squared * 3.14159265359);\r\n}\r\n\r\n\r\nfn geometry_smith(NdotV:f32,NdotL:f32,roughness:f32) -> f32 {\rlet alpha=roughness * roughness;\rlet k=alpha/2.0; \r\n\rlet ggx1=NdotV/(NdotV * (1.0 - k) + k);\rlet ggx2=NdotL/(NdotL * (1.0 - k) + k);\r\n\rreturn ggx1 * ggx2;\r\n}\r\n\r\n\r\nfn fresnel_schlick(cosTheta:f32,F0:vec3<f32>) -> vec3<f32> {\rreturn F0 + (vec3<f32>(1.0) - F0) * pow(1.0 - cosTheta,5.0);\r\n}\r\n\r\nfn get_transformed_uv(\rinput_uv:vec2<f32>,\rinput_uv1:vec2<f32>,\rtexCoord_index:u32,\ruse_transform:u32,\rtransform_offset:vec2<f32>,\rtransform_rotation:f32,\rtransform_scale:vec2<f32>\r\n) -> vec2<f32> {\r\rvar result_uv=select(input_uv,input_uv1,texCoord_index==1);\r\n\r\rif (use_transform==1) {\r\rlet translation=mat3x3<f32>(\r1.0,0.0,0.0,\r0.0,1.0,0.0,\rtransform_offset.x,transform_offset.y,1.0\r);\r\n\rlet cos_rot=cos(transform_rotation);\rlet sin_rot=sin(transform_rotation);\rlet rotation_matrix=mat3x3<f32>(\rcos_rot,-sin_rot,0.0,\rsin_rot,cos_rot,0.0,\r0.0,0.0,1.0\r);\r\n\rlet scale_matrix=mat3x3<f32>(\rtransform_scale.x,0.0,0.0,\r0.0,transform_scale.y,0.0,\r0.0,0.0,1.0\r);\r\n\rlet result_matrix=translation * rotation_matrix * scale_matrix;\rresult_uv=(result_matrix * vec3<f32>(result_uv,1.0)).xy;\r}\r\n\rreturn result_uv;\r\n}\r\n\r\nfn linear_to_srgb(linearColor:vec4<f32>) -> vec4<f32> {\rlet cutoff=vec4<f32>(0.0031308);\rlet higher=vec4<f32>(1.055) * pow(linearColor,vec4<f32>(1.0/2.4)) - vec4<f32>(0.055);\rlet lower=linearColor * vec4<f32>(12.92);\r\n\rreturn vec4<f32>(\rmix(higher.r,lower.r,step(linearColor.r,cutoff.r)),\rmix(higher.g,lower.g,step(linearColor.g,cutoff.g)),\rmix(higher.b,lower.b,step(linearColor.b,cutoff.b)),\rlinearColor.a \r);\r\n}\r\n"));class PBRMaterial extends ABitmapBaseMaterial{get packedKHR_iridescence(){return this.#pt}#ft;#gt;#_t;#xt;#vt;#pt;get packedORMTexture(){return this.#ft}get packedKHR_sheen(){return this.#vt}get packedKHR_transmission(){return this.#_t}get packedKHR_diffuse_transmission(){return this.#xt}get packedKHR_clearcoatTexture(){return this.#gt}async setupPackORMTexture(){const e=Math.max(this.occlusionTexture?.gpuTexture.width||1,this.metallicRoughnessTexture?.gpuTexture.width||1),t=Math.max(this.occlusionTexture?.gpuTexture.height||1,this.metallicRoughnessTexture?.gpuTexture.height||1);await this.#ft.packing({r:this.occlusionTexture?.gpuTexture,g:this.metallicRoughnessTexture?.gpuTexture,b:this.metallicRoughnessTexture?.gpuTexture},e,t)}async setupPackedKHR_clearcoatTexture(){const e=Math.max(this.KHR_clearcoatTexture?.gpuTexture.width||1,this.KHR_clearcoatRoughnessTexture?.gpuTexture.width||1),t=Math.max(this.KHR_clearcoatTexture?.gpuTexture.height||1,this.KHR_clearcoatRoughnessTexture?.gpuTexture.height||1);await this.#gt.packing({r:this.KHR_clearcoatTexture?.gpuTexture,g:this.KHR_clearcoatRoughnessTexture?.gpuTexture},e,t)}async setupPackedKHR_transmission(){const e=Math.max(this.KHR_transmissionTexture?.gpuTexture.width||1,this.KHR_thicknessTexture?.gpuTexture.width||1),t=Math.max(this.KHR_transmissionTexture?.gpuTexture.height||1,this.KHR_thicknessTexture?.gpuTexture.height||1);await this.#_t.packing({r:this.KHR_transmissionTexture?.gpuTexture,g:this.KHR_thicknessTexture?.gpuTexture},e,t)}async setupPackedKHR_diffuse_transmission(){const e=Math.max(this.KHR_diffuseTransmissionColorTexture?.gpuTexture.width||1,this.KHR_diffuseTransmissionTexture?.gpuTexture.width||1),t=Math.max(this.KHR_diffuseTransmissionColorTexture?.gpuTexture.height||1,this.KHR_diffuseTransmissionTexture?.gpuTexture.height||1);await this.#xt.packing({r:this.KHR_diffuseTransmissionColorTexture?.gpuTexture,g:this.KHR_diffuseTransmissionColorTexture?.gpuTexture,b:this.KHR_diffuseTransmissionColorTexture?.gpuTexture,a:this.KHR_diffuseTransmissionTexture?.gpuTexture},e,t)}async setupPackedKHR_sheen(){const e=Math.max(this.KHR_sheenColorTexture?.gpuTexture.width||1,this.KHR_sheenRoughnessTexture?.gpuTexture.width||1),t=Math.max(this.KHR_sheenColorTexture?.gpuTexture.height||1,this.KHR_sheenRoughnessTexture?.gpuTexture.height||1);await this.#vt.packing({r:this.KHR_sheenColorTexture?.gpuTexture,g:this.KHR_sheenColorTexture?.gpuTexture,b:this.KHR_sheenColorTexture?.gpuTexture,a:this.KHR_sheenRoughnessTexture?.gpuTexture},e,t)}async setupPackedKHR_iridescence(){const e=Math.max(this.KHR_iridescenceTexture?.gpuTexture.width||1,this.KHR_iridescenceThicknessTexture?.gpuTexture.width||1),t=Math.max(this.KHR_iridescenceTexture?.gpuTexture.height||1,this.KHR_iridescenceThicknessTexture?.gpuTexture.height||1);await this.#pt.packing({r:this.KHR_iridescenceTexture?.gpuTexture,g:this.KHR_iridescenceThicknessTexture?.gpuTexture},e,t)}constructor(e){super(e,"PBR_MATERIAL",gt,2),this.initGPURenderInfos(),this.#ft=new PackedTexture(e),this.#gt=new PackedTexture(e),this.#_t=new PackedTexture(e),this.#xt=new PackedTexture(e),this.#vt=new PackedTexture(e),this.#pt=new PackedTexture(e),this.__packingList=[()=>{this.setupPackORMTexture(),this.setupPackedKHR_clearcoatTexture(),this.setupPackedKHR_transmission(),this.setupPackedKHR_diffuse_transmission(),this.setupPackedKHR_sheen(),this.setupPackedKHR_iridescence()}]}}rt.defineByPreset(PBRMaterial,[rt.PRESET_POSITIVE_NUMBER.EMISSIVE_STRENGTH,rt.PRESET_POSITIVE_NUMBER.NORMAL_SCALE]);ft.forEach((e=>{const{extensionName:t,textureList:r,useSampler:n}=e,{positiveNumberList:i,vec3List:s,vec4List:a}=e;t&&rt.defineBoolean(PBRMaterial,[`use${t}`]),((e,t)=>{e?.forEach((e=>{rt.defineBoolean(PBRMaterial,[`use_${e}`]),rt.definePositiveNumber(PBRMaterial,[[`${e}_KHR_texture_transform_rotation`,0]]),rt.defineBoolean(PBRMaterial,[`use_${e}_KHR_texture_transform`]),rt.defineVec2(PBRMaterial,[`${e}_KHR_texture_transform_offset`,[`${e}_KHR_texture_transform_scale`,[1,1]]]),rt.defineUint(PBRMaterial,[`${e}_texCoord_index`]),rt.defineTexture(PBRMaterial,[e]),t&&rt.defineSampler(PBRMaterial,[`${e}Sampler`])}))})(r,!n),i?.forEach((e=>{rt.definePositiveNumber(PBRMaterial,[e])})),s?.forEach((e=>{rt.defineVec3(PBRMaterial,[e])})),a?.forEach((e=>{rt.defineVec4(PBRMaterial,[e])}))})),rt.definePositiveNumber(PBRMaterial,[["cutOff",0],["KHR_materials_ior",1.5],["KHR_dispersion",0]]),rt.defineUint(PBRMaterial,["alphaBlend"]),rt.defineBoolean(PBRMaterial,["doubleSided","useCutOff","useVertexColor","useVertexTangent","useKHR_materials_unlit"]),Object.freeze(PBRMaterial);var _t="#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include drawDirectionalShadowDepth;\r\nstruct VertexUniforms {\rpickingId:u32,\r\n\t modelMatrix:mat4x4<f32>,\r\n\t normalModelMatrix:mat4x4<f32>,\r\n\t useDisplacementTexture:u32,\r\n\t displacementScale:f32,\r\n\t receiveShadow:f32,\rcombinedOpacity:f32,\r\n};\r\nconst maxDistance:f32=1000.0;\r\nconst maxMipLevel:f32=10.0;\r\n\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n@group(1) @binding(1) var displacementTextureSampler:sampler;\r\n@group(1) @binding(2) var displacementTexture:texture_2d<f32>;\r\n\r\nstruct InputData {\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r\n};\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(14) receiveShadow:f32,\r@location(15) pickingId:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn main( inputData:InputData ) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_resolution=systemUniforms.resolution;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\rlet u_displacementScale=vertexUniforms.displacementScale;\rlet u_useDisplacementTexture=vertexUniforms.useDisplacementTexture==1u;\rlet u_receiveShadow=vertexUniforms.receiveShadow;\r\rlet u_directionalLightCount=systemUniforms.directionalLightCount;\rlet u_directionalLights=systemUniforms.directionalLights;\rlet u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix;\r\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\rposition=u_modelMatrix * vec4<f32>(input_position,1.0);\r\n\rif (u_useDisplacementTexture) {\rlet distance=distance(position.xyz,u_cameraPosition);\rlet mipLevel=(distance/maxDistance) * maxMipLevel;\rlet displacementSample=textureSampleLevel(displacementTexture,displacementTextureSampler,input_uv,mipLevel).r;\rlet scaledDisplacement=displacementSample * u_displacementScale;\rlet displacedPosition=input_position + input_vertexNormal * scaledDisplacement;\r\n\rposition=u_modelMatrix * vec4<f32>(displacedPosition,1.0);\rnormalPosition=u_normalModelMatrix * vec4<f32>(input_vertexNormal * scaledDisplacement,1.0);\r} else {\rnormalPosition=u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0);\r}\r\n\r\n\routput.position=u_projectionMatrix * u_cameraMatrix * position;\routput.vertexPosition=position.xyz;\routput.vertexNormal=normalPosition.xyz;\routput.uv=input_uv;\rvar posFromLight= u_directionalLightProjectionViewMatrix * vec4(position.xyz,1.0);\r\r\routput.shadowPos=vec3(\rposFromLight.xy * vec2(0.5,-0.5) + vec2(0.5),\rposFromLight.z\r);\routput.receiveShadow=u_receiveShadow;\routput.combinedOpacity=vertexUniforms.combinedOpacity;\r\n\r\n\rreturn output;\r\n}\r\n\r\n@vertex\r\nfn picking(inputData:InputData) -> OutputData {\rvar output:OutputData;\rlet input_position=inputData.position;\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rvar position:vec4<f32>=u_modelMatrix * vec4<f32>(input_position,1.0);\routput.position=u_projectionMatrix * u_cameraMatrix * position;\routput.pickingId=unpack4x8unorm(vertexUniforms.pickingId);\rreturn output;\r\n}\r\n",xt="#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include drawDirectionalShadowDepth;\r\nstruct VertexUniforms {\rpickingId:u32,\rlocalMatrix:mat4x4<f32>,\rmodelMatrix:mat4x4<f32>,\rnormalModelMatrix:mat4x4<f32>,\ruseDisplacementTexture:u32,\rdisplacementScale:f32,\rreceiveShadow:f32\r\n};\r\nconst maxDistance:f32=1000.0;\r\nconst maxMipLevel:f32=10.0;\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n@group(1) @binding(1) var displacementTextureSampler:sampler;\r\n@group(1) @binding(2) var displacementTexture:texture_2d<f32>;\r\n\r\nstruct InputData {\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(3) uv1:vec2<f32>,\r@location(4) vertexColor_0:vec4<f32>,\r@location(5) vertexWeight:vec4<f32>,\r@location(6) vertexJoint:vec4<f32>,\r@location(7) vertexTangent:vec4<f32>,\r\n};\r\n\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(3) uv1:vec2<f32>,\r@location(4) vertexColor_0:vec4<f32>,\r@location(5) vertexTangent:vec4<f32>,\r@location(6) shadowPos:vec3<f32>,\r@location(7) receiveShadow:f32,\r@location(8) pickingId:vec4<f32>,\r@location(9) ndcPosition:vec3<f32>,\r@location(10) localNodeScale:f32,\r@location(11) volumeScale:f32,\r\n};\r\n@vertex\r\nfn main(inputData:InputData) -> OutputData {\rvar output:OutputData;\r\n\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\r\n\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_localMatrix=vertexUniforms.localMatrix;\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\rlet u_directionalLightCount=systemUniforms.directionalLightCount;\rlet u_directionalLights=systemUniforms.directionalLights;\rlet u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix;\rlet u_receiveShadow=vertexUniforms.receiveShadow;\r\n\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\r\n\rposition= u_modelMatrix * vec4<f32>(input_position,1.0);\rnormalPosition= u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0);\r\n\routput.position=u_projectionMatrix * u_cameraMatrix * position;\routput.vertexPosition=position.xyz;\routput.vertexNormal=normalPosition.xyz;\routput.uv=inputData.uv;\routput.uv1=inputData.uv1;\routput.vertexColor_0=inputData.vertexColor_0;\routput.vertexTangent=u_normalModelMatrix * inputData.vertexTangent;\r\n\rlet viewDirection=normalize(position.xyz - u_cameraPosition);\r\n\r\n\rvar posFromLight= u_directionalLightProjectionViewMatrix * vec4(position.xyz,1.0);\r\r\routput.shadowPos=vec3(\rposFromLight.xy * vec2(0.5,-0.5) + vec2(0.5),\rposFromLight.z\r);\routput.receiveShadow=u_receiveShadow;\routput.ndcPosition=output.position.xyz/output.position.w;\r\n\r\nlet nodeScaleX:f32=length(u_localMatrix[0].xyz);\r\nlet nodeScaleY:f32=length(u_localMatrix[1].xyz);\r\nlet nodeScaleZ=length(u_localMatrix[2].xyz);\r\noutput.localNodeScale=pow(nodeScaleX * nodeScaleY * nodeScaleZ,1.0/3.0);\r\n\r\nlet volumeScaleX:f32=length(u_modelMatrix[0].xyz);\r\nlet volumeScaleY:f32=length(u_modelMatrix[1].xyz);\r\nlet volumeScaleZ=length(u_modelMatrix[2].xyz);\r\noutput.volumeScale=pow(volumeScaleX * volumeScaleY * volumeScaleZ,1.0/3.0);\rreturn output;\r\n}\r\n\r\n@vertex\r\nfn picking(inputData:InputData) -> OutputData {\rvar output:OutputData;\rlet input_position=inputData.position;\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rvar position:vec4<f32>=u_modelMatrix * vec4<f32>(input_position,1.0);\routput.position=u_projectionMatrix * u_cameraMatrix * position;\routput.pickingId=unpack4x8unorm(vertexUniforms.pickingId);\rreturn output;\r\n}\r\n";class ResourceStateStorageBuffer{static dirtyList=[];buffer;uuid;#_=0;constructor(e){this.buffer=e,this.uuid=e.uuid}get useNum(){return this.#_}set useNum(e){this.#_=e,ResourceStateStorageBuffer.dirtyList.push(this)}}class StorageBuffer extends AUniformBaseBuffer{constructor(e,t,r="",n=""){super(e,"managedStorageBufferState",GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,t,r);const i=getCacheBufferFromResourceState(this,n);if(i)return i;n&&(this.name=n),basicRegisterResource(this,new ResourceStateStorageBuffer(this))}}Object.freeze(StorageBuffer);const getBasicMeshVertexBindGroupDescriptor=(e,t=!1)=>{const{redGPUContext:r,gpuRenderInfo:n,material:i}=e,{resourceManager:s}=r,{vertexUniformBuffer:a,vertexBindGroupLayout:o}=n,{basicSampler:u,emptyBitmapTextureView:l,emptyCubeTextureView:c}=s,{gpuSampler:h}=u;return{layout:o,label:t?"VERTEX_BIND_GROUP_DESCRIPTOR_MESH_SKIN":"VERTEX_BIND_GROUP_DESCRIPTOR_MESH",entries:t?[{binding:0,resource:{buffer:a.gpuBuffer,offset:0,size:a.size}},{binding:1,resource:getGPUResourceSampler(i?.displacementTextureSampler)||h},{binding:2,resource:getGPUResourceBitmapTextureView(i?.displacementTexture)||l},{binding:3,resource:{buffer:e.animationInfo.skinInfo.vertexStorageBuffer.gpuBuffer,offset:0,size:e.animationInfo.skinInfo.vertexStorageBuffer.size}}]:[{binding:0,resource:{buffer:a.gpuBuffer,offset:0,size:a.size}},{binding:1,resource:getGPUResourceSampler(i?.displacementTextureSampler)||h},{binding:2,resource:getGPUResourceBitmapTextureView(i?.displacementTexture)||l}]}},getGPUResourceBitmapTextureView=e=>e?.gpuTexture?.createView({label:e.src}),getGPUResourceSampler=e=>e?.gpuSampler,vt=parseWGSL(xt),Tt=vt.uniforms.vertexUniforms,yt=parseWGSL(_t),bt=yt.uniforms.vertexUniforms,createMeshVertexShaderModule=e=>{const{material:t}=e;let r;return r=t instanceof PBRMaterial?e.animationInfo.skinInfo?((e,t)=>{const{redGPUContext:r,currentShaderModuleName:n}=t,{resourceManager:i}=r,{gpuRenderInfo:s}=t,a=`${t.animationInfo.skinInfo.joints.length}`,o=`${e}_${a}`,u="#redgpu_include SYSTEM_UNIFORM;\r\nstruct VertexUniforms {\rpickingId:u32,\rlocalMatrix:mat4x4<f32>,\rmodelMatrix:mat4x4<f32>,\rnormalModelMatrix:mat4x4<f32>,\ruseDisplacementTexture:u32,\rdisplacementScale:f32,\rreceiveShadow:f32\r\n};\r\nstruct VertexStorages {\rjointMatrix:array<mat4x4<f32>,#JOINT_NUM>,\r\n};\r\nconst maxDistance:f32=1000.0;\r\nconst maxMipLevel:f32=10.0;\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n@group(1) @binding(1) var displacementTextureSampler:sampler;\r\n@group(1) @binding(2) var displacementTexture:texture_2d<f32>;\r\n@group(1) @binding(3) var<storage,read> vertexStorages:VertexStorages;\r\nstruct InputDataSkin {\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(3) uv1:vec2<f32>,\r@location(4) vertexColor_0:vec4<f32>,\r@location(5) vertexWeight:vec4<f32>,\r@location(6) vertexJoint:vec4<f32>,\r@location(7) vertexTangent:vec4<f32>,\r\n};\r\nstruct OutputDataSkin {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(3) uv1:vec2<f32>,\r@location(4) vertexColor_0:vec4<f32>,\r@location(5) vertexTangent:vec4<f32>,\r@location(6) shadowPos:vec3<f32>,\r@location(7) receiveShadow:f32,\r@location(8) pickingId:vec4<f32>,\r\n\r@location(9) ndcPosition:vec3<f32>,\r@location(10) localNodeScale:f32,\r@location(11) volumeScale:f32,\r\n};\r\n\r\nstruct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\n\r\n\r\n@vertex\r\nfn main( inputData:InputDataSkin ) -> OutputDataSkin {\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\r\rlet u_localMatrix=vertexUniforms.localMatrix;\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\n\r\rlet u_directionalLightCount=systemUniforms.directionalLightCount;\rlet u_directionalLights=systemUniforms.directionalLights;\rlet u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix;\rlet u_receiveShadow=vertexUniforms.receiveShadow;\r\n\rvar output:OutputDataSkin;\rvar skinMat:mat4x4<f32>;\rlet vertexJoint:vec4<f32>=inputData.vertexJoint;\rlet vertexWeight:vec4<f32>=inputData.vertexWeight;\rlet jointMatrix=vertexStorages.jointMatrix;\rskinMat=vertexWeight.x * jointMatrix[ u32(vertexJoint.x) ]+\rvertexWeight.y * jointMatrix[ u32(vertexJoint.y) ]+\rvertexWeight.z * jointMatrix[ u32(vertexJoint.z) ]+\rvertexWeight.w * jointMatrix[ u32(vertexJoint.w) ];\r\n\r\n\rlet position= u_modelMatrix * skinMat * vec4<f32>(inputData.position,1.0);\rlet normalPosition= u_normalModelMatrix * skinMat * vec4<f32>(inputData.vertexNormal,1.0);\r\n\routput.position=u_projectionCameraMatrix * position;\routput.vertexPosition=position.xyz;\routput.vertexNormal=normalPosition.xyz;\routput.uv=inputData.uv;\routput.uv1=inputData.uv1;\routput.vertexColor_0=inputData.vertexColor_0;\r\n\routput.vertexTangent=u_normalModelMatrix * inputData.vertexTangent;\r\n\rvar posFromLight= u_directionalLightProjectionViewMatrix * position;\r\r\routput.shadowPos=vec3<f32>(\rposFromLight.xy * vec2<f32>(0.5,-0.5) + vec2<f32>(0.5),\rposFromLight.z\r);\routput.receiveShadow=u_receiveShadow;\r\n\rlet nodeScaleX:f32=length(u_localMatrix[0].xyz);\rlet nodeScaleY:f32=length(u_localMatrix[1].xyz);\rlet nodeScaleZ:f32=length(u_localMatrix[2].xyz);\routput.localNodeScale=pow(nodeScaleX * nodeScaleY * nodeScaleZ,1.0/3.0);\r\n\rlet volumeScaleX:f32=length(u_modelMatrix[0].xyz);\rlet volumeScaleY:f32=length(u_modelMatrix[1].xyz);\rlet volumeScaleZ:f32=length(u_modelMatrix[2].xyz);\routput.volumeScale=pow(volumeScaleX * volumeScaleY * volumeScaleZ,1.0/3.0);\rreturn output;\r\n}\r\n\r\n@vertex\r\nfn drawDirectionalShadowDepth( inputData:InputDataSkin ) -> OutputShadowData {\rvar output:OutputShadowData;\rlet u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix;\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet input_position=inputData.position;\rvar position:vec4<f32>;\r\n\rvar skinMat:mat4x4<f32>=mat4x4<f32>(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0);\rvar vertexJoint:vec4<f32>=inputData.vertexJoint;\rvar vertexWeight:vec4<f32>=inputData.vertexWeight;\rvar jointMatrix=vertexStorages.jointMatrix;\rskinMat=\r\n\rvertexWeight.x * jointMatrix[ u32(vertexJoint.x) ]+\rvertexWeight.y * jointMatrix[ u32(vertexJoint.y) ]+\rvertexWeight.z * jointMatrix[ u32(vertexJoint.z) ]+\rvertexWeight.w * jointMatrix[ u32(vertexJoint.w) ];\r\n\rposition= u_modelMatrix * skinMat * vec4<f32>(input_position,1.0);\routput.position=u_directionalLightProjectionViewMatrix * position;\rreturn output;\r\n}\r\n@vertex\r\nfn picking(inputData:InputDataSkin) -> OutputDataSkin {\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_modelMatrix=vertexUniforms.modelMatrix;\r\rvar output:OutputDataSkin;\rvar skinMat:mat4x4<f32>=mat4x4<f32>(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0);\rvar vertexJoint:vec4<f32>=inputData.vertexJoint;\rvar vertexWeight:vec4<f32>=inputData.vertexWeight;\rvar jointMatrix=vertexStorages.jointMatrix;\rskinMat=\r\n\rvertexWeight.x * jointMatrix[ u32(vertexJoint.x) ]+\rvertexWeight.y * jointMatrix[ u32(vertexJoint.y) ]+\rvertexWeight.z * jointMatrix[ u32(vertexJoint.z) ]+\rvertexWeight.w * jointMatrix[ u32(vertexJoint.w) ];\r\n\r\n\rvar position:vec4<f32>;\rposition= u_modelMatrix * skinMat * vec4<f32>(inputData.position,1.0);\routput.position=u_projectionMatrix * u_cameraMatrix * position;\routput.pickingId=unpack4x8unorm(vertexUniforms.pickingId);\rreturn output;\r\n}\r\n",l={code:u};if(n===o)return i.getGPUShaderModule(o);if(l.code=u.replaceAll("#JOINT_NUM",a),s.vertexUniformInfo=parseWGSL(l.code).uniforms.vertexUniforms,t.animationInfo.skinInfo){createMeshVertexUniformBuffers(t,!0),t.animationInfo.skinInfo.vertexStorageInfo=parseWGSL(l.code).storage.vertexStorages;const e=new ArrayBuffer(t.animationInfo.skinInfo.vertexStorageInfo.arrayBufferByteLength);t.animationInfo.skinInfo.vertexStorageBuffer=new StorageBuffer(t.redGPUContext,e,t.name),s.vertexUniformBindGroup=r.gpuDevice.createBindGroup(getBasicMeshVertexBindGroupDescriptor(t,!0))}else createMeshVertexUniformBuffers(t),s.vertexUniformBindGroup=r.gpuDevice.createBindGroup(getBasicMeshVertexBindGroupDescriptor(t));return i.createGPUShaderModule(o,l)})("VERTEX_MODULE_MESH_PBR_SKIN",e):e.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_MESH_PBR",vt,Tt,xt):e.createCustomMeshVertexShaderModule?e.createCustomMeshVertexShaderModule():e.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_MESH",yt,bt,_t),e.currentShaderModuleName=r.label,r},St={NEVER:"never",LESS:"less",EQUAL:"equal",LESS_EQUAL:"less-equal",GREATER:"greater",NOT_EQUAL:"not-equal",GREATER_EQUAL:"greater-equal",ALWAYS:"always"};Object.freeze(St);const Mt="shadow",Rt="picking",createBasePipeline=(e,t,r,n)=>{const{redGPUContext:i}=e,{gpuDevice:s}=i,a=e.material.gpuRenderInfo;let o,u;switch(n){case Mt:o="drawDirectionalShadowDepth",u=`${t.label}_shadow_pipelineDescriptor`;break;case Rt:o="picking",u=`${t.label}_picking_pipelineDescriptor`;break;default:o="main",u=`${t.label}_pipelineDescriptor`}const l={module:t,entryPoint:o,buffers:e.vertexStateBuffers},c=[i.resourceManager.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),r];n!==Mt&&c.push(a.fragmentBindGroupLayout);const h={bindGroupLayouts:c},d={label:u,layout:s.createPipelineLayout(h),vertex:l,primitive:e.primitiveState.state};switch(n){case Mt:d.depthStencil={depthWriteEnabled:!0,depthCompare:St.LESS_EQUAL,format:"depth32float"};break;case Rt:e.material&&(d.fragment={module:e.material.gpuRenderInfo.fragmentShaderModule,entryPoint:"picking",targets:[{format:navigator.gpu.getPreferredCanvasFormat()}]},d.depthStencil=e.depthStencilState.state);break;default:d.fragment=a.fragmentState,d.depthStencil=e.depthStencilState.state,d.multisample={count:i.useMSAA?4:1}}return s.createRenderPipeline(d)},updateMeshDirtyPipeline=(e,t)=>{const{material:r,gpuRenderInfo:n,redGPUContext:i}=e,{resourceManager:s}=i;e.dirtyTransform=!0,r.dirtyPipeline&&r._updateFragmentState();const a=createMeshVertexShaderModule(e),o=s.getGPUBindGroupLayout(e.animationInfo.skinInfo?ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_SKIN:ResourceManager.PRESET_VERTEX_GPUBindGroupLayout);n.vertexShaderModule=a,n.pipeline=createBasePipeline(e,a,o),n.shadowPipeline=e.gpuRenderInfo.vertexStructInfo.vertexEntries.includes("drawDirectionalShadowDepth")?createBasePipeline(e,a,o,Mt):null,n.pickingPipeline=e.gpuRenderInfo.vertexStructInfo.vertexEntries.includes("picking")?createBasePipeline(e,a,o,Rt):null;const{vertexUniformInfo:u}=e.gpuRenderInfo,{members:l}=u;for(const t in l)"pickingId"!==t&&(e[t]=e[t]);e.gpuRenderInfo.vertexUniformInfo.members.pickingId&&e.gpuRenderInfo.vertexUniformBuffer.writeBuffer(e.gpuRenderInfo.vertexUniformInfo.members.pickingId,e.pickingId),r.dirtyPipeline=!1,e.dirtyPipeline=!1,t&&t.numDirtyPipelines++},wt=Object.values(St);class DepthStencilState{state;#Tt;#Q="depth24plus";#yt=["r8unorm","r8snorm","r8uint","r8sint","r16uint","r16sint","r16float","rg8unorm","rg8snorm","rg8uint","rg8sint","r32uint","r32sint","r32float","rg16uint","rg16sint","rg16float","rgba8unorm","rgba8unorm-srgb","rgba8snorm","rgba8uint","rgba8sint","bgra8unorm","bgra8unorm-srgb","rgb9e5ufloat","rgb10a2uint","rgb10a2unorm","rg11b10ufloat","rg32uint","rg32sint","rg32float","rgba16uint","rgba16sint","rgba16float","rgba32uint","rgba32sint","rgba32float","stencil8","depth16unorm","depth24plus","depth24plus-stencil8","depth32float","depth32float-stencil8","bc1-rgba-unorm","bc1-rgba-unorm-srgb","bc2-rgba-unorm","bc2-rgba-unorm-srgb","bc3-rgba-unorm","bc3-rgba-unorm-srgb","bc4-r-unorm","bc4-r-snorm","bc5-rg-unorm","bc5-rg-snorm","bc6h-rgb-ufloat","bc6h-rgb-float","bc7-rgba-unorm","bc7-rgba-unorm-srgb","etc2-rgb8unorm","etc2-rgb8unorm-srgb","etc2-rgb8a1unorm","etc2-rgb8a1unorm-srgb","etc2-rgba8unorm","etc2-rgba8unorm-srgb","eac-r11unorm","eac-r11snorm","eac-rg11unorm","eac-rg11snorm","astc-4x4-unorm","astc-4x4-unorm-srgb","astc-5x4-unorm","astc-5x4-unorm-srgb","astc-5x5-unorm","astc-5x5-unorm-srgb","astc-6x5-unorm","astc-6x5-unorm-srgb","astc-6x6-unorm","astc-6x6-unorm-srgb","astc-8x5-unorm","astc-8x5-unorm-srgb","astc-8x6-unorm","astc-8x6-unorm-srgb","astc-8x8-unorm","astc-8x8-unorm-srgb","astc-10x5-unorm","astc-10x5-unorm-srgb","astc-10x6-unorm","astc-10x6-unorm-srgb","astc-10x8-unorm","astc-10x8-unorm-srgb","astc-10x10-unorm","astc-10x10-unorm-srgb","astc-12x10-unorm","astc-12x10-unorm-srgb","astc-12x12-unorm","astc-12x12-unorm-srgb"];#bt=!0;#St=St.LESS_EQUAL;#Mt;#Rt;#wt;#Pt;#Et;#kt;#Ct;constructor(e){this.#Tt=e,this.#qe()}get format(){return this.#Q}set format(e){this.#yt.includes(e)?(this.#Q=e,this.#qe()):consoleAndThrowError(`Invalid value for format. Received ${e}. Expected one of:${this.#yt.join(",")}`)}get depthWriteEnabled(){return this.#bt}set depthWriteEnabled(e){this.#bt=e,this.#qe()}get depthCompare(){return this.#St}set depthCompare(e){wt.includes(e)?(this.#St=e,this.#qe()):consoleAndThrowError(`Invalid value for depthCompare. Received ${e}. Expected one of:${wt.join(",")}`)}get stencilFront(){return this.#Mt}set stencilFront(e){this.#Mt=e,this.#qe()}get stencilBack(){return this.#Rt}set stencilBack(e){this.#Rt=e,this.#qe()}get stencilReadMask(){return this.#wt}set stencilReadMask(e){this.#wt=e,this.#qe()}get stencilWriteMask(){return this.#Pt}set stencilWriteMask(e){this.#Pt=e,this.#qe()}get depthBias(){return this.#Et}set depthBias(e){this.#Et=e,this.#qe()}get depthBiasSlopeScale(){return this.#kt}set depthBiasSlopeScale(e){this.#kt=e,this.#qe()}get depthBiasClamp(){return this.#Ct}set depthBiasClamp(e){this.#Ct=e,this.#qe()}#qe(){this.state={format:this.#Q,depthWriteEnabled:this.#bt,depthCompare:this.#St,stencilFront:this.#Mt,stencilBack:this.#Rt,stencilReadMask:this.#wt,stencilWriteMask:this.#Pt,depthBias:this.#Et,depthBiasSlopeScale:this.#kt,depthBiasClamp:this.#Ct},this.#Tt.dirtyPipeline=!0}}const Pt={NONE:"none",FRONT:"front",BACK:"back"};Object.freeze(Pt);const Et={CW:"cw",CCW:"ccw"};Object.freeze(Et);const kt={UINT16:"uint16",UINT32:"uint32"};Object.freeze(kt);const Ct={POINT_LIST:"point-list",LINE_LIST:"line-list",LINE_STRIP:"line-strip",TRIANGLE_LIST:"triangle-list",TRIANGLE_STRIP:"triangle-strip"};Object.freeze(Ct);const Lt=Object.values(kt),Bt=Object.values(Et),It=Object.values(Pt),Ut=["point-list","line-list","line-strip","triangle-list","triangle-strip"];class PrimitiveState{dirtyPipeline=!1;state;#Tt;#Lt=Ct.TRIANGLE_LIST;#Bt;#It=Et.CCW;#Ut=Pt.BACK;#At=!1;constructor(e){this.#Tt=e,this.#qe()}get topology(){return this.#Lt}set topology(e){Ut.includes(e)?(this.#Lt=e,this.#qe()):consoleAndThrowError(`Invalid value for topology. Received ${e}. Expected one of:${Ut.join(",")}`)}get stripIndexFormat(){return this.#Bt}set stripIndexFormat(e){Lt.includes(e)?(this.#Bt=e,this.#qe()):consoleAndThrowError(`Invalid value for stripIndexFormat. Received ${e}. Expected one of:${Lt.join(",")}`)}get frontFace(){return this.#It}set frontFace(e){Bt.includes(e)?(this.#It=e,this.#qe()):consoleAndThrowError(`Invalid value for frontFace. Received ${e}. Expected one of:${Bt.join(",")}`)}get cullMode(){return this.#Ut}set cullMode(e){It.includes(e)?(this.#Ut=e,this.#qe()):consoleAndThrowError(`Invalid value for cullMode. Received ${e}. Expected one of:${It.join(",")}`)}get unclippedDepth(){return this.#At}set unclippedDepth(e){"boolean"==typeof e?(this.#At=e,this.#qe()):consoleAndThrowError(`Invalid type for unclippedDepth. Received ${typeof e}. Expected type:boolean.`)}#qe(){this.state={topology:this.#Lt,stripIndexFormat:this.#Bt,frontFace:this.#It,cullMode:this.#Ut,unclippedDepth:this.#At},this.#Tt.dirtyPipeline=!0}}const At=create$5(),Dt={x:0,y:0,z:0,w:0},getScreenPoint=(e,t)=>{"View"!==e?.constructor?.name&&consoleAndThrowError("allow only View3D instance"),identity$2(At);const{projectionMatrix:r,rawCamera:n,pixelRectArray:i}=e;return multiply$5(At,r,n.modelMatrix),multiply$5(At,At,t),Dt.z=At[14],Dt.w=At[15],Dt.x=.5*At[12]/Dt.w+.5,Dt.y=.5*At[13]/Dt.w+.5,[(i[0]+Dt.x*i[2])/window.devicePixelRatio,(i[1]+(1-Dt.y)*i[3])/window.devicePixelRatio]},Nt=create$5(),localToWorld=(e,t,r,n)=>(validateNumber(t),validateNumber(r),validateNumber(n),identity$2(Nt),translate$1(Nt,Nt,[t,r,n]),multiply$5(Nt,e,Nt),[Nt[12],Nt[13],Nt[14]]),Ot=create$5(),Gt=create$5(),worldToLocal=(e,t,r,n)=>(validateNumber(t),validateNumber(r),validateNumber(n),identity$2(Ot),identity$2(Gt),translate$1(Ot,Ot,[t,r,n]),multiply$5(Gt,Ot,e),[Gt[0]*t+Gt[1]*r+Gt[2]*n+Gt[3],Gt[4]*t+Gt[5]*r+Gt[6]*n+Gt[7],Gt[8]*t+Gt[9]*r+Gt[10]*n+Gt[11]]);class Object3DContainer{modelMatrix=create$5();#Dt=[];constructor(){}get children(){return this.#Dt}get numChildren(){return this.#Dt.length}contains(e){return this.#Nt(e),this.#Dt.includes(e)}addChild(e){return this.#Nt(e),this.#Ot(e)?(this.#Dt.push(e),e.dirtyTransform=!0,e):null}addChildAt(e,t){if(validateUintRange(t),this.#Dt.length<t&&(t=this.#Dt.length),!(t<0||t>this.#Dt.length)&&this.#Ot(e))return this.#Dt.splice(t,0,e),e.dirtyTransform=!0,this}getChildAt(e){if(validateUintRange(e),!(e>=this.#Dt.length||e<0))return this.#Dt[e]}getChildIndex(e){this.#Nt(e);const t=this.#Dt.indexOf(e);return-1===t?-1:t}setChildIndex(e,t){this.#Nt(e),validateUintRange(t);const r=this.#Dt.length,n=t>=r,i=this.#Dt.indexOf(e);-1!==i?n?consoleAndThrowError(`Invalid index. Index ${t} is out of bounds. Index should be between 0 and ${r-1}.`):(this.#Dt.splice(i,1),this.#Dt.splice(t,0,e)):consoleAndThrowError(`The provided is not a child of the Object3DContainer.:${e}`)}swapChildren(e,t){if(this.#Nt(e),this.#Nt(t),e===t)return void consoleAndThrowError("Error:child1 and child2 are the same. Cannot swap a child with itself.");const r=this.#Dt.indexOf(e),n=this.#Dt.indexOf(t);-1!==r&&-1!==n||consoleAndThrowError(`Error:${-1===r?"child1":"child2"} is not a child of this Object3DContainer.`),this.swapChildrenAt(r,n)}swapChildrenAt(e,t){validateUintRange(e),validateUintRange(t),e===t&&consoleAndThrowError("Error:index1 and index2 are identical. Cannot swap a child with itself.");const r=this.#Dt.length;(e>=r||t>=r)&&consoleAndThrowError(`Error:Both index1 and index2 should be less than the number of children. Provided index1:${e},index2:${t},number of children:${r}`);let n=this.#Dt[e];this.#Dt[e]=this.#Dt[t],this.#Dt[t]=n}removeChild(e){this.#Nt(e);const t=this.#Dt.indexOf(e);if(t>-1)return e.parent=null,this.#Dt.splice(t,1)[0];consoleAndThrowError("Error:Child not found within parent.")}removeChildAt(e){validateUintRange(e);const t=this.#Dt[e];if(t)return t.parent=null,this.#Dt.splice(e,1)[0];throw new Error(`Error:No child found at provided index:${e}.`)}removeAllChildren(){let e=this.#Dt.length;for(;e--;)this.#Dt[e].parent=null;return this.#Dt.length=0,this}#Nt(e){e instanceof Object3DContainer||consoleAndThrowError("allow only Object3DContainer instance.")}#Ot=e=>(this.#Nt(e),e.parent?!!e.parent?.removeChild(e)&&(e.parent=this,!0):(e.parent=this,!0))}class MeshBase extends Object3DContainer{gpuRenderInfo;animationInfo={skinInfo:null,morphInfo:null,animationsList:null};gltfLoaderInfo;dirtyPipeline=!0;dirtyTransform=!0;dirtyOpacity=!0;modelMatrix=create$5();localMatrix=create$5();normalModelMatrix=create$5();castShadow=!1;#v;#T;#Gt;#Vt;#Ft;#y=[];#x=createUUID();constructor(e){super(),validateRedGPUContext(e),this.#v=e,this.#T=e.gpuDevice,this.#Gt=new PrimitiveState(this),this.#Vt=new DepthStencilState(this)}get uuid(){return this.#x}get currentShaderModuleName(){return this.#Ft}set currentShaderModuleName(e){this.#Ft=e}get primitiveState(){return this.#Gt}get depthStencilState(){return this.#Vt}get gpuDevice(){return this.#T}get redGPUContext(){return this.#v}worldToLocal(e,t,r){return worldToLocal(this.modelMatrix,e,t,r)}localToWorld(e,t,r){return localToWorld(this.modelMatrix,e,t,r)}getScreenPoint(e){return getScreenPoint(e,this.modelMatrix)}__fireListenerList(e=!1){for(const e of this.#y)e(this);e&&(this.#y.length=0)}}const Vt="VERTEX_MODULE_MESH_PBR_SKIN",Ft=Math.PI/180,Ht=3.141592653589793,zt=6.283185307179586,Kt=.225,$t=1.27323954,Xt=.405284735,jt=1.5707963267948966;class Mesh extends MeshBase{displacementTexture;#Ht=!0;#e;#s;#zt;#r=0;#i=0;#n=0;#Kt=[0,0,0];#$t=0;#Xt=0;#jt=0;#Yt;#Zt=1;#qt=1;#Wt=1;#Jt=[1,1,1];#o=0;#u=0;#l=0;#Qt=[0,0,0];#er={};#tr=0;#rr=!1;#nr=1;constructor(e,t,r,n){super(e),n&&(this.name=n),this._geometry=t,this._material=r,this.#Yt=uuidToUint(this.uuid)}_material;get material(){return this._material}set material(e){this._material=e,this.dirtyPipeline=!0,"blendMode"in this&&(this.blendMode=this.blendMode)}_geometry;get geometry(){return this._geometry}set geometry(e){this._geometry=e,this.dirtyPipeline=!0,this.dirtyTransform=!0}get opacity(){return this.#nr}set opacity(e){validatePositiveNumberRange(e,0,1),this.#nr=e,this.dirtyOpacity=!0}get ignoreFrustumCulling(){return this.#rr}set ignoreFrustumCulling(e){this.#rr=e}get pickingId(){return this.#Yt}get events(){return this.#er}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#s||`${this.constructor.name} Instance ${this.#e}`}set name(e){this.#s=e}get vertexStateBuffers(){return this._geometry.gpuRenderInfo.buffers}get parent(){return this.#zt}set parent(e){this.#zt=e}get pivotX(){return this.#$t}set pivotX(e){this.#$t=e,this.dirtyTransform=!0}get pivotY(){return this.#Xt}set pivotY(e){this.#Xt=e,this.dirtyTransform=!0}get pivotZ(){return this.#jt}set pivotZ(e){this.#jt=e,this.dirtyTransform=!0}get x(){return this.#r}set x(e){this.#r=this.#Kt[0]=e,this.dirtyTransform=!0}get y(){return this.#n}set y(e){this.#n=this.#Kt[1]=e,this.dirtyTransform=!0}get z(){return this.#i}set z(e){this.#i=this.#Kt[2]=e,this.dirtyTransform=!0}get position(){return this.#Kt}get scaleX(){return this.#Zt}set scaleX(e){this.#Zt=this.#Jt[0]=e,this.dirtyTransform=!0}get scaleY(){return this.#qt}set scaleY(e){this.#qt=this.#Jt[1]=e,this.dirtyTransform=!0}get scaleZ(){return this.#Wt}set scaleZ(e){this.#Wt=this.#Jt[2]=e,this.dirtyTransform=!0}get scale(){return this.#Kt}get rotationX(){return this.#o}set rotationX(e){this.#o=this.#Qt[0]=e,this.dirtyTransform=!0}get rotationY(){return this.#u}set rotationY(e){this.#u=this.#Qt[1]=e,this.dirtyTransform=!0}get rotationZ(){return this.#l}set rotationZ(e){this.#l=this.#Qt[2]=e,this.dirtyTransform=!0}get rotation(){return this.#Qt}getCombinedOpacity(){if(this.is2DMeshType){const e=this.parent;return this.#nr*(e?.getCombinedOpacity?e.getCombinedOpacity():1)}return 1}addListener(e,t){this.#er[e]=t,this.#tr=Object.keys(this.#er).length}setScale(e,t,r){t=t??e,r=r??e;const n=this.#Jt;this.#Zt=n[0]=e,this.#qt=n[1]=t,this.#Wt=n[2]=r,this.dirtyTransform=!0}setPosition(e,t,r){t=t??e,r=r??e;const n=this.#Kt;this.#r=n[0]=e,this.#n=n[1]=t,this.#i=n[2]=r,this.dirtyTransform=!0}setRotation(e,t,r){t=t??e,r=r??e;const n=this.#Qt;this.#o=n[0]=e,this.#u=n[1]=t,this.#l=n[2]=r,this.dirtyTransform=!0}clone(){const e=new Mesh(this.redGPUContext,this._geometry,this._material);e.setPosition(this.#r,this.#n,this.#i),e.setRotation(this.#o,this.#u,this.#l),e.setScale(this.#Zt,this.#qt,this.#Wt);let t=this.children.length;for(;t--;)e.addChild(this.children[t].clone());return e}render(e){const{redGPUContext:t}=this,{view:r,isScene2DMode:n,currentRenderPassEncoder:i,timestamp:s,frustumPlanes:a,dirtyVertexUniformFromMaterial:o,useDistanceCulling:u,cullingDistanceSquared:l,distanceCulling:c}=e,{scene:h}=r,{shadowManager:d}=h,{pickingManager:m}=r,{castingList:p}=d,f=this._geometry,g=this._material,{uuid:_}=g||{};let x,v;if(n&&(this.#i=0,this.#jt=0,this.depthStencilState.depthWriteEnabled&&(this.depthStencilState.depthWriteEnabled=!1)),this.dirtyTransform){x=!0;{const{pixelRectObject:e}=r,t=this.parent,i=this.localMatrix;let s,a,o,u,l,c,h,d,m,p,f,g,_,x,v,T,y,b,S,M,R,w,P,E,k,C,L,B,I,U,A,D,N,O,G,V,F,H,z;if(i[12]=this.#r,i[13]=this.#n,i[14]=this.#i,i[15]=1,s=this.#o*Ft,a=this.#u*Ft,o=this.#l*Ft,P=1,E=0,k=0,L=0,B=1,I=0,A=0,D=0,N=1,z=s%zt,z<-3.141592653589793?z+=zt:z>Ht&&(z-=zt),z=z<0?$t*z+Xt*z*z:$t*z-Xt*z*z,u=z<0?Kt*(z*-z-z)+z:Kt*(z*z-z)+z,z=(s+jt)%zt,z<-3.141592653589793?z+=zt:z>Ht&&(z-=zt),z=z<0?$t*z+Xt*z*z:$t*z-Xt*z*z,h=z<0?Kt*(z*-z-z)+z:Kt*(z*z-z)+z,z=a%zt,z<-3.141592653589793?z+=zt:z>Ht&&(z-=zt),z=z<0?$t*z+Xt*z*z:$t*z-Xt*z*z,l=z<0?Kt*(z*-z-z)+z:Kt*(z*z-z)+z,z=(a+jt)%zt,z<-3.141592653589793?z+=zt:z>Ht&&(z-=zt),z=z<0?$t*z+Xt*z*z:$t*z-Xt*z*z,d=z<0?Kt*(z*-z-z)+z:Kt*(z*z-z)+z,z=o%zt,z<-3.141592653589793?z+=zt:z>Ht&&(z-=zt),z=z<0?$t*z+Xt*z*z:$t*z-Xt*z*z,c=z<0?Kt*(z*-z-z)+z:Kt*(z*z-z)+z,z=(o+jt)%zt,z<-3.141592653589793?z+=zt:z>Ht&&(z-=zt),z=z<0?$t*z+Xt*z*z:$t*z-Xt*z*z,m=z<0?Kt*(z*-z-z)+z:Kt*(z*z-z)+z,x=d*m,v=u*l*m-h*c,T=h*l*m+u*c,y=d*c,b=u*l*c+h*m,S=h*l*c-u*m,M=-l,R=u*d,w=h*d,s=this.#Zt,a=this.#qt,o=this.#Wt,this.renderTextureWidth&&(s*=this.renderTextureWidth,a*=this.renderTextureHeight),i[0]=(P*x+L*v+A*T)*s,i[1]=(E*x+B*v+D*T)*s,i[2]=(k*x+I*v+N*T)*s,i[3]=i[3]*s,i[4]=(P*y+L*b+A*S)*a,i[5]=(E*y+B*b+D*S)*a,i[6]=(k*y+I*b+N*S)*a,i[7]=i[7]*a,i[8]=(P*M+L*R+A*w)*o,i[9]=(E*M+B*R+D*w)*o,i[10]=(k*M+I*R+N*w)*o,i[11]=i[11]*o,(this.#$t||this.#Xt||this.#jt)&&(P=i[0],E=i[1],k=i[2],C=i[3],L=i[4],B=i[5],I=i[6],U=i[7],A=i[8],D=i[9],N=i[10],O=i[11],G=i[12],V=i[13],F=i[14],H=i[15],p=1,f=0,g=0,_=0,i[0]=p*P+f*L+g*A+_*G,i[1]=p*E+f*B+g*D+_*V,i[2]=p*k+f*I+g*N+_*F,i[3]=p*C+f*U+g*O+_*H,p=0,f=1,g=0,_=0,i[4]=p*P+f*L+g*A+_*G,i[5]=p*E+f*B+g*D+_*V,i[6]=p*k+f*I+g*N+_*F,i[7]=p*C+f*U+g*O+_*H,p=0,f=0,g=1,_=0,i[8]=p*P+f*L+g*A+_*G,i[9]=p*E+f*B+g*D+_*V,i[10]=p*k+f*I+g*N+_*F,i[11]=p*C+f*U+g*O+_*H,n?t?.modelMatrix?(p=-this.#$t,f=-this.#Xt,g=-this.#jt,_=1):(p=-this.#$t/s,f=-this.#Xt/a,g=-this.#jt,_=1):(p=-this.#$t,f=-this.#Xt,g=-this.#jt,_=1),i[12]=p*P+f*L+g*A+_*G,i[13]=p*E+f*B+g*D+_*V,i[14]=p*k+f*I+g*N+_*F,i[15]=p*C+f*U+g*O+_*H),t?.modelMatrix){let e=t.modelMatrix,r=this.localMatrix,n=this.modelMatrix,i=e[0],s=e[1],a=e[2],o=e[3],u=e[4],l=e[5],c=e[6],h=e[7],d=e[8],m=e[9],p=e[10],f=e[11],g=e[12],_=e[13],x=e[14],v=e[15],T=r[0],y=r[1],b=r[2],S=r[3];n[0]=T*i+y*u+b*d+S*g,n[1]=T*s+y*l+b*m+S*_,n[2]=T*a+y*c+b*p+S*x,n[3]=T*o+y*h+b*f+S*v,T=r[4],y=r[5],b=r[6],S=r[7],n[4]=T*i+y*u+b*d+S*g,n[5]=T*s+y*l+b*m+S*_,n[6]=T*a+y*c+b*p+S*x,n[7]=T*o+y*h+b*f+S*v,T=r[8],y=r[9],b=r[10],S=r[11],n[8]=T*i+y*u+b*d+S*g,n[9]=T*s+y*l+b*m+S*_,n[10]=T*a+y*c+b*p+S*x,n[11]=T*o+y*h+b*f+S*v,T=r[12],y=r[13],b=r[14],S=r[15],n[12]=T*i+y*u+b*d+S*g,n[13]=T*s+y*l+b*m+S*_,n[14]=T*a+y*c+b*p+S*x,n[15]=T*o+y*h+b*f+S*v}else{const{modelMatrix:e,localMatrix:t}=this;e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]}{let e=this.normalModelMatrix,t=this.modelMatrix,r=t[0],n=t[1],i=t[2],s=t[3],a=t[4],o=t[5],u=t[6],l=t[7],c=t[8],h=t[9],d=t[10],m=t[11],p=t[12],f=t[13],g=t[14],_=t[15],x=r*o-n*a,v=r*u-i*a,T=r*l-s*a,y=n*u-i*o,b=n*l-s*o,S=i*l-s*u,M=c*f-h*p,R=c*g-d*p,w=c*_-m*p,P=d*_-m*g,E=h*_-m*f,k=x*P-v*E+T*P+y*w-b*R+S*M;k=1/k,e[0]=(o*P-u*E+l*P)*k,e[4]=(-n*P+i*E-s*P)*k,e[8]=(f*S-g*b+_*y)*k,e[12]=(-h*S+d*b-m*y)*k,e[1]=(-a*P+u*w-l*R)*k,e[5]=(r*P-i*w+s*R)*k,e[9]=(-p*S+g*T-_*v)*k,e[13]=(c*S-d*T+m*v)*k,e[2]=(a*E-o*w+l*M)*k,e[6]=(-r*E+n*w-s*M)*k,e[10]=(p*b-f*T+_*x)*k,e[14]=(-c*b+h*T-m*x)*k,e[3]=(-a*P+o*R-u*M)*k,e[7]=(r*P-n*R+i*M)*k,e[11]=(-p*y+f*v-g*x)*k,e[15]=(c*y-h*v+d*x)*k}}}this.gltfLoaderInfo?.activeAnimations?.length&&((e,t)=>{let r,n,i,s,a,o,u,l,c,h,d,m,p,f,g=t.length;for(;g--;)for(u=t[g],o=u.targetAniTrackList,a=o.length;a--;){l=o[a];const{animationTargetMesh:t,timeAnimationInfo:g,aniDataAnimationInfo:_,weightMeshes:x}=l;for(r=(e-u.startTime)%(1e3*o.maxTime)/1e3,d=g.dataList,m=_.dataList,p=d.length,f=0,h=d.length-1,c=0,n=d[h],i=d[c];f<p;f++){const e=d[f];if(e<r&&(h=f,n=d[h],c=null==d[h+1]?0:h+1,i=d[c]),0==f&&r<e){h=p-1,n=d[h],c=f,i=d[c],r=e;break}if(f==p-1&&r>e){h=0,n=d[h],c=p-1,i=d[c],r=e;break}}let v,T,y,b,S,M,R;switch("CUBICSPLINE"==l.interpolation?(s=i-n,"NaN"==s.toString()&&(s=0),v=(r-n)/s,"NaN"==v.toString()&&(v=0),T=v*v,y=T*v,M=-2*y+3*T,R=y-T,b=1-M,S=R-T+v):(s="STEP"==l.interpolation?0:(r-n)/(i-n),"NaN"==s.toString()&&(s=0)),l.key){case"rotation":gltfAnimationLooper_rotation(l.interpolation,t,m,p,s,h,c,b,S,M,R);break;case"translation":gltfAnimationLooper_transition(l.interpolation,t,m,p,s,h,c,b,S,M,R);break;case"scale":gltfAnimationLooper_scale(l.interpolation,t,m,p,s,h,c,b,S,M,R);break;case"weights":gltfAnimationLooper_weight(x,m,s,h,c)}}})(s,this.gltfLoaderInfo.activeAnimations),this.animationInfo.skinInfo&&(this.currentShaderModuleName.includes(Vt)||(this.dirtyPipeline=!0),this.currentShaderModuleName===`${Vt}_${this.animationInfo.skinInfo.joints?.length}`&&(this.animationInfo.skinInfo.update(t,this),x=!1));let T=!0;if(u&&f){const{rawCamera:e}=r,t=e.x-this.#r,n=e.y-this.#n,i=e.z-this.#i,s=this.modelMatrix;f.volume.geometryRadius;s[0],s[5],s[10];const a=t*t;if(a>l)T=!1;else{const e=n*n;if(a+e>l)T=!1;else{a+e+i*i>l&&(T=!1)}}}if(a&&T)if(f){const e=this.modelMatrix,t=a[0],r=a[1],n=a[2],i=a[3],s=a[4],o=a[5],u=f.volume.geometryRadius,l=u*e[0],c=u*e[5],h=u*e[10],d=2*Math.max(u,l,c,h),m=e[12],p=e[13],g=e[14];(t[0]*m+t[1]*p+t[2]*g+t[3]<=-d||r[0]*m+r[1]*p+r[2]*g+r[3]<=-d||n[0]*m+n[1]*p+n[2]*g+n[3]<=-d||i[0]*m+i[1]*p+i[2]*g+i[3]<=-d||s[0]*m+s[1]*p+s[2]*g+s[3]<=-d||o[0]*m+o[1]*p+o[2]*g+o[3]<=-d)&&(T=!1)}else T=!1;this.#rr&&(T=!0),f?e.num3DObjects++:e.num3DGroups++;const{displacementTexture:y,displacementScale:b}=g||{};(this.dirtyPipeline||g?.dirtyPipeline||o[_])&&(o[_]=!0);const{useMSAA:S,gpuDevice:M}=t;if(f&&(S!==this.#Ht&&(this.#Ht=S,this.dirtyPipeline=!0),this.gpuRenderInfo||this.initGPURenderInfos(),(this.dirtyPipeline||o[_])&&updateMeshDirtyPipeline(this,e)),f&&T){{const{gpuRenderInfo:e}=this,{vertexUniformBuffer:t,vertexUniformInfo:r,pipeline:n}=e,{members:i}=r;void 0!==i.displacementScale&&i.displacementScale!==b&&M.queue.writeBuffer(t.gpuBuffer,i.displacementScale.uniformOffset,new i.displacementScale.View([b])),void 0!==i.useDisplacementTexture&&i.useDisplacementTexture!==y&&M.queue.writeBuffer(t.gpuBuffer,i.useDisplacementTexture.uniformOffset,new i.useDisplacementTexture.View([y?1:0]))}const{gpuRenderInfo:t}=this,{vertexUniformBuffer:r,vertexUniformBindGroup:n,vertexUniformInfo:s,pipeline:a}=t,{members:o}=s;if(this.dirtyTransform&&(M.queue.writeBuffer(r.gpuBuffer,o.modelMatrix.uniformOffset,new o.modelMatrix.View(this.is2DMeshType?multiply$5(create$5(),this.modelMatrix,fromValues$5(this.width,0,0,0,0,this.height,0,0,0,0,1,0,0,0,0,1)):this.modelMatrix)),M.queue.writeBuffer(r.gpuBuffer,o.normalModelMatrix.uniformOffset,new o.normalModelMatrix.View(this.normalModelMatrix)),o.localMatrix&&M.queue.writeBuffer(r.gpuBuffer,o.localMatrix.uniformOffset,new o.localMatrix.View(this.localMatrix)),x=!0,this.dirtyTransform=!1),this.dirtyOpacity&&(v=!0,o.combinedOpacity&&M.queue.writeBuffer(r.gpuBuffer,o.combinedOpacity.uniformOffset,new o.combinedOpacity.View([this.getCombinedOpacity()])),this.dirtyOpacity=!1),g.use2PathRender)e.render2PathLayer[e.render2PathLayer.length]=this;else if("particle"===this.meshType)e.particleLayer[e.particleLayer.length]=this;else if("instanceMesh"===this.meshType)e.instanceMeshLayer[e.instanceMeshLayer.length]=this;else if(g.transparent)e.transparentLayer[e.transparentLayer.length]=this;else if(2===g.alphaBlend||g.opacity<1||!this.depthStencilState.depthWriteEnabled)e.alphaLayer[e.alphaLayer.length]=this;else{i.setPipeline(a);const{gpuBuffer:t}=f.vertexBuffer,{fragmentUniformBindGroup:r}=g.gpuRenderInfo;if(e.prevVertexGpuBuffer!==t&&(i.setVertexBuffer(0,t),e.prevVertexGpuBuffer=t),i.setBindGroup(1,n),e.prevFragmentUniformBindGroup!==r&&(i.setBindGroup(2,r),e.prevFragmentUniformBindGroup=r),e.numDrawCalls++,f.indexBuffer){const{indexBuffer:t}=f,{indexNum:r,triangleCount:n,gpuBuffer:s}=t;i.setIndexBuffer(s,"uint32"),this.particleBuffers?i.drawIndexed(r,this.particleNum,0,0,0):i.drawIndexed(r,1,0,0,0),e.numTriangles+=n,e.numPoints+=r}else{const{vertexBuffer:t}=f,{vertexCount:r,triangleCount:n}=t;i.draw(r,1,0,0),e.numTriangles+=n,e.numPoints+=r}}this.#tr&&(m.castingList[m.castingList.length]=this)}(this.castShadow||this.castShadow&&!f)&&(p[p.length]=this);const{children:R}=this;let w=0;const P=R.length;for(;w<P;w++)x&&(R[w].dirtyTransform=x),v&&(R[w].dirtyOpacity=v),R[w].render(e)}initGPURenderInfos(){this.gpuRenderInfo=new VertexGPURenderInfo(null,null,null,null,null,null),updateMeshDirtyPipeline(this)}createMeshVertexShaderModuleBASIC(e,t,r,n){const{redGPUContext:i}=this,{resourceManager:s}=i,{gpuRenderInfo:a}=this,o={code:n};return a.vertexUniformInfo!==r&&(a.vertexUniformInfo=r,a.vertexStructInfo=t,createMeshVertexUniformBuffers(this)),a.vertexUniformBindGroup=i.gpuDevice.createBindGroup(getBasicMeshVertexBindGroupDescriptor(this)),s.createGPUShaderModule(e,o)}}Object.defineProperty(Mesh.prototype,"meshType",{value:"mesh",writable:!1}),Le.defineByPreset(Mesh,[Le.PRESET_BOOLEAN.RECEIVE_SHADOW]),Object.freeze(Mesh);class AController{#ir;constructor(){}get camera(){return this.#ir}set camera(e){this.#ir=e}update(e){}getCanvasEventPoint=(e,t)=>{const r=t.htmlCanvas,n=t.detector.isMobile,i=r.getBoundingClientRect(),s="clientX",a="clientY";let o,u;if(n){const t=e.changedTouches[0];o=t[s],u=t[a]}else{const t=e;o=t[s],u=t[a]}return{x:o-i.left,y:u-i.top}}}let Yt,Zt=create$5();const qt=create$5(),Wt=create$4();const validateNumberRange=(e,t=0,r=Number.MAX_VALUE)=>("number"!=typeof e&&consoleAndThrowError("Only numbers allowed."),"number"!=typeof t&&consoleAndThrowError("Only numbers allowed."),"number"!=typeof r&&consoleAndThrowError("Only numbers allowed."),(e<t||e>r)&&consoleAndThrowError(`Only numbers within the range of [${t},${r}] are allowed. input:${e}`),!0);let Jt;var Qt=Object.freeze({__proto__:null,BasicController:class extends AController{#sr=!0;#ar;#or={moveForward:"w",moveBack:"s",moveLeft:"a",moveRight:"d",moveUp:"t",moveDown:"g",turnLeft:"q",turnRight:"e",turnUp:"r",turnDown:"f"};#ur=1;#lr=.1;#cr=1;#hr=.1;#dr=3;#mr=0;#pr=[0,0,0];#fr=0;#gr=0;#_r;constructor(e){super(),this.#_r=new Mesh(e),this.camera=new PerspectiveCamera;const t=e.detector.isMobile,r={move:t?"touchmove":"mousemove",up:t?"touchend":"mouseup",down:t?"touchstart":"mousedown"};let n,i;const checkArea=t=>{let r=this.#ar;if(Yt&&r===Yt){let n,i,s=r.pixelRectObject;const{x:a,y:o}=this.getCanvasEventPoint(t,e);if(n=a*window.devicePixelRatio*e.renderScale,i=o*window.devicePixelRatio*e.renderScale,!(s.x<n&&n<s.x+s.width))return;if(!(s.y<i&&i<s.y+s.height))return}return!0};n=0,i=0;const HD_Move=t=>{const{x:r,y:s}=this.getCanvasEventPoint(t,e),a=r-n,o=s-i;n=r,i=s,this.#fr-=a*this.#cr*.1,this.#gr-=o*this.#cr*.1},HD_up=()=>{Yt=null,e.htmlCanvas.removeEventListener(r.move,HD_Move),window.removeEventListener(r.up,HD_up)};e.htmlCanvas.addEventListener(r.down,(t=>{if(Yt=this.#ar,!checkArea(t))return;const{x:s,y:a}=this.getCanvasEventPoint(t,e);n=s,i=a,e.htmlCanvas.addEventListener(r.move,HD_Move),window.addEventListener(r.up,HD_up)}))}get x(){return this.#_r.x}set x(e){validateNumber(e),this.#_r.x=e,this.#pr[0]=e}get y(){return this.#_r.y}set y(e){validateNumber(e),this.#_r.y=e,this.#pr[1]=e}get z(){return this.#_r.z}set z(e){validateNumber(e),this.#_r.z=e,this.#pr[2]=e}get tilt(){return this.#gr}set tilt(e){validateNumber(e),this.#_r.rotationX=e,this.#gr=e}get pan(){return this.#fr}set pan(e){validateNumber(e),this.#_r.rotationY=e,this.#fr=e}get keyNameMapper(){return{...this.#or}}setMoveForwardKey(e){this.#or.moveForward=e}setMoveBackKey(e){this.#or.moveBack=e}setMoveLeftKey(e){this.#or.moveLeft=e}setMoveRightKey(e){this.#or.moveRight=e}setMoveUpKey(e){this.#or.moveUp=e}setMoveDownKey(e){this.#or.moveDown=e}setTurnLeftKey(e){this.#or.turnLeft=e}setTurnRightKey(e){this.#or.turnRight=e}setTurnUpKey(e){this.#or.turnUp=e}setTurnDownKey(e){this.#or.turnDown=e}update(e){this.#ar=e;const t=this.#lr,r=this.#hr,n=this.#pr,i=this.#_r;i.rotationY+=(this.#fr-i.rotationY)*r,i.rotationX+=(this.#gr-i.rotationX)*r,this.#xr(e)&&(Zt=i.modelMatrix,identity$2(qt),rotateY$3(qt,qt,i.rotationY*Math.PI/180),rotateX$3(qt,qt,i.rotationX*Math.PI/180),translate$1(qt,qt,Wt),identity$2(Zt),translate$1(Zt,Zt,i.position),multiply$5(Zt,Zt,qt),n[0]=Zt[12],n[1]=Zt[13],n[2]=Zt[14]),i.x+=(n[0]-i.x)*t,i.y+=(n[1]-i.y)*t,i.z+=(n[2]-i.z)*t,i.rotationY+=(this.#fr-i.rotationY)*r,i.rotationX+=(this.#gr-i.rotationX)*r,Zt=i.modelMatrix,identity$2(Zt),translate$1(Zt,Zt,i.position),rotateY$3(Zt,Zt,i.rotationY*Math.PI/180),rotateX$3(Zt,Zt,i.rotationX*Math.PI/180);const s=clone$5(Zt);translate$1(s,s,[0,0,.01]),this.camera.setPosition(s[12],s[13],s[14]),this.camera.lookAt(i.x,i.y,i.z)}#xr(e){if(!e.checkMouseInViewBounds())return;const t=this.#ur,r=this.#cr,{keyboardKeyBuffer:n}=e.redGPUContext,i=this.#or;let s=!1,a=!1,o=0,u=0;Wt[0]=0,Wt[1]=0,Wt[2]=0;const l=this.#mr*t;return n[i.turnLeft]&&(a=!0,o=r),n[i.turnRight]&&(a=!0,o=-r),n[i.turnUp]&&(a=!0,u=r),n[i.turnDown]&&(a=!0,u=-r),n[i.moveForward]&&(s=!0,Wt[2]=-l),n[i.moveBack]&&(s=!0,Wt[2]=l),n[i.moveLeft]&&(s=!0,Wt[0]=-l),n[i.moveRight]&&(s=!0,Wt[0]=l),n[i.moveUp]&&(s=!0,Wt[1]=l),n[i.moveDown]&&(s=!0,Wt[1]=-l),a||s?(this.#mr+=.1,this.#mr>this.#dr&&(this.#mr=this.#dr)):(this.#mr+=-.1,this.#mr<0&&(this.#mr=0)),a&&(this.#fr+=o,this.#gr+=u),s||a}},Camera2D:Camera2D,ObitController:class extends AController{#e;#vr=0;#Tr=0;#yr=0;#br=15;#Sr=2;#Mr=.1;#cr=3;#hr=.1;#Rr=-35;#wr=-90;#Pr=90;#Er=0;#kr=0;#Cr=0;#Lr=0;#ar;#s;constructor(e){super(),this.camera=new PerspectiveCamera;const t=e.detector.isMobile,r={move:t?"touchmove":"mousemove",up:t?"touchend":"mouseup",down:t?"touchstart":"mousedown"};let n,i;const checkArea=t=>{let r=this.#ar;if(Jt&&r===Jt){let n,i,s=r.pixelRectObject;const{x:a,y:o}=this.getCanvasEventPoint(t,e);if(n=a*window.devicePixelRatio*e.renderScale,i=o*window.devicePixelRatio*e.renderScale,!(s.x<n&&n<s.x+s.width))return;if(!(s.y<i&&i<s.y+s.height))return}return!0};n=0,i=0;const HD_Move=t=>{const{x:r,y:s}=this.getCanvasEventPoint(t,e),a=r-n,o=s-i;n=r,i=s,this.#Er-=a*this.#cr*.1,this.#Rr-=o*this.#cr*.1},HD_up=()=>{Jt=null,e.htmlCanvas.removeEventListener(r.move,HD_Move),window.removeEventListener(r.up,HD_up)};e.htmlCanvas.addEventListener(r.down,(t=>{if(Jt=this.#ar,!checkArea(t))return;const{x:s,y:a}=this.getCanvasEventPoint(t,e);n=s,i=a,e.htmlCanvas.addEventListener(r.move,HD_Move),window.addEventListener(r.up,HD_up)})),e.htmlCanvas.addEventListener("wheel",(e=>{Jt=this.#ar,checkArea(e)&&(this.#br+=e.deltaY/100*this.#Sr,Jt=null)}))}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#s||`${this.constructor.name} Instance ${this.#e}`}set name(e){this.#s=e}get centerX(){return this.#vr}set centerX(e){this.#vr=e}get centerY(){return this.#Tr}set centerY(e){this.#Tr=e}get centerZ(){return this.#yr}set centerZ(e){this.#yr=e}get distance(){return this.#br}set distance(e){validateNumberRange(e,0),this.#br=e}get speedDistance(){return this.#Sr}set speedDistance(e){validateNumberRange(e,.01),this.#Sr=e}get delayDistance(){return this.#Mr}set delayDistance(e){validateNumberRange(e,.01,.99),this.#Mr=e}get speedRotation(){return this.#cr}set speedRotation(e){validateNumberRange(e,.01),this.#cr=e}get delayRotation(){return this.#hr}set delayRotation(e){validateNumberRange(e,.01,.99),this.#hr=e}get minTilt(){return this.#wr}set minTilt(e){validateNumberRange(e,-90,90),this.#wr=e}get maxTilt(){return this.#Pr}set maxTilt(e){validateNumberRange(e,-90,90),this.#Pr=e}get pan(){return this.#Er}set pan(e){this.#Er=e}get tilt(){return this.#Rr}set tilt(e){validateNumberRange(e,-90,90),this.#Rr=e}update(e){let t,r,n;this.#ar=e,n=Math.PI/180,this.#Rr<this.#wr&&(this.#Rr=this.#wr),this.#Rr>this.#Pr&&(this.#Rr=this.#Pr),t=this.#hr;const{camera:i}=this;r=i.modelMatrix,this.#kr+=(this.#Er-this.#kr)*t,this.#Cr+=(this.#Rr-this.#Cr)*t,this.#br<i.nearClipping&&(this.#br=i.nearClipping),this.#Lr+=(this.#br-this.#Lr)*this.#Mr,this.#Lr<i.nearClipping&&(this.#Lr=i.nearClipping),identity$2(r),translate$1(r,r,[this.#vr,this.#Tr,this.#yr]),rotateY$3(r,r,this.#kr*n),rotateX$3(r,r,this.#Cr*n),translate$1(r,r,[0,0,this.#Lr]),i.x=r[12],i.y=r[13],i.z=r[14],this.camera.lookAt(this.#vr,this.#Tr,this.#yr)}},OrthographicCamera:OrthographicCamera,PerspectiveCamera:PerspectiveCamera});class RedGPUContextSizeManager{#Br;#Ir;#v;#Ur=[0,0,0,0];#Ar;#Dr=1;constructor(e,t="100%",r="100%"){this.#v=e,this.#Ar=e.htmlCanvas,this.#Ar.style.boxSizing="border-box",this.#Br=t,this.#Ir=r}get renderScale(){return this.#Dr}set renderScale(e){validateNumber(e),e<=0&&(e=.01),this.#Dr=e,this.setSize()}get width(){return this.#Br}set width(e){this.setSize(e,this.#Ir)}get height(){return this.#Ir}set height(e){this.setSize(this.#Br,e)}get pixelRectArray(){return this.#Ur}get pixelRectObject(){return{x:this.#Ur[0],y:this.#Ur[1],width:this.#Ur[2],height:this.#Ur[3]}}get parentDomRect(){return(this.#Ar.parentNode||document.body).getBoundingClientRect()}get screenRectObject(){return{x:this.#Ur[0]/devicePixelRatio,y:this.#Ur[1]/devicePixelRatio,width:this.#Ur[2]/devicePixelRatio,height:this.#Ur[3]/devicePixelRatio}}static validateSizeValue=e=>{switch(typeof e){case"number":validatePositiveNumberRange(e);break;case"string":new RegExp(/^[+]?^[.]?(\d+)(\.\d+)?(?:px|%|$)/gm).test(e)||consoleAndThrowError(`allow positive number,%,px model/input:${e}`);break;default:consoleAndThrowError(`positive number,%,px model/input:${e}`)}};static validatePositionValue=e=>{switch(typeof e){case"number":validateNumber(e);break;case"string":new RegExp(/^-?\d+(\.\d+)?(px|%)?$/).test(e)||consoleAndThrowError(`allow number,%,px model /input:${e}`);break;default:consoleAndThrowError(`number,%,px model/input:${e}`)}};static getPixelDimension(e,t,r){return"number"==typeof r?r:RedGPUContextSizeManager.calculateSizeFromString(e,t,r)}static calculateSizeFromString(e,t,r){return r.includes("%")?Math.floor(e[t]*+r.replace("%","")/100):+r.replace("px","")}setSize(e=this.#Br,t=this.#Ir){RedGPUContextSizeManager.validateSizeValue(e),RedGPUContextSizeManager.validateSizeValue(t),this.#Br=e,this.#Ir=t;const r=Math.max(.01,RedGPUContextSizeManager.getPixelDimension(this.parentDomRect,"width",e)),n=Math.max(.01,RedGPUContextSizeManager.getPixelDimension(this.parentDomRect,"height",t));this.#Nr(r,n),this.#Or(r,n),this.#Gr()}#Or(e,t){this.#Ur[2]=Math.floor(e*this.#Dr*window.devicePixelRatio),this.#Ur[3]=Math.floor(t*this.#Dr*window.devicePixelRatio)}#Gr(){this.#v.onResize&&this.#v.onResize(this.screenRectObject.width,this.screenRectObject.height),this.#v.viewList.forEach((e=>{e.setSize(),e.setPosition()}))}#Nr(e,t){const r=this.#Ar,{style:n}=r;r.width=e*this.#Dr*window.devicePixelRatio,r.height=t*this.#Dr*window.devicePixelRatio,n.width=`${e}px`,n.height=`${t}px`}}const er=new Uint32Array([0,0,0,0]);class PassPointLightClusters{#Vr;#Fr;#Hr;#zr;#v;constructor(e,t){validateRedGPUContext(e),this.#v=e,this.#Vr=t,this.#Kr()}get clusterLightsBuffer(){return this.#zr}render(){const{gpuDevice:e}=this.#v,t=this.#Vr.systemUniform_Vertex_UniformBindGroup;if(t){const r=e.createCommandEncoder(),n=r.beginComputePass({label:"PointLight cluster"}),i=Fe.getDispatchSize();this.#v.gpuDevice.queue.writeBuffer(this.clusterLightsBuffer,0,er),n.setPipeline(this.#Hr),n.setBindGroup(0,t),n.setBindGroup(1,this.#Fr),n.dispatchWorkgroups(i[0],i[1],i[2]),n.end(),e.queue.submit([r.finish()])}}#Kr(){const{gpuDevice:e,resourceManager:t}=this.#v,r=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\r\n@group(1) @binding(0) var<storage> pointLight_Clusters:PointLight_Clusters;\r\n\r\nfn pointLight_testSphereAABB(light:u32, tile:u32) -> bool {\r\rlet targetLight=pointLightList.lights[light];\rlet targetTile=pointLight_Clusters.cubeList[tile];\r\n\r\rlet radius:f32=targetLight.radius;\rlet position:vec3<f32>=targetLight.position;\rlet center:vec3<f32>=(systemUniforms.camera.cameraMatrix * vec4<f32>(position,1.0)).xyz;\r\n\r\rlet squaredDistance:f32=pointLight_sqDistPointAABB(center,tile,targetTile.minAABB.xyz,targetTile.maxAABB.xyz);\r\n\rreturn squaredDistance <=(radius * radius);\r\n}\r\n\r\nfn pointLight_sqDistPointAABB(targetPoint:vec3<f32>,tile:u32,minAABB:vec3<f32>,maxAABB:vec3<f32>) -> f32 {\rvar sqDist=0.0;\rfor(var i=0u;i < 3u;i=i + 1u) {\r\rlet v=targetPoint[i];\rlet _minAABB=minAABB[i];\rlet _maxAABB=maxAABB[i];\r\n\rif(v < _minAABB){\rsqDist += (_minAABB - v) * (_minAABB - v);\r}\rif(v > _maxAABB){\rsqDist +=(v - _maxAABB) * (v - _maxAABB);\r}\r}\r\n\rreturn sqDist;\r\n}\r\nfn spotLight_testConeAABB(light:u32,tile:u32) -> bool {\rlet targetLight=pointLightList.lights[light];\rlet targetTile=pointLight_Clusters.cubeList[tile];\r\n\rlet position:vec3<f32>=(systemUniforms.camera.cameraMatrix * vec4<f32>(targetLight.position,1.0)).xyz;\r\nlet spotlightDirection:vec3<f32>=normalize(\r(systemUniforms.camera.cameraMatrix * vec4<f32>(targetLight.position + vec3<f32>(0,-1,0),1.0)).xyz - position\r\n);\rlet innerCutoffAngle:f32=radians(25.0);\rlet outerCutoffAngle:f32=radians(26.0);\r\n\rlet tileMin:vec3<f32>=targetTile.minAABB.xyz;\rlet tileMax:vec3<f32>=targetTile.maxAABB.xyz;\r\n\r\rlet corners:array<vec3<f32>,8>=array<vec3<f32>,8>(\rtileMin,\rvec3<f32>(tileMax.x,tileMin.y,tileMin.z),\rvec3<f32>(tileMin.x,tileMax.y,tileMin.z),\rvec3<f32>(tileMax.x,tileMax.y,tileMin.z),\rvec3<f32>(tileMin.x,tileMin.y,tileMax.z),\rvec3<f32>(tileMax.x,tileMin.y,tileMax.z),\rvec3<f32>(tileMin.x,tileMax.y,tileMax.z),\rtileMax\r);\r\n\rvar isCornerInsideCone=false;\r\r\n\r\rlet tileCenter:vec3<f32>=(tileMin + tileMax) * 0.5;\r\n\rfor (var i:u32=0u;i < 9u;i=i+1) {\rvar toCorner:vec3<f32>;\rif(i<8u){\rtoCorner= corners[i] - position;\r}else{\rtoCorner= tileCenter - position;\r}\rvar cosOuterCutoffAngle=cos(outerCutoffAngle);\rvar dotProduct=dot(normalize(toCorner),spotlightDirection);\rdotProduct=clamp(dotProduct,-1.0,1.0);\r\n\rif(dotProduct >=cosOuterCutoffAngle) {\risCornerInsideCone=true;\rbreak;\r}\r}\r\n\rreturn isCornerInsideCone;\r\n}\r\n@compute @workgroup_size(REDGPU_DEFINE_WORKGROUP_SIZE_X,REDGPU_DEFINE_WORKGROUP_SIZE_Y,REDGPU_DEFINE_WORKGROUP_SIZE_Z)\r\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>) {\r\rlet tileIndex=global_id.x +\rglobal_id.y * pointLight_tileCount.x +\rglobal_id.z * pointLight_tileCount.x * pointLight_tileCount.y;\r\rvar clusterLightCount=0u;\r\rvar clusterPointLightIndices:array<u32,REDGPU_DEFINE_MAX_LIGHTS_PER_CLUSTERu>;\r\n\r\rfor (var i=0u;i < u32(pointLightList.count[0]);i=i + 1u) {\r\rlet lightInCluster=pointLight_testSphereAABB(i,tileIndex);\r\n\r\rif (lightInCluster) {\r\rclusterPointLightIndices[clusterLightCount]=i;\r\rclusterLightCount=clusterLightCount + 1u;\r}\r\n\r\rif (clusterLightCount==REDGPU_DEFINE_MAX_LIGHTS_PER_CLUSTERu) {\rbreak;\r}\r}\r\n\r\rvar offset=atomicAdd(&pointLight_clusterLightGroup.offset,clusterLightCount);\r\n\r\rfor(var i=0u;i < clusterLightCount;i=i + 1u) {\r\rpointLight_clusterLightGroup.indices[offset + i]=clusterPointLightIndices[i];\r}\r\n\r\rpointLight_clusterLightGroup.lights[tileIndex].offset=offset;\rpointLight_clusterLightGroup.lights[tileIndex].count=clusterLightCount;\r\n}\r\n").shaderSource;this.#zr=e.createBuffer({size:Fe.getPointLight_ClusterLightsBufferSize(),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});const n=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]});this.#Fr=e.createBindGroup({label:"clusterLightBindGroup",layout:n,entries:[{binding:0,resource:{buffer:this.#Vr.passLightClustersBound.clusterBoundBuffer}}]}),this.#Hr=e.createComputePipeline({label:"clusterLightPipeline",layout:e.createPipelineLayout({bindGroupLayouts:[t.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),n]}),compute:{module:e.createShaderModule({code:r,label:"Cluster Light"}),entryPoint:"main"}})}}class PassPointLightClustersBound{#Vr;#$r;#Xr;#jr;#Yr;#v;constructor(e,t){validateRedGPUContext(e),this.#v=e,this.#Vr=t,this.#Kr()}get clusterBoundBuffer(){return this.#$r}render(){const e=this.#Vr.systemUniform_Vertex_UniformBindGroup;if(e){const{gpuDevice:t}=this.#v,r=t.createCommandEncoder(),n=r.beginComputePass({label:"Bound cluster"}),i=Fe.getDispatchSize();n.setPipeline(this.#Yr),n.setBindGroup(0,e),n.setBindGroup(1,this.#jr),n.dispatchWorkgroups(i[0],i[1],i[2]),n.end(),t.queue.submit([r.finish()])}}#Kr(){const{gpuDevice:e,resourceManager:t}=this.#v,r=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\r\n@group(1) @binding(0) var<storage,read_write> pointLight_Clusters:PointLight_Clusters;\r\n\r\nfn lineIntersectionToZPlane(a:vec3<f32>,b:vec3<f32>,zDistance:f32) -> vec3<f32> {\rlet normal=vec3<f32>(0.0,0.0,0.5);\rlet ab=b - a;\rlet t=(zDistance - dot(normal,a))/dot(normal,ab);\rreturn a + t * ab;\r\n}\r\n\r\nfn clipToView(clip:vec4<f32>) -> vec4<f32> {\rlet view=systemUniforms.inverseProjectionMatrix * clip;\rreturn view/vec4<f32>(view.w,view.w,view.w,view.w);\r\n}\r\n\r\nfn screen2View(screen:vec4<f32>) -> vec4<f32> {\rlet texCoord=screen.xy/systemUniforms.resolution.xy;\rlet clip=vec4<f32>(vec2<f32>(texCoord.x,1.0 - texCoord.y) * 2.0 - vec2<f32>(1.0,1.0),screen.z,screen.w );\rreturn clipToView(clip);\r\n}\r\n\r\nconst eyePos=vec3<f32>(0.0);\r\n\r\n@compute @workgroup_size(REDGPU_DEFINE_WORKGROUP_SIZE_X,REDGPU_DEFINE_WORKGROUP_SIZE_Y,REDGPU_DEFINE_WORKGROUP_SIZE_Z)\r\n\r\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>) {\r\rlet tileIndex=global_id.x +\rglobal_id.y * pointLight_tileCount.x +\rglobal_id.z * pointLight_tileCount.x * pointLight_tileCount.y;\r\n\r\rlet tileSize=vec2<f32>(\rsystemUniforms.resolution.x/f32(pointLight_tileCount.x),\rsystemUniforms.resolution.y/f32(pointLight_tileCount.y)\r);\r\n\r\rlet global_id_x_pos_one=vec2<f32>(f32(global_id.x + 1u),f32(global_id.y + 1u)) * tileSize;\rlet global_id_x_y=vec2<f32>(f32(global_id.x),f32(global_id.y)) * tileSize;\r\n\rlet maxPoint_sS=vec4<f32>(global_id_x_pos_one,0.0,1.0);\rlet minPoint_sS=vec4<f32>(global_id_x_y,0.0,1.0);\r\n\rlet maxPoint_vS=screen2View(maxPoint_sS).xyz;\rlet minPoint_vS=screen2View(minPoint_sS).xyz;\r\n\r\rlet nearFarX=systemUniforms.camera.nearClipping;\rlet nearFarY=systemUniforms.camera.farClipping;\r\n\rlet tileZ=f32(global_id.z)/f32(pointLight_tileCount.z);\rlet tileZ_plus_one=f32(global_id.z + 1u)/f32(pointLight_tileCount.z);\r\n\rlet tileNear=-nearFarX * pow(nearFarY/nearFarX,tileZ);\rlet tileFar=-nearFarX * pow(nearFarY/nearFarX,tileZ_plus_one);\r\n\r\rlet minPointNear=lineIntersectionToZPlane(eyePos,minPoint_vS,tileNear);\rlet minPointFar=lineIntersectionToZPlane(eyePos,minPoint_vS,tileFar);\rlet maxPointNear=lineIntersectionToZPlane(eyePos,maxPoint_vS,tileNear);\rlet maxPointFar=lineIntersectionToZPlane(eyePos,maxPoint_vS,tileFar);\r\n\r\rlet minAABB=min(min(minPointNear,minPointFar),min(maxPointNear,maxPointFar));\rlet maxAABB=max(max(minPointNear,minPointFar),max(maxPointNear,maxPointFar));\r\n\rpointLight_Clusters.cubeList[tileIndex].minAABB=vec4<f32>(minAABB,0.0);\rpointLight_Clusters.cubeList[tileIndex].maxAABB=vec4<f32>(maxAABB,0.0);\r\n}\r\n").shaderSource;this.#$r=e.createBuffer({size:32*Fe.getTotalTileSize(),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.#Xr=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),this.#jr=e.createBindGroup({label:"clusterBoundBindGroup",layout:this.#Xr,entries:[{binding:0,resource:{buffer:this.#$r}}]}),this.#Yr=e.createComputePipeline({label:"clusterBoundPipeline",layout:e.createPipelineLayout({bindGroupLayouts:[t.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),this.#Xr]}),compute:{module:e.createShaderModule({code:r,label:"Cluster Bounds"}),entryPoint:"main"}})}}class PickingEvent{pickingId;mouseX;mouseY;target;time;type;movementX=0;movementY=0;localX=0;localY=0;localZ=0;altKey=!1;ctrlKey=!1;shiftKey=!1;constructor(e,t,r,n,i,s,a){this.pickingId=e,this.mouseX=t,this.mouseY=r,this.target=n,this.time=i,this.type=s,this.altKey=a.altKey,this.ctrlKey=a.ctrlKey,this.shiftKey=a.shiftKey}}const tr={MOVE:"move",DOWN:"down",UP:"up",OVER:"over",OUT:"out",CLICK:"click"};class PickingManager{lastMouseEvent;lastMouseClickEvent;#Zr;#qr;#Wr;#Jr;#v;#Vr;#Qr=[];#en=0;#tn=0;#rn;#nn;get mouseX(){return this.#en}set mouseX(e){this.#en=e}get mouseY(){return this.#tn}set mouseY(e){this.#tn=e}get castingList(){return this.#Qr}get pickingGPUTexture(){return this.#Wr}get pickingGPUTextureView(){return this.#Jr}get pickingDepthGPUTextureView(){return this.#qr}resetCastingList(){this.#Qr.length=0}destroy(){this.#Wr&&(this.#Wr.destroy(),this.#Zr.destroy(),this.#Wr=null,this.#Jr=null,this.#Zr=null,this.#qr=null)}checkTexture(e){const{redGPUContext:t}=e;this.#Vr=e,this.#v=t,this.#Wr?.width===this.#Vr.pixelRectObject.width&&this.#Wr?.height===this.#Vr.pixelRectObject.height||(this.destroy(),this.#Wr=this.#in(navigator.gpu.getPreferredCanvasFormat()),this.#Jr=this.#Wr.createView(),this.#Zr=this.#in("depth24plus"),this.#qr=this.#Zr.createView())}checkEvents(e,t){this.#sn(e,t),this.resetCastingList()}#in(e){const{gpuDevice:t}=this.#v;return t.createTexture({size:[this.#Vr.pixelRectObject.width,this.#Vr.pixelRectObject.height,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC,format:e,sampleCount:1})}#sn=async(e,t,r=1,n=1)=>{const{gpuDevice:i}=e.redGPUContext,{pixelRectArray:s}=e,a=this.#en,o=this.#tn;if(a<=0||a>=s[2]||o<=0||o>=s[3])return;const u=this.#an(),l=this.#on(i,r,n,a,o),c=await this.#un(l);l.destroy(),c?(this.#ln(c,a,o,t,u),this.#cn(c,a,o,t,u)):this.#hn(),this.lastMouseEvent=null,this.lastMouseClickEvent=null};#an=()=>this.#Qr.reduce(((e,t)=>(e[t.pickingId]=t,e)),{});#on=(e,t,r,n,i)=>{const s=e.createCommandEncoder(),a=e.createBuffer({size:16*t*r,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),o={texture:this.#Wr,origin:{x:n,y:i,z:0}},u={buffer:a,bytesPerRow:Math.max(256,4*t*r),rowsPerImage:1},l={width:t,height:r,depthOrArrayLayers:1};return s.copyTextureToBuffer(o,u,l),e.queue.submit([s.finish()]),a};#ln=(e,t,r,n,i)=>{const s=i[e],a=this.lastMouseClickEvent?.type;if(a===tr.CLICK){const i=new PickingEvent(e,t,r,s,n,a,this.lastMouseClickEvent);this.#dn(a,i)}};#cn=(e,t,r,n,i)=>{const s=i[e],a=this.lastMouseEvent?.type;if(a){const i=new PickingEvent(e,t,r,s,n,a,this.lastMouseEvent);switch(this.#rn&&(i.movementX=t-this.#rn.mouseX,i.movementY=r-this.#rn.mouseY),a){case tr.DOWN:case tr.UP:this.#dn(a,i);break;case tr.MOVE:this.#mn(e,s,i)}this.#rn=i}};#mn=(e,t,r)=>{const n=this.#rn?.pickingId;n!==e?(this.#rn&&n&&n!==e&&this.#hn(),this.#nn!==t&&(this.#dn(tr.OVER,r),document.body.style.cursor="pointer"),this.#nn=t):this.#dn(tr.MOVE,r)};#hn=()=>{this.#rn&&this.#dn(tr.OUT,this.#rn),this.#rn=null,this.#nn=null,document.body.style.cursor="default"};async#un(e){await e.mapAsync(GPUMapMode.READ);const t=new DataView(e.getMappedRange()),r="rgba8unorm"==this.#Wr.format?[0,1,2,3]:[2,1,0,3],n=t.getUint8(r[0]),i=t.getUint8(r[1]),s=t.getUint8(r[2]);return(t.getUint8(r[3])<<24|s<<16|i<<8|n)>>>0}#dn(e,t){t.target.events[e]&&t.target.events[e](t)}}Object.freeze(PickingManager);class PostEffectManager{#Vr;#pn=[];#fn;#gn;#_n=16;#xn=4;#vn=1;constructor(e){this.#Vr=e}get view(){return this.#Vr}get effectList(){return this.#pn}addEffect(e){this.#pn.push(e)}addEffectAt(e){}getEffectAt(e){return this.#pn[e]}removeEffect(e){}removeEffectAt(e){}removeAllEffect(e){this.#pn.forEach((e=>{e.clear()})),this.#pn.length=0}render(){const{colorResolveTextureView:e,colorTexture:t}=this.#Vr.viewRenderTextureManager;this.#gn=this.#Tn(this.#Vr,e);let r=this.#gn;const{width:n,height:i}=t;return this.#pn.forEach((e=>{r=e.render(this.#Vr,n,i,r)})),r}clear(){this.#pn.forEach((e=>{e.clear()}))}#Tn(e,t){this.#fn&&(this.#fn.destroy(),this.#fn=null);const{redGPUContext:r,viewRenderTextureManager:n}=e,{colorTexture:i}=n,{gpuDevice:s}=r,{width:a,height:o}=i,u=this.#yn(),l=s.createShaderModule({code:u}),c=this.#bn(r);this.#fn=this.#in(s,a,o);const h=this.#fn.createView();return this.#Sn(s,this.#Mn(s,l,c),this.#Rn(r,c,t,h),a,o),h}#yn(){return`@group(0) @binding(0) var sourceTextureSampler:sampler;@group(0) @binding(1) var sourceTexture:texture_2d<f32>;@group(0) @binding(2) var outputTexture:texture_storage_2d<rgba8unorm,write>;@compute @workgroup_size(${this.#_n},${this.#xn},${this.#vn})fn main (@builtin(global_invocation_id) global_id:vec3<u32>,){let index=vec2<u32>(global_id.xy );let dimensions:vec2<u32>=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let uv=\tvec2<f32>((f32(index.x)+0.5)/dimW,(f32(index.y)+0.5)/dimH);var color:vec4<f32>=textureSampleLevel(sourceTexture,sourceTextureSampler,uv,0);textureStore(outputTexture,index,color );};`}#bn(e){return e.resourceManager.createBindGroupLayout("POST_EFFECT_COPY_TO_STORAGE",{entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,sampler:{type:"filtering"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{}},{binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm"}}]})}#in(e,t,r){return e.createTexture({size:{width:t,height:r},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING})}#Rn(e,t,r,n){return e.gpuDevice.createBindGroup({layout:t,entries:[{binding:0,resource:new Sampler(e).gpuSampler},{binding:1,resource:r},{binding:2,resource:n}]})}#Mn(e,t,r){return e.createComputePipeline({layout:e.createPipelineLayout({bindGroupLayouts:[r]}),compute:{module:t,entryPoint:"main"}})}#Sn(e,t,r,n,i){const s=e.createCommandEncoder(),a=s.beginComputePass();a.setPipeline(t),a.setBindGroup(0,r),a.dispatchWorkgroups(Math.ceil(n/this.#_n),Math.ceil(i/this.#xn)),a.end(),e.queue.submit([s.finish()])}}Object.freeze(PostEffectManager);class RenderViewStateData{useDistanceCulling;cullingDistanceSquared;distanceCulling;num3DGroups;num3DObjects;numDrawCalls;numDirtyPipelines;numInstances;numTriangles;numPoints;viewRenderTime;viewportSize;usedVideoMemory;currentRenderPassEncoder;timestamp;frustumPlanes;prevVertexGpuBuffer;prevFragmentUniformBindGroup;dirtyVertexUniformFromMaterial={};alphaLayer=[];transparentLayer=[];particleLayer=[];instanceMeshLayer=[];render2PathLayer=[];startTime;isScene2DMode=!1;#Vr;constructor(e){this.#Vr=e}get view(){return this.#Vr}reset(e,t){if(!t||!this.#Vr)throw new Error("Invalid parameters provided");const r=this.#Vr,{useFrustumCulling:n,frustumPlanes:i}=r,{colorTexture:s,depthTexture:a}=r.viewRenderTextureManager;if(!s||!a)throw new Error("Invalid view properties");this.useDistanceCulling=r.useDistanceCulling,this.distanceCulling=r.distanceCulling,this.cullingDistanceSquared=this.distanceCulling*this.distanceCulling,this.num3DGroups=0,this.num3DObjects=0,this.numDrawCalls=0,this.numInstances=0,this.numDirtyPipelines=0,this.numTriangles=0,this.numPoints=0,this.viewRenderTime=0,this.currentRenderPassEncoder=e,this.timestamp=t,this.prevVertexGpuBuffer=null,this.prevFragmentUniformBindGroup=null,this.dirtyVertexUniformFromMaterial={},this.alphaLayer=[],this.transparentLayer=[],this.particleLayer=[],this.instanceMeshLayer=[],this.render2PathLayer=[],this.startTime=performance.now(),this.isScene2DMode=r.camera instanceof Camera2D,this.viewportSize={x:r.x,y:r.y,width:r.width,height:r.height,pixelRectArray:r.pixelRectArray};try{this.usedVideoMemory=calculateTextureByteSize({size:[s.width,s.height,s.depthOrArrayLayers],format:s.format,sampleCount:s.sampleCount,usage:s.usage})+calculateTextureByteSize({size:[a.width,a.height,a.depthOrArrayLayers],format:a.format,sampleCount:a.sampleCount,usage:a.usage})}catch(e){throw new Error("Could not calculate texture size:"+e.message)}this.frustumPlanes=n?i:null}}const rr=parseWGSL("#redgpu_include drawPicking;\r\n#redgpu_include calcTintBlendMode;\r\nstruct Uniforms {\rcolor:vec3<f32>,\r\ropacity:f32,\ruseTint:u32,\rtint:vec4<f32>,\rtintBlendMode:u32,\r\n};\r\n\r\nstruct InputData {\r\r@builtin(position) position:vec4<f32>,\r@location(12) combinedOpacity:f32,\r@location(15) pickingId:vec4<f32>,\r\n}\r\n\r\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\r\n@fragment\r\nfn main(inputData:InputData) -> @location(0) vec4<f32> {\rvar finalColor=vec4<f32>( uniforms.color.r,uniforms.color.g,uniforms.color.b,uniforms.opacity * inputData.combinedOpacity);\rif(uniforms.useTint==1u){\rfinalColor=calcTintBlendMode(finalColor,uniforms.tintBlendMode,uniforms.tint);\r}\rreturn finalColor;\r\n}\r\n\r\n\r\n");class ColorMaterial extends ABaseMaterial{constructor(e,t="#fff"){super(e,"COLOR_MATERIAL",rr,2),this.initGPURenderInfos(),this.color.setColorByHEX(t)}}rt.defineByPreset(ColorMaterial,[rt.PRESET_COLOR_RGB.COLOR]),Object.freeze(ColorMaterial);class GeometryGPURenderInfo{buffers;constructor(e){this.buffers=e}}Object.freeze(GeometryGPURenderInfo);const calculateVolume=e=>{const t=e.stride,r=e.data;let n=e.vertexCount,i=1/0,s=1/0,a=1/0,o=-1/0,u=-1/0,l=-1/0,c=0;for(;c<=n-4;c+=4){let e=c*t;const n=r[e],h=r[e+1],d=r[e+2];e=(c+1)*t;const m=r[e],p=r[e+1],f=r[e+2];e=(c+2)*t;const g=r[e],_=r[e+1],x=r[e+2];e=(c+3)*t;const v=r[e],T=r[e+1],y=r[e+2];i=Math.min(n,m,g,v,i),s=Math.min(h,p,_,T,s),a=Math.min(d,f,x,y,a),o=Math.max(n,m,g,v,o),u=Math.max(h,p,_,T,u),l=Math.max(d,f,x,y,l)}for(;c<n;c++){let e=c*t;const n=r[e],h=r[e+1],d=r[e+2];i=Math.min(n,i),s=Math.min(h,s),a=Math.min(d,a),o=Math.max(n,o),u=Math.max(h,u),l=Math.max(d,l)}const h=Math.max(Math.abs(i),Math.abs(o)),d=Math.max(Math.abs(s),Math.abs(u)),m=Math.max(Math.abs(a),Math.abs(l));return{volume:[o-i,u-s,l-a],minX:i,maxX:o,minY:s,maxY:u,minZ:a,maxZ:l,xSize:h,ySize:d,zSize:m,geometryRadius:Math.max(h,d,m)}};class Geometry extends ResourceBase{gpuRenderInfo;#wn;#Pn;#En;constructor(e,t,r){super(e),this.#kn(t),this.#Cn(r);const{interleavedStruct:n}=this.#wn;this.gpuRenderInfo=new GeometryGPURenderInfo([{arrayStride:n.arrayStride,attributes:n.attributes}])}get vertexBuffer(){return this.#wn}get indexBuffer(){return this.#Pn}get volume(){return this.#En||(this.#En=calculateVolume(this.#wn)),this.#En}#kn(e){const t=this.#wn;this.#wn=e,t&&t.__removeDirtyPipelineListener(this.#Ln),e&&e.__addDirtyPipelineListener(this.#Ln),this.#En=null}#Cn(e){const t=this.#Pn;this.#Pn=e,t&&t.__removeDirtyPipelineListener(this.#Bn),e&&e.__addDirtyPipelineListener(this.#Bn)}#Ln(){this.__fireListenerList()}#Bn(){this.__fireListenerList()}}Object.freeze(Geometry);class ResourceStateIndexBuffer{static dirtyList=[];buffer;label;uuid;#_=0;constructor(e){this.buffer=e,this.label=e.name,this.uuid=e.uuid}get useNum(){return this.#_}set useNum(e){this.#_=e,ResourceStateIndexBuffer.dirtyList.push(this)}}class IndexBuffer extends ABaseBuffer{#P;#In=0;#Un=0;#E;constructor(e,t,r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n=""){super(e,"managedIndexBufferState",r);const i=getCacheBufferFromResourceState(this,n);if(i)return i;n&&(this.name=n),this.changeData(t),basicRegisterResource(this,new ResourceStateIndexBuffer(this))}get gpuBuffer(){return this.#E}get size(){return this.#P.byteLength||0}get triangleCount(){return this.#Un}get indexNum(){return this.#In}destroy(){const e=this.#E;e&&(this.#E=null,this.__fireListenerList(!0),basicUnregisterResource(this),e&&e.destroy())}changeData(e){const{gpuDevice:t}=this;if(Array.isArray(e)&&(e=new Uint32Array(e)),this.#E){this.targetResourceManagedState.videoMemory-=this.#P.byteLength||0;let e=this.#E;requestAnimationFrame((()=>{e.destroy()})),this.#E=null}this.#P=e,this.#In=e.length,this.targetResourceManagedState.videoMemory+=this.#P.byteLength;const r={size:this.#P.byteLength,usage:this.usage,label:this.name};this.#E=t.createBuffer(r),this.#Un=this.#In/3,t.queue.writeBuffer(this.#E,0,this.#P)}updatePartialData(e,t){const{gpuDevice:r}=this;(e<0||e>=this.#P.length)&&consoleAndThrowError(`Offset value is out of data bounds. Tried to access index ${e} on data of length ${this.#P.length}`),Array.isArray(t)&&(t=new Uint32Array(t)),this.#In=t.length,r.queue.writeBuffer(this.#E,e,t)}}Object.freeze(IndexBuffer);class ResourceStateVertexBuffer{static dirtyList=[];buffer;label;uuid;#_=0;constructor(e){this.buffer=e,this.label=e.name,this.uuid=e.uuid}get useNum(){return this.#_}set useNum(e){this.#_=e,ResourceStateVertexBuffer.dirtyList.push(this)}}class VertexBuffer extends ABaseBuffer{#An=0;#Dn=0;#Nn;#P;#Un=0;#E;constructor(e,t,r,n=GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,i=""){super(e,"managedVertexBufferState",n);const s=getCacheBufferFromResourceState(this,i);if(s)return s;this.#Nn=r,i&&(this.name=i),this.changeData(t,this.#Nn),basicRegisterResource(this,new ResourceStateVertexBuffer(this))}get gpuBuffer(){return this.#E}get stride(){return this.#Dn}get data(){return this.#P}get size(){return this.#P.byteLength||0}get interleavedStruct(){return this.#Nn}get vertexCount(){return this.#An}get triangleCount(){return this.#Un}destroy(){const e=this.#E;e&&(this.#E=null,this.__fireListenerList(!0),basicUnregisterResource(this),e&&e.destroy())}updateAllData(e){const{gpuDevice:t}=this;t.queue.writeBuffer(this.#E,0,this.#P)}changeData(e,t){const{gpuDevice:r}=this;if(Array.isArray(e)&&(e=new Float32Array(e)),this.#P=e,t&&this.#On(t),this.#E){this.targetResourceManagedState.videoMemory-=this.#P.byteLength||0;let e=this.#E;requestAnimationFrame((()=>{e.destroy()})),this.#E=null}this.targetResourceManagedState.videoMemory+=this.#P.byteLength;const n={size:this.#P.byteLength,usage:this.usage,label:this.name};this.#E=r.createBuffer(n),this.#Un=this.#P.length/this.#Dn,r.queue.writeBuffer(this.#E,0,this.#P)}#On(e){this.#Nn=e,this.#An=0,this.#Dn=0;for(const e in this.#Nn.define){const t=this.#Nn.define[e].attributeStride/Float32Array.BYTES_PER_ELEMENT;this.#An+=t,this.#Dn+=t}this.#An=this.#P.length/this.#An}}Object.freeze(VertexBuffer);class InterleaveType{static get float32(){return{numElements:1,stride:Float32Array.BYTES_PER_ELEMENT,gpuVertexFormat:"float32",offset:0}}static get float32x2(){return{numElements:2,stride:2*Float32Array.BYTES_PER_ELEMENT,gpuVertexFormat:"float32x2",offset:0}}static get float32x3(){return{numElements:3,stride:3*Float32Array.BYTES_PER_ELEMENT,gpuVertexFormat:"float32x3",offset:0}}static get float32x4(){return{numElements:4,stride:4*Float32Array.BYTES_PER_ELEMENT,gpuVertexFormat:"float32x4",offset:0}}}Object.freeze(InterleaveType);class InterleavedStructElement{attributeName;attributeStride;interleaveType;constructor(e,t,r){this.attributeName=e,this.attributeStride=t,this.interleaveType=r}}class InterleavedStruct{#Gn;#s="";#Vn=[];#Fn=0;constructor(e,t=""){this.#s=t,this.#Hn(e),this.#zn()}get label(){return this.#s}get attributes(){return this.#Vn}get arrayStride(){return this.#Fn}get define(){return{...this.#Gn}}#Hn(e){let t={};for(const r in e){const n=e[r],i=n.stride;t[r]=new InterleavedStructElement(r,i,n),i%4!=0&&consoleAndThrowError(`Invalid attribute stride:${i}`)}this.#Gn=t}#zn(){this.#Fn=0,this.#Vn=[];for(const[e,{attributeStride:t,interleaveType:r}]of Object.entries(this.#Gn))this.#Vn.push({attributeName:e,shaderLocation:this.#Vn.length,offset:this.#Fn,format:r.gpuVertexFormat}),this.#Fn+=t}}class Primitive{#Kn;#wn;#Pn;#En;constructor(e){validateRedGPUContext(e)}static get primitiveInterleaveStruct(){return new InterleavedStruct({vertexPosition:InterleaveType.float32x3,vertexNormal:InterleaveType.float32x3,texcoord:InterleaveType.float32x2},"primitiveInterleaveStruct")}get gpuRenderInfo(){return this.#Kn}get vertexBuffer(){return this.#wn}get indexBuffer(){return this.#Pn}get volume(){return this.#En||(this.#En=calculateVolume(this.#wn)),this.#En}_setData(e){if(this.#wn=e.vertexBuffer,this.#Pn=e.indexBuffer,this.#wn){const{interleavedStruct:e}=this.#wn;this.#Kn=new GeometryGPURenderInfo([{arrayStride:e.arrayStride,attributes:e.attributes}])}}}Object.freeze(Primitive);const createPrimitiveGeometry=(e,t,r,n)=>new Geometry(e,new VertexBuffer(e,new Float32Array(t),Primitive.primitiveInterleaveStruct,void 0,`VertexBuffer_${n}`),new IndexBuffer(e,new Uint32Array(r),void 0,`IndexBuffer_${n}`));class Box extends Primitive{#$n=function(){let e,t;return t=function(t,r,n,i,s,a,o,u,l,c,h,d,m){let p,f,g=u/h,_=l/d,x=u/2,v=l/2,T=c/2,y=h+1,b=d+1,S=0,M=[];for(f=0;f<b;f++){let e=f*_-v;for(p=0;p<y;p++){let r=p*g-x;M[n]=r*a,M[i]=e*o,M[s]=T,t.push(M.x,M.y,M.z),M[n]=0,M[i]=0,M[s]=c>0?1:-1,t.push(M.x,M.y,M.z),t.push(p/h*m,f/d*m),S+=1}}for(f=0;f<d;f++)for(p=0;p<h;p++){let t=e+p+y*f,n=e+p+y*(f+1),i=e+(p+1)+y*(f+1),s=e+(p+1)+y*f;r.push(t,n,s,n,i,s)}e+=S},function(r,n,i,s,a,o,u,l,c){let h=[],d=[];return e=0,t(h,d,"z","y","x",-1,-1,a,s,i,l,u,c),t(h,d,"z","y","x",1,-1,a,s,-i,l,u,c),t(h,d,"x","z","y",1,1,i,a,s,o,l,c),t(h,d,"x","z","y",1,-1,i,a,-s,o,l,c),t(h,d,"x","y","z",1,-1,i,s,a,o,u,c),t(h,d,"x","y","z",-1,-1,i,s,-a,o,u,c),createPrimitiveGeometry(n,h,d,r)}}();constructor(e,t=1,r=1,n=1,i=1,s=1,a=1,o=1){super(e);const u=`PRIMITIVE_BOX_W${t}_H${r}_D${n}_WS${i}_HS${s}_DS${a}_UV${o}`,l=e.resourceManager.cachedBufferState;let c=l[u];c||(c=l[u]=this.#$n(u,e,t,r,n,i,s,a,o)),this._setData(c)}}class Cylinder extends Primitive{#$n=function(){let e,t;return function(r,n,i,s,a,o,u,l,c,h){const d=[],m=[];let p=0;const f=[],g=a/2;return e=function(){let e,t;const r=[],n=[],l=(s-i)/a;for(t=0;t<=u;t++){const m=[],_=t/u,x=_*(s-i)+i;for(e=0;e<=o;e++){const t=e/o,i=t*h+c,s=Math.sin(i),u=Math.cos(i);n[0]=x*s,n[1]=-_*a+g,n[2]=x*u,d.push(n[0],n[1],n[2]),r[0]=s,r[1]=l,r[2]=u,normalize$4(r,r),d.push(r[0],r[1],r[2]),d.push(t,_),m.push(p++)}f.push(m)}for(e=0;e<o;e++)for(t=0;t<u;t++){const r=f[t][e],n=f[t+1][e],i=f[t+1][e+1],s=f[t][e+1];m.push(r,n,s),m.push(n,i,s)}},t=function(e){let t,r,n;const a=[],u=[],l=!0===e?i:s,f=!0===e?1:-1;for(r=p,t=1;t<=o;t++)d.push(0,g*f,0),d.push(0,f,0),d.push(.5,.5),p++;for(n=p,t=0;t<=o;t++){const e=t/o*h+c,r=Math.cos(e),n=Math.sin(e);u[0]=l*n,u[1]=g*f,u[2]=l*r,d.push(u[0],u[1],u[2]),d.push(0,f,0),a[0]=.5*r+.5,a[1]=.5*n*f+.5,d.push(a[0],1-a[1]),p++}for(t=0;t<o;t++){const i=r+t,s=n+t;!0===e?m.push(s,s+1,i):m.push(s+1,s,i)}},e(),!1===l&&(i>0&&t(!0),s>0&&t(!1)),createPrimitiveGeometry(n,d,m,r)}}();constructor(e,t=1,r=1,n=1,i=8,s=8,a=!1,o=0,u=2*Math.PI){super(e);const l=`PRIMITIVE_CYLINDER_RT${t}_RB${r}_H${n}_RS${i}_HS${s}_TS${a}_TS${o}_TL${u}`,c=e.resourceManager.cachedBufferState;let h=c[l];h||(h=c[l]=this.#$n(l,e,t,r,n,i,s,a,o,u)),this._setData(h)}}class Sphere extends Primitive{#$n=function(){let e,t,r,n,i,s,a,o,u=[],l=new Float32Array([0,0,0]),c=new Float32Array([0,0,0]);return function(h,d,m,p,f,g,_,x,v,T){e=x+v,n=0,u.length=0,l[0]=0,l[1]=0,l[2]=0,c[0]=0,c[1]=0,c[2]=0;let y=[],b=[];for(r=0;r<=f;r++){let e=[],i=r/f;for(t=0;t<=p;t++){let r=t/p;l.x=-m*Math.cos(g+r*_)*Math.sin(x+i*v),l.y=m*Math.cos(x+i*v),l.z=m*Math.sin(g+r*_)*Math.sin(x+i*v),y.push(l.x,l.y,l.z),c[0]=l.x,c[1]=l.y,c[2]=l.z,normalize$4(c,c),y.push(c[0],c[1],c[2]),y.push(r*T,i*T),e.push(n++)}u.push(e)}for(r=0;r<f;r++)for(t=0;t<p;t++)i=u[r][t+1],s=u[r][t],a=u[r+1][t],o=u[r+1][t+1],(0!==r||x>0)&&b.push(i,s,o),(r!==f-1||e<Math.PI)&&b.push(s,a,o);return createPrimitiveGeometry(d,y,b,h)}}();constructor(e,t=1,r=16,n=16,i=0,s=2*Math.PI,a=0,o=Math.PI,u=1){super(e);const l=`PRIMITIVE_SPHERE_R${t}_WS${r}_HS${n}_PS${i}_PL${s}_TS${a}_TL${o}_UV${u}`,c=e.resourceManager.cachedBufferState;let h=c[l];h||(h=c[l]=this.#$n(l,e,t,r,n,i,s,a,o,u)),this._setData(h)}}class Axis extends Mesh{constructor(e){super(e,null,null);const t=new Mesh(e,new Sphere(e,.5),new ColorMaterial(e));this.addChild(t);const r=new Box(e);this.addChild(this.#Xn(r,"#ff0000",[5,.1,.1],[2.5,0,0])),this.addChild(this.#jn(e,"#ff0000",[.5,1.25],[5.5,0,0],[0,0,-90])),this.addChild(this.#Xn(r,"#00ff00",[.1,5,.1],[0,2.5,0])),this.addChild(this.#jn(e,"#00ff00",[.5,1.25],[0,5.5,0],[180,0,0])),this.addChild(this.#Xn(r,"#0000ff",[.1,.1,5],[0,0,2.5])),this.addChild(this.#jn(e,"#0000ff",[.5,1.25],[0,0,5.5],[90,0,0]))}#Xn(e,t,r,n){const{redGPUContext:i}=this,s=new Mesh(i,e,new ColorMaterial(i,t));return s.setScale(...r),s.setPosition(...n),s}#jn(e,t,r,n,i){const s=new Mesh(e,new Cylinder(e,r[0],.001,r[1],32,1),new ColorMaterial(e,t));return s.setScale(r[0],r[1],r[0]),s.setPosition(...n),s.setRotation(...i),s}}const nr=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include calcTintBlendMode;\r\n#redgpu_include drawPicking;\r\n\r\nstruct Uniforms {\ruseDiffuseTexture:u32,\r\ropacity:f32,\ruseTint:u32,\rtint:vec4<f32>,\rtintBlendMode:u32,\r\n};\r\n\r\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\r\n@group(2) @binding(1) var diffuseTextureSampler:sampler;\r\n@group(2) @binding(2) var diffuseTexture:texture_2d<f32>;\r\n\r\nstruct InputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(15) pickingId:vec4<f32>,\r\n};\r\n\r\n@fragment\r\nfn main(inputData:InputData) -> @location(0) vec4<f32> {\r\rvar finalColor:vec4<f32>=textureSample(diffuseTexture,diffuseTextureSampler,inputData.uv);\rfinalColor=vec4<f32>(finalColor.rgb,finalColor.a * uniforms.opacity * inputData.combinedOpacity);\r\n\rif(uniforms.useTint==1u){\rfinalColor=calcTintBlendMode(finalColor,uniforms.tintBlendMode,uniforms.tint);\r}\r\n\r\rif (systemUniforms.isView3D==1 && finalColor.a==0.0) {\rdiscard;\r}\r\n\rreturn finalColor;\r\n};\r\n");class BitmapMaterial extends ABitmapBaseMaterial{dirtyPipeline=!1;constructor(e,t,r){super(e,"BITMAP_MATERIAL",nr,2),r&&(this.name=r),this.diffuseTexture=t,this.diffuseTextureSampler=new Sampler(this.redGPUContext),this.initGPURenderInfos()}}rt.defineByPreset(BitmapMaterial,[rt.PRESET_TEXTURE.DIFFUSE_TEXTURE,rt.PRESET_SAMPLER.DIFFUSE_TEXTURE_SAMPLER]),Object.freeze(BitmapMaterial);const ir={NORMAL:0,MULTIPLY:1,LIGHTEN:2,SCREEN:3,LINEAR_DODGE:4,SUBTRACT:5,DIFFERENCE:6,EXCLUSION:7};const sr=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include calcTintBlendMode;\r\n#redgpu_include calcDirectionalShadowVisibility;\r\n#redgpu_include normalFunctions;\r\n#redgpu_include drawPicking;\r\nstruct Uniforms {\ruseDiffuseTexture:u32,\rcolor:vec3<f32>,\r\remissiveColor:vec3<f32>,\remissiveStrength:f32,\ruseEmissiveTexture:u32,\r\rspecularColor:vec3<f32>,\rspecularStrength:f32,\ruseSpecularTexture:u32,\rshininess:f32,\r\ruseAoTexture:u32,\raoStrength:f32,\r\ruseAlphaTexture:u32,\r\ruseNormalTexture:u32,\rnormalScale:f32,\r\ropacity:f32,\ruseTint:u32,\rtint:vec4<f32>,\rtintBlendMode:u32,\r\r\n};\r\n\r\nstruct InputData {\r\r@builtin(position) position:vec4<f32>,\r\n\r\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(14) receiveShadow:f32,\r@location(15) pickingId:vec4<f32>,\r\n}\r\n\r\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\r\n@group(2) @binding(1) var diffuseTextureSampler:sampler;\r\n@group(2) @binding(2) var diffuseTexture:texture_2d<f32>;\r\n@group(2) @binding(3) var alphaTextureSampler:sampler;\r\n@group(2) @binding(4) var alphaTexture:texture_2d<f32>;\r\n@group(2) @binding(5) var specularTextureSampler:sampler;\r\n@group(2) @binding(6) var specularTexture:texture_2d<f32>;\r\n@group(2) @binding(7) var emissiveTextureSampler:sampler;\r\n@group(2) @binding(8) var emissiveTexture:texture_2d<f32>;\r\n@group(2) @binding(9) var aoTextureSampler:sampler;\r\n@group(2) @binding(10) var aoTexture:texture_2d<f32>;\r\n@group(2) @binding(11) var normalTextureSampler:sampler;\r\n@group(2) @binding(12) var normalTexture:texture_2d<f32>;\r\n\r\n\r\n@fragment\r\nfn main(inputData:InputData) -> @location(0) vec4<f32> {\r\n\r\rlet u_ambientLight=systemUniforms.ambientLight;\rlet u_ambientLightColor=u_ambientLight.color;\rlet u_ambientLightIntensity=u_ambientLight.intensity;\r\n\r\rlet u_directionalLightCount=systemUniforms.directionalLightCount;\rlet u_directionalLights=systemUniforms.directionalLights;\rlet u_directionalLightShadowDepthTextureSize=systemUniforms.directionalLightShadowDepthTextureSize;\rlet u_directionalLightShadowBias=systemUniforms.directionalLightShadowBias;\r\n\r\n\r\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\n\r\n\r\rlet u_color=uniforms.color;\rlet u_aoStrength=uniforms.aoStrength;\rlet u_emissiveColor=uniforms.emissiveColor;\rlet u_emissiveStrength=uniforms.emissiveStrength;\rlet u_normalScale=uniforms.normalScale;\rlet u_specularColor=uniforms.specularColor;\rlet u_specularStrength=uniforms.specularStrength;\rlet u_shininess=uniforms.shininess;\rlet u_opacity=uniforms.opacity;\rlet E=normalize(u_cameraPosition);\r\rlet u_useDiffuseTexture=uniforms.useDiffuseTexture==1;\rlet u_useAlphaTexture=uniforms.useAlphaTexture==1;\rlet u_useSpecularTexture=uniforms.useSpecularTexture==1;\rlet u_useEmissiveTexture=uniforms.useEmissiveTexture==1;\rlet u_useAoTexture=uniforms.useAoTexture==1;\rlet u_useNormalTexture=uniforms.useNormalTexture==1;\r\rlet receiveShadowYn=inputData.receiveShadow !=.0;\r\n\r\n\r\r\n\r\rvar N=normalize(inputData.vertexNormal);\rif(u_useNormalTexture){\rlet normalSamplerColor=textureSample(normalTexture,normalTextureSampler,inputData.uv).rgb;\rN=perturb_normal( N,inputData.vertexPosition,inputData.uv,normalSamplerColor,u_normalScale );\r}else{\rN=N * u_normalScale;\r}\r\rvar finalColor:vec4<f32>;\rvar resultAlpha:f32=u_opacity * inputData.combinedOpacity;\rvar diffuseColor:vec3<f32>=u_color;\rif(u_useDiffuseTexture){\rlet diffuseSampleColor=textureSample(diffuseTexture,diffuseTextureSampler,inputData.uv);\rdiffuseColor=diffuseSampleColor.rgb;\rresultAlpha=resultAlpha * diffuseSampleColor.a;\r}\r\n\rvar specularSamplerValue:f32=1;\rif(u_useSpecularTexture){\rspecularSamplerValue=textureSample(specularTexture,specularTextureSampler,inputData.uv).r;\r}\rvar mixColor:vec3<f32>;\r\n\rvar visibility:f32=1.0;\rvisibility=calcDirectionalShadowVisibility(\rdirectionalShadowMap,\rdirectionalShadowMapSampler,\ru_directionalLightShadowDepthTextureSize,\ru_directionalLightShadowBias,\rinputData.shadowPos\r);\r\n\rif(!receiveShadowYn){\rvisibility=1.0;\r}\r\n\rfor (var i=0u;i < u_directionalLightCount;i=i + 1) {\rlet u_directionalLightDirection=u_directionalLights[i].direction;\rlet u_directionalLightColor=u_directionalLights[i].color;\rlet u_directionalLightIntensity=u_directionalLights[i].intensity * visibility;\r\n\rlet L=normalize(u_directionalLightDirection);\rlet R=reflect(L,N);\rlet lambertTerm=max(dot(N,-L),0.0);\rlet specular=pow(max(dot(R,E),0.0),u_shininess) * specularSamplerValue;\rlet la=u_ambientLightColor * u_ambientLightIntensity * visibility;\rlet ld=diffuseColor * (u_directionalLightColor * u_directionalLightIntensity) * lambertTerm;\rlet ls=u_specularColor * u_specularStrength * (u_directionalLightColor * u_directionalLightIntensity) * specular;\rmixColor +=la + ld + ls;\r}\r\n\r\rlet clusterIndex=getPointLightClusterIndex(inputData.position);\rlet lightOffset =pointLight_clusterLightGroup.lights[clusterIndex].offset;\rlet lightCount:u32 =pointLight_clusterLightGroup.lights[clusterIndex].count;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\rfor (var lightIndex=0u;lightIndex < lightCount;lightIndex=lightIndex + 1u) {\rlet i=pointLight_clusterLightGroup.indices[lightOffset + lightIndex];\rlet u_pointLightPosition=pointLightList.lights[i].position;\rlet u_pointLightColor=pointLightList.lights[i].color;\rlet u_pointLightIntensity=pointLightList.lights[i].intensity;\rlet u_pointLightRadius=pointLightList.lights[i].radius;\r\n\rlet lightDir=normalize(u_pointLightPosition - inputData.vertexPosition);\rlet lightDistance=length(u_pointLightPosition - inputData.vertexPosition);\rlet attenuation=clamp(0.0,1.0,1.0 - (lightDistance * lightDistance)/(u_pointLightRadius * u_pointLightRadius));\rif(lightDistance<=u_pointLightRadius){\r\n\rlet L=normalize(lightDir);\rlet R=reflect(-L,N);\r\n\rlet diffuse=max(dot(N,L),0.0);\rlet specular=pow(max(dot(R,E),0.0),u_shininess);\r\n\rlet ld=(u_pointLightColor * u_pointLightIntensity) * diffuse * attenuation * u_pointLightIntensity;\rlet ls=u_specularColor * u_specularStrength * specular * attenuation * u_pointLightIntensity;\r\n\rmixColor +=ld + ls;\r}\r}\r\n\r\n\rif(u_useAlphaTexture){\rlet alphaMapValue:f32=textureSample(alphaTexture,alphaTextureSampler,inputData.uv).r;\rresultAlpha=alphaMapValue * resultAlpha;\rif(resultAlpha==0){\rdiscard;\r}\r}\rvar emissiveColor=u_emissiveColor * u_emissiveStrength;\rif(u_useEmissiveTexture){\remissiveColor=textureSample(emissiveTexture,emissiveTextureSampler,inputData.uv).rgb * u_emissiveStrength;\r}\rif(u_useAoTexture){\rmixColor=mixColor * textureSample(aoTexture,aoTextureSampler,inputData.uv).rgb * u_aoStrength;\r}\rfinalColor=vec4<f32>(mixColor + emissiveColor,resultAlpha);\rif(uniforms.useTint==1u){\rfinalColor=calcTintBlendMode(finalColor,uniforms.tintBlendMode,uniforms.tint);\r}\r\rif (systemUniforms.isView3D==1 && finalColor.a==0.0) {\rdiscard;\r}\rreturn finalColor;\r\n}\r\n");class PhongMaterial extends ABitmapBaseMaterial{#Yn;#Zn=1;constructor(e,t="#fff",r){super(e,"PHONG_MATERIAL",sr,2),r&&(this.name=r),this.initGPURenderInfos(),this.color.setColorByHEX(t),this.emissiveColor.setColorByHEX(this.emissiveColor.hex),this.specularColor.setColorByHEX(this.specularColor.hex)}get displacementScale(){return this.#Zn}set displacementScale(e){this.#Zn=e}get displacementTexture(){return this.#Yn}set displacementTexture(e){const t=this.#Yn;this.#Yn=e,this.updateTexture(t,e),this.dirtyPipeline=!0}}rt.defineByPreset(PhongMaterial,[rt.PRESET_COLOR_RGB.COLOR,rt.PRESET_TEXTURE.ALPHA_TEXTURE,rt.PRESET_SAMPLER.ALPHA_TEXTURE_SAMPLER,rt.PRESET_TEXTURE.AO_TEXTURE,rt.PRESET_SAMPLER.AO_TEXTURE_SAMPLER,rt.PRESET_POSITIVE_NUMBER.AO_STRENGTH,rt.PRESET_TEXTURE.DIFFUSE_TEXTURE,rt.PRESET_SAMPLER.DIFFUSE_TEXTURE_SAMPLER,rt.PRESET_TEXTURE.EMISSIVE_TEXTURE,rt.PRESET_SAMPLER.EMISSIVE_TEXTURE_SAMPLER,rt.PRESET_POSITIVE_NUMBER.EMISSIVE_STRENGTH,[rt.PRESET_COLOR_RGB.EMISSIVE_COLOR,"#000000"],rt.PRESET_TEXTURE.NORMAL_TEXTURE,rt.PRESET_SAMPLER.NORMAL_TEXTURE_SAMPLER,rt.PRESET_POSITIVE_NUMBER.NORMAL_SCALE,rt.PRESET_TEXTURE.SPECULAR_TEXTURE,rt.PRESET_SAMPLER.SPECULAR_TEXTURE_SAMPLER,rt.PRESET_POSITIVE_NUMBER.SPECULAR_STRENGTH,[rt.PRESET_COLOR_RGB.SPECULAR_COLOR,"#ffffff"],[rt.PRESET_POSITIVE_NUMBER.SHININESS,32]]),Object.freeze(PhongMaterial);var ar=Object.freeze({__proto__:null,ABaseMaterial:ABaseMaterial,ABitmapBaseMaterial:ABitmapBaseMaterial,BLEND_MODE:ir,BitmapMaterial:BitmapMaterial,COMPOSITE_MODE:{ADDITIVE:"additive",SOURCE_OVER:"source-over",SOURCE_IN:"source-in",SOURCE_OUT:"source-out",SOURCE_ATOP:"source-atop",DESTINATION_OVER:"destination-over",DESTINATION_IN:"destination-in",DESTINATION_OUT:"destination-out",DESTINATION_ATOP:"destination-atop"},ColorMaterial:ColorMaterial,PhongMaterial:PhongMaterial,TINT_BLEND_MODE:mt,getComputeBindGroupLayoutDescriptorFromShaderInfo:getComputeBindGroupLayoutDescriptorFromShaderInfo,getFragmentBindGroupLayoutDescriptorFromShaderInfo:getFragmentBindGroupLayoutDescriptorFromShaderInfo,getVertexBindGroupLayoutDescriptorFromShaderInfo:getVertexBindGroupLayoutDescriptorFromShaderInfo}),or="#redgpu_include SYSTEM_UNIFORM;\r\nstruct VertexIn {\r@location(0) pos:vec4<f32>,\r@location(1) uv:vec2<f32>,\r\n}\r\n\r\nstruct VertexOut {\r@builtin(position) pos:vec4<f32>,\r@location(0) uv:vec2<f32>,\r\n}\r\n\r\n\r\n@vertex\r\nfn vertexMain(in:VertexIn) -> VertexOut {\rvar out:VertexOut;\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\r\rout.pos=u_projectionMatrix * u_cameraMatrix * in.pos;\rout.uv=in.uv;\rreturn out;\r\n}\r\n\r\nfn PristineGrid(uv:vec2<f32>,lineWidth:vec2<f32>) -> f32 {\rlet uvDDXY=vec4<f32>(dpdx(uv),dpdy(uv));\rlet uvDeriv=vec2<f32>(length(uvDDXY.xz),length(uvDDXY.yw));\rlet invertLine:vec2<bool>=lineWidth > vec2f(0.5);\rlet targetWidth:vec2<f32>=select(lineWidth,1 - lineWidth,invertLine);\rlet drawWidth:vec2<f32>=clamp(targetWidth,uvDeriv,vec2f(0.5));\rlet lineAA:vec2<f32>=uvDeriv * 1.5;\rvar gridUV:vec2<f32>=abs(fract(uv) * 2.0 - 1.0);\rgridUV=select(1 - gridUV,gridUV,invertLine);\rvar grid2:vec2<f32>=smoothstep(drawWidth + lineAA,drawWidth - lineAA,gridUV);\rgrid2 *=saturate(targetWidth/drawWidth);\rgrid2=mix(grid2,targetWidth,saturate(uvDeriv * 2.0 - 1.0));\rgrid2=select(grid2,1.0 - grid2,invertLine);\rreturn mix(grid2.x,1.0,grid2.y);\r\n}\r\n\r\n\r\nstruct GridArgs {\rlineColor:vec4<f32>,\rbaseColor:vec4<f32>,\rlineWidth:vec2<f32>,\rsize:f32,\rdistance:f32,\r\n}\r\n@group(1) @binding(0) var<uniform> gridArgs:GridArgs;\r\n\r\n@fragment\r\nfn fragmentMain(in:VertexOut) -> @location(0) vec4<f32> {\rvar lineWidthWeight:f32=1;\rvar color:vec4<f32>=gridArgs.lineColor;\rlet DIVISION_SIZE:f32=gridArgs.size;\rlet ASIX_SIZE:f32=max(DIVISION_SIZE * gridArgs.lineWidth.x,DIVISION_SIZE/20);\r\n\rlet HALF_DIVISION_SIZE:f32=DIVISION_SIZE * 0.5;\rlet PER_SIZE:f32=1/DIVISION_SIZE * ASIX_SIZE;\rlet MIN_RANGE=HALF_DIVISION_SIZE - PER_SIZE;\rlet MAX_RANGE=HALF_DIVISION_SIZE + PER_SIZE;\rif( MIN_RANGE <=in.uv.x && in.uv.x <=MAX_RANGE) {\rcolor=vec4<f32>(0,0,1,1);\rlineWidthWeight=ASIX_SIZE;\r}else if( MIN_RANGE <=in.uv.y && in.uv.y <=MAX_RANGE) {\rcolor=vec4<f32>(1,0,0,1);\rlineWidthWeight=ASIX_SIZE;\r}\rvar grid=PristineGrid(in.uv,gridArgs.lineWidth * lineWidthWeight);\r\n\r\n\rreturn mix(gridArgs.baseColor,color,grid * gridArgs.lineColor.a);\r\n;\r\n}\r\n";const ur=parseWGSL(or),lr=ur.uniforms.gridArgs;class Grid{#wn;#Pn;#qn;#Wn;#ze;#Jn;#Je;#Qe;#Qn;#w=100;#e;#s;#ei=1;constructor(e){validateRedGPUContext(e),this.#e=InstanceIdGenerator.getNextId(this.constructor);const{resourceManager:t,gpuDevice:r}=e,n={code:or},i=t.createGPUShaderModule("VERTEX_MODULE_GRID",n);this.#Je=new BlendState(this,lt.ONE,lt.ONE_MINUS_SRC_ALPHA,ct.ADD),this.#Qe=new BlendState(this,lt.SRC_ALPHA,lt.ONE_MINUS_SRC_ALPHA,ct.ADD),this.#Qn=new ColorRGBA(128,128,128,1);const s=t.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),a=e.resourceManager.getGPUBindGroupLayout("GRID_MATERIAL_BIND_GROUP_LAYOUT")||e.resourceManager.createBindGroupLayout("GRID_MATERIAL_BIND_GROUP_LAYOUT",getFragmentBindGroupLayoutDescriptorFromShaderInfo(ur,1));this.#ti(e),this.#Wn=r.createBindGroup({label:"FRAGMENT_BIND_GROUP_DESCRIPTOR_GRID",layout:a,entries:[{binding:0,resource:{buffer:this.#qn.gpuBuffer,offset:0,size:this.#qn.size}}]});const o={label:"PIPELINE_DESCRIPTOR_GRID",layout:r.createPipelineLayout({bindGroupLayouts:[s,a]}),vertex:{module:i,entryPoint:"vertexMain",buffers:[{arrayStride:this.#wn.interleavedStruct.arrayStride,attributes:this.#wn.interleavedStruct.attributes}]},fragment:{module:i,entryPoint:"fragmentMain",targets:[{format:navigator.gpu.getPreferredCanvasFormat(),blend:{color:this.#Je.state,alpha:this.#Qe.state}}]},depthStencil:{format:"depth24plus",depthWriteEnabled:!1,depthCompare:St.LESS_EQUAL}};this.#ze=r.createRenderPipeline(o),this.#Jn=r.createRenderPipeline({...o,multisample:{count:4}})}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#s||`${this.constructor.name} Instance ${this.#e}`}set name(e){this.#s=e}get size(){return this.#w}set size(e){this.#w=e}get lineColor(){return this.#Qn}get lineWidth(){return this.#ei}set lineWidth(e){validatePositiveNumberRange(e),this.#ei=e}render(e){const{view:t,currentRenderPassEncoder:r}=e,n=create$4();set$4(n,t.rawCamera.x,t.rawCamera.y,t.rawCamera.z);const i=distance$2(n,[0,0,0]),s=this.#w;e.num3DObjects++,e.numDrawCalls++;const a=1/t.pixelRectObject.width*i*this.#ei;this.#qn.writeBuffers([[lr.members.lineColor,this.#Qn.rgbaNormal],[lr.members.lineWidth,[a,a]],[lr.members.size,s],[lr.members.distance,i]]);const o=[-s/2,-0,-s/2,0,0,s/2,-0,-s/2,s,0,-s/2,-0,s/2,0,s,s/2,-0,s/2,s,s];if(this.#wn.changeData(o),this.#ze){const{triangleCount:n,indexNum:i}=this.#Pn;r.setPipeline(t.redGPUContext.useMSAA?this.#Jn:this.#ze),r.setBindGroup(1,this.#Wn),r.setVertexBuffer(0,this.#wn.gpuBuffer),r.setIndexBuffer(this.#Pn.gpuBuffer,"uint32"),r.drawIndexed(6),e.numTriangles+=n,e.numPoints+=i}}#ti(e){const t=this.#w,{resourceManager:r}=e,{cachedBufferState:n}=r;{const r="VertexBuffer_Grid",i=n[r],s=[-t,-0,-t,0,0,t,-0,-t,t,0,-t,-0,t,0,t,t,-0,t,t,t];n[r]=this.#wn=i||new VertexBuffer(e,s,new InterleavedStruct({position:InterleaveType.float32x3,uv:InterleaveType.float32x2}),void 0,r)}{const t="IndexBuffer_Grid",r=n[t],i=[0,1,2,1,2,3];n[t]=this.#Pn=r||new IndexBuffer(e,i,void 0,t)}{const t="UniformBuffer_Grid",r=n[t],i=new ArrayBuffer(lr.arrayBufferByteLength);n[t]=this.#qn=r||new UniformBuffer(e,i)}}}class BaseLight{#ri;#ni;constructor(e,t=1){this.#ri=e,this.#ni=t}get color(){return this.#ri}set color(e){this.#ri=e}get intensity(){return this.#ni}set intensity(e){this.#ni=e}}Object.freeze(BaseLight);class AmbientLight extends BaseLight{constructor(e=new ColorRGB(7,7,7),t=.2){super(e,t)}}Object.freeze(AmbientLight);class DirectionalLight extends BaseLight{#ii;constructor(e=[-1,-1,-1],t="#fff",r=1){super(new ColorRGB(...convertHexToRgb(t,!0)),r),this.#ii=e}get direction(){return this.#ii}set direction(e){this.#ii=e}}Object.freeze(DirectionalLight);class PointLight extends BaseLight{#si=1;#r=0;#n=0;#i=0;constructor(e="#fff",t=1){super(new ColorRGB(...convertHexToRgb(e,!0)),t)}get x(){return this.#r}set x(e){this.#r=e}get y(){return this.#n}set y(e){this.#n=e}get z(){return this.#i}set z(e){this.#i=e}get position(){return[this.#r,this.#n,this.#i]}get radius(){return this.#si}set radius(e){this.#si=e}setPosition(e,t,r){Array.isArray(e)?[this.#r,this.#n,this.#i]=e:(this.#r=e,this.#n=t,this.#i=r)}}Object.freeze(PointLight);class LightManager{#ai=3;#oi=Fe.MAX_POINT_LIGHTS;#ui=[];#li=[];#ci=new AmbientLight;#hi=create$5();get limitPointLightCount(){return this.#oi}get pointLights(){return this.#li}get limitDirectionalLightCount(){return this.#ai}get directionalLightCount(){return this.#ui.length}get pointLightCount(){return this.#li.length}get directionalLights(){return this.#ui}get ambientLight(){return this.#ci}set ambientLight(e){e instanceof AmbientLight||consoleAndThrowError("allow only AmbientLight instance"),this.#ci=e}addPointLight(e){e instanceof PointLight||consoleAndThrowError("allow only PointLight instance");this.#li.length>this.#oi&&consoleAndThrowError("Cannot add more directional lights. The limit has been reached."),this.#li.push(e)}addDirectionalLight(e){e instanceof DirectionalLight||consoleAndThrowError("allow only DirectionalLight instance");this.#ui.length>this.#ai&&consoleAndThrowError("Cannot add more directional lights. The limit has been reached."),this.#ui.push(e)}removeDirectionalLight(e){const t=this.#ui.indexOf(e);-1!==t&&this.#ui.splice(t,1)}removeAllDirectionalLight(){this.#ui=[],this.#ci=null}updateViewSystemUniforms(e){const{redGPUContext:t,scene:r}=e,n=e.systemUniform_Vertex_StructInfo,{systemUniform_Vertex_UniformBuffer:i}=e,{members:s}=n,{lightManager:a,shadowManager:o}=r;if(i.writeBuffers([[s.directionalLightCount,a.directionalLightCount],[s.directionalLightProjectionViewMatrix,this.#di(e)],[s.directionalLightProjectionMatrix,this.#mi(e)],[s.directionalLightViewMatrix,this.#pi(e)],[s.directionalLightShadowDepthTextureSize,o.directionalLightShadowDepthTextureSize],[s.directionalLightShadowBias,o.directionalLightShadowBias]]),a.directionalLights.forEach(((e,t)=>{const{directionalLights:r}=s,{direction:n,color:a,intensity:o}=r.memberList[t];i.writeBuffers([[n,e.direction],[a,e.color.rgbNormal],[o,e.intensity]])})),a.ambientLight){const t=e.scene.lightManager.ambientLight,{ambientLight:r}=s,{color:n,intensity:a}=r.members;i.writeBuffers([[n,t.color.rgbNormal],[a,t.intensity]])}}#di(e){return multiply$5(create$5(),this.#mi(e),this.#pi(e))}#mi(e){const t=create$5(),r=fromValues$4(e.rawCamera.x,e.rawCamera.y,e.rawCamera.z),n=Math.max(distance$2(r,create$4()),1);return f(t,-n,n,-n,n,3*-n,3*n),t}#pi(e){identity$2(this.#hi);const t=Math.max(distance$2(fromValues$4(e.rawCamera.x,e.rawCamera.y,e.rawCamera.z),create$4()),1),r=fromValues$4(0,1,0),n=fromValues$4(0,0,0),i=e.scene.lightManager.directionalLights.length?fromValues$4(-e.scene.lightManager.directionalLights[0].direction[0]*t,-e.scene.lightManager.directionalLights[0].direction[1]*t,-e.scene.lightManager.directionalLights[0].direction[2]*t):create$4(),s=create$5();return lookAt(s,i,n,r),s}}Object.freeze(LightManager);class ShadowManager{#fi=2048;#gi=.005;#_i;#xi;#vi;#v;#Qr=[];get castingList(){return this.#Qr}get shadowDepthGPUTextureView(){return this.#xi}get shadowDepthGPUTextureViewEmpty(){return this.#vi}get directionalLightShadowBias(){return this.#gi}set directionalLightShadowBias(e){validatePositiveNumberRange(e,0,1),this.#gi=e}get directionalLightShadowDepthTextureSize(){return this.#fi}set directionalLightShadowDepthTextureSize(e){validateUintRange(e,1),this.#fi=e,this.#Ti()}resetCastingList(){this.#Qr.length=0}updateViewSystemUniforms(e){this.#v=e,this.#Ti()}destroy(){this.#_i&&(this.#_i.destroy(),this.#_i=null,this.#xi=null)}#Ti(){this.#_i?.width!==this.#fi&&(this.destroy(),this.#yi())}#bi(e){const t=e.createTexture({size:[1,1,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,format:"depth32float"});this.#vi=t.createView()}#yi(){const{gpuDevice:e}=this.#v;this.#_i=e.createTexture({size:[this.#fi,this.#fi,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,format:"depth32float"}),this.#xi=this.#_i.createView(),this.#vi||this.#bi(e)}}Object.freeze(ShadowManager);class Scene extends Object3DContainer{#e;#s;#Si=new ColorRGBA;#Mi=!1;#Ri=new LightManager;#wi=new ShadowManager;constructor(e){super(),this.#e=InstanceIdGenerator.getNextId(this.constructor),this.#s=e}get lightManager(){return this.#Ri}get shadowManager(){return this.#wi}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#s||`${this.constructor.name} Instance ${this.#e}`}set name(e){this.#s=e}get backgroundColor(){return this.#Si}set backgroundColor(e){e instanceof ColorRGBA||consoleAndThrowError("allow only ColorRGBA instance"),this.#Si=e}get useBackgroundColor(){return this.#Mi}set useBackgroundColor(e){this.#Mi=e}}const cr=parseWGSL("\r\nstruct Uniforms {\ropacity:f32,\ruseSkyboxTexture:u32\r\n};\r\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\r\n@group(2) @binding(1) var skyboxTextureSampler:sampler;\r\n@group(2) @binding(2) var skyboxTexture:texture_cube<f32>;\r\n\r\nstruct InputData {\r@location(0) vertexPosition:vec4<f32>,\r\n};\r\n@fragment\r\nfn main(inputData:InputData) -> @location(0) vec4<f32> {\rvar cubemapVec=inputData.vertexPosition.xyz - vec3<f32>(0.5);\r\n\r\n\rvar sampleColor:vec4<f32>=textureSample(skyboxTexture,skyboxTextureSampler,cubemapVec);\rvar outColor=vec4<f32>(sampleColor.rgb,sampleColor.a * uniforms.opacity);\rif(outColor.a==0.0) {\rdiscard;\r}\rreturn outColor;\r\n}\r\n");class SkyBoxMaterial extends ABitmapBaseMaterial{dirtyPipeline=!1;constructor(e,t){super(e,"SKYBOX_MATERIAL",cr,2),this.skyboxTexture=t,this.skyboxTextureSampler=new Sampler(this.redGPUContext),this.initGPURenderInfos()}}rt.defineCubeTexture(SkyBoxMaterial,["skyboxTexture"]),rt.defineSampler(SkyBoxMaterial,["skyboxTextureSampler"]),Object.freeze(SkyBoxMaterial);class ViewRenderTextureManager{get render2PathTexture(){return this.#Pi}#Ei;#Pi;#ki;get render2PathTextureDescriptor(){return this.#ki}#Ci;#Li;#Bi;#Ii;#Ui;#Ai=!0;#Di=!0;#v;#Vr;constructor(e){validateRedGPUContext(e.redGPUContext),this.#v=e.redGPUContext,this.#Vr=e}get colorTexture(){return this.#Ei}get colorResolveTexture(){return this.#Ci}get depthTexture(){return this.#Li}get depthTextureView(){return this.#Ni("depth"),this.#Ui}get colorTextureView(){return this.#Ni("color"),this.#Bi}get colorResolveTextureView(){return this.#Ii}#Ni(e){const t="depth"===e,{useMSAA:r,gpuDevice:n}=this.#v,i=t?this.#Li:this.#Ei,{pixelRectObject:s}=this.#Vr,{width:a,height:o}=s,u=i?.width!==a||i?.height!==o,l=t?this.#Di!==r:this.#Ai!==r,c=!i||u||l;if(t?this.#Di=r:this.#Ai=r,c){i&&(i?.destroy(),t||this.#Ci?.destroy()),this.#Pi?.destroy();const s=n.createTexture({size:[Math.max(a,1),Math.max(o,1),1],sampleCount:r?4:1,format:t?"depth24plus":navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT|("color"===e?GPUTextureUsage.TEXTURE_BINDING:0)});if(t)this.#Li=s,this.#Ui=s.createView();else if(this.#Ei=s,this.#Bi=s.createView(),r){const e=n.createTexture({size:{width:Math.max(a,1),height:Math.max(o,1),depthOrArrayLayers:1},sampleCount:1,format:navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});this.#Ci=e,this.#Ii=e.createView()}this.#ki={size:{width:a,height:o,depthOrArrayLayers:1},format:navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,mipLevelCount:getMipLevelCount(a,o)},this.#Pi=n.createTexture(this.#ki)}}}Object.freeze(ViewRenderTextureManager);const hr=create$5(),computeViewFrustumPlanes=(e,t)=>{multiply$5(hr,e,t);const r=[[hr[3]-hr[0],hr[7]-hr[4],hr[11]-hr[8],hr[15]-hr[12]],[hr[3]+hr[0],hr[7]+hr[4],hr[11]+hr[8],hr[15]+hr[12]],[hr[3]+hr[1],hr[7]+hr[5],hr[11]+hr[9],hr[15]+hr[13]],[hr[3]-hr[1],hr[7]-hr[5],hr[11]-hr[9],hr[15]-hr[13]],[hr[3]-hr[2],hr[7]-hr[6],hr[11]-hr[10],hr[15]-hr[14]],[hr[3]+hr[2],hr[7]+hr[6],hr[11]+hr[10],hr[15]+hr[14]]];for(let e=0;e<6;e++){const t=r[e],n=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);t[0]/=n,t[1]/=n,t[2]/=n,t[3]/=n}return r};class ViewTransform{onResize=null;#v;#Oi=create$5();#ir;#r=0;#n=0;#Br;#Ir;#Ur=[0,0,0,0];constructor(e){validateRedGPUContext(e),this.#v=e}get redGPUContext(){return this.#v}get camera(){return this.#ir}set camera(e){e instanceof PerspectiveCamera||e instanceof Camera2D||e instanceof Camera2D||e instanceof OrthographicCamera||e instanceof AController||consoleAndThrowError("allow PerspectiveCamera or OrthographicCamera or AController instance"),this.#ir=e}get x(){return this.#r}set x(e){this.setPosition(e,this.y)}get y(){return this.#n}set y(e){this.setPosition(this.x,e)}get width(){return this.#Br}set width(e){this.setSize(e,this.#Ir)}get height(){return this.#Ir}set height(e){this.setSize(this.#Br,e)}get pixelRectArray(){return this.#Ur}get pixelRectObject(){return{x:this.#Ur[0],y:this.#Ur[1],width:this.#Ur[2],height:this.#Ur[3]}}get screenRectObject(){return{x:this.#Ur[0]/devicePixelRatio,y:this.#Ur[1]/devicePixelRatio,width:this.#Ur[2]/devicePixelRatio,height:this.#Ur[3]/devicePixelRatio}}get aspect(){return this.#Ur[2]/this.#Ur[3]}get frustumPlanes(){return this.#ir instanceof AController?computeViewFrustumPlanes(this.projectionMatrix,this.#ir.camera.modelMatrix):computeViewFrustumPlanes(this.projectionMatrix,this.#ir.modelMatrix)}get rawCamera(){return this.#ir instanceof AController?this.#ir.camera:this.#ir}get projectionMatrix(){const{pixelRectObject:e,redGPUContext:t}=this;if(this.rawCamera instanceof OrthographicCamera){const{nearClipping:e,farClipping:t}=this.rawCamera;orthoZO(this.#Oi,this.rawCamera.left,this.rawCamera.right,this.rawCamera.bottom,this.rawCamera.top,e,t)}else if(this.rawCamera instanceof Camera2D)f(this.#Oi,-.5,.5,-.5,.5,-1e5,1e5),scale$5(this.#Oi,this.#Oi,[t.renderScale,t.renderScale,1]),translate$1(this.#Oi,this.#Oi,[-.5,.5,0]),scale$5(this.#Oi,this.#Oi,[1/e.width*window.devicePixelRatio,-1/e.height*window.devicePixelRatio,1]),identity$2(this.rawCamera.modelMatrix);else{const{fieldOfView:e,nearClipping:t,farClipping:r}=this.rawCamera;p(this.#Oi,Math.PI/180*e,this.aspect,t,r)}return this.#Oi}get inverseProjectionMatrix(){return invert$2(create$5(),this.#Oi)}setPosition(e=this.#r,t=this.#n){const{sizeManager:r}=this.#v;RedGPUContextSizeManager.validatePositionValue(e),RedGPUContextSizeManager.validatePositionValue(t),this.#r=e,this.#n=t;const n=r.pixelRectObject,i=RedGPUContextSizeManager.getPixelDimension(n,"width",e),s=RedGPUContextSizeManager.getPixelDimension(n,"height",t);this.#Ur[0]=Math.floor(i*(this.#r.toString().includes("%")?1:r.renderScale*window.devicePixelRatio)),this.#Ur[1]=Math.floor(s*(this.#n.toString().includes("%")?1:r.renderScale*window.devicePixelRatio))}setSize(e=this.#Br,t=this.#Ir){const{sizeManager:r}=this.#v;RedGPUContextSizeManager.validateSizeValue(e),RedGPUContextSizeManager.validateSizeValue(t),this.#Br=e,this.#Ir=t;const n=r.pixelRectObject,i=RedGPUContextSizeManager.getPixelDimension(n,"width",e),s=RedGPUContextSizeManager.getPixelDimension(n,"height",t);this.#Ur[2]=Math.floor(i*(this.#Br.toString().includes("%")?1:r.renderScale*window.devicePixelRatio)),this.#Ur[3]=Math.floor(s*(this.#Ir.toString().includes("%")?1:r.renderScale*window.devicePixelRatio)),this.onResize&&this.onResize(this.screenRectObject.width,this.screenRectObject.height)}}const dr=parseWGSL(He.SYSTEM_UNIFORM).uniforms.systemUniforms;class View3D extends ViewTransform{#Gi=dr;#Vi;#Fi;#e;#Hi;#zi;#Ki;#s;#$i;#Xi=!0;#ji=!1;#Yi=50;#Zi;#qi;#Wi;#Ji;#Qi=new PickingManager;#es=[];#ts;#Pe;#rs;#ns;#is;#ss;#as=void 0;#os=void 0;constructor(e,t,r,n){super(e),this.scene=t,this.camera=r,n&&(this.name=n),this.#us(),this.#Ji=new ViewRenderTextureManager(this),this.#qi=new RenderViewStateData(this),this.#Wi=new PostEffectManager(this),this.setSize("100%","100%")}get viewRenderTextureManager(){return this.#Ji}get systemUniform_Vertex_StructInfo(){return this.#Gi}get systemUniform_Vertex_UniformBindGroup(){return this.#Vi}get systemUniform_Vertex_UniformBuffer(){return this.#Fi}get passLightClustersBound(){return this.#ss}get iblTexture(){return this.#Zi}set iblTexture(e){this.#Zi=e}get pickingManager(){return this.#Qi}get postEffectManager(){return this.#Wi}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#s||`${this.constructor.name} Instance ${this.#e}`}set name(e){this.#s=e}get debugViewRenderState(){return this.#qi}get grid(){return this.#Hi}set grid(e){if("boolean"==typeof e)e=!0===e?new Grid(this.redGPUContext):null;else if(!(e instanceof Grid)&&null!==e)throw new TypeError("grid must be of type 'Grid','boolean',or 'null'.");this.#Hi=e}get axis(){return this.#zi}set axis(e){if("boolean"==typeof e)e=!0===e?new Axis(this.redGPUContext):null;else if(!(e instanceof Axis)&&null!==e)throw new TypeError("axis must be of type 'Axis','boolean',or 'null'.");this.#zi=e}get skybox(){return this.#Ki}set skybox(e){this.#Ki=e}get useFrustumCulling(){return this.#Xi}set useFrustumCulling(e){this.#Xi=e}get useDistanceCulling(){return this.#ji}set useDistanceCulling(e){this.#ji=e}get distanceCulling(){return this.#Yi}set distanceCulling(e){this.#Yi=e}get scene(){return this.#$i}set scene(e){e instanceof Scene||consoleAndThrowError("allow only Scene instance"),this.#$i=e}update(e,t=!1,r=!1,n){const{scene:i}=e,s=e.iblTexture?.gpuTexture||(e.skybox?._material instanceof SkyBoxMaterial?e.skybox._material.skyboxTexture?.gpuTexture:void 0);let a=t?i.shadowManager.shadowDepthGPUTextureViewEmpty:i.shadowManager.shadowDepthGPUTextureView;const o=e.redGPUContext.viewList.indexOf(e),u=`${o}_${t?"shadowRender":"basic"}`;if(o>-1){let t=!0,r=this.#es[u];r&&(t=r.iblTexture!==s||r.renderPath1ResultTexture!==n||r.shadowDepthGPUTextureView!==a||!this.#is),t?this.#ls(u,a,s,n):this.#Vi=this.#es[u].vertexUniformBindGroup,[{key:"useIblTexture",value:[s?1:0]},{key:"time",value:[e.debugViewRenderState.timestamp||0]},{key:"isView3D",value:[this.constructor===View3D?1:0]}].forEach((({key:e,value:t})=>{this.redGPUContext.gpuDevice.queue.writeBuffer(this.#Fi.gpuBuffer,this.#Gi.members[e].uniformOffset,new this.#Gi.members[e].View(t))})),this.#es[u]={iblTexture:s,renderPath1ResultTexture:n,shadowDepthGPUTextureView:a,vertexUniformBindGroup:this.#Vi}}this.#cs(r)}checkMouseInViewBounds(){const{pixelRectObject:e,pickingManager:t}=this,{mouseX:r,mouseY:n}=t;return 0<r&&r<e.width&&0<n&&n<e.height}#ls(e,t,r,n){this.#cs(!0);const i={layout:this.redGPUContext.resourceManager.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),label:`SYSTEM_UNIFORM_bindGroup_${e}`,entries:[{binding:0,resource:{buffer:this.#Fi.gpuBuffer,offset:0,size:this.#Fi.size}},{binding:1,resource:this.#ts},{binding:2,resource:t},{binding:3,resource:this.#Pe},{binding:4,resource:this.iblTexture?.gpuTexture?.createView(this.iblTexture?.viewDescriptor||CubeTexture.defaultViewDescriptor)||this.#Ki?._material?.skyboxTexture?.gpuTexture?.createView(this.#Ki._material.skyboxTexture.viewDescriptor||CubeTexture.defaultViewDescriptor)||this.redGPUContext.resourceManager.emptyCubeTextureView},{binding:5,resource:{buffer:this.#rs,offset:0,size:this.#rs.size}},{binding:6,resource:{buffer:this.#is.clusterLightsBuffer,offset:0,size:this.#is.clusterLightsBuffer.size}},{binding:7,resource:this.#Pe},{binding:8,resource:n?.createView()||this.redGPUContext.resourceManager.emptyBitmapTextureView},{binding:9,resource:this.#Pe}]};this.#Vi=this.redGPUContext.gpuDevice.createBindGroup(i)}#us(){const e=new ArrayBuffer(dr.arrayBufferByteLength);this.#Fi=new UniformBuffer(this.redGPUContext,e,"#systemUniform_Vertex_UniformBuffer"),this.#ns=new Float32Array(8*Fe.MAX_POINT_LIGHTS+4),this.#rs=this.redGPUContext.gpuDevice.createBuffer({label:"clusterPointLightsBuffer",size:this.#ns.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),this.redGPUContext.gpuDevice.queue.writeBuffer(this.#rs,0,this.#ns),this.#ts=new Sampler(this.redGPUContext,{addressModeU:Be.CLAMP_TO_EDGE,addressModeV:Be.CLAMP_TO_EDGE,addressModeW:Be.CLAMP_TO_EDGE,compare:St.LESS_EQUAL}).gpuSampler,this.#Pe=new Sampler(this.redGPUContext).gpuSampler}#cs(e=!1){if(!e)return;const{redGPUContext:t,scene:r}=this;if(this.#ss||(this.#ss=new PassPointLightClustersBound(t,this)),this.#is&&(this.#ss.render(),this.#as=this.pixelRectArray[2],this.#os=this.pixelRectArray[3]),this.#is||(this.#is=new PassPointLightClusters(t,this)),r){const{pointLights:e}=r.lightManager,t=e.length;if(t){let r=t;for(;r--;){const t=e[r],n=4+8*r;this.#ns.set([...t.position,t.radius,...t.color.rgbNormal,t.intensity],n)}this.#ns.set([t,0,0,0],0),this.redGPUContext.gpuDevice.queue.writeBuffer(this.#rs,0,this.#ns)}this.#is.render()}}}Object.freeze(View3D);class RedGPUContextViewContainer{#hs=[];constructor(){}get viewList(){return this.#hs}get numViews(){return this.#hs.length}contains(e){return this.#hs.includes(e)}addView(e){this.#ds(e),this.#hs.push(e)}addViewAt(e,t){this.#ds(e),validateUintRange(t);const r=this.#hs.length;r<t&&(t=r),this.#hs[t]=e}getViewAt(e){return validateUintRange(e),this.#hs[e]}getViewIndex(e){return this.#ds(e),this.#hs.indexOf(e)}setViewIndex(e,t){this.#ds(e),validateUintRange(t);const r=this.#hs.length,n=t>=r,i=this.#hs.indexOf(e);-1===i&&consoleAndThrowError(" View  RedGPUContext instance    View ."),n&&consoleAndThrowError(`index must be smaller than the viewList length./index:${t}/this.#viewList.length:${r}`),this.#hs.splice(i,1),this.#hs.splice(t,0,e)}swapViews(e,t){this.#ds(e),this.#ds(t);const r=this.#hs.indexOf(e),n=this.#hs.indexOf(t);-1!==r&&-1!==n||consoleAndThrowError((-1===r?"view1":"view2")+" is not child of this RedGPUContext instance."),this.swapViewsAt(r,n)}swapViewsAt(e,t){e===t&&consoleAndThrowError("The indices to swap cannot be the same."),validateUintRange(e),validateUintRange(t);const r=this.#hs.length;(e>=r||t>=r)&&consoleAndThrowError(`index1,index2 must be smaller than the viewList length./index1:${e}/index2:${t}/this.#viewList.length:${r}`);const n=this.#hs[e];this.#hs[e]=this.#hs[t],this.#hs[t]=n}removeView(e){this.#ds(e);const t=this.#hs.indexOf(e);t>-1?this.#hs.splice(t,1):consoleAndThrowError("View3D is not found in the view list.")}removeViewAt(e){validateUintRange(e);const t=this.#hs.length;e<t?this.#hs.splice(e,1):consoleAndThrowError(`Index ${e} is out of range. View list length is ${t}.`)}removeAllViews(){this.#hs.length=0}#ds(e){e instanceof View3D||consoleAndThrowError("allow only View3D instance")}}class RedGPUContextDetector{#ms;#ps;#fs;#gs;#_s;constructor(e){this.#us(e.gpuAdapter)}get adapterInfo(){return this.#ms}get limits(){return this.#ps}get isFallbackAdapter(){return this.#fs}get groupedLimits(){return this.#gs}get userAgent(){return this.#_s}get isMobile(){return/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Windows Phone|Kindle|Silk|PlayBook/i.test(navigator.userAgent)}#us(e){this.#_s=navigator.userAgent,this.#xs(e),this.#vs()}#xs(e){if(e){const{isFallbackAdapter:t,limits:r,info:n}=e;this.#ms=n,this.#fs=t,this.#ps=r}}#vs(){const e={TextureLimits:["maxTextureDimension1D","maxTextureDimension2D","maxTextureDimension3D","maxTextureArrayLayers","maxSampledTexturesPerShaderStage","maxSamplersPerShaderStage"],BufferLimits:["maxBindGroups","maxBindGroupsPlusVertexBuffers","maxBindingsPerBindGroup","maxDynamicUniformBuffersPerPipelineLayout","maxDynamicStorageBuffersPerPipelineLayout","maxStorageBuffersPerShaderStage","maxStorageTexturesPerShaderStage","maxUniformBuffersPerShaderStage","maxUniformBufferBindingSize","maxStorageBufferBindingSize","minUniformBufferOffsetAlignment","minStorageBufferOffsetAlignment","maxBufferSize"],PipelineAndShaderLimits:["maxVertexBuffers","maxVertexAttributes","maxVertexBufferArrayStride","maxInterStageShaderComponents","maxInterStageShaderVariables"],ComputeLimits:["maxComputeWorkgroupStorageSize","maxComputeInvocationsPerWorkgroup","maxComputeWorkgroupSizeX","maxComputeWorkgroupSizeY","maxComputeWorkgroupSizeZ","maxComputeWorkgroupsPerDimension"],ColorLimits:["maxColorAttachments","maxColorAttachmentBytesPerSample"]};let t={TextureLimits:{},BufferLimits:{},PipelineAndShaderLimits:{},ComputeLimits:{},ColorLimits:{},EtcLimit:{}};for(const r in this.#ps){let n=!1;for(const i in e)if(e[i].includes(r)){t[i][r]=this.#ps[r],n=!0;break}n||(t.EtcLimit[r]=this.#ps[r])}this.#gs=t}}class RedGPUContext extends RedGPUContextViewContainer{currentRequestAnimationFrame;useMSAA=!0;onResize=null;#Ts;#ys;#bs;#Ss;#T;#Ar;#Ms;#Rs;#et;#Si=new ColorRGBA(0,0,0,1);#ws=!1;#Ps={};constructor(e,t,r,n,i){super(),this.#ys=t,this.#T=r,this.#Ss=n,this.#bs=i,this.#Ar=e,this.#Ms=new RedGPUContextSizeManager(this),this.#Rs=new RedGPUContextDetector(this),this.#et=new ResourceManager(this),this.#Es()}get useDebugPanel(){return this.#ws}set useDebugPanel(e){this.#ws=e}get backgroundColor(){return this.#Si}set backgroundColor(e){e instanceof ColorRGBA||consoleAndThrowError("allow only ColorRGBA instance"),this.#Si=e}get detector(){return this.#Rs}get configurationDescription(){return this.#Ts}get gpuAdapter(){return this.#ys}get alphaMode(){return this.#bs}set alphaMode(e){this.#bs=e,this.#ks()}get gpuContext(){return this.#Ss}get gpuDevice(){return this.#T}get htmlCanvas(){return this.#Ar}get keyboardKeyBuffer(){return this.#Ps}set keyboardKeyBuffer(e){this.#Ps=e}get resourceManager(){return this.#et}get sizeManager(){return this.#Ms}get width(){return this.#Ms.width}set width(e){this.#Ms.width=e}get height(){return this.#Ms.height}set height(e){this.#Ms.height=e}get screenRectObject(){return this.#Ms.screenRectObject}get renderScale(){return this.#Ms.renderScale}set renderScale(e){this.#Ms.renderScale=e,this.viewList.forEach((e=>{e.setPosition(),e.setSize()}))}destroy(){this.#T.destroy()}setSize(e=this.width,t=this.height){this.sizeManager.setSize(e,t)}#Es(){this.#ks(),this.sizeManager.setSize("100%","100%"),window?.addEventListener("resize",(()=>{this.sizeManager.setSize(),this.viewList.forEach((e=>{e.setSize(),e.setPosition()}))}));(this.detector.isMobile?["click","touchmove","touchstart","touchend"]:["click","mousemove","mousedown","mouseup"]).forEach((e=>{const t=this.detector.isMobile?{click:tr.CLICK,touchmove:tr.MOVE,touchstart:tr.DOWN,touchend:tr.UP}:{click:tr.CLICK,mousemove:tr.MOVE,mousedown:tr.DOWN,mouseup:tr.UP};this.#Ar.addEventListener(e,(e=>{const r=t[e.type];this.viewList.forEach((t=>{this.detector.isMobile&&e instanceof TouchEvent&&e.touches.length>0?(t.pickingManager.mouseX=e.touches[0].clientX*devicePixelRatio-t.pixelRectObject.x,t.pickingManager.mouseY=e.touches[0].clientY*devicePixelRatio-t.pixelRectObject.y):e instanceof MouseEvent&&(t.pickingManager.mouseX=e.offsetX*devicePixelRatio-t.pixelRectObject.x,t.pickingManager.mouseY=e.offsetY*devicePixelRatio-t.pixelRectObject.y),r===tr.CLICK?t.pickingManager.lastMouseClickEvent={...e,type:r}:t.pickingManager.lastMouseEvent={...e,type:r}}))}))}));{const HD_keyDown=e=>{this.#Ps[e.key]=!0},HD_keyUp=e=>{this.#Ps[e.key]=!1};window?.addEventListener("keyup",HD_keyUp),window?.addEventListener("keydown",HD_keyDown)}new ResizeObserver((e=>{})).observe(this.#Ar)}#ks(){const e=navigator.gpu.getPreferredCanvasFormat();this.#Ts={device:this.#T,format:e,alphaMode:this.#bs},this.#Ss.configure(this.#Ts)}#Cs=()=>{this.sizeManager.setSize()};saveCanvasAsImage(){const e=this.htmlCanvas.toDataURL("image/png"),t=document.createElement("a");t.href=e,t.download="image.png",t.click()}}Object.freeze(RedGPUContext);const getFileExtension=e=>{if(!e||0===e.trim().length)throw new Error("URL must not be empty or undefined");const t=e.split("/"),r=t[t.length-1],n=r.lastIndexOf(".");return-1===n?"":r.substring(n+1).toLowerCase()},getFileName=(e,t=!0)=>{const r=e.substring(e.lastIndexOf("/")+1);return t?r:r.split(".").slice(0,-1).join(".")},getFilePath=e=>{if(!e||0===e.trim().length)throw new Error("URL must not be empty or undefined");return e.substring(0,e.lastIndexOf("/")+1)},calculateNormals=(e,t)=>{let r,n,i=[];for(r=0;r<e.length;r+=3)i[r+0]=0,i[r+1]=0,i[r+2]=0;for(r=0;r<t.length;r+=3){let s,a,o,u,l=[],c=[],h=[];for(s=3*t[r],a=3*t[r+1],o=3*t[r+2],l[0]=e[o+0]-e[a+0],l[1]=e[o+1]-e[a+1],l[2]=e[o+2]-e[a+2],c[0]=e[s+0]-e[a+0],c[1]=e[s+1]-e[a+1],c[2]=e[s+2]-e[a+2],h[0]=l[1]*c[2]-l[2]*c[1],h[1]=l[2]*c[0]-l[0]*c[2],h[2]=l[0]*c[1]-l[1]*c[0],n=0;n<3;n++)u=3*t[r+n],i[u+0]=i[u+0]+h[0],i[u+1]=i[u+1]+h[1],i[u+2]=i[u+2]+h[2]}for(r=0;r<e.length;r+=3){let e=[];e[0]=i[r+0],e[1]=i[r+1],e[2]=i[r+2];let t=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);0===t&&(t=1),e[0]=e[0]/t,e[1]=e[1]/t,e[2]=e[2]/t,i[r+0]=e[0],i[r+1]=e[1],i[r+2]=e[2]}return i},formatBytes=(e,t=2)=>{if(("number"!=typeof e||e<0||Number.isNaN(e)||!Number.isInteger(e))&&consoleAndThrowError("Invalid input:'bytes' must be a uint"),0===e)return"0 Bytes";const r=t<0?0:t,n=Math.floor(Math.log(e)/Math.log(1024));return parseFloat((e/Math.pow(1024,n)).toFixed(r))+" "+["Bytes","KB","MB","GB"][n]},mat4ToEuler=(e,t,r)=>{t=t||[0,0,0],r=r||"XYZ";let n=e[0],i=e[4],s=e[8],a=e[1],o=e[5],u=e[9],l=e[2],c=e[6],h=e[10];return"XYZ"===r?(t[1]=Math.asin(clamp(s,-1,1)),Math.abs(s)<.99999?(t[0]=Math.atan2(-u,h),t[2]=Math.atan2(-i,n)):(t[0]=Math.atan2(c,o),t[2]=0)):"YXZ"===r?(t[0]=Math.asin(-clamp(u,-1,1)),Math.abs(u)<.99999?(t[1]=Math.atan2(s,h),t[2]=Math.atan2(a,o)):(t[1]=Math.atan2(-l,n),t[2]=0)):"ZXY"===r?(t[0]=Math.asin(clamp(c,-1,1)),Math.abs(c)<.99999?(t[1]=Math.atan2(-l,h),t[2]=Math.atan2(-i,o)):(t[1]=0,t[2]=Math.atan2(a,n))):"ZYX"===r?(t[1]=Math.asin(-clamp(l,-1,1)),Math.abs(l)<.99999?(t[0]=Math.atan2(c,h),t[2]=Math.atan2(a,n)):(t[0]=0,t[2]=Math.atan2(-i,o))):"YZX"===r?(t[2]=Math.asin(clamp(a,-1,1)),Math.abs(a)<.99999?(t[0]=Math.atan2(-u,o),t[1]=Math.atan2(-l,n)):(t[0]=0,t[1]=Math.atan2(s,h))):"XZY"===r&&(t[2]=Math.asin(-clamp(i,-1,1)),Math.abs(i)<.99999?(t[0]=Math.atan2(c,o),t[1]=Math.atan2(s,n)):(t[0]=Math.atan2(-u,h),t[1]=0)),t};let clamp=function(e,t,r){return Math.max(t,Math.min(r,e))};const quaternionToRotationMat4=(e,t)=>{let r=e[0],n=e[1],i=e[2],s=e[3],a=r+r,o=n+n,u=i+i,l=r*a,c=r*o,h=r*u,d=n*o,m=n*u,p=i*u,f=s*a,g=s*o,_=s*u;return t[0]=1-(d+p),t[4]=c-_,t[8]=h+g,t[1]=c+_,t[5]=1-(l+p),t[9]=m-f,t[2]=h-g,t[6]=m+f,t[10]=1-(l+d),t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t};let mr,pr,fr,gr,_r,xr,vr=create$4(),Tr=create$5(),yr=create$5();function sortTransparentObjects(e,t){const r={},{x:n,y:i,z:s}=e;return t.sort(((e,t)=>{if(!r[e.uuid]){const t=e.x-n,a=e.y-i,o=e.z-s;r[e.uuid]=t*t+a*a+o*o}if(!r[t.uuid]){const e=t.x-n,a=t.y-i,o=t.z-s;r[t.uuid]=e*e+a*a+o*o}return r[t.uuid]-r[e.uuid]}))}var br=Object.freeze({__proto__:null,calculateNormals:calculateNormals,calculateTextureByteSize:calculateTextureByteSize,calculateVolume:calculateVolume,computeViewFrustumPlanes:computeViewFrustumPlanes,convertHexToRgb:convertHexToRgb,convertRgbToHex:convertRgbToHex,createUUID:createUUID,formatBytes:formatBytes,getFileExtension:getFileExtension,getFileName:getFileName,getFilePath:getFilePath,getMipLevelCount:getMipLevelCount,getScreenPoint:getScreenPoint,localToWorld:localToWorld,matToEuler:mat4ToEuler,quaternionToRotationMat4:quaternionToRotationMat4,screenToWorld:(e,t)=>{const{rawCamera:r}=t;return mr=2*e[0]/e[2]-1,pr=-2*e[1]/e[3]+1,fr=1,multiply$5(yr,t.projectionMatrix,r.modelMatrix),xr=clone$5(yr),invert$2(xr,xr),vr=fromValues$4(mr,pr,1),identity$2(Tr),translate$1(Tr,Tr,vr),multiply$5(xr,xr,Tr),vr[0]=xr[12],vr[1]=xr[13],vr[2]=xr[14],gr=yr[12]*mr+yr[13]*pr+yr[15],0!==gr&&(_r=1/gr,vr[0]/=_r,vr[1]/=_r,vr[2]/=_r,vr[0]=vr[0]+r.x,vr[1]=vr[1]+r.y,vr[2]=vr[2]+r.z),[vr[0],vr[1],vr[2]]},sortTransparentObjects:sortTransparentObjects,uuidToUint:uuidToUint,worldToLocal:worldToLocal});const copyGPUBuffer=(e,t,r)=>{const n=e.createCommandEncoder();n.copyBufferToBuffer(t,0,r,0,Math.min(t.size,r.size));const i=n.finish();e.queue.submit([i])};var Sr="#redgpu_include SYSTEM_UNIFORM;\r\n\r\nstruct InstanceUniforms {\rinstanceGroupModelMatrix:mat4x4<f32>,\r\n\t instanceModelMatrixs:array<mat4x4<f32>,100000>,\r\n\t instanceNormalModelMatrix:array<mat4x4<f32>,100000>,\r\n\t instanceOpacity:array<f32,100000>,\ruseDisplacementTexture:u32,\rdisplacementScale:f32,\r\n};\r\n@group(1) @binding(0) var<storage,read> instanceUniforms:InstanceUniforms;\r\n@group(1) @binding(1) var displacementTextureSampler:sampler;\r\n@group(1) @binding(2) var displacementTexture:texture_2d<f32>;\r\n\r\nstruct InputData {\r@builtin(instance_index) instanceIdx:u32,\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r\n\r\n};\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) instanceOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(14) receiveShadow:f32,\r@location(15) pickingId:vec4<f32>,\r\n};\r\nstruct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\nconst maxDistance:f32=1000.0;\r\nconst maxMipLevel:f32=10.0;\r\n@vertex\r\nfn main( inputData:InputData ) -> OutputData {\rvar output:OutputData;\r\n\rlet input_instanceIdx:u32=inputData.instanceIdx;\rlet u_modelMatrix=instanceUniforms.instanceModelMatrixs[input_instanceIdx];\rlet u_normalModelMatrix=instanceUniforms.instanceNormalModelMatrix[input_instanceIdx];\rlet u_instanceGroupModelMatrix=instanceUniforms.instanceGroupModelMatrix;\rlet u_useDisplacementTexture=instanceUniforms.useDisplacementTexture==1u;\rlet u_displacementScale=instanceUniforms.displacementScale;\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\n\r\n\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>=u_modelMatrix * vec4<f32>(input_position,1.0);\r\n\r\r\rlet worldPosition=position.xyz;\r\n\r\rlet margin:f32=0.5;\r\n\r\rvar clipPosition:vec4<f32>=u_projectionMatrix * u_cameraMatrix * vec4<f32>(worldPosition,1.0);\r\n\r\rlet ndcPosition:vec3<f32>=clipPosition.xyz/clipPosition.w;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\noutput.position=clipPosition;\r\n\r\r\n\r\n\rvar normalPosition:vec3<f32>=(u_instanceGroupModelMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0)).xyz;;\r\n\r\n\rif (u_useDisplacementTexture) {\rlet distance=distance(position.xyz,u_cameraPosition);\rlet mipLevel=(distance/maxDistance) * maxMipLevel;\rlet displacementSample=textureSampleLevel(displacementTexture,displacementTextureSampler,input_uv,mipLevel).r;\rlet scaledDisplacement=displacementSample * u_displacementScale;\rlet displacedPosition=input_position + input_vertexNormal * scaledDisplacement;\r\n\rposition=u_modelMatrix * vec4<f32>(displacedPosition,1.0);\r\n\r}\r\n\routput.position=u_projectionMatrix * u_cameraMatrix * u_instanceGroupModelMatrix * position;\routput.vertexPosition=position.xyz;\routput.vertexNormal=normalPosition;\routput.uv=input_uv;\routput.instanceOpacity=instanceUniforms.instanceOpacity[input_instanceIdx];\rreturn output;\r\n}\r\n@vertex\r\nfn drawDirectionalShadowDepth( inputData:InputData ) -> OutputShadowData {\rvar output:OutputShadowData;\rlet input_instanceIdx:u32=inputData.instanceIdx;\rlet u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix;\rlet u_modelMatrix=instanceUniforms.instanceModelMatrixs[input_instanceIdx];\rlet u_useDisplacementTexture=instanceUniforms.useDisplacementTexture==1u;\rlet u_displacementScale=instanceUniforms.displacementScale;\r\n\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>;\rposition= u_modelMatrix * vec4<f32>(input_position,1.0);\r\n\r\n\rif (u_useDisplacementTexture) {\rlet distance=distance(position.xyz,u_directionalLightProjectionViewMatrix[3].xyz);\rlet mipLevel=(distance/maxDistance) * maxMipLevel;\rlet displacementSample=textureSampleLevel(displacementTexture,displacementTextureSampler,input_uv,mipLevel).r;\rlet scaledDisplacement=displacementSample * u_displacementScale;\rlet displacedPosition=input_position + input_vertexNormal * scaledDisplacement;\r\n\rposition=u_modelMatrix * vec4<f32>(displacedPosition,1.0);\r}\r\n\r\n\routput.position=u_directionalLightProjectionViewMatrix * position;\rreturn output;\r\n}\r\n";const Mr=3.141592653589793,Rr=6.283185307179586,wr=.225,Pr=1.27323954,Er=.405284735,kr=1.5707963267948966,Cr=Math.PI/180;class InstancingMeshObject3D{modelMatrix=create$5();localMatrix=create$5();normalModelMatrix=create$5();inited=!1;#r=0;#i=0;#n=0;#Kt=[0,0,0];#Zt=1;#qt=1;#Wt=1;#Jt=[1,1,1];#o=0;#u=0;#l=0;#Qt=[0,0,0];#Ls=0;#Bs;#v;#nr=1;get opacity(){return this.#nr}set opacity(e){validatePositiveNumberRange(e,0,1),this.#nr=e,this.#Is()}constructor(e,t,r){validateRedGPUContext(e),this.#v=e,this.#Bs=r,this.#Ls=t}get x(){return this.#r}set x(e){this.#r=this.#Kt[0]=e,this.#Is()}get y(){return this.#n}set y(e){this.#n=this.#Kt[1]=e,this.#Is()}get z(){return this.#i}set z(e){this.#i=this.#Kt[2]=e,this.#Is()}get position(){return this.#Kt}set position(e){this.#r=this.#Kt[0]=e,this.#n=this.#Kt[1]=e,this.#i=this.#Kt[2]=e,this.#Is()}get scaleX(){return this.#Zt}set scaleX(e){this.#Zt=this.#Jt[0]=e,this.#Is()}get scaleY(){return this.#qt}set scaleY(e){this.#qt=this.#Jt[1]=e,this.#Is()}get scaleZ(){return this.#Wt}set scaleZ(e){this.#Wt=this.#Jt[2]=e,this.#Is()}get scale(){return this.#Kt}set scale(e){this.#Zt=this.#Jt[0]=e,this.#qt=this.#Jt[1]=e,this.#Wt=this.#Jt[2]=e,this.#Is()}get rotationX(){return this.#o}set rotationX(e){this.#o=this.#Qt[0]=e,this.#Is()}get rotationY(){return this.#u}set rotationY(e){this.#u=this.#Qt[1]=e,this.#Is()}get rotationZ(){return this.#l}set rotationZ(e){this.#l=this.#Qt[2]=e,this.#Is()}get rotation(){return this.#Qt}set rotation(e){this.#o=this.#Qt[0]=e,this.#u=this.#Qt[1]=e,this.#l=this.#Qt[2]=e,this.#Is()}setScale(e,t,r){t=t??e,r=r??e;const n=this.#Jt;this.#Zt=n[0]=e,this.#qt=n[1]=t,this.#Wt=n[2]=r,this.#Is()}setPosition(e,t,r){t=t??e,r=r??e;const n=this.#Kt;this.#r=n[0]=e,this.#n=n[1]=t,this.#i=n[2]=r,this.#Is()}setRotation(e,t,r){t=t??e,r=r??e;const n=this.#Qt;this.#o=n[0]=e,this.#u=n[1]=t,this.#l=n[2]=r,this.#Is()}#Is(){let e,t,r,n,i,s,a,o,u,l,c,h,d,m,p,f,g,_,x,v,T,y,b,S,M,R,w,P,E,k,C,L,B,I,U,A,D,N;this.inited=!0;{const d=this.localMatrix;let g;l=1,c=0,h=0,m=0,p=1,f=0,_=0,x=0,v=1,d[12]=this.#r,d[13]=this.#n,d[14]=this.#i,d[15]=1,a=this.#o*Cr,o=this.#u*Cr,u=this.#l*Cr,g=a%Rr,g<-3.141592653589793?g+=Rr:g>Mr&&(g-=Rr),g=g<0?Pr*g+Er*g*g:Pr*g-Er*g*g,e=g<0?wr*(g*-g-g)+g:wr*(g*g-g)+g,g=(a+kr)%Rr,g<-3.141592653589793?g+=Rr:g>Mr&&(g-=Rr),g=g<0?Pr*g+Er*g*g:Pr*g-Er*g*g,n=g<0?wr*(g*-g-g)+g:wr*(g*g-g)+g,g=o%Rr,g<-3.141592653589793?g+=Rr:g>Mr&&(g-=Rr),g=g<0?Pr*g+Er*g*g:Pr*g-Er*g*g,t=g<0?wr*(g*-g-g)+g:wr*(g*g-g)+g,g=(o+kr)%Rr,g<-3.141592653589793?g+=Rr:g>Mr&&(g-=Rr),g=g<0?Pr*g+Er*g*g:Pr*g-Er*g*g,i=g<0?wr*(g*-g-g)+g:wr*(g*g-g)+g,g=u%Rr,g<-3.141592653589793?g+=Rr:g>Mr&&(g-=Rr),g=g<0?Pr*g+Er*g*g:Pr*g-Er*g*g,r=g<0?wr*(g*-g-g)+g:wr*(g*g-g)+g,g=(u+kr)%Rr,g<-3.141592653589793?g+=Rr:g>Mr&&(g-=Rr),g=g<0?Pr*g+Er*g*g:Pr*g-Er*g*g,s=g<0?wr*(g*-g-g)+g:wr*(g*g-g)+g,k=i*s,C=e*t*s-n*r,L=n*t*s+e*r,B=i*r,I=e*t*r+n*s,U=n*t*r-e*s,A=-t,D=e*i,N=n*i,a=this.#Zt,o=this.#qt,u=this.#Wt,d[0]=(l*k+m*C+_*L)*a,d[1]=(c*k+p*C+x*L)*a,d[2]=(h*k+f*C+v*L)*a,d[3]=d[3]*a,d[4]=(l*B+m*I+_*U)*o,d[5]=(c*B+p*I+x*U)*o,d[6]=(h*B+f*I+v*U)*o,d[7]=d[7]*o,d[8]=(l*A+m*D+_*N)*u,d[9]=(c*A+p*D+x*N)*u,d[10]=(h*A+f*D+v*N)*u,d[11]=d[11]*u}this.modelMatrix=this.localMatrix;{let e=this.normalModelMatrix,t=this.modelMatrix;l=t[0],c=t[1],h=t[2],d=t[3],m=t[4],p=t[5],f=t[6],g=t[7],_=t[8],x=t[9],v=t[10],T=t[11],b=t[12],S=t[13],M=t[14],R=t[15],y=l*p-c*m,w=l*f-h*m,P=l*g-d*m,E=c*f-h*p,k=c*g-d*p,C=h*g-d*f,L=_*S-x*b,B=_*M-v*b,I=_*R-T*b,A=x*R-T*S,U=v*R-T*M,N=y*U-w*A+P*U+E*I-k*B+C*L,N=1/N,e[0]=(p*U-f*A+g*U)*N,e[4]=(-c*U+h*A-d*U)*N,e[8]=(S*C-M*k+R*E)*N,e[12]=(-x*C+v*k-T*E)*N,e[1]=(-m*U+f*I-g*B)*N,e[5]=(l*U-h*I+d*B)*N,e[9]=(-b*C+M*P-R*w)*N,e[13]=(_*C-v*P+T*w)*N,e[2]=(m*A-p*I+g*L)*N,e[6]=(-l*A+c*I-d*L)*N,e[10]=(b*k-S*P+R*y)*N,e[14]=(-_*k+x*P-T*y)*N,e[3]=(-m*U+p*B-f*L)*N,e[7]=(l*U-c*B+h*L)*N,e[11]=(-b*E+S*w-M*y)*N,e[15]=(_*E-x*w+v*y)*N}if(this.#Bs.gpuRenderInfo){const{vertexUniformBuffer:e,vertexUniformInfo:t}=this.#Bs.gpuRenderInfo,r=t.members.instanceModelMatrixs,n=t.members.instanceNormalModelMatrix,i=t.members.instanceOpacity;this.#v.gpuDevice.queue.writeBuffer(e.gpuBuffer,r.uniformOffset+r.stride*this.#Ls,new r.View(this.modelMatrix)),this.#v.gpuDevice.queue.writeBuffer(e.gpuBuffer,n.uniformOffset+n.stride*this.#Ls,new n.View(this.normalModelMatrix)),this.#v.gpuDevice.queue.writeBuffer(e.gpuBuffer,i.uniformOffset+i.stride*this.#Ls,new i.View([this.opacity]))}}}const Lr="VERTEX_BIND_GROUP_DESCRIPTOR_INSTANCING";class InstancingMesh extends Mesh{#Ht=!0;#v;#Us=1;#As=[];constructor(e,t,r,n){super(e,r,n),this.#v=e,this.gpuRenderInfo=new VertexGPURenderInfo(null,null,null,null,null,null),this.instanceCount=t,this.#Ds(e)}get instanceCount(){return this.#Us}set instanceCount(e){validateUintRange(e),this.gpuRenderInfo.vertexUniformInfo=parseWGSL(Sr).storage.instanceUniforms;const t=new ArrayBuffer(this.gpuRenderInfo.vertexUniformInfo.arrayBufferByteLength),r=new StorageBuffer(this.#v,t,this.name),n=this.gpuRenderInfo.vertexUniformBuffer;n?.gpuBuffer&&copyGPUBuffer(this.#v.gpuDevice,n.gpuBuffer,r.gpuBuffer),n?.destroy(),this.gpuRenderInfo.vertexUniformBuffer=r;let i=e;for(;i--;)this.#As[i]||(this.#As[i]=new InstancingMeshObject3D(this.#v,i,this));this.#Us=e,this.#Ds(this.#v)}get instanceChildren(){return this.#As}render(e,t=!1){const{view:r,currentRenderPassEncoder:n}=e,{scene:i}=r,{shadowManager:s}=i,{castingList:a}=s,o=this.parent;let u=this.dirtyTransform;u&&(identity$2(this.localMatrix),translate$1(this.localMatrix,this.localMatrix,[this.x,this.y,this.z]),rotateX$3(this.localMatrix,this.localMatrix,this.rotationX),rotateY$3(this.localMatrix,this.localMatrix,this.rotationY),rotateZ$3(this.localMatrix,this.localMatrix,this.rotationZ),scale$5(this.localMatrix,this.localMatrix,[this.scaleX,this.scaleY,this.scaleZ]),o?.modelMatrix?multiply$5(this.modelMatrix,this.localMatrix,o.modelMatrix):this.modelMatrix=clone$5(this.localMatrix)),this.geometry?e.num3DObjects++:e.num3DGroups++;const l=this.#v;if(this.geometry){const{useMSAA:r,gpuDevice:i}=l;r!==this.#Ht&&(this.#Ht=r,this.dirtyPipeline=!0),this.gpuRenderInfo||this.#Ds(l);const s=this.dirtyPipeline||this.material.dirtyPipeline,{displacementTexture:a,displacementScale:o}=this.material||{};s&&(this.dirtyTransform=!0,this.material.dirtyPipeline&&this.material._updateFragmentState(),this.#Ns(),this.material.dirtyPipeline=!1,this.dirtyPipeline=!1,e.numDirtyPipelines++);const{gpuRenderInfo:u}=this,{vertexUniformBuffer:c,vertexUniformBindGroup:h,vertexUniformInfo:d,pipeline:m,shadowPipeline:p}=u;void 0!==d.members.displacementScale&&i.queue.writeBuffer(c.gpuBuffer,d.members.displacementScale.uniformOffset,new d.members.displacementScale.View([o])),void 0!==d.members.useDisplacementTexture&&i.queue.writeBuffer(c.gpuBuffer,d.members.useDisplacementTexture.uniformOffset,new d.members.useDisplacementTexture.View([a?1:0])),this.dirtyTransform&&i.queue.writeBuffer(c.gpuBuffer,d.members.instanceGroupModelMatrix.uniformOffset,new d.members.instanceGroupModelMatrix.View(this.modelMatrix)),this.dirtyTransform=!1,n.setPipeline(t?p:m);const{gpuBuffer:f}=this.geometry.vertexBuffer,{fragmentUniformBindGroup:g}=this.material.gpuRenderInfo;if(e.prevVertexGpuBuffer!==f&&(n.setVertexBuffer(0,f),e.prevVertexGpuBuffer=f),n.setBindGroup(1,h),n.setBindGroup(2,g),e.numDrawCalls++,e.numInstances++,this.geometry.indexBuffer){const{indexBuffer:t}=this.geometry,{indexNum:r,triangleCount:i,gpuBuffer:s}=t;n.setIndexBuffer(s,"uint32"),n.drawIndexed(r,this.#Us,0,0,0),e.numTriangles+=i*this.#Us,e.numPoints+=r*this.#Us}else{const{vertexBuffer:t}=this.geometry,{vertexCount:r,triangleCount:i}=t;n.draw(r,this.#Us,0,0),e.numTriangles+=i,e.numPoints+=r}}this.castShadow&&(a[a.length]=this);const{children:c}=this;let h=c.length;for(;h--;)c[h].dirtyTransform=u,c[h].render(e);this.dirtyTransform=!1}#Ds(e){this.dirtyPipeline=!0;const{resourceManager:t}=this.#v,r=t.getGPUBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_Instancing),{basicSampler:n,emptyBitmapTextureView:i,emptyCubeTextureView:s}=t,{gpuSampler:a}=n,{vertexUniformBuffer:o}=this.gpuRenderInfo,{material:u}=this,l={layout:r,label:Lr,entries:[{binding:0,resource:{buffer:o.gpuBuffer,offset:0,size:o.size}},{binding:1,resource:u?.displacementTextureSampler?.gpuSampler||a},{binding:2,resource:u?.displacementTexture?.gpuTexture?.createView()||i}]},c=e.gpuDevice.createBindGroup(l);this.#Ns(),this.gpuRenderInfo.vertexBindGroupLayout=r,this.gpuRenderInfo.vertexUniformBindGroup=c}#Ns(){const{resourceManager:e}=this.#v,t={code:Sr},r=e.createGPUShaderModule("VERTEX_MODULE_INSTANCING",t),{vertexUniformBuffer:n}=this.gpuRenderInfo,{material:i}=this,{basicSampler:s,emptyBitmapTextureView:a,emptyCubeTextureView:o}=e,{gpuSampler:u}=s,l=e.getGPUBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_Instancing),c={layout:l,label:Lr,entries:[{binding:0,resource:{buffer:n.gpuBuffer,offset:0,size:n.size}},{binding:1,resource:i?.displacementTextureSampler?.gpuSampler||u},{binding:2,resource:i?.displacementTexture?.gpuTexture?.createView()||a}]};this.gpuRenderInfo.vertexUniformBindGroup=this.redGPUContext.gpuDevice.createBindGroup(c),this.gpuRenderInfo.pipeline=createBasePipeline(this,r,l),this.gpuRenderInfo.shadowPipeline=createBasePipeline(this,r,l,Mt)}}Object.defineProperty(InstancingMesh.prototype,"meshType",{value:"instanceMesh",writable:!1});var Br="#redgpu_include SYSTEM_UNIFORM;\r\n\r\nstruct InputData {\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r\n};\r\n\r\nstruct OutData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec4<f32>,\r\n};\r\nstruct VertexUniforms {\r\n\t modelMatrix:mat4x4<f32>,\r\n};\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n@vertex\r\nfn main(inputData:InputData) -> OutData {\rvar outData:OutData;\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\routData.position=u_projectionMatrix * u_cameraMatrix * vertexUniforms.modelMatrix * vec4<f32>(inputData.position,1.0);\routData.vertexPosition=0.5 * (vec4<f32>(inputData.position,1.0) + vec4<f32>(1.0,1.0,1.0,1.0));\rreturn outData;\r\n}\r\n";const Ir=parseWGSL(Br),Ur=Ir.uniforms.vertexUniforms;var Ar="#redgpu_include SYSTEM_UNIFORM;\r\n\r\nstruct InputData {\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r\n};\r\n\r\nstruct OutData {\r@builtin(position) position:vec4<f32>,\r@location(0) uv:vec2<f32>,\r\n};\r\nstruct VertexUniforms {\r\n\t modelMatrix:mat4x4<f32>,\r\n};\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n@vertex\r\nfn main(inputData:InputData) -> OutData {\rvar outData:OutData;\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet input_uv=inputData.uv;\routData.position=u_projectionMatrix * u_cameraMatrix * vertexUniforms.modelMatrix * vec4<f32>(inputData.position,1.0);\r\n\routData.uv=input_uv;\rreturn outData;\r\n}\r\n";const Dr=parseWGSL("\r\nstruct Uniforms {\ropacity:f32,\ruseSkyboxTexture:u32\r\n};\r\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\r\n@group(2) @binding(1) var skyboxTextureSampler:sampler;\r\n@group(2) @binding(2) var skyboxTexture:texture_2d<f32>;\r\n\r\nstruct InputData {\r@location(0) uv:vec2<f32>,\r\n};\r\n@fragment\r\nfn main(inputData:InputData) -> @location(0) vec4<f32> {\rvar sampleColor:vec4<f32>=textureSample(skyboxTexture,skyboxTextureSampler,inputData.uv);\rvar outColor=vec4<f32>(sampleColor.rgb,sampleColor.a * uniforms.opacity);\rif(outColor.a==0.0) {\rdiscard;\r}\rreturn outColor;\r\n}\r\n");class SphericalSkyBoxMaterial extends ABitmapBaseMaterial{dirtyPipeline=!1;constructor(e,t){super(e,"SPHERICAL_SKYBOX_MATERIAL",Dr,2),this.skyboxTexture=t,this.skyboxTextureSampler=new Sampler(this.redGPUContext),this.initGPURenderInfos()}}rt.defineCubeTexture(SphericalSkyBoxMaterial,["skyboxTexture"]),rt.defineSampler(SphericalSkyBoxMaterial,["skyboxTextureSampler"]),Object.freeze(SphericalSkyBoxMaterial);const Nr=parseWGSL(Ar),Or=Nr.uniforms.vertexUniforms;class View2D extends View3D{constructor(e,t,r){super(e,t,new Camera2D,r)}}Object.freeze(View2D);const Gr=Math.PI/180;class GroupBase extends Object3DContainer{modelMatrix=create$5();localMatrix=create$5();#e;#s;#zt;#r=0;#i=0;#n=0;#Kt=[0,0,0];#$t=0;#Xt=0;#jt=0;#Zt=1;#qt=1;#Wt=1;#Jt=[1,1,1];#o=0;#u=0;#l=0;#Qt=[0,0,0];#Os=!0;constructor(e){super(),e&&(this.name=e)}get dirtyTransform(){return this.#Os}set dirtyTransform(e){this.#Os=e}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#s||`${this.constructor.name} Instance ${this.#e}`}set name(e){this.#s=e}get parent(){return this.#zt}set parent(e){this.#zt=e}get pivotX(){return this.#$t}set pivotX(e){this.#$t=e,this.dirtyTransform=!0}get pivotY(){return this.#Xt}set pivotY(e){this.#Xt=e,this.dirtyTransform=!0}get pivotZ(){return this.#jt}set pivotZ(e){this.#jt=e,this.dirtyTransform=!0}get x(){return this.#r}set x(e){this.#r=this.#Kt[0]=e,this.dirtyTransform=!0}get y(){return this.#n}set y(e){this.#n=this.#Kt[1]=e,this.dirtyTransform=!0}get z(){return this.#i}set z(e){this.#i=this.#Kt[2]=e,this.dirtyTransform=!0}get position(){return this.#Kt}get scaleX(){return this.#Zt}set scaleX(e){this.#Zt=this.#Jt[0]=e,this.dirtyTransform=!0}get scaleY(){return this.#qt}set scaleY(e){this.#qt=this.#Jt[1]=e,this.dirtyTransform=!0}get scaleZ(){return this.#Wt}set scaleZ(e){this.#Wt=this.#Jt[2]=e,this.dirtyTransform=!0}get scale(){return this.#Kt}get rotationX(){return this.#o}set rotationX(e){this.#o=this.#Qt[0]=e,this.dirtyTransform=!0}get rotationY(){return this.#u}set rotationY(e){this.#u=this.#Qt[1]=e,this.dirtyTransform=!0}get rotationZ(){return this.#l}set rotationZ(e){this.#l=this.#Qt[2]=e,this.dirtyTransform=!0}get rotation(){return this.#Qt}setScale(e,t,r){t=t??e,r=r??e;const n=this.#Jt;this.#Zt=n[0]=e,this.#qt=n[1]=t,this.#Wt=n[2]=r,this.dirtyTransform=!0}setPosition(e,t,r){t=t??e,r=r??e;const n=this.#Kt;this.#r=n[0]=e,this.#n=n[1]=t,this.#i=n[2]=r,this.dirtyTransform=!0}setRotation(e,t,r){t=t??e,r=r??e;const n=this.#Qt;this.#o=n[0]=e,this.#u=n[1]=t,this.#l=n[2]=r,this.dirtyTransform=!0}render(e){const{view:t,isScene2DMode:r}=e;let n;if(r&&(this.#i=0,this.#jt=0),this.dirtyTransform){n=!0;{const{pixelRectObject:e}=t,r=this.parent,n=this.localMatrix;identity$2(n),translate$1(n,n,[this.#r,this.#n,this.#i]),rotateX$3(n,n,this.#o*Gr),rotateY$3(n,n,this.#u*Gr),rotateZ$3(n,n,this.#l*Gr);let i=[this.#Zt,this.#qt,this.#Wt];if(this.renderTextureWidth&&(i[0]*=this.renderTextureWidth/e.height,i[1]*=this.renderTextureHeight/e.height),scale$5(n,n,i),this.#$t||this.#Xt||this.#jt){translate$1(n,n,[-this.#$t,-this.#Xt,-this.#jt])}r?.modelMatrix?multiply$5(this.modelMatrix,r.modelMatrix,this.localMatrix):copy$5(this.modelMatrix,this.localMatrix)}}this.dirtyTransform&&(n=!0,this.dirtyTransform=!1),e.num3DGroups++;const{children:i}=this;let s=0;const a=i.length;for(;s<a;s++)n&&(i[s].dirtyTransform=n),i[s].render(e)}}Object.defineProperty(GroupBase.prototype,"meshType",{value:"mesh",writable:!1}),Object.freeze(GroupBase);class Group3D extends GroupBase{#e;#s;constructor(e){super(),e&&(this.name=e)}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#s||`${this.constructor.name} Instance ${this.#e}`}set name(e){this.#s=e}}Object.defineProperty(Group3D.prototype,"meshType",{value:"mesh",writable:!1}),Object.freeze(Group3D);class Group2D extends GroupBase{#e;#s;#Gs=0;constructor(e){super(),e&&(this.name=e)}get name(){return this.#e||(this.#e=InstanceIdGenerator.getNextId(this.constructor)),this.#s||`${this.constructor.name} Instance ${this.#e}`}set name(e){this.#s=e}get rotation(){return this.#Gs}set rotation(e){this.#Gs=e,super.rotationZ=e}setScale(e,t){t=t??e,super.setScale(e,t,1)}setPosition(e,t){t=t??e,super.setPosition(e,t,0)}setRotation(e){this.rotation=e}}Object.defineProperty(Group2D.prototype,"is2DMeshType",{value:!0,writable:!1}),Object.freeze(Group2D);const Vr={Linear:0,QuintIn:1,QuintOut:2,QuintInOut:3,BackIn:4,BackOut:5,BackInOut:6,CircIn:7,CircOut:8,CircInOut:9,CubicIn:10,CubicOut:11,CubicInOut:12,ExpoIn:13,ExpoOut:14,ExpoInOut:15,QuadIn:16,QuadOut:17,QuadInOut:18,QuartIn:19,QuartOut:20,QuartInOut:21,SineIn:22,SineOut:23,SineInOut:24,ElasticIn:25,ElasticOut:26,ElasticInOut:27};class Plane extends Primitive{#$n=function(){const e=[],t=[];return function(r,n,i,s,a,o,u,l){const c=i/2,h=s/2,d=Math.floor(a)||1,m=Math.floor(o)||1,p=d+1,f=m+1,g=i/d,_=s/m;e.length=0,t.length=0;for(let r=0;r<f;r++){const n=r*_-h,i=l?(1-r/m)*u:r/m*u;for(let s=0;s<p;s++){const a=s*g-c,o=s/d*u;if(e.push(a,-n,0,0,0,1,o,i),r<m&&s<d){const e=s+p*r,n=s+p*(r+1),i=s+1+p*(r+1),a=s+1+p*r;t.push(e,n,a),t.push(n,i,a)}}}return createPrimitiveGeometry(n,e,t,r)}}();constructor(e,t=1,r=1,n=1,i=1,s=1,a=!1){super(e);const o=`PRIMITIVE_PLANE_W${t}_H${r}_WS${n}_HS${i}_UV${s}_FY${a}`,u=e.resourceManager.cachedBufferState;let l=u[o];l||(l=u[o]=this.#$n(o,e,t,r,n,i,s,a)),this._setData(l)}}var Fr="#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include getBillboardMatrix;\r\nstruct VertexUniforms {\rpickingId:u32,\r\n\t modelMatrix:mat4x4<f32>,\r\n\t normalModelMatrix:mat4x4<f32>,\r\n\t useBillboardPerspective:u32,\r\n\t useBillboard:u32,\r\n\t combinedOpacity:f32,\r\n};\r\n\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n\r\nstruct InputData {\r@location(0) a_position:vec3<f32>,\r@location(1) a_normal:vec3<f32>,\r@location(2) a_uv:vec2<f32>,\r@location(3) position:vec3<f32>,\r@location(4) alpha:f32,\r@location(5) rotation:vec3<f32>,\r@location(6) scale:f32,\r\n};\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(14) receiveShadow:f32,\r@location(15) pickingId:vec4<f32>,\r\n};\r\nfn mat4_inverse(a:mat4x4<f32>) -> mat4x4<f32> {\rvar a00:f32=a[0][0];\rvar a01:f32=a[0][1];\rvar a02:f32=a[0][2];\rvar a03:f32=a[0][3];\rvar a10:f32=a[1][0];\rvar a11:f32=a[1][1];\rvar a12:f32=a[1][2];\rvar a13:f32=a[1][3];\rvar a20:f32=a[2][0];\rvar a21:f32=a[2][1];\rvar a22:f32=a[2][2];\rvar a23:f32=a[2][3];\rvar a30:f32=a[3][0];\rvar a31:f32=a[3][1];\rvar a32:f32=a[3][2];\rvar a33:f32=a[3][3];\r\n\rvar b00:f32=a00*a11 - a01*a10;\rvar b01:f32=a00*a12 - a02*a10;\rvar b02:f32=a00*a13 - a03*a10;\rvar b03:f32=a01*a12 - a02*a11;\rvar b04:f32=a01*a13 - a03*a11;\rvar b05:f32=a02*a13 - a03*a12;\rvar b06:f32=a20*a31 - a21*a30;\rvar b07:f32=a20*a32 - a22*a30;\rvar b08:f32=a20*a33 - a23*a30;\rvar b09:f32=a21*a32 - a22*a31;\rvar b10:f32=a21*a33 - a23*a31;\rvar b11:f32=a22*a33 - a23*a32;\r\n\r\rvar det:f32=b00*b11 - b01*b10 + b02*b09 + b03*b08 - b04*b07 + b05*b06;\r\n\r\rif (det !=0.0) {\rdet=1.0/det;\rreturn mat4x4<f32>(\r(a11*b11 - a12*b10 + a13*b09) * det,\r(a02*b10 - a01*b11 - a03*b09) * det,\r(a31*b05 - a32*b04 + a33*b03) * det,\r(a22*b04 - a21*b05 - a23*b03) * det,\r(a12*b08 - a10*b11 - a13*b07) * det,\r(a00*b11 - a02*b08 + a03*b07) * det,\r(a32*b02 - a30*b05 - a33*b01) * det,\r(a20*b05 - a22*b02 + a23*b01) * det,\r(a10*b10 - a11*b08 + a13*b06) * det,\r(a01*b08 - a00*b10 - a03*b06) * det,\r(a30*b04 - a31*b02 + a33*b00) * det,\r(a21*b02 - a20*b04 - a23*b00) * det,\r(a11*b07 - a10*b09 - a12*b06) * det,\r(a00*b09 - a01*b07 + a02*b06) * det,\r(a31*b01 - a30*b03 - a32*b00) * det,\r(a20*b03 - a21*b01 + a22*b00) * det\r);\r}\r\n\r\rreturn mat4x4<f32>(\r0.0,0.0,0.0,0.0,\r0.0,0.0,0.0,0.0,\r0.0,0.0,0.0,0.0,\r0.0,0.0,0.0,0.0\r);\r\n}\r\nfn rotationMTX(t:vec3<f32>)->mat4x4<f32>\r\n{\rvar s:f32=sin(t.x);\rvar c:f32=cos(t.x);\rvar m1=mat4x4<f32>(1,0, 0,0,\r0,c,-s,0,\r0,s, c,0,\r0,0, 0,1);\r\n\rs=sin(t[1]);c=cos(t[1]);\rvar m2=mat4x4<f32>(c,0,s,0,\r0,1,0,0,\r-s,0,c,0,\r0,0,0,1);\r\n\rs=sin(t[2]);c=cos(t[2]);\rvar m3=mat4x4<f32>(c,-s,0,0,\rs,c,0,0,\r0,0,1,0,\r0,0,0,1);\r\n\rreturn m1 * m2 * m3;\r\n}\r\n\r\n@vertex\r\nfn main( inputData:InputData) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_resolution=systemUniforms.resolution;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\n\rlet u_useBillboardPerspective=vertexUniforms.useBillboardPerspective==1u;\rlet u_useBillboard=vertexUniforms.useBillboard==1u;\r\n\r\rlet input_position=inputData.position;\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\rvar scaleMTX=mat4x4<f32>(\rinputData.scale,0,0,0,\r0,inputData.scale,0,0,\r0,0,inputData.scale,0,\r0,0,0,1\r);\r\n\r\n\rvar translateTX=mat4x4<f32>(\r1,0,0,0,\r0,1,0,0,\r0,0,1,0,\rinputData.position.x,inputData.position.y,inputData.position.z,1\r);\r\n\r\n\rvar temp:mat4x4<f32>;\rif(u_useBillboard){\rvar rotateMTX2=rotationMTX( vec3(0,0,inputData.rotation.z) );\rtemp=translateTX * rotateMTX2;\rposition=rotateMTX2 * vec4<f32>(inputData.a_position ,1);\routput.position= u_projectionMatrix * getBillboardMatrixNoScaleRatio( u_cameraMatrix, temp ) * scaleMTX * position;\r}else{\rvar rotateMTX=rotationMTX( inputData.rotation );\rtemp=translateTX * rotateMTX * scaleMTX;\rposition=temp * vec4<f32>(inputData.a_position,1);\routput.position=u_projectionMatrix * u_cameraMatrix * position;\r}\r\n\routput.vertexPosition=position.xyz;\routput.vertexNormal= (transpose(mat4_inverse(temp) ) * vec4<f32>(inputData.a_normal,1.0)).xyz;\routput.uv=inputData.a_uv;\routput.combinedOpacity=vertexUniforms.combinedOpacity;\rreturn output;\r\n}\r\nstruct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\n";const Hr=parseWGSL(Fr),zr=Hr.uniforms.vertexUniforms;class ParticleEmitter extends Mesh{#Vs=1e3;#Fs=5e3;#Hs=0;#zs=0;#Ks=0;#$s=0;#Xs=0;#js=0;#Ys=-5;#Zs=-5;#qs=-5;#Ws=5;#Js=5;#Qs=5;#ea=0;#ta=0;#ra=1;#na=1;#ia=0;#sa=1;#aa=0;#oa=0;#ua=-360;#la=-360;#ca=-360;#ha=360;#da=360;#ma=360;#pa=-360;#fa=-360;#ga=-360;#_a=360;#xa=360;#va=360;#Ta=Vr.CubicOut;#ya=Vr.CubicOut;#ba=Vr.CubicOut;#Sa=Vr.Linear;#Ma=Vr.Linear;#Ra=Vr.CubicOut;#wa=Vr.CubicOut;#Pa=Vr.CubicOut;#Ea;#ka;#Ca;#La;#Ba;#Ia=2e3;constructor(e){super(e),this.geometry=new Plane(e),this.material=new BitmapMaterial(e),this.ignoreFrustumCulling=!0,this.useBillboard=!0}get vertexStateBuffers(){return[{arrayStride:32,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x3"},{shaderLocation:2,offset:24,format:"float32x2"}]},{arrayStride:48,stepMode:"instance",attributes:[{shaderLocation:3,offset:16,format:"float32x3"},{shaderLocation:4,offset:28,format:"float32"},{shaderLocation:5,offset:32,format:"float32x3"},{shaderLocation:6,offset:44,format:"float32"}]}]}get particleBuffers(){return this.#ka}get particleNum(){return this.#Ia}set particleNum(e){this.#Ia=Math.max(Math.min(e,5e5),1),this.#Ua()}get minLife(){return this.#Vs}set minLife(e){this.#Vs=e}get maxLife(){return this.#Fs}set maxLife(e){this.#Fs=e}get minStartX(){return this.#Hs}set minStartX(e){this.#Hs=e}get minStartY(){return this.#zs}set minStartY(e){this.#zs=e}get minStartZ(){return this.#Ks}set minStartZ(e){this.#Ks=e}get maxStartX(){return this.#$s}set maxStartX(e){this.#$s=e}get maxStartY(){return this.#Xs}set maxStartY(e){this.#Xs=e}get maxStartZ(){return this.#js}set maxStartZ(e){this.#js=e}get minEndX(){return this.#Ys}set minEndX(e){this.#Ys=e}get minEndY(){return this.#Zs}set minEndY(e){this.#Zs=e}get minEndZ(){return this.#qs}set minEndZ(e){this.#qs=e}get maxEndX(){return this.#Ws}set maxEndX(e){this.#Ws=e}get maxEndY(){return this.#Js}set maxEndY(e){this.#Js=e}get maxEndZ(){return this.#Qs}set maxEndZ(e){this.#Qs=e}get minStartAlpha(){return this.#ea}set minStartAlpha(e){this.#ea=e}get maxStartAlpha(){return this.#ta}set maxStartAlpha(e){this.#ta=e}get minEndAlpha(){return this.#ra}set minEndAlpha(e){this.#ra=e}get maxEndAlpha(){return this.#na}set maxEndAlpha(e){this.#na=e}get minStartScale(){return this.#ia}set minStartScale(e){this.#ia=e}get maxStartScale(){return this.#sa}set maxStartScale(e){this.#sa=e}get minEndScale(){return this.#aa}set minEndScale(e){this.#aa=e}get maxEndScale(){return this.#oa}set maxEndScale(e){this.#oa=e}get minStartRotationX(){return this.#ua}set minStartRotationX(e){this.#ua=e}get minStartRotationY(){return this.#la}set minStartRotationY(e){this.#la=e}get minStartRotationZ(){return this.#ca}set minStartRotationZ(e){this.#ca=e}get maxStartRotationX(){return this.#ha}set maxStartRotationX(e){this.#ha=e}get maxStartRotationY(){return this.#da}set maxStartRotationY(e){this.#da=e}get maxStartRotationZ(){return this.#ma}set maxStartRotationZ(e){this.#ma=e}get minEndRotationX(){return this.#pa}set minEndRotationX(e){this.#pa=e}get minEndRotationY(){return this.#fa}set minEndRotationY(e){this.#fa=e}get minEndRotationZ(){return this.#ga}set minEndRotationZ(e){this.#ga=e}get maxEndRotationX(){return this.#_a}set maxEndRotationX(e){this.#_a=e}get maxEndRotationY(){return this.#xa}set maxEndRotationY(e){this.#xa=e}get maxEndRotationZ(){return this.#va}set maxEndRotationZ(e){this.#va=e}get easeX(){return this.#Ta}set easeX(e){this.#Ta=e}get easeY(){return this.#ya}set easeY(e){this.#ya=e}get easeZ(){return this.#ba}set easeZ(e){this.#ba=e}get easeAlpha(){return this.#Sa}set easeAlpha(e){this.#Sa=e}get easeScale(){return this.#Ma}set easeScale(e){this.#Ma=e}get easeRotationX(){return this.#Ra}set easeRotationX(e){this.#Ra=e}get easeRotationY(){return this.#wa}set easeRotationY(e){this.#wa=e}get easeRotationZ(){return this.#Pa}set easeRotationZ(e){this.#Pa=e}createCustomMeshVertexShaderModule(){return this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_PARTICLE_EMITTER",Hr,zr,Fr)}render(e){this.#ka||this.#us(),this.#Aa(e.timestamp),super.render(e)}#Ua(){let e=this.redGPUContext;const t=new Float32Array(12*this.#Ia),r=new Float32Array(12*this.#Ia),n=new Float32Array(12*this.#Ia),i=new Float32Array(4*this.#Ia),s=new Float32Array(4*this.#Ia),a=performance.now(),o=this.localToWorld(this.x,this.y,this.z);for(let e=0;e<this.#Ia;++e){let u=Math.random()*this.#Fs,l=Math.random()*u;const c=o[0]+Math.random()*(this.#$s-this.#Hs)+this.#Hs,h=o[1]+Math.random()*(this.#Xs-this.#zs)+this.#zs,d=o[2]+Math.random()*(this.#js-this.#Ks)+this.#Ks,m=Math.random()*(this.#ha-this.#ua)+this.#ua,p=Math.random()*(this.#da-this.#la)+this.#la,f=Math.random()*(this.#ma-this.#ca)+this.#ca;Math.random(),this.#sa,this.#ia,this.#ia,Math.random(),this.#ta,this.#ea,this.#ea,t[12*e]=a-l,t[12*e+1]=u,t[12*e+4]=c,t[12*e+5]=h,t[12*e+6]=d,t[12*e+7]=0,t[12*e+8]=m,t[12*e+9]=p,t[12*e+10]=f,t[12*e+11]=0,r[4*e]=c,r[4*e+1]=Math.random()*(this.#Ws-this.#Ys)+this.#Ys,r[4*e+2]=this.#Ta,r[4*e+3]=o[0],r[4*e+4]=h,r[4*e+5]=Math.random()*(this.#Js-this.#Zs)+this.#Zs,r[4*e+6]=this.#ya,r[4*e+7]=o[1],r[4*e+8]=d,r[4*e+9]=Math.random()*(this.#Qs-this.#qs)+this.#qs,r[4*e+10]=this.#ba,r[4*e+11]=o[2],n[4*e]=m,n[4*e+1]=Math.random()*(this.#_a-this.#pa)+this.#pa,n[4*e+2]=this.#Ra,n[4*e+3]=0,n[4*e+4]=p,n[4*e+5]=Math.random()*(this.#xa-this.#fa)+this.#fa,n[4*e+6]=this.#wa,n[4*e+7]=0,n[4*e+8]=f,n[4*e+9]=Math.random()*(this.#va-this.#ga)+this.#ga,n[4*e+10]=this.#Pa,n[4*e+11]=0,i[4*e]=0,i[4*e+1]=Math.random()*(this.#oa-this.#aa)+this.#aa,i[4*e+2]=this.#Ma,i[4*e+3]=0,s[4*e]=0,s[4*e+1]=Math.random()*(this.#na-this.#ra)+this.#ra,s[4*e+2]=this.#Sa,s[4*e+3]=0}const u=this.#ka;this.#ka=[];const l=[t,r,n,i,s];l.forEach(((t,r)=>{const n=e.gpuDevice.createBuffer({size:t.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC|GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE});e.gpuDevice.queue.writeBuffer(n,0,t),this.#ka.push(n),u?.length&&copyGPUBuffer(e.gpuDevice,u[r],n)})),u&&u.forEach((e=>e.destroy()));let c={code:"\r\nstruct Info {\rstartValue:f32,\rendValue:f32,\reaseType:f32,\rbirthCenterValue:f32\r\n};\r\n\r\nstruct InfoGroup {\rinfoX:Info,\rinfoY:Info,\rinfoZ:Info,\r\n};\r\n\r\nstruct Particle {\rstartTime:f32,\rlife:f32,\rvaluePosition:vec3<f32>,\rvalueAlpha:f32,\rvalueRotation:vec3<f32>,\rvalueScale:f32,\r\n};\r\nstruct SimParams {\rtime:f32,\rcurrentPositionX:f32,currentPositionY:f32,currentPositionZ:f32,\rminLife:f32,maxLife:f32,\rminStartX:f32,maxStartX:f32,minEndX:f32,maxEndX:f32,easeX:f32,\rminStartY:f32,maxStartY:f32,minEndY:f32,maxEndY:f32,easeY:f32,\rminStartZ:f32,maxStartZ:f32,minEndZ:f32,maxEndZ:f32,easeZ:f32,\rminStartAlpha:f32,maxStartAlpha:f32,minEndAlpha:f32,maxEndAlpha:f32,easeAlpha:f32,\rminStartScale:f32,maxStartScale:f32,minEndScale:f32,maxEndScale:f32,easeScale:f32,\rminStartRotationX:f32,maxStartRotationX:f32,minEndRotationX:f32,maxEndRotationX:f32,easeRotationX:f32,\rminStartRotationY:f32,maxStartRotationY:f32,minEndRotationY:f32,maxEndRotationY:f32,easeRotationY:f32,\rminStartRotationZ:f32,maxStartRotationZ:f32,minEndRotationZ:f32,maxEndRotationZ:f32,easeRotationZ:f32,\r\n};\r\n\r\n\r\n@group(0) @binding(0) var<uniform> params:SimParams;\r\n@group(0) @binding(1) var<storage,read_write> particles:array<Particle>;\r\n@group(0) @binding(2) var<storage,read_write> infoPosition:array<InfoGroup>;\r\n@group(0) @binding(3) var<storage,read_write> infoRotation:array<InfoGroup>;\r\n@group(0) @binding(4) var<storage,read_write> infoScale:array<Info>;\r\n@group(0) @binding(5) var<storage,read_write> infoAlpha:array<Info>;\r\n\r\nconst PI:f32=3.141592653589793;\r\nconst HPI:f32=PI * 0.5;\r\nconst PI2:f32=PI * 2.0;\r\n\r\nfn calEasing(n:f32,easingType:f32) -> f32 {\rvar m:f32=n;\rlet easingInt:i32=i32(easingType);\r\n\rswitch (easingInt) {\rcase 0:{ m=m;}\rcase 1:{ m=m * m * m * m * m;}\rcase 2:{\rm -=1.0;\rm=(m * m * m * m * m) + 1.0;\r}\rcase 3:{\rif(m * 2.0 < 1.0) {\rm *=2.0;\rm=m * m * m * m * m * 0.5;\r}\relse {\rm=m * 2.0 - 2.0;\rm=0.5 * (m * m * m * m * m + 2.0);\r}\r}\rcase 4:{ m=m * m * (m * 1.70158 + m - 1.70158);}\rcase 5:{\rm -=1.0;\rm=m * m * (m * 1.70158 + m + 1.70158) + 1.0;\r}\rcase 6:{\rif(m * 2.0 < 1.0) {\rm *=2.0;\rm=0.5 * m * m * (m * 1.70158 + m - 1.70158);\r}\relse {\rm=m * 2.0 - 2.0;\rm=0.5 * m * m * (m * 1.70158 + m + 1.70158) + 1.0;\r}\r}\rcase 7:{ m=-1.0 * (sqrt(1.0 - m * m) - 1.0);}\rcase 8:{\rm -=1.0;\rm=sqrt(1.0 - m * m);\r}\rcase 9:{\rif(m * 2.0 < 1.0) {\rm *=2.0;\rm=-0.5 * (sqrt(1.0 - m * m) - 1.0);\r}\relse {\rm=m * 2.0 - 2.0;\rm=0.5 * sqrt(1.0 - m * m) + 0.5;\r}\r}\rcase 10:{ m=m * m * m;}\rcase 11:{\rm -=1.0;\rm=m * m * m + 1.0;\r}\rcase 12:{\rif(m * 2.0 < 1.0) {\rm *=2.0;\rm=m * m * m * 0.5;\r}\relse {\rm=m * 2.0 - 2.0;\rm=0.5 * (m * m * m + 2.0);\r}\r}\rcase 13:{\rif (m==0.0) { m=0.0;}\relse { m=pow(2.0,10.0 * (m - 1.0));}\r}\rcase 14:{\rif (m==1.0) { m=1.0;}\relse { m=-pow(2.0,-10.0 * m) + 1.0;}\r}\rcase 15:{\rif(m * 2.0 < 1.0) {\rif (m==0.0) { m=0.0;}\relse { m *=2.0;m=0.5 * pow(2.0,10.0 * (m - 1.0));}\r}\relse {\rif (m==2.0) { m=1.0;}\relse { m=m * 2.0 - 1.0;m=-0.5 * pow(2.0,-10.0 * m) + 1.0;}\r}\r}\rcase 16:{ m=m * m;}\rcase 17:{ m=(2.0 - m) * m;}\rcase 18:{\rif(m * 2.0 < 1.0) {\rm *=2.0;\rm=m * m * 0.5;\r}\relse {\rm=2.0 - m;\rm=0.5 * (m * m + 1.0);\r}\r}\rcase 19:{ m=m * m * m * m;}\rcase 20:{\rm -=1.0;\rm=1.0 - (m * m * m * m);\r}\rcase 21:{\rif(m * 2.0 < 1.0) {\rm *=2.0;\rm=m * m * m * m * 0.5;\r}\relse {\rm=m * 2.0 - 2.0;\rm=1.0 - (m * m * m * m * 0.5);\r}\r}\rcase 22:{ m=-cos(m * HPI) + 1.0;}\rcase 23:{ m=sin(m * HPI);}\rcase 24:{ m=(-cos(m * PI) + 1.0) * 0.5;}\rcase 25:{\rif (m==0.0) { m=0.0;}\relse if (m==1.0) { m=1.0;}\relse { m -=1.0;m=-1.0 * pow(2.0,10.0 * m) * sin((m - 0.075) * (PI2)/0.3);}\r}\r\rcase 26:{\rif (m==0.0) {\rm=0.0;\r} else if (m==1.0) {\rm=1.0;\r} else {\rm -=1.0;\rm=-pow(2.0,10.0 * m) * sin((m - 0.075) * PI2/0.3);\r}\r}\r\rcase 27:{\rif (m==0.0) {\rm=0.0;\r} else if (m==1.0) {\rm=1.0;\r} else {\rm=pow(2.0,-10.0 * m) * sin((m - 0.075) * PI2/0.3) + 1.0;\r}\r}\rdefault:{ m=m;}\r}\rreturn m;\r\n}\r\nfn rand(n:f32) -> f32 {\rreturn fract(sin(n) * 43758.5453123);\r\n}\r\nfn randomRange(min:f32,max:f32,v:f32)->f32\r\n{\rvar newValue:f32=rand(v);\rreturn (newValue * (max-min)) + min;\r\n}\r\nfn compute_value(tInfo:Info,lifeRatio:f32) -> f32 {\rreturn tInfo.startValue + ((tInfo.endValue - tInfo.startValue) * calEasing(lifeRatio,tInfo.easeType));\r\n}\r\n@compute @workgroup_size(256,1,1)\r\nfn main(\r@builtin(global_invocation_id) global_id:vec3<u32>\r) {\rlet index:u32=(global_id.x);\rlet age:f32=(params.time - particles[index].startTime);\rvar lifeRatio:f32=(age/particles[index].life);\rif (lifeRatio >=1.0 ) {\rlet uuid:f32=(params.time + f32(index));\rparticles[index].startTime=params.time;\rparticles[index].life=randomRange( params.minLife,params.maxLife,uuid );\r\n\r\rinfoPosition[index].infoX.startValue=randomRange( params.minStartX + params.currentPositionX,params.maxStartX + params.currentPositionX,(uuid + 1.0) );\rinfoPosition[index].infoX.endValue =randomRange( params.minEndX + params.currentPositionX,params.maxEndX + params.currentPositionX,(uuid + 2.0) );\rinfoPosition[index].infoX.easeType =params.easeX;\rinfoPosition[index].infoX.birthCenterValue=params.currentPositionX;\r\rinfoPosition[index].infoY.startValue=randomRange( params.minStartY +params.currentPositionY,params.maxStartY+params.currentPositionY,(uuid + 3.0) );\rinfoPosition[index].infoY.endValue =randomRange( params.minEndY+params.currentPositionY,params.maxEndY+params.currentPositionY,(uuid + 4.0) );\rinfoPosition[index].infoY.easeType =params.easeY;\rinfoPosition[index].infoY.birthCenterValue=params.currentPositionY;\r\rinfoPosition[index].infoZ.startValue=randomRange( params.minStartZ+params.currentPositionZ,params.maxStartZ+params.currentPositionZ,(uuid + 5.0) );\rinfoPosition[index].infoZ.endValue =randomRange( params.minEndZ+params.currentPositionZ,params.maxEndZ+params.currentPositionZ,(uuid + 6.0) );\rinfoPosition[index].infoZ.easeType =params.easeZ;\rinfoPosition[index].infoZ.birthCenterValue=params.currentPositionZ;\r\rinfoAlpha[index].startValue=randomRange( params.minStartAlpha,params.maxStartAlpha,(uuid + 7.0) );\rinfoAlpha[index].endValue =randomRange( params.minEndAlpha,params.maxEndAlpha,(uuid + 8.0) );\rinfoAlpha[index].easeType =params.easeAlpha;\r\rinfoScale[index].startValue=randomRange( params.minStartScale,params.maxStartScale,(uuid + 9.0) );\rinfoScale[index].endValue =randomRange( params.minEndScale,params.maxEndScale,(uuid + 10.0));\rinfoScale[index].easeType =params.easeScale;\r\rinfoRotation[index].infoX.startValue=randomRange( params.minStartRotationX,params.maxStartRotationX,(uuid + 11.0));\rinfoRotation[index].infoX.endValue =randomRange( params.minEndRotationX,params.maxEndRotationX,(uuid + 12.0));\rinfoRotation[index].infoX.easeType =params.easeRotationX;\r\rinfoRotation[index].infoY.startValue=randomRange( params.minStartRotationY,params.maxStartRotationY,(uuid + 13.0));\rinfoRotation[index].infoY.endValue =randomRange( params.minEndRotationY,params.maxEndRotationY,(uuid + 14.0));\rinfoRotation[index].infoY.easeType =params.easeRotationY;\r\rinfoRotation[index].infoZ.startValue=randomRange( params.minStartRotationZ,params.maxStartRotationZ,(uuid + 15.0));\rinfoRotation[index].infoZ.endValue =randomRange( params.minEndRotationZ,params.maxEndRotationZ,(uuid + 16.0));\rinfoRotation[index].infoZ.easeType =params.easeRotationZ;\r\n\rlifeRatio=0.0;\r}\rvar targetInfo:Info;\rlet targetParticle=particles[index];\r\rtargetInfo=infoPosition[index].infoX;\rparticles[index].valuePosition.x=compute_value(targetInfo,lifeRatio);\rtargetInfo=infoPosition[index].infoY;\rparticles[index].valuePosition.y= compute_value(targetInfo,lifeRatio);\rtargetInfo=infoPosition[index].infoZ;\rparticles[index].valuePosition.z= compute_value(targetInfo,lifeRatio);\r\rtargetInfo=infoAlpha[index];\rparticles[index].valueAlpha=compute_value(targetInfo,lifeRatio);\r\rtargetInfo=infoScale[index];\rparticles[index].valueScale=compute_value(targetInfo,lifeRatio);\r\rtargetInfo=infoRotation[index].infoX;\rparticles[index].valueRotation.x= compute_value(targetInfo,lifeRatio) * PI/180.0;\rtargetInfo=infoRotation[index].infoY;\rparticles[index].valueRotation.y= compute_value(targetInfo,lifeRatio) * PI/180.0;\rtargetInfo=infoRotation[index].infoZ;\rparticles[index].valueRotation.z= compute_value(targetInfo,lifeRatio) * PI/180.0;\r\n\r\n\r\n}\r\n"},h=e.resourceManager.createGPUShaderModule("PARTICLE_EMITTER_MODULE",c);const d=[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}],m=[{binding:0,resource:{buffer:this.#Ea,offset:0,size:this.#Ca.byteLength}}];l.forEach(((e,t)=>{d.push({binding:t+1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}),m.push({binding:t+1,resource:{buffer:this.#ka[t],offset:0,size:e.byteLength}})}));const p=e.gpuDevice.createBindGroupLayout({entries:d}),f=e.gpuDevice.createPipelineLayout({bindGroupLayouts:[p]});this.#Ba=e.gpuDevice.createBindGroup({layout:p,entries:m}),this.#La=e.gpuDevice.createComputePipeline({layout:f,compute:{module:h,entryPoint:"main"}})}#us(){this.#Ca=new Float32Array(46);let e={size:this.#Ca.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST};const{gpuDevice:t}=this.redGPUContext;this.#Ea=t.createBuffer(e),t.queue.writeBuffer(this.#Ea,0,this.#Ca),this.#Ua(),this.depthStencilState.depthWriteEnabled=!1}#Aa(e){const t=this.localToWorld(this.x,this.y,this.z);this.#Ca.set([e,...t,this.#Vs,this.#Fs,this.#Hs,this.#$s,this.#Ys,this.#Ws,this.#Ta,this.#zs,this.#Xs,this.#Zs,this.#Js,this.#ya,this.#Ks,this.#js,this.#qs,this.#Qs,this.#ba,this.#ea,this.#ta,this.#ra,this.#na,this.#Sa,this.#ia,this.#sa,this.#aa,this.#oa,this.#Ma,this.#ua,this.#ha,this.#pa,this.#_a,this.#Ra,this.#la,this.#da,this.#fa,this.#xa,this.#wa,this.#ca,this.#ma,this.#ga,this.#va,this.#Pa],0);const{gpuDevice:r}=this.redGPUContext;r.queue.writeBuffer(this.#Ea,0,this.#Ca);const n=r.createCommandEncoder({}),i=n.beginComputePass();i.setPipeline(this.#La),i.setBindGroup(0,this.#Ba),i.dispatchWorkgroups(Math.ceil(this.#Ia/256)),i.end(),r.queue.submit([n.finish()])}}function mixInMesh2D(e){const t=class extends e{#Gs=0;#Da=ir.NORMAL;get blendMode(){const e=Object.entries(ir).find((([,e])=>e===this.#Da));if(!e)throw new Error(`Invalid blendMode value:${this.#Da}`);return e[0]}set blendMode(e){let t;if("string"==typeof e){if(!(e in ir))throw new Error(`Invalid blendMode key:${e}`);t=ir[e]}else{if("number"!=typeof e||!Object.values(ir).includes(e))throw new Error(`Invalid blendMode:${e}`);t=e}this.#Da=t,this.#Na(t)}get rotation(){return this.#Gs}set rotation(e){this.#Gs=e,super.rotationZ=e}setScale(e,t){t=t??e,super.setScale(e,t,1)}setPosition(e,t){t=t??e,super.setPosition(e,t,0)}setRotation(e){this.rotation=e}#Na(e){const{blendColorState:t,blendAlphaState:r}=this._material;switch(e){case ir.NORMAL:t.operation=ct.ADD,t.srcFactor=lt.ONE,t.dstFactor=lt.ONE_MINUS_SRC_ALPHA,r.operation=ct.ADD,r.srcFactor=lt.ONE,r.dstFactor=lt.ONE_MINUS_SRC_ALPHA;break;case ir.MULTIPLY:t.operation=ct.ADD,t.srcFactor=lt.ONE_MINUS_DST_ALPHA,t.dstFactor=lt.ONE_MINUS_SRC_ALPHA,r.operation=ct.ADD,r.srcFactor=lt.SRC_ALPHA,r.dstFactor=lt.ONE_MINUS_SRC_ALPHA;break;case ir.LIGHTEN:t.operation=ct.MAX,t.srcFactor=lt.ONE,t.dstFactor=lt.ONE,r.operation=ct.ADD,r.srcFactor=lt.SRC_ALPHA,r.dstFactor=lt.ONE_MINUS_SRC_ALPHA;break;case ir.SCREEN:t.operation=ct.ADD,t.srcFactor=lt.ONE,t.dstFactor=lt.ONE_MINUS_SRC,r.operation=ct.ADD,r.srcFactor=lt.SRC_ALPHA,r.dstFactor=lt.ONE_MINUS_SRC_ALPHA;break;case ir.LINEAR_DODGE:t.operation=ct.ADD,t.srcFactor=lt.ONE,t.dstFactor=lt.ONE,r.operation=ct.ADD,r.srcFactor=lt.SRC_ALPHA,r.dstFactor=lt.ONE;break;case ir.SUBTRACT:t.operation=ct.REVERSE_SUBTRACT,t.srcFactor=lt.SRC_ALPHA,t.dstFactor=lt.ONE_MINUS_SRC_ALPHA,r.operation=ct.REVERSE_SUBTRACT,r.srcFactor=lt.ONE,r.dstFactor=lt.ONE;break;case ir.DIFFERENCE:t.operation=ct.SUBTRACT,t.srcFactor=lt.ONE,t.dstFactor=lt.ONE,r.operation=ct.SUBTRACT,r.srcFactor=lt.ONE,r.dstFactor=lt.ONE;break;case ir.EXCLUSION:t.operation=ct.ADD,t.srcFactor=lt.ONE_MINUS_DST_ALPHA,t.dstFactor=lt.ONE_MINUS_SRC_ALPHA,r.operation=ct.ADD,r.srcFactor=lt.ONE,r.dstFactor=lt.ONE;break;default:console.warn(`Unsupported blend mode:${e}`)}}};return Object.defineProperty(t.prototype,"is2DMeshType",{value:!0,writable:!1}),t}Object.defineProperty(ParticleEmitter.prototype,"meshType",{value:"particle",writable:!1}),Le.defineByPreset(ParticleEmitter,[Le.PRESET_BOOLEAN.USE_BILLBOARD]),Le.definePositiveNumber(ParticleEmitter,[]),Object.freeze(ParticleEmitter);const Kr=mixInMesh2D(Mesh);class Sprite2D extends Kr{#Br=1;#Ir=1;constructor(e,t){super(e,new Plane(e,1,1,1,1,1,!0),t),this.primitiveState.cullMode=Pt.FRONT}get width(){return this.#Br}set width(e){validatePositiveNumberRange(e),this.#Br=e,this.dirtyTransform=!0}get height(){return this.#Ir}set height(e){validatePositiveNumberRange(e),this.#Ir=e,this.dirtyTransform=!0}get material(){return this._material}set material(e){consoleAndThrowError("Sprite2D can not change material")}setSize(e,t){this.width=e,this.height=void 0!==t?t:e}}Object.freeze(Sprite2D);var $r="#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include getBillboardMatrix;\r\nstruct VertexUniforms {\rpickingId:u32,\rmodelMatrix:mat4x4<f32>,\rnormalModelMatrix:mat4x4<f32>,\ruseBillboardPerspective:u32,\ruseBillboard:u32,\rbillboardFixedScale:f32,\rcombinedOpacity:f32,\r\n};\r\n\r\n\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n\r\nstruct InputData {\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r\n};\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(15) pickingId:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn main(inputData:InputData) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_resolution=systemUniforms.resolution;\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\n\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\rlet u_useBillboardPerspective=vertexUniforms.useBillboardPerspective;\rlet u_useBillboard=vertexUniforms.useBillboard;\rlet u_billboardFixedScale=vertexUniforms.billboardFixedScale;\r\n\r\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_positionVec4=vec4<f32>(input_position,1.0);\rlet input_vertexNormalVec4=vec4<f32>(input_vertexNormal,1.0);\rlet input_uv=inputData.uv;\r\n\r\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\r\n\r\n\r\n\r\rif (u_useBillboard==1) {\r\rlet projectionModelMatrix=u_projectionMatrix * u_modelMatrix;\rlet billboardMatrix=getBillboardMatrix(u_cameraMatrix,u_modelMatrix);\rlet billboardNormalMatrix=getBillboardMatrix(u_cameraMatrix,u_normalModelMatrix);\rif(u_useBillboardPerspective==1){\rposition=billboardMatrix * input_positionVec4;\rnormalPosition=billboardNormalMatrix * input_vertexNormalVec4;\r}else{\rposition=billboardMatrix * input_positionVec4;\rnormalPosition=billboardNormalMatrix * input_vertexNormalVec4;\r}\r\n\r\routput.position=u_projectionMatrix * position;\r\n\rif (u_useBillboardPerspective !=1) {\r\rvar temp=output.position/output.position.w;\r\n\r\rlet aspectRatio=u_resolution.x/u_resolution.y;\rlet scaleX=clamp((projectionModelMatrix)[1][1],-1.0,1.0)/aspectRatio;\rlet scaleY=clamp((projectionModelMatrix)[1][1],-1.0,1.0);\r\n\r\routput.position=vec4<f32>(\rtemp.xy + input_position.xy * vec2<f32>(scaleX * u_billboardFixedScale,scaleY * u_billboardFixedScale),\rtemp.zw\r);\r}\r} else {\r\rposition=u_cameraMatrix * u_modelMatrix * input_positionVec4;\rnormalPosition=u_cameraMatrix * u_normalModelMatrix * input_vertexNormalVec4;\r\n\r\routput.position=u_projectionMatrix * position;\r}\r\n\r\routput.vertexPosition=position.xyz;\routput.vertexNormal=normalPosition.xyz;\routput.uv=input_uv;\routput.combinedOpacity=vertexUniforms.combinedOpacity;\rreturn output;\r\n}\r\nstruct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn drawDirectionalShadowDepth( inputData:InputData ) -> OutputShadowData {\rvar output:OutputShadowData;\r\rlet u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix;\rlet u_directionalLightProjectionMatrix=systemUniforms.directionalLightProjectionMatrix;\rlet u_directionalLightViewMatrix=systemUniforms.directionalLightViewMatrix;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\rlet u_useBillboardPerspective=vertexUniforms.useBillboardPerspective;\rlet u_useBillboard=vertexUniforms.useBillboard;\rlet u_billboardFixedScale=vertexUniforms.billboardFixedScale;\rlet input_position=inputData.position;\rlet input_positionVec4=vec4<f32>(input_position,1.0);\rvar position:vec4<f32>;\r\n\rreturn output;\r\n}\r\n@vertex\r\nfn picking(inputData:InputData) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_cameraMatrix=systemUniforms.camera.cameraMatrix;\rlet u_modelMatrix=vertexUniforms.modelMatrix;\r\n\r\rlet u_useBillboardPerspective=vertexUniforms.useBillboardPerspective;\rlet u_useBillboard=vertexUniforms.useBillboard;\rlet u_billboardFixedScale=vertexUniforms.billboardFixedScale;\r\n\r\rlet input_position=inputData.position;\rlet input_positionVec4=vec4<f32>(input_position,1.0);\r\rlet u_resolution=systemUniforms.resolution;\r\n\r\rvar position:vec4<f32>;\r\n\rif (u_useBillboard==1) {\r\rlet projectionModelMatrix=u_projectionMatrix * u_modelMatrix;\rlet billboardMatrix=getBillboardMatrix(u_cameraMatrix,u_modelMatrix);\rif(u_useBillboardPerspective==1){\rposition=billboardMatrix * input_positionVec4;\r}else{\rposition=billboardMatrix * input_positionVec4;\r}\r\n\r\routput.position=u_projectionMatrix * position;\r\n\rif (u_useBillboardPerspective !=1) {\r\rvar temp=output.position/output.position.w;\r\n\r\rlet aspectRatio=u_resolution.x/u_resolution.y;\rlet scaleX=clamp((projectionModelMatrix)[1][1],-1.0,1.0)/aspectRatio;\rlet scaleY=clamp((projectionModelMatrix)[1][1],-1.0,1.0);\r\n\r\routput.position=vec4<f32>(\rtemp.xy + input_position.xy * vec2<f32>(scaleX * u_billboardFixedScale,scaleY * u_billboardFixedScale),\rtemp.zw\r);\r}\r} else {\r\rposition=u_cameraMatrix * u_modelMatrix * input_positionVec4;\routput.position=u_projectionMatrix * position;\r}\r\n\r\routput.pickingId=unpack4x8unorm(vertexUniforms.pickingId);\r\n\rreturn output;\r\n}\r\n";const Xr=parseWGSL($r),jr=Xr.uniforms.vertexUniforms;class Sprite3D extends Mesh{constructor(e,t,r){super(e),this._geometry=r||new Plane(e),this._material=t,this._material.transparent=!0,this.dirtyPipeline=!0,this.dirtyTransform=!0,this.primitiveState.cullMode=Pt.NONE}createCustomMeshVertexShaderModule(){return this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_SPRITE_3D",Xr,jr,$r)}}Le.defineByPreset(Sprite3D,[[Le.PRESET_BOOLEAN.USE_BILLBOARD_PERSPECTIVE,!0],[Le.PRESET_BOOLEAN.USE_BILLBOARD,!0],[Le.PRESET_POSITIVE_NUMBER.BILLBOARD_FIXED_SCALE,.1,.1]]),Object.freeze(Sprite3D);class ASpriteSheet extends Mesh{#Oa=0;#Ga=0;#Va=0;#Fa=!0;#Ha=!0;#za;#Ka;#$a="play";constructor(e,t,r){super(e),this.#Ka=r,this._material=new BitmapMaterial(e),this._material.transparent=!0,this.dirtyPipeline=!0,this.dirtyTransform=!0,this.spriteSheetInfo=t}get state(){return this.#$a}get loop(){return this.#Ha}set loop(e){this.#Ha=e}get frameRate(){return this.#Oa}set frameRate(e){e<0&&(e=0),0===this.#Oa&&e&&(this.#Ga=0),this.#Oa=e,this.#Va=1e3/this.#Oa}get geometry(){return this._geometry}set geometry(e){consoleAndThrowError("ASpriteSheet can not change geometry")}get material(){return this._material}set material(e){consoleAndThrowError("ASpriteSheet can not change material")}get spriteSheetInfo(){return this.#za}set spriteSheetInfo(e){this.#za=e,this.frameRate=e.frameRate,this.segmentW=e.segmentW,this.segmentH=e.segmentH,this.totalFrame=e.totalFrame,this.currentIndex=e.startIndex,this.#Ha=!0,this.#Ga=0,this._material.diffuseTexture=e.texture}play(){this.#Fa=!0,this.#$a="play",this.#Ga=0}pause(){this.#Fa=!1,this.#$a="pause"}stop(){this.#Fa=!1,this.currentIndex=0,this.#$a="stop"}render(e){const{diffuseTexture:t}=this._material;this.#Ka(t,this.segmentW,this.segmentH);const{timestamp:r}=e;if(this.#Ga||(this.#Ga=this.#Va+r),this.#Fa&&this.#Ga<r&&this.#Oa){const e=Math.floor((r-this.#Ga)/this.#Va),t=(Number.isFinite(e)?e:0)||1;this.#Ga=this.#Va+r,this.currentIndex+=t,this.currentIndex>=this.totalFrame&&(this.loop?(this.#Fa=!0,this.currentIndex=0):(this.#Fa=!1,this.currentIndex=this.totalFrame-1))}super.render(e)}}Le.definePositiveNumber(ASpriteSheet,[["segmentW",5],["segmentH",3],["totalFrame",15],["currentIndex",0]]),Object.freeze(ASpriteSheet);var Yr="#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include getBillboardMatrix;\r\nstruct VertexUniforms {\rpickingId:u32,\rmodelMatrix:mat4x4<f32>,\rnormalModelMatrix:mat4x4<f32>,\rsegmentW:f32,\rsegmentH:f32,\rtotalFrame:f32,\rcurrentIndex:f32,\rcombinedOpacity:f32,\r\n};\r\n\r\n\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n\r\nstruct InputData {\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r\n};\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(15) pickingId:vec4<f32>,\r\n};\r\n\r\n\r\n@vertex\r\nfn main( inputData:InputData ) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\n\r\n\r\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\r\n\rposition=u_cameraMatrix * u_modelMatrix * vec4<f32>(input_position,1.0);\rnormalPosition=u_cameraMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0);\r\n\routput.position=u_projectionMatrix * position;\routput.vertexPosition=position.xyz;\routput.vertexNormal=normalPosition.xyz;\routput.combinedOpacity=vertexUniforms.combinedOpacity;\r\n\rlet uv=vec2<f32>(\rinput_uv.x * 1/vertexUniforms.segmentW + ((vertexUniforms.currentIndex % vertexUniforms.segmentW)/vertexUniforms.segmentW),\rinput_uv.y * 1/vertexUniforms.segmentH - (floor(vertexUniforms.currentIndex/vertexUniforms.segmentH)/vertexUniforms.segmentH)\r);\r\n\routput.uv=uv;\rreturn output;\r\n}\r\nstruct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn drawDirectionalShadowDepth( inputData:InputData ) -> OutputShadowData {\rvar output:OutputShadowData;\r\rlet u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix;\rlet u_directionalLightProjectionMatrix=systemUniforms.directionalLightProjectionMatrix;\rlet u_directionalLightViewMatrix=systemUniforms.directionalLightViewMatrix;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\rlet input_position=inputData.position;\rvar position:vec4<f32>;\r\n\rreturn output;\r\n}\r\n\r\n@vertex\r\nfn picking(inputData:InputData) -> OutputData {\rvar output:OutputData;\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\r\n\r\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\r\n\rposition=u_cameraMatrix * u_modelMatrix * vec4<f32>(input_position,1.0);\rnormalPosition=u_cameraMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0);\routput.position=u_projectionMatrix * position;\r\n\routput.pickingId=unpack4x8unorm(vertexUniforms.pickingId);\rreturn output;\r\n}\r\n";const Zr=parseWGSL(Yr),qr=Zr.uniforms.vertexUniforms,Wr=mixInMesh2D(ASpriteSheet);class SpriteSheet2D extends Wr{#Br=1;#Ir=1;constructor(e,t){super(e,t,((e,t,r)=>{if(e){const{gpuTexture:n}=e,i=n?.width/t,s=n?.height/r;i===this.#Br&&s===this.#Ir||(this.#Br=n?.width/t,this.#Ir=n?.height/r,this.dirtyTransform=!0)}else this.#Br=1,this.#Ir=1})),this._geometry=new Plane(e,1,1,1,1,1,!0),this.primitiveState.cullMode=Pt.FRONT}get width(){return this.#Br}get height(){return this.#Ir}get geometry(){return this._geometry}set geometry(e){consoleAndThrowError("SpriteSheet2D can not change geometry")}get material(){return this._material}set material(e){consoleAndThrowError("SpriteSheet2D can not change material")}createCustomMeshVertexShaderModule(){return this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_SPRITE_SHEET_2D",Zr,qr,Yr)}}Object.freeze(SpriteSheet2D);var Jr="#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include getBillboardMatrix;\r\nstruct VertexUniforms {\rpickingId:u32,\rmodelMatrix:mat4x4<f32>,\rnormalModelMatrix:mat4x4<f32>,\ruseBillboardPerspective:u32,\ruseBillboard:u32,\rsegmentW:f32,\rsegmentH:f32,\rtotalFrame:f32,\rcurrentIndex:f32,\rbillboardFixedScale:f32,\r_renderRatioX:f32,\r_renderRatioY:f32,\rcombinedOpacity:f32,\r\n};\r\n\r\n\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n\r\nstruct InputData {\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r\n};\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(15) pickingId:vec4<f32>,\r\n};\r\n\r\n\r\n@vertex\r\nfn main( inputData:InputData ) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_resolution=systemUniforms.resolution;\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\n\rlet u_useBillboardPerspective=vertexUniforms.useBillboardPerspective;\rlet u_useBillboard=vertexUniforms.useBillboard;\rlet u_billboardFixedScale=vertexUniforms.billboardFixedScale;\rlet u_renderRatioX=vertexUniforms._renderRatioX;\rlet u_renderRatioY=vertexUniforms._renderRatioY;\rvar ratioScaleMatrix:mat4x4<f32>=mat4x4<f32>(\ru_renderRatioX,0,0,0,\r0,u_renderRatioY,0,0,\r0,0,1,0,\r0,0,0,1\r);\r\n\r\n\r\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\r\n\r\rif (u_useBillboard==1) {\r\rif(u_useBillboardPerspective==1){\rposition=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * ratioScaleMatrix * vec4<f32>(input_position,1.0);\rnormalPosition=getBillboardMatrix(u_cameraMatrix,u_normalModelMatrix) * ratioScaleMatrix *vec4<f32>(input_vertexNormal,1.0);\r}else{\rposition=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * ratioScaleMatrix *vec4<f32>(input_position,1.0);\rnormalPosition=getBillboardMatrix(u_cameraMatrix,u_normalModelMatrix) * ratioScaleMatrix * vec4<f32>(input_vertexNormal,1.0);\r}\r\n\r\routput.position=u_projectionMatrix * position;\r\n\rif (u_useBillboardPerspective !=1) {\r\rvar temp=output.position/output.position.w;\r\n\r\rlet aspectRatio=u_resolution.x/u_resolution.y;\rlet scaleX=clamp((u_projectionMatrix)[1][1],-1.0,1.0)/aspectRatio * u_renderRatioX;\rlet scaleY=clamp((u_projectionMatrix)[1][1],-1.0,1.0) * u_renderRatioY;\r\n\r\routput.position=vec4<f32>(\rtemp.xy + input_position.xy * vec2<f32>(scaleX * u_billboardFixedScale,scaleY * u_billboardFixedScale),\rtemp.zw\r);\r}\r} else {\r\rposition=u_cameraMatrix * u_modelMatrix * ratioScaleMatrix * vec4<f32>(input_position,1.0);\rnormalPosition=u_cameraMatrix * u_normalModelMatrix * ratioScaleMatrix * vec4<f32>(input_vertexNormal,1.0);\r\n\r\routput.position=u_projectionMatrix * position;\r}\r\n\r\n\routput.vertexPosition=position.xyz;\routput.vertexNormal=normalPosition.xyz;\routput.combinedOpacity=vertexUniforms.combinedOpacity;\r\n\r\n\rlet uv=vec2<f32>(\rinput_uv.x * 1/vertexUniforms.segmentW + ((vertexUniforms.currentIndex % vertexUniforms.segmentW)/vertexUniforms.segmentW),\rinput_uv.y * 1/vertexUniforms.segmentH - (floor(vertexUniforms.currentIndex/vertexUniforms.segmentH)/vertexUniforms.segmentH)\r);\r\n\routput.uv=uv;\rreturn output;\r\n}\r\nstruct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn drawDirectionalShadowDepth( inputData:InputData ) -> OutputShadowData {\rvar output:OutputShadowData;\r\rlet u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix;\rlet u_directionalLightProjectionMatrix=systemUniforms.directionalLightProjectionMatrix;\rlet u_directionalLightViewMatrix=systemUniforms.directionalLightViewMatrix;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\rlet u_useBillboardPerspective=vertexUniforms.useBillboardPerspective;\rlet u_useBillboard=vertexUniforms.useBillboard;\rlet input_position=inputData.position;\rvar position:vec4<f32>;\r\n\rreturn output;\r\n}\r\n\r\n@vertex\r\nfn picking(inputData:InputData) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_cameraMatrix=systemUniforms.camera.cameraMatrix;\rlet u_modelMatrix=vertexUniforms.modelMatrix;\r\n\r\rlet u_useBillboardPerspective=vertexUniforms.useBillboardPerspective;\rlet u_useBillboard=vertexUniforms.useBillboard;\rlet u_billboardFixedScale=vertexUniforms.billboardFixedScale;\rlet u_renderRatioX=vertexUniforms._renderRatioX;\rlet u_renderRatioY=vertexUniforms._renderRatioY;\rvar ratioScaleMatrix:mat4x4<f32>=mat4x4<f32>(\ru_renderRatioX,0,0,0,\r0,u_renderRatioY,0,0,\r0,0,1,0,\r0,0,0,1\r);\r\n\r\rlet input_position=inputData.position;\r\n\r\rlet u_resolution=systemUniforms.resolution;\r\n\r\rvar position:vec4<f32>;\r\n\rif (u_useBillboard==1) {\r\rif(u_useBillboardPerspective==1){\rposition=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * ratioScaleMatrix * vec4<f32>(input_position,1.0);\r}else{\rposition=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * ratioScaleMatrix *vec4<f32>(input_position,1.0);\r}\r\n\r\routput.position=u_projectionMatrix * position;\r\n\rif (u_useBillboardPerspective !=1) {\r\rvar temp=output.position/output.position.w;\r\n\r\rlet aspectRatio=u_resolution.x/u_resolution.y;\rlet scaleX=clamp((u_projectionMatrix)[1][1],-1.0,1.0)/aspectRatio * u_renderRatioX;\rlet scaleY=clamp((u_projectionMatrix)[1][1],-1.0,1.0) * u_renderRatioY;\r\n\r\routput.position=vec4<f32>(\rtemp.xy + input_position.xy * vec2<f32>(scaleX * u_billboardFixedScale,scaleY * u_billboardFixedScale),\rtemp.zw\r);\r}\r} else {\r\rposition=u_cameraMatrix * u_modelMatrix * ratioScaleMatrix * vec4<f32>(input_position,1.0);\r\routput.position=u_projectionMatrix * position;\r}\r\n\r\routput.pickingId=unpack4x8unorm(vertexUniforms.pickingId);\r\n\rreturn output;\r\n}\r\n";const Qr=parseWGSL(Jr),en=Qr.uniforms.vertexUniforms;class SpriteSheet3D extends ASpriteSheet{#Xa=1;#ja=1;constructor(e,t){super(e,t,((e,t,r)=>{if(e){const{gpuTexture:n}=e,i=n?.width/t,s=n?.height/r;i===this.#Xa&&s===this.#ja||(this.#Xa=n?.width/t,this.#ja=n?.height/r,this.#ja>this.#Xa?(this._renderRatioX=1,this._renderRatioY=this.#ja/this.#Xa):(this._renderRatioX=this.#Xa/this.#ja,this._renderRatioY=1),this.dirtyTransform=!0)}else this.#Xa=1,this.#ja=1})),this._geometry=new Plane(e)}get geometry(){return this._geometry}set geometry(e){consoleAndThrowError("SpriteSheet3D can not change geometry")}get material(){return this._material}set material(e){consoleAndThrowError("SpriteSheet3D can not change material")}createCustomMeshVertexShaderModule(){return this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_SPRITE_SHEET_3D",Qr,en,Jr)}}Le.definePositiveNumber(SpriteSheet3D,[["_renderRatioX",1],["_renderRatioY",1]]),Le.defineByPreset(SpriteSheet3D,[[Le.PRESET_BOOLEAN.USE_BILLBOARD_PERSPECTIVE,!0],[Le.PRESET_BOOLEAN.USE_BILLBOARD,!0],[Le.PRESET_POSITIVE_NUMBER.BILLBOARD_FIXED_SCALE,.1,.1]]),Object.freeze(SpriteSheet3D);class SpriteSheetInfo{#Ya=0;#Za=0;#qa=0;#Wa=0;#Oa=0;#Ha=!0;#Ja;constructor(e,t,r,n,i,s,a=!0,o=60){validateRedGPUContext(e),validateUintRange(r),validateUintRange(n),validateUintRange(i),validateUintRange(s),validateUintRange(o),this.#Ya=r,this.#Za=n,this.#qa=i,this.#Wa=s,this.#Ja=new BitmapTexture(e,t),this.#Ha=a,this.#Oa=o}get segmentW(){return this.#Ya}get segmentH(){return this.#Za}get totalFrame(){return this.#qa}get startIndex(){return this.#Wa}get texture(){return this.#Ja}get frameRate(){return this.#Oa}get loop(){return this.#Ha}}Object.freeze(SpriteSheetInfo);const tn=parseWGSL("#redgpu_include drawPicking;\r\nstruct Uniforms {\r\topacity:f32\r\n};\r\n\r\nstruct InputData {\r\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexColor:vec4<f32>,\r@location(15) pickingId:vec4<f32>,\r\n}\r\n\r\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\r\n@fragment\r\nfn main(inputData:InputData) -> @location(0) vec4<f32> {\rreturn inputData.vertexColor;\r\n}\r\n\r\n\r\n");class LineMaterial extends ABaseMaterial{constructor(e,t){super(e,"LINE_MATERIAL",tn,2),t&&(this.name=t),this.initGPURenderInfos()}}Object.freeze(LineMaterial);class LinePoint{position;colorRGBA;constructor(e=0,t=0,r=0,n){this.position=[e,t,r],this.colorRGBA=n}}const getPointsOnBezierCurveWithSplitting=(e,t,r,n)=>{let i=n||[];if(((e,t)=>{let r=e[t].position,n=e[t+1].position,i=e[t+2].position,s=e[t+3].position,a=3*n[0]-2*r[0]-s[0],o=3*n[1]-2*r[1]-s[1],u=3*i[0]-2*s[0]-r[0],l=3*i[1]-2*s[1]-r[1];return a*=a,o*=o,u*=u,l*=l,a<u&&(a=u),o<l&&(o=l),a+o})(e,t)<r)i.push(e[t],e[t+3]);else{let n=.5,s=e[t],a=e[t+1],o=e[t+2],u=e[t+3],l=lerp$4(create$4(),s.position,a.position,n),c=lerp$4(create$4(),a.position,o.position,n),h=lerp$4(create$4(),o.position,u.position,n),d=lerp$4(create$4(),l,c,n),m=lerp$4(create$4(),c,h,n),p=lerp$4(create$4(),d,m,n);p=new LinePoint(p[0],p[1],p[2],s.colorRGBA),l=new LinePoint(l[0],l[1],l[2],l.colorRGBA),h=new LinePoint(h[0],h[1],h[2],h.colorRGBA),d=new LinePoint(d[0],d[1],d[2],d.colorRGBA),m=new LinePoint(m[0],m[1],m[2],m.colorRGBA),getPointsOnBezierCurveWithSplitting([s,l,d,p],0,r,i),getPointsOnBezierCurveWithSplitting([p,m,h,u],0,r,i)}return i};class LinePointWithInOut{inLinePoint;linePoint;outLinePoint;constructor(e=0,t=0,r=0,n=0,i=0,s=0,a=0,o=0,u=0,l,c){let h=[...convertHexToRgb(l,!0)];h=[h[0]/255,h[1]/255,h[2]/255,c],this.inLinePoint=new LinePoint(n,i,s,h),this.linePoint=new LinePoint(e,t,r,h),this.outLinePoint=new LinePoint(a,o,u,h)}}const lineVec2DistanceToSegmentSq=function(e,t,r){e=[e[0],e[1]],t=[t[0],t[1]],r=[r[0],r[1]];let n=be(t,r);if(0===n)return be(e,t);let i=((e[0]-t[0])*(r[0]-t[0])+(e[1]-t[1])*(r[1]-t[1]))/n;return i=Math.max(0,Math.min(1,i)),be(e,lerp([0,0],t,r,i))},lineSimplifyPoints=(e,t,r,n,i)=>{let s=i||[],a=e[t],o=e[r-1],u=0,l=1,c=t+1;for(;c<r-1;++c){let t=lineVec2DistanceToSegmentSq(e[c].position,a.position,o.position);t>u&&(u=t,l=c)}return Math.sqrt(u)>n?(lineSimplifyPoints(e,t,l+1,n,s),lineSimplifyPoints(e,l,r,n,s)):s.push(a,o),s},rn={LINEAR:"linear",CATMULL_ROM:"catmullRom",BEZIER:"bezier"};Object.freeze(rn);var nn="#redgpu_include SYSTEM_UNIFORM;\r\nstruct VertexUniforms {\rpickingId:u32,\rmodelMatrix:mat4x4<f32>,\rnormalModelMatrix:mat4x4<f32>,\r\n};\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n\r\nstruct InputData {\r@location(0) position:vec3<f32>,\r@location(1) vertexColor:vec4<f32>,\r\n};\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexColor:vec4<f32>,\r\n\r\n\r\n\r@location(15) pickingId:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn main( inputData:InputData ) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_resolution=systemUniforms.resolution;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\r\rlet input_position=inputData.position;\rlet input_vertexColor=inputData.vertexColor;\r\n\rvar position:vec4<f32>;\rposition=u_modelMatrix * vec4<f32>(input_position,1.0);\routput.position=u_projectionMatrix * u_cameraMatrix * position;\routput.vertexPosition=position.xyz;\routput.vertexColor=input_vertexColor;\rreturn output;\r\n}\r\nstruct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\n@vertex\r\nfn picking(inputData:InputData) -> OutputData {\r\n\rvar output:OutputData;\rreturn output;\r\n}\r\n";const sn=parseWGSL(nn),an=sn.uniforms.vertexUniforms;class Line3D extends Mesh{baseColor;#Qa;#eo=1;#to=.01;#br=.01;#ro=[];#no=[];#io;constructor(e,t=rn.LINEAR,r="#fff"){super(e),this.primitiveState.topology=Ct.LINE_STRIP,this.baseColor=r,this.#Qa=t,this._geometry=new Geometry(e,new VertexBuffer(e,this.#ro,new InterleavedStruct({vertexPosition:InterleaveType.float32x3,vertexColor:InterleaveType.float32x4}))),this._material=new LineMaterial(e)}get originalPoints(){return this.#no}get type(){return this.#Qa}set type(e){this.#Qa=e,this.#so()}get interleaveData(){return this.#ro}get tension(){return this.#eo}set tension(e){validatePositiveNumberRange(e),this.#eo=e,this.#so()}get tolerance(){return this.#to}set tolerance(e){validatePositiveNumberRange(e),this.#to=e,this.#so()}get distance(){return this.#br}set distance(e){validatePositiveNumberRange(e),this.#br=e,this.#so()}get numPoints(){return this.#no.length}get geometry(){return this._geometry}set geometry(e){consoleAndThrowError("Line3D can not change geometry")}get material(){return this._material}set material(e){consoleAndThrowError("Line3D can not change material")}createCustomMeshVertexShaderModule(){return this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_LINE_3D",sn,an,nn)}addPoint(e=0,t=0,r=0,n=this.baseColor,i=1,s=0,a=0,o=0,u=0,l=0,c=0){this.#no.push(new LinePointWithInOut(e,t,r,s,a,o,u,l,c,n,i)),this.#so()}addPointAt(e,t=0,r=0,n=0,i=this.baseColor,s=1,a=0,o=0,u=0,l=0,c=0,h=0){this.#no.length<e&&(e=this.#no.length),null!=e?this.#no.splice(e,0,new LinePointWithInOut(t,r,n,a,o,u,l,c,h,i,s)):this.#no.push(new LinePointWithInOut(t,r,n,a,o,u,l,c,h,i,s)),this.#so()}removePointAt(e){validateUintRange(e),this.#no[e]?this.#no.splice(e,1):consoleAndThrowError("removeChildAt","index    .",":"+e),this.#so()}removeAllPoint(){this.#no.length=0,this.#so()}#qe(){if(this._geometry,this.#no.length){const{redGPUContext:e}=this;this._geometry=new Geometry(e,new VertexBuffer(e,this.#ro,new InterleavedStruct({vertexPosition:InterleaveType.float32x3,vertexColor:InterleaveType.float32x4})))}this.dirtyPipeline=!0}#so(){const e=this.#no,t=this.#eo,r=this.#to,n=this.#br;let i,s,a,o;switch(this.#ro.length=0,this.#Qa){case rn.CATMULL_ROM:case rn.BEZIER:if(e.length>1)for(this.#io=(e=>{let t,r=[],n=0,i=0;const s=e.length;for(;n<s;n++){t=e[n];const{inLinePoint:s,linePoint:a,outLinePoint:o}=t;0===i?(r[i++]=a,r[i++]=o):(r[i++]=s,r[i++]=a,e[n+1]&&(r[i++]=o))}return r})(rn.CATMULL_ROM===this.#Qa?((e,t=1)=>{const r=e.length,n=r-2;for(let i=0;i<r-1;i++){const r=i?e[i-1].linePoint.position:e[i].linePoint.position,s=e[i].linePoint.position,a=e[i+1].linePoint.position,o=i===n?a:e[i+2].linePoint.position;e[i].outLinePoint.position=[s[0]+(a[0]-r[0])/6*t,s[1]+(a[1]-r[1])/6*t,s[2]+(a[2]-r[2])/6*t],e[i+1].inLinePoint.position=[a[0]-(o[0]-s[0])/6*t,a[1]-(o[1]-s[1])/6*t,a[2]-(o[2]-s[2])/6*t]}return e})(e,t):e),i=((e,t)=>{let r=[],n=(e.length-1)/3;n=Math.floor(n);let i,s=0;for(;s<n;++s)i=3*s,getPointsOnBezierCurveWithSplitting(e,i,t,r);return r})(this.#io,r),i=lineSimplifyPoints(i,0,i.length,n),s=0,a=i.length;s<a;s++)o=i[s],this.#ro.push(...o.position,...o.colorRGBA);else this.#ro.push(0,0,0,1,1,1,1);break;default:for(s=0,a=e.length;s<a;s++){const{linePoint:t}=e[s],r=t.colorRGBA;this.interleaveData.push(...t.position,...r)}}this.#qe()}}Object.freeze(Line3D);const on=parseWGSL(nn),un=on.uniforms.vertexUniforms;const cn=";box-sizing:content-box;white-space:nowrap;",hn={padding:0,background:"transparent",color:"#fff",fontFamily:"Arial",fontSize:16,fontWeight:"normal",fontStyle:"normal",letterSpacing:0,wordBreak:"keep-all",verticalAlign:"middle",textAlign:"center",lineHeight:1.4,border:"",boxShadow:"none",boxSizing:"border-box",filter:""};class ATextField extends Mesh{#ao;#oo;#uo;#lo;#co;#ho;#do;#mo=!0;#v;#po;#fo=!1;#go=!1;#_o=!1;constructor(e,t,r=!0){super(e),this.#v=e,this.#mo=r,this.#do=t,this._material=new BitmapMaterial(e,new BitmapTexture(e)),this._material.transparent=!0,this._material.diffuseTextureSampler=new Sampler(e,r?{minFilter:Ie.LINEAR,magFilter:Ie.LINEAR,mipmapFilter:Ue.LINEAR}:{minFilter:Ie.NEAREST,magFilter:Ie.NEAREST,mipmapFilter:null}),this.depthStencilState.depthWriteEnabled=!1,this.#xo(),this.#vo(),this.#To(),this.#yo(),this.#bo()}get text(){return this.#ho}set text(e){this.#ho=e;const t=this.#uo.querySelector("foreignObject div"),r=this.#So(e);this.#lo.innerHTML=r,t.innerHTML=r,this.#Mo()}render(e){this.#do(this.#co.width,this.#co.height),super.render(e)}#So(e){return e.toString().replace(/\<br\/>/gi,"<div/>")}#xo(){"undefined"!=typeof OffscreenCanvas?this.#ao=new OffscreenCanvas(100,100):this.#ao=document.createElement("canvas"),this.#oo=this.#ao.getContext("2d")}#Ro(){const e=this.#lo.getBoundingClientRect();const t=e.width+2+2,r=e.height+2+2;return{width:-2&Math.ceil(t),height:-2&Math.ceil(r),extraTop:2,extraRight:2,extraBottom:2,extraLeft:2}}#Mo(){if(this.#fo=!0,this.#go)return void(this.#_o=!0);this.#go=!0;const updateFrame=()=>{if(this.#fo){this.#fo=!1;const e=this.#uo,t=e.querySelector("foreignObject"),{width:r,height:n,extraTop:i,extraRight:s,extraBottom:a,extraLeft:o}=this.#Ro();t.setAttribute("width",r.toString()),t.setAttribute("height",n.toString()),t.style.padding=`${i}px ${s}px ${a}px ${o}px`,e.setAttribute("width",r.toString()),e.setAttribute("height",n.toString()),this.#co.src="data:image/svg+xml;charset=utf-8,"+encodeURIComponent(e.outerHTML)}this.#_o?(this.#fo=!0,this.#_o=!1,requestAnimationFrame(updateFrame)):this.#go=!1};requestAnimationFrame(updateFrame)}#yo(){this.#co=new Image,this.#co.style.cssText="position:absolute;bottom:0px;left:0;",this.#co.onload=e=>{let t,r;const{width:n,height:i}=this.#Ro(),s=(this.#mo,2),a=this.#mo?1:2;t=n*s,r=i*s,this.#co.width=t/a,this.#co.height=r/a,this.#ao.width=t,this.#ao.height=r,this.#ao instanceof OffscreenCanvas||(this.#ao.style.width=t/s+"px",this.#ao.style.height=r/s+"px"),this.#oo.imageSmoothingEnabled=!0,this.#oo.imageSmoothingQuality="high",this.#oo.clearRect(0,0,t,r),this.#oo.fillStyle="rgba(0,0,0,0)",this.#oo.fillRect(0,0,t,r),this.#oo.drawImage(this.#co,0,0,t,r),this.dirtyTransform=!0;const callback=e=>{this.material.diffuseTexture.src=URL.createObjectURL(e)};this.#ao instanceof OffscreenCanvas?this.#ao.convertToBlob({type:"image/png"}).then(callback):this.#ao.toBlob(callback,"image/png")}}#wo=(e,t)=>{const r=this.#uo.querySelector("foreignObject > div").style,n=this.#lo.style,i=`_${e}`;this[i]=t,Object.defineProperty(this,e,{get:()=>this[i],set:t=>{this[i]=t,(e=>"number"==typeof e)(t)&&(e=>!["lineHeight","fontWeight"].includes(e))(e)&&(t=`${t}px`),r[e]=t,n[e]=t,this.#po&&cancelAnimationFrame(this.#po),this.#po=requestAnimationFrame((()=>{this.#Mo()}))}}),this[e]=t};#vo(){this.#lo=document.createElement("div"),this.#lo.style.cssText=cn+";position:absolute;top:200px;left:0;visibility:hidden;text-rendering:optimizeLegibility",document.body.appendChild(this.#lo)}#To(){const e=this.#uo=document.createElementNS("http://www.w3.org/2000/svg","svg");e.setAttribute("xmlns","http://www.w3.org/2000/svg"),e.setAttribute("text-rendering","optimizeLegibility"),e.style.cssText="position:absolute;top:0px;left:0px;z-index:1;margin:0;padding:0;overflow:visible;background:transparent",e.innerHTML=`<rect x="0" y="0" width="100%" height="100%" fill="rgba(0,0,0,0)"/><foreignObject width="100%" height="100%" style="margin:0;padding:0;" overflow="visible"><div xmlns="http://www.w3.org/1999/xhtml" style="${cn}"></div></foreignObject>`}#bo(){for(const[e,t]of Object.entries(hn))this.#wo(e,t)}}Object.freeze(ATextField);var dn="#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include getBillboardMatrix;\r\nstruct VertexUniforms {\rpickingId:u32,\r\n\t modelMatrix:mat4x4<f32>,\r\n\t normalModelMatrix:mat4x4<f32>,\r\n\t useBillboardPerspective:u32,\r\n\t useBillboard:u32,\r\n\t combinedOpacity:f32,\r\n};\r\n\r\n\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n\r\nstruct InputData {\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r\n};\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(15) pickingId:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn main( inputData:InputData ) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_resolution=systemUniforms.resolution;\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\n\rlet u_useBillboardPerspective=vertexUniforms.useBillboardPerspective;\rlet u_useBillboard=vertexUniforms.useBillboard;\r\n\r\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_positionVec4=vec4<f32>(input_position,1.0);\rlet input_vertexNormalVec4=vec4<f32>(input_vertexNormal,1.0);\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\r\n\r\n\r\nvar scaleMatrix:mat4x4<f32>;\r\rlet cameraPosition=vec3<f32>((u_cameraMatrix * u_modelMatrix)[3].xyz);\rlet objectPosition=input_position.xyz;\rlet distance=length(cameraPosition - objectPosition);\r\n\r\rlet scaleFactor=distance;\rscaleMatrix=mat4x4<f32>(\r10,0.0,0.0,0.0,\r0.0,10,0.0,0.0,\r0.0,0.0,1.0,0.0,\r0.0,0.0,0.0,1.0\r);\r\n\r\n\r\n\r\rif (u_useBillboard==1) {\r\r\rif (u_useBillboardPerspective==1) {\r\r\n\r} else {\r\rscaleMatrix=mat4x4<f32>(\rscaleFactor,0.0,0.0,0.0,\r0.0,scaleFactor,0.0,0.0,\r0.0,0.0,1.0,0.0,\r0.0,0.0,0.0,1.0\r);\r}\r\n\r\rposition=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * scaleMatrix * vec4<f32>(objectPosition,1.0);\rnormalPosition=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * scaleMatrix * vec4<f32>(input_vertexNormal.xyz,1.0);\r\n\r\rvar temp=output.position/output.position.w;\routput.position=vec4<f32>(\rtemp.xy + objectPosition.xy * vec2<f32>(\r(u_projectionMatrix * u_modelMatrix)[0][0],\r(u_projectionMatrix * u_modelMatrix)[1][1]\r),\rtemp.zw\r);\r\n\r} else {\r\rposition=u_cameraMatrix * u_modelMatrix * scaleMatrix * vec4<f32>(objectPosition,1.0);\rnormalPosition=u_cameraMatrix * u_normalModelMatrix * scaleMatrix * vec4<f32>(input_vertexNormal.xyz,1.0);\r}\r\n\r\routput.position=u_projectionMatrix * position;\routput.vertexPosition=position.xyz;\routput.vertexNormal=normalPosition.xyz;\routput.uv=input_uv;\routput.combinedOpacity=vertexUniforms.combinedOpacity;\rreturn output;\r\n}\r\nstruct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn picking(inputData:InputData) -> OutputData {\rvar output:OutputData;\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\rlet u_useBillboardPerspective=vertexUniforms.useBillboardPerspective;\rlet u_useBillboard=vertexUniforms.useBillboard;\r\n\r\rlet input_position=inputData.position;\rlet input_positionVec4=vec4<f32>(input_position,1.0);\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>;\r\n\r\n\rvar scaleMatrix:mat4x4<f32>;\r\rlet cameraPosition=vec3<f32>((u_cameraMatrix * u_modelMatrix)[3].xyz);\rlet objectPosition=input_position.xyz;\rlet distance=length(cameraPosition - objectPosition);\r\n\r\rlet scaleFactor=distance;\rscaleMatrix=mat4x4<f32>(\r10,0.0,0.0,0.0,\r0.0,10,0.0,0.0,\r0.0,0.0,1.0,0.0,\r0.0,0.0,0.0,1.0\r);\r\rif (u_useBillboard==1) {\r\rif (u_useBillboardPerspective==1) {\r\r\n\r} else {\r\rscaleMatrix=mat4x4<f32>(\rscaleFactor,0.0,0.0,0.0,\r0.0,scaleFactor,0.0,0.0,\r0.0,0.0,1.0,0.0,\r0.0,0.0,0.0,1.0\r);\r}\r\n\r\rposition=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * scaleMatrix * vec4<f32>(objectPosition,1.0);\r\n\r\rvar temp=output.position/output.position.w;\routput.position=vec4<f32>(\rtemp.xy + objectPosition.xy * vec2<f32>(\r(u_projectionMatrix * u_modelMatrix)[0][0],\r(u_projectionMatrix * u_modelMatrix)[1][1]\r),\rtemp.zw\r);\r\n\r} else {\r\rposition=u_cameraMatrix * u_modelMatrix * scaleMatrix * vec4<f32>(objectPosition,1.0);\r}\routput.position=u_projectionMatrix * position;\routput.pickingId=unpack4x8unorm(vertexUniforms.pickingId);\rreturn output;\r\n}\r\n";const mn=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include calcTintBlendMode;\r\n#redgpu_include drawPicking;\r\n\r\nstruct Uniforms {\ruseDiffuseTexture:u32,\r\ropacity:f32,\ruseTint:u32,\rtint:vec4<f32>,\rtintBlendMode:u32,\r\n};\r\n\r\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\r\n@group(2) @binding(1) var diffuseTextureSampler:sampler;\r\n@group(2) @binding(2) var diffuseTexture:texture_2d<f32>;\r\n\r\nstruct InputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(15) pickingId:vec4<f32>,\r\n};\r\n\r\n@fragment\r\nfn main(inputData:InputData) -> @location(0) vec4<f32> {\r\rvar finalColor:vec4<f32>=textureSample(diffuseTexture,diffuseTextureSampler,inputData.uv);\rfinalColor=vec4<f32>(finalColor.rgb,finalColor.a * uniforms.opacity * inputData.combinedOpacity);\r\n\rif(uniforms.useTint==1u){\rfinalColor=calcTintBlendMode(finalColor,uniforms.tintBlendMode,uniforms.tint);\r}\r\n\r\rif (finalColor.a==0.0) {\rdiscard;\r}\r\n\rreturn finalColor;\r\n};\r\n");class TextFieldMaterial extends ABitmapBaseMaterial{dirtyPipeline=!1;constructor(e,t,r){super(e,"TEXT_FILED_MATERIAL",mn,2),r&&(this.name=r),this.diffuseTexture=t,this.diffuseTextureSampler=new Sampler(this.redGPUContext),this.initGPURenderInfos()}}rt.defineByPreset(TextFieldMaterial,[rt.PRESET_TEXTURE.DIFFUSE_TEXTURE,rt.PRESET_SAMPLER.DIFFUSE_TEXTURE_SAMPLER]),Object.freeze(TextFieldMaterial);const pn=parseWGSL(dn),fn=pn.uniforms.vertexUniforms;class TextField3D extends ATextField{#Xa=1;#ja=1;constructor(e){super(e,((e,t)=>{this.#Xa=e/1024,this.#ja=t/1024})),this._geometry=new Plane(e),this._material=new TextFieldMaterial(e,new BitmapTexture(e)),this._material.transparent=!0,this.dirtyPipeline=!0,this.dirtyTransform=!0}get geometry(){return this._geometry}set geometry(e){console.error("TextField3D can not change geometry")}get material(){return this._material}set material(e){console.error("TextField3D can not change material")}get renderTextureWidth(){return this.#Xa}get renderTextureHeight(){return this.#ja}createCustomMeshVertexShaderModule(){return this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_TEXT_FIELD_3D",pn,fn,dn)}}Le.defineByPreset(TextField3D,[[Le.PRESET_BOOLEAN.USE_BILLBOARD_PERSPECTIVE,!0],Le.PRESET_BOOLEAN.USE_BILLBOARD]),Object.freeze(TextField3D);var gn="#redgpu_include SYSTEM_UNIFORM;\r\n#redgpu_include getBillboardMatrix;\r\nstruct VertexUniforms {\rpickingId:u32,\r\n\t modelMatrix:mat4x4<f32>,\r\n\t normalModelMatrix:mat4x4<f32>,\r\n\t combinedOpacity:f32,\r\n};\r\n\r\n\r\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\r\n\r\nstruct InputData {\r@location(0) position:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r\n};\r\nstruct OutputData {\r@builtin(position) position:vec4<f32>,\r@location(0) vertexPosition:vec3<f32>,\r@location(1) vertexNormal:vec3<f32>,\r@location(2) uv:vec2<f32>,\r@location(12) combinedOpacity:f32,\r@location(13) shadowPos:vec3<f32>,\r@location(15) pickingId:vec4<f32>,\r\n};\r\n\r\n\r\n@vertex\r\nfn main( inputData:InputData ) -> OutputData {\rvar output:OutputData;\r\n\r\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\n\r\n\r\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\r\n\rposition=u_cameraMatrix * u_modelMatrix * vec4<f32>(input_position,1.0);\rnormalPosition=u_cameraMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0);\routput.position=u_projectionMatrix * position;\r\n\r\n\routput.vertexPosition=position.xyz;\routput.vertexNormal=normalPosition.xyz;\routput.uv=input_uv;\routput.combinedOpacity=vertexUniforms.combinedOpacity;\rreturn output;\r\n}\r\nstruct OutputShadowData {\r@builtin(position) position:vec4<f32>,\r\n};\r\n\r\n@vertex\r\nfn picking(inputData:InputData) -> OutputData {\rvar output:OutputData;\rlet u_projectionMatrix=systemUniforms.projectionMatrix;\rlet u_camera=systemUniforms.camera;\rlet u_cameraMatrix=u_camera.cameraMatrix;\rlet u_cameraPosition=u_camera.cameraPosition;\r\rlet u_modelMatrix=vertexUniforms.modelMatrix;\rlet u_normalModelMatrix=vertexUniforms.normalModelMatrix;\r\r\n\r\n\r\rlet input_position=inputData.position;\rlet input_vertexNormal=inputData.vertexNormal;\rlet input_uv=inputData.uv;\r\n\rvar position:vec4<f32>;\rvar normalPosition:vec4<f32>;\r\n\rposition=u_cameraMatrix * u_modelMatrix * vec4<f32>(input_position,1.0);\rnormalPosition=u_cameraMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0);\routput.position=u_projectionMatrix * position;\r\n\routput.pickingId=unpack4x8unorm(vertexUniforms.pickingId);\rreturn output;\r\n}\r\n";const _n=parseWGSL(gn),xn=_n.uniforms.vertexUniforms,vn=mixInMesh2D(ATextField);class TextField2D extends vn{get useSmoothing(){return this.#Po}set useSmoothing(e){this.#Po=e,this.useSmoothing?(this._material.diffuseTextureSampler.minFilter=Ie.LINEAR,this._material.diffuseTextureSampler.magFilter=Ie.LINEAR,this._material.diffuseTextureSampler.mipmapFilter=Ue.LINEAR):(this._material.diffuseTextureSampler.minFilter=Ie.NEAREST,this._material.diffuseTextureSampler.magFilter=Ie.NEAREST,this._material.diffuseTextureSampler.mipmapFilter=null)}#Br=1;#Ir=1;#Po=!1;constructor(e,t=!1){super(e,((e,t)=>{this.#Br=e,this.#Ir=t}),!1),this._geometry=new Plane(e,1,1,1,1,1,!0),this._material=new TextFieldMaterial(e,new BitmapTexture(e)),this._material.transparent=!0,this.useSmoothing=t,this.dirtyPipeline=!0,this.dirtyTransform=!0,this.primitiveState.cullMode=Pt.FRONT}get width(){return this.#Br}get height(){return this.#Ir}get geometry(){return this._geometry}set geometry(e){console.error("TextField2D can not change geometry")}get material(){return this._material}set material(e){console.error("TextField2D can not change material")}createCustomMeshVertexShaderModule(){return this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_TEXT_FIELD_2D",_n,xn,gn)}}Object.freeze(TextField2D);var Tn=Object.freeze({__proto__:null,Group2D:Group2D,Group3D:Group3D,InstancingMesh:InstancingMesh,LINE_TYPE:rn,Line2D:class extends Line3D{constructor(e,t=rn.LINEAR,r="#fff"){super(e,t,r),this._material=new LineMaterial(e)}get geometry(){return this._geometry}set geometry(e){consoleAndThrowError("Line2D can not change geometry")}get material(){return this._material}set material(e){consoleAndThrowError("Line2D can not change material")}createCustomMeshVertexShaderModule(){return this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_LINE_2D",on,un,nn)}addPoint(e=0,t=0,r=this.baseColor,n=1,i=0,s=0,a=0,o=0){super.addPoint(e,t,0,r,n,i,s,0,a,o,0)}addPointAt(e,t=0,r=0,n=this.baseColor,i=1,s=0,a=0,o=0,u=0){super.addPointAt(e,t,r,0,n,i,s,a,0,o,u,0)}},Line3D:Line3D,Mesh:Mesh,Object3DContainer:Object3DContainer,PARTICLE_EASE:Vr,ParticleEmitter:ParticleEmitter,Scene:Scene,SkyBox:class{dirtyPipeline=!0;modelMatrix=create$5();gpuRenderInfo;_geometry;_material;#Ht=!0;#v;#Gt;#Vt;constructor(e,t){validateRedGPUContext(e),this.#v=e,this._geometry=new Box(e),this._material=new SkyBoxMaterial(e,t),this.#Gt=new PrimitiveState(this),this.#Gt.cullMode=Pt.NONE,this.#Vt=new DepthStencilState(this),this.#Vt.depthWriteEnabled=!1}render(e){const{currentRenderPassEncoder:t}=e;this.#Eo(),this.gpuRenderInfo||this.#Ds(this.#v),this.dirtyPipeline&&(this.gpuRenderInfo.pipeline=this.#ko(),this.dirtyPipeline=!1,e.numDirtyPipelines++);const{gpuRenderInfo:r}=this,{vertexUniformBindGroup:n,pipeline:i}=r,{indexBuffer:s}=this._geometry,{triangleCount:a,indexNum:o}=s;t.setPipeline(i),t.setVertexBuffer(0,this._geometry.vertexBuffer.gpuBuffer),t.setBindGroup(1,n),t.setBindGroup(2,this._material.gpuRenderInfo.fragmentUniformBindGroup),t.setIndexBuffer(s.gpuBuffer,"uint32"),t.drawIndexed(s.indexNum,1,0,0,0),e.num3DObjects++,e.numDrawCalls++,e.numTriangles+=a,e.numPoints+=o}#Eo(){const{useMSAA:e}=this.#v;e!==this.#Ht&&(this.#Ht=e,this.dirtyPipeline=!0)}#Ds(e){const{resourceManager:t}=this.#v,r=t.getGPUBindGroupLayout("SKYBOX_VERTEX_BIND_GROUP_LAYOUT")||t.createBindGroupLayout("SKYBOX_VERTEX_BIND_GROUP_LAYOUT",getVertexBindGroupLayoutDescriptorFromShaderInfo(Ir,1)),n=new ArrayBuffer(Ur.arrayBufferByteLength),i=new UniformBuffer(e,n);identity$2(this.modelMatrix),scale$5(this.modelMatrix,this.modelMatrix,[1e4,1e4,1e4]),i.writeBuffer(Ur.members.modelMatrix,this.modelMatrix);const s={layout:r,label:"VERTEX_BIND_GROUP_DESCRIPTOR_SKYBOX",entries:[{binding:0,resource:{buffer:i.gpuBuffer,offset:0,size:i.size}}]},a=e.gpuDevice.createBindGroup(s);this.gpuRenderInfo=new VertexGPURenderInfo(null,Ur,r,i,a,this.#ko())}#ko(){const{resourceManager:e,gpuDevice:t}=this.#v,r={code:Br},n={module:e.createGPUShaderModule("VERTEX_MODULE_SKYBOX",r),entryPoint:"main",buffers:this._geometry.gpuRenderInfo.buffers},i=e.getGPUBindGroupLayout("SKYBOX_VERTEX_BIND_GROUP_LAYOUT")||e.createBindGroupLayout("SKYBOX_VERTEX_BIND_GROUP_LAYOUT",getVertexBindGroupLayoutDescriptorFromShaderInfo(Ir,1)),s={bindGroupLayouts:[e.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),i,this._material.gpuRenderInfo.fragmentBindGroupLayout]},a={label:"PIPELINE_DESCRIPTOR_SKYBOX",layout:t.createPipelineLayout(s),vertex:n,fragment:this._material.gpuRenderInfo.fragmentState,primitive:this.#Gt.state,depthStencil:this.#Vt.state,multisample:{count:this.#v.useMSAA?4:1}};return t.createRenderPipeline(a)}},SphericalSkyBox:class{dirtyPipeline=!0;modelMatrix=create$5();gpuRenderInfo;_geometry;_material;#Ht=!0;#v;#Gt;#Vt;constructor(e,t){validateRedGPUContext(e),this.#v=e,this._geometry=new Sphere(e,1,64,64,64),this._material=new SphericalSkyBoxMaterial(e,t),this.#Gt=new PrimitiveState(this),this.#Gt.cullMode=Pt.FRONT,this.#Vt=new DepthStencilState(this),this.#Vt.depthWriteEnabled=!1}render(e){const{currentRenderPassEncoder:t}=e;this.#Eo(),this.gpuRenderInfo||this.#Ds(this.#v),this.dirtyPipeline&&(this.gpuRenderInfo.pipeline=this.#ko(),this.dirtyPipeline=!1,e.numDirtyPipelines++);const{gpuRenderInfo:r}=this,{vertexUniformBindGroup:n,pipeline:i}=r,{indexBuffer:s}=this._geometry,{triangleCount:a,indexNum:o}=s;t.setPipeline(i),t.setVertexBuffer(0,this._geometry.vertexBuffer.gpuBuffer),t.setBindGroup(1,n),t.setBindGroup(2,this._material.gpuRenderInfo.fragmentUniformBindGroup),t.setIndexBuffer(s.gpuBuffer,"uint32"),t.drawIndexed(s.indexNum,1,0,0,0),e.num3DObjects++,e.numDrawCalls++,e.numTriangles+=a,e.numPoints+=o}#Eo(){const{useMSAA:e}=this.#v;e!==this.#Ht&&(this.#Ht=e,this.dirtyPipeline=!0)}#Ds(e){const{resourceManager:t}=this.#v,r=t.getGPUBindGroupLayout("SPHERICAL_SKYBOX_VERTEX_BIND_GROUP_LAYOUT")||t.createBindGroupLayout("SPHERICAL_SKYBOX_VERTEX_BIND_GROUP_LAYOUT",getVertexBindGroupLayoutDescriptorFromShaderInfo(Nr,1)),n=new ArrayBuffer(Or.arrayBufferByteLength),i=new UniformBuffer(e,n);identity$2(this.modelMatrix),scale$5(this.modelMatrix,this.modelMatrix,[5e3,5e3,5e3]),i.writeBuffer(Or.members.modelMatrix,this.modelMatrix);const s={layout:r,label:"VERTEX_BIND_GROUP_DESCRIPTOR_SPHERICAL_SKYBOX",entries:[{binding:0,resource:{buffer:i.gpuBuffer,offset:0,size:i.size}}]},a=e.gpuDevice.createBindGroup(s);this.gpuRenderInfo=new VertexGPURenderInfo(null,Or,r,i,a,this.#ko())}#ko(){const{resourceManager:e,gpuDevice:t}=this.#v,r={code:Ar},n={module:e.createGPUShaderModule("VERTEX_MODULE_SPHERICAL_SKYBOX",r),entryPoint:"main",buffers:this._geometry.gpuRenderInfo.buffers},i=e.getGPUBindGroupLayout("SPHERICAL_SKYBOX_VERTEX_BIND_GROUP_LAYOUT")||e.createBindGroupLayout("SPHERICAL_SKYBOX_VERTEX_BIND_GROUP_LAYOUT",getVertexBindGroupLayoutDescriptorFromShaderInfo(Nr,1)),s={bindGroupLayouts:[e.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),i,this._material.gpuRenderInfo.fragmentBindGroupLayout]},a={label:"PIPELINE_DESCRIPTOR_SPHERICAL_SKYBOX",layout:t.createPipelineLayout(s),vertex:n,fragment:this._material.gpuRenderInfo.fragmentState,primitive:this.#Gt.state,depthStencil:this.#Vt.state,multisample:{count:this.#v.useMSAA?4:1}};return t.createRenderPipeline(a)}},Sprite2D:Sprite2D,Sprite3D:Sprite3D,SpriteSheet2D:SpriteSheet2D,SpriteSheet3D:SpriteSheet3D,SpriteSheetInfo:SpriteSheetInfo,TextField2D:TextField2D,TextField3D:TextField3D,View2D:View2D,View3D:View3D}),yn=Object.freeze({__proto__:null,AmbientLight:AmbientLight,DirectionalLight:DirectionalLight,PointLight:PointLight});function calculatePositionOnCurve(e,t,r,n,i){const s=Math.cos(e),a=Math.sin(e),o=r/t*e,u=Math.cos(o);i[0]=n*(2+u)*.5*s,i[1]=n*(2+u)*a*.5,i[2]=n*Math.sin(o)*.5}var bn=Object.freeze({__proto__:null,Box:Box,Circle:class extends Primitive{#$n=function(){return function(e,t,r,n,i,s){const a=[],o=[];let u,l,c;a.push(0,0,0,0,0,1,.5,.5);let h=0,d=3;for(;h<=n;)u=i+h/n*s,l=Math.cos(u),c=Math.sin(u),a.push(r*l,r*c,0,0,0,1,(l/r+1)/2,(c/r+1)/2),h++,d+=3;for(d=1;d<=n;)o.push(d,d+1,0),d++;return createPrimitiveGeometry(t,a,o,e)}}();constructor(e,t=1,r=32,n=0,i=2*Math.PI){super(e);const s=`PRIMITIVE_CIRCLE_R${t}_S${r}_TS${n}_TL${i}`,a=e.resourceManager.cachedBufferState;let o=a[s];o||(o=a[s]=this.#$n(s,e,t,r,n,i)),this._setData(o)}},Cylinder:Cylinder,Plane:Plane,Primitive:Primitive,Sphere:Sphere,Torus:class extends Primitive{#$n=function(){return function(e,t,r,n,i,s,a,o){a=a||0;const u=(o=o||2*Math.PI)-a,l=i+1,c=s+1,h=[],d=[];for(let e=0;e<c;++e){const t=e/s,o=t*Math.PI*2,c=Math.sin(o),d=r+c*n,m=Math.cos(o),p=m*n;for(let e=0;e<l;++e){const r=e/i,n=a+r*u,s=Math.sin(n),o=Math.cos(n),l=s*d,f=o*d,g=s*c,_=o*c;h.push(l,p,f,g,m,_,r,1-t)}}for(let e=0;e<s;++e)for(let t=0;t<i;++t){const r=1+t,n=1+e;d.push(l*e+t,l*n+t,l*e+r),d.push(l*n+t,l*n+r,l*e+r)}return createPrimitiveGeometry(t,h,d,e)}}();constructor(e,t=1,r=.5,n=16,i=16,s=0,a=2*Math.PI){if(super(e),n<3)throw new Error("radialSubdivisions must be 3 or greater");if(i<3)throw new Error("verticalSubdivisions must be 3 or greater");const o=`PRIMITIVE_TORUS_R${t}_T${r}_RSD${n}_BSD${i}_SA${s}_EA${a}`,u=e.resourceManager.cachedBufferState;let l=u[o];l||(l=u[o]=this.#$n(o,e,t,r,n,i,s,a)),this._setData(l)}},TorusKnot:class extends Primitive{#$n=function(){return function(e,t,r,n,i,s,a,o){i=Math.floor(i),s=Math.floor(s);const u=[],l=[],c=[],h=[],d=[0,0,0],m=[0,0,0],p=[0,0,0],f=[0,0,0],g=[0,0,0];for(let e=0;e<=i;++e){const t=e/i*a*Math.PI*2;calculatePositionOnCurve(t,a,o,r,d),calculatePositionOnCurve(t+.01,a,o,r,m),f[0]=m[0]-d[0],f[1]=m[1]-d[1],f[2]=m[2]-d[2],g[0]=m[0]+d[0],g[1]=m[1]+d[1],g[2]=m[2]+d[2];{const e=f[0],t=f[1],r=f[2],n=g[0],i=g[1],s=g[2];p[0]=t*s-r*i,p[1]=r*n-e*s,p[2]=e*i-t*n}{const e=p[0],t=p[1],r=p[2],n=f[0],i=f[1],s=f[2];g[0]=t*s-r*i,g[1]=r*n-e*s,g[2]=e*i-t*n}{let e=p[0],t=p[1],r=p[2],n=e*e+t*t+r*r;n>0&&(n=1/Math.sqrt(n||1)),p[0]=p[0]*n,p[1]=p[1]*n,p[2]=p[2]*n}{let e=g[0],t=g[1],r=g[2],n=e*e+t*t+r*r;n>0&&(n=1/Math.sqrt(n)),g[0]=g[0]*n,g[1]=g[1]*n,g[2]=g[2]*n}for(let t=0;t<=s;++t){const r=t/s*Math.PI*2,a=-n*Math.cos(r),o=n*Math.sin(r);c[0]=d[0]+(a*g[0]+o*p[0]),c[1]=d[1]+(a*g[1]+o*p[1]),c[2]=d[2]+(a*g[2]+o*p[2]),u.push(c[0],c[1],c[2]);{h[0]=c[0]-d[0],h[1]=c[1]-d[1],h[2]=c[2]-d[2];let e=h[0],t=h[1],r=h[2],n=e*e+t*t+r*r;n>0&&(n=1/Math.sqrt(n)),h[0]=h[0]*n,h[1]=h[1]*n,h[2]=h[2]*n}u.push(h[0],h[1],h[2],e/i,t/s)}}for(let e=1;e<=i;e++)for(let t=1;t<=s;t++){const r=(s+1)*(e-1)+(t-1),n=(s+1)*e+(t-1),i=(s+1)*e+t,a=(s+1)*(e-1)+t;l.push(r,n,a),l.push(n,i,a)}return createPrimitiveGeometry(t,u,l,e)}}();constructor(e,t=1,r=.4,n=64,i=8,s=2,a=3){super(e);const o=`PRIMITIVE_TORUS_NUT_R${t}_T${r}_TS${n}_RS${i}_P${s}_Q${a}`,u=e.resourceManager.cachedBufferState;let l=u[o];l||(l=u[o]=this.#$n(o,e,t,r,n,i,s,a)),this._setData(l)}}});class ResourceStateCubeTextureFromSphericalSky{texture;src;cacheKey;useNum=0;uuid;constructor(e){this.texture=e,this.src=e.src,this.cacheKey=e.cacheKey,this.useNum=0,this.uuid=e.uuid}}class CubeTextureFromSphericalSky extends ManagedResourceBase{static defaultViewDescriptor={dimension:"cube",aspect:"all",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:0,arrayLayerCount:6};#$;#X;#j;#Y;#Z;#q;#W=0;#Q;#ee;#te;constructor(e,t,r=!0,n,i,s){if(super(e,"managedCubeTextureFromSphericalSkyState"),this.#ee=n,this.#te=i,this.#Z=r,this.#Q=s||navigator.gpu.getPreferredCanvasFormat(),t){this.#X=t?.src||t,this.#j=t?.cacheKey||t||this.uuid;const{table:e}=this.targetResourceManagedState;let r;for(const t in e)if(e[t].cacheKey===this.#j){r=e[t];break}if(r)return this.#ee?.(this),e[r.uuid].texture;this.src=t,this.#re()}}get cacheKey(){return this.#j}get videoMemorySize(){return this.#W}get gpuTexture(){return this.#$}get mipLevelCount(){return this.#Y}get src(){return this.#X}set src(e){this.#X=e?.src||e,this.#j=e?.cacheKey||e||this.uuid,this.#X&&this.#ne(this.#X)}get useMipmap(){return this.#Z}set useMipmap(e){this.#Z=e,this.#ie()}destroy(){const e=this.#$;this.#se(null),this.__fireListenerList(!0),this.#X=null,this.#j=null,this.#ae(),e&&e.destroy()}#se(e){this.#$=e,e||(this.#q=null),this.__fireListenerList()}#re(){basicRegisterResource(this,new ResourceStateCubeTextureFromSphericalSky(this))}#ae(){basicUnregisterResource(this)}#ie(){const{gpuDevice:e,resourceManager:t}=this.redGPUContext,{mipmapGenerator:r}=t;this.#$&&(this.#$.destroy(),this.#$=null),this.#Y=1;{const t=this.#q,r=e.createTexture({size:[t.width,t.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});e.queue.copyExternalImageToTexture({source:t},{texture:r},[t.width,t.height]);const i=(n=512,e.createTexture({size:[n,n,6],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC})),s=e.createSampler({magFilter:"linear",minFilter:"linear"}),a=e.createShaderModule({code:"\nstruct VertexOutput {@builtin(position) position:vec4<f32>,@location(0) uv:vec2<f32>,\n};\n\n\n@group(0) @binding(0) var textureSampler:sampler;\n@group(0) @binding(1) var sphericalTexture:texture_2d<f32>;\n@group(0) @binding(2) var<uniform> cubeFaceIndex:u32;\n\n\nfn atan2(y:f32,x:f32) -> f32 {if (x > 0.0) {return atan(y/x);} else if (x < 0.0 && y >=0.0) {return atan(y/x) + 3.141592653589793;} else if (x < 0.0 && y < 0.0) {return atan(y/x) - 3.141592653589793;} else if (x==0.0 && y > 0.0) {return 1.5707963267948966;} else if (x==0.0 && y < 0.0) {return -1.5707963267948966;} else {return 0.0;}\n}\n\n@vertex\n\nfn vertexMain(@builtin(vertex_index) vertexIndex:u32) -> VertexOutput {var positions=array<vec3<f32>,6>(vec3<f32>(-1.0, 1.0,0.0),vec3<f32>( 1.0, 1.0,0.0),vec3<f32>(-1.0,-1.0,0.0),vec3<f32>( 1.0,-1.0,0.0),vec3<f32>(-1.0,-1.0,0.0),vec3<f32>( 1.0, 1.0,0.0));var position=positions[vertexIndex];var output:VertexOutput;output.position=vec4<f32>(position,1.0);\nvar direction:vec3<f32>;if (cubeFaceIndex==0u) {direction=vec3<f32>(1.0,position.y,-position.x);} else if (cubeFaceIndex==1u) { direction=vec3<f32>(-1.0,position.y,position.x);} else if (cubeFaceIndex==2u) {direction=vec3<f32>(position.x,1.0,-position.y);} else if (cubeFaceIndex==3u) { direction=vec3<f32>(position.x,-1.0,position.y);} else if (cubeFaceIndex==4u) {direction=vec3<f32>(position.x,position.y,1.0);} else {direction=vec3<f32>(-position.x,position.y,-1.0);}\n// \ndirection=normalize(direction);\n//  UV  \nlet theta=atan2(direction.z,direction.x);let phi=acos(direction.y); \n//  UV \nlet PI=3.1415927;let u=theta/(2.0 * PI);let v=phi/PI; \n//UV  \noutput.uv=vec2<f32>(u,v);\n\n\nreturn output;\n}\n\n\n@fragment\n\nfn fragmentMain(@location(0) fragUV:vec2<f32>) -> @location(0) vec4<f32> {var sampledColor:vec4<f32>=textureSample(sphericalTexture,textureSampler,fragUV);;if (fragUV.x < 0.0 || fragUV.x > 1.0 || fragUV.y < 0.0 || fragUV.y > 1.0) {sampledColor=vec4<f32>(0.0,0.0,0.0,1.0);} \nlet gamma=2.2;let outputColor=pow(sampledColor.rgb,vec3<f32>(1.0/gamma));\nreturn vec4<f32>(outputColor,sampledColor.a);\n}"}),{pipeline:o,renderPassViews:u}=function(e,t,r){const n=e.createRenderPipeline({layout:"auto",vertex:{module:r,entryPoint:"vertexMain"},fragment:{module:r,entryPoint:"fragmentMain",targets:[{format:"rgba8unorm"}]},primitive:{topology:"triangle-list"}}),i=[];for(let e=0;e<6;e++)i.push(t.createView({dimension:"2d",arrayLayerCount:1,baseArrayLayer:e}));return{pipeline:n,renderPassViews:i}}(e,i,a),l=e.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),c=e.createBindGroup({layout:o.getBindGroupLayout(0),entries:[{binding:0,resource:s},{binding:1,resource:r.createView()},{binding:2,resource:{buffer:l,offset:0,size:4}}]}),h=e.createCommandEncoder();for(let t=0;t<6;t++){e.queue.writeBuffer(l,0,new Uint32Array([t]));const r=h.beginRenderPass({colorAttachments:[{view:u[t],loadOp:"clear",clearValue:[0,0,0,1],storeOp:"store"}]});r.setPipeline(o),r.setBindGroup(0,c),r.draw(6,1,0,0),r.end()}e.queue.submit([h.finish()]),this.#se(i)}var n}async#ne(e){this.#q=await loadAndCreateBitmapImage(e);try{this.#ie(),this.#ee?.(this)}catch(e){console.error(e),this.#te?.(e)}}}Object.freeze(CubeTextureFromSphericalSky);var Sn=Object.freeze({__proto__:null,AUniformBaseBuffer:AUniformBaseBuffer,BitmapTexture:BitmapTexture,CubeTexture:CubeTexture,CubeTextureFromSphericalSky:CubeTextureFromSphericalSky,IndexBuffer:IndexBuffer,InterleavedStructElement:InterleavedStructElement,ResourceBase:ResourceBase,ResourceManager:ResourceManager,ResourceState:ResourceState,Sampler:Sampler,StorageBuffer:StorageBuffer,UniformBuffer:UniformBuffer,UniformType:UniformType,VertexBuffer:VertexBuffer,getUniformOffsetByRoundUp:(e,t)=>((e+t-1)/t|0)*t,loadAndCreateBitmapImage:loadAndCreateBitmapImage,parseIncludeWGSL:parseIncludeWGSL,parseWGSL:parseWGSL}),Mn=Object.freeze({__proto__:null,BlendState:BlendState,DepthStencilState:DepthStencilState,PrimitiveState:PrimitiveState}),Rn="\r\n\r\n@group(1) @binding(0)\r\nvar _sampler:sampler;\r\n\r\n@group(1) @binding(1)\r\nvar _texture:texture_2d<f32>;\r\n\r\n\r\n\r\n@fragment\r\nfn main(@location(0) fragUV:vec2<f32>) -> @location(0) vec4<f32> {\r\rvar diffuseColor:vec4<f32>=textureSample(_texture,_sampler,fragUV);\r\n\r\rdiffuseColor=vec4<f32>(diffuseColor.rgb,diffuseColor.a);\r\n\r\rreturn diffuseColor;\r\n}\r\n",wn="\r\n\r\nstruct VertexUniforms {\rmodelMatrix:mat4x4<f32>,\r\n};\r\n\r\n\r\n@group(0) @binding(0)\r\nvar<uniform> vertexUniforms:VertexUniforms;\r\n\r\n\r\n\r\n\r\nstruct VertexOutput {\r@builtin(position) Position:vec4<f32>,\r@location(0) fragUV:vec2<f32>,\r\n};\r\n\r\n\r\n@vertex\r\nfn main(@builtin(vertex_index) VertexIndex:u32) -> VertexOutput {\r\n\r\rvar pos=array<vec2<f32>,6>(\rvec2( 1.0, 1.0),\rvec2( 1.0,-1.0),\rvec2(-1.0,-1.0),\rvec2( 1.0, 1.0),\rvec2(-1.0,-1.0),\rvec2(-1.0, 1.0),\r);\r\n\r\rvar uv=array<vec2<f32>,6>(\rvec2(1.0,0.0),\rvec2(1.0,1.0),\rvec2(0.0,1.0),\rvec2(1.0,0.0),\rvec2(0.0,1.0),\rvec2(0.0,0.0),\r);\r\n\r\rvar output:VertexOutput;\r\n\r\routput.Position=vertexUniforms.modelMatrix * vec4<f32>(pos[VertexIndex],0.0,1.0);\routput.fragUV=uv[VertexIndex];\r\n\r\rreturn output;\r\n}\r\n";const Pn=parseWGSL(wn),En=parseWGSL(Rn),kn=Pn.uniforms.vertexUniforms;class FinalRender{#Ht;#Co=[];#Lo=[];#Bo;#Io;#Uo;#Ao;#Do;#No=[];#ze;#Oo=[];#Go=[];#ue;constructor(){}render(e,t){const{useMSAA:r,sizeManager:n,gpuDevice:i,resourceManager:s}=e,{pixelRectObject:a}=n,{width:o,height:u}=a;if(0===o||0===u)return;const l=this.#Vo(e),c=i.createCommandEncoder(),h=c.beginRenderPass(l);h.setViewport(0,0,o,u,0,1),h.setScissorRect(0,0,o,u),this.#Bo||this.#Fo(e),this.#Ho(e,h,t.map((e=>{const t=e.colorAttachments[0];return t.postEffectView||t.pickingView||t.resolveTarget||t.view})),o,u,r),h.end(),i.queue.submit([c.finish()]),this.#Ht=r}#Ho(e,t,r,n,i,s){const{gpuDevice:a}=e;r.forEach(((r,o)=>{const u=e.viewList[o],{x:l,y:c,width:h,height:d}=u.pixelRectObject,m=create$5();f(m,0,1,0,1,-1e3,1e3),scale$5(m,m,[1/n,1/i,1]),translate$1(m,m,[h/2+l,i-d/2-c,0]),scale$5(m,m,[h/2,d/2,1]),this.#zo(e,o);const p=this.#Co[o],g=this.#Lo[o];a.queue.writeBuffer(p.gpuBuffer,kn.members.modelMatrix.uniformOffset,new kn.members.modelMatrix.View(m));if(this.#Ht!==s||!this.#Oo[o]||this.#Oo[o].width!==h||this.#Oo[o].height!==d||this.#Go[o]!==r){const e={layout:this.#Ao,label:"FRAGMENT_BIND_GROUP_DESCRIPTOR_FINAL_RENDER",entries:[{binding:0,resource:this.#ue.gpuSampler},{binding:1,resource:r}]};this.#No[o]=a.createBindGroup(e),this.#Oo[o]={width:h||1,height:d||1},this.#Go[o]=r}t.setPipeline(this.#Ko(e)),t.setBindGroup(0,g),t.setBindGroup(1,this.#No[o]),t.draw(6,1,0,0)}))}#Fo(e){const{resourceManager:t}=e;this.#Bo=t.createBindGroupLayout("FINAL_RENDER_VERTEX_BIND_GROUP_LAYOUT",getVertexBindGroupLayoutDescriptorFromShaderInfo(Pn,0)),this.#Io=t.createGPUShaderModule("VERTEX_MODULE_FINAL_RENDER",{code:wn}),this.#Uo={module:this.#Io,entryPoint:"main"},this.#Do=t.createGPUShaderModule("FRAGMENT_MODULE_FINAL_RENDER",{code:Rn}),this.#Ao=t.createBindGroupLayout("FINAL_RENDER_BIND_GROUP_LAYOUT",getFragmentBindGroupLayoutDescriptorFromShaderInfo(En,1)),this.#ue=new Sampler(e,{minFilter:"linear"})}#zo(e,t){const{gpuDevice:r}=e;if(!this.#Co[t]){const n=new ArrayBuffer(kn.arrayBufferByteLength),i=this.#Co[t]=new UniformBuffer(e,n,`FinalRender_View(${t})_VertexUniform`),s={layout:this.#Bo,label:"VERTEX_BIND_GROUP_DESCRIPTOR_FINAL_RENDER",entries:[{binding:0,resource:{buffer:i.gpuBuffer,offset:0,size:i.size}}]};this.#Lo[t]=r.createBindGroup(s)}}#Vo(e){const{backgroundColor:t,gpuContext:r}=e,n=t.rgbaNormal;return{colorAttachments:[{view:r.getCurrentTexture().createView(),clearValue:{r:n[0]*n[3],g:n[1]*n[3],b:n[2]*n[3],a:n[3]},loadOp:Ge.CLEAR,storeOp:Ve.STORE}]}}#Ko(e){if(!this.#ze){const{gpuDevice:t}=e,r={label:"PIPELINE_DESCRIPTOR_FINAL_RENDER",layout:t.createPipelineLayout({bindGroupLayouts:[this.#Bo,this.#Ao]}),vertex:this.#Uo,fragment:{module:this.#Do,entryPoint:"main",targets:[{format:navigator.gpu.getPreferredCanvasFormat(),blend:{color:{srcFactor:lt.ONE,dstFactor:lt.ONE_MINUS_SRC_ALPHA,operation:ct.ADD},alpha:{srcFactor:lt.ONE,dstFactor:lt.ONE_MINUS_SRC_ALPHA,operation:ct.ADD}}}]}};this.#ze=t.createRenderPipeline(r)}return this.#ze}}!function(e,t){void 0===t&&(t={});var r=t.insertAt;if("undefined"!=typeof document){var n=document.head||document.getElementsByTagName("head")[0],i=document.createElement("style");i.type="text/css","top"===r&&n.firstChild?n.insertBefore(i,n.firstChild):n.appendChild(i),i.styleSheet?i.styleSheet.cssText=e:i.appendChild(document.createTextNode(e))}}(".RedGPUDebugPanel{background:rgba(0,0,0,.8);bottom:0;color:#fff;font-size:11px;left:0;line-height:1;max-height:100%;min-width:250px;overflow-y:auto;position:fixed;transform:translateZ(0);will-change:transform;z-index:2}.RedGPUDebugPanel::-webkit-scrollbar{width:6px}.RedGPUDebugPanel::-webkit-scrollbar-track{background:#000}.RedGPUDebugPanel::-webkit-scrollbar-thumb{background:#333}.RedGPUDebugPanel::-webkit-scrollbar-thumb:hover{background:#444}.debug-group{line-height:1.4;padding:10px;b{color:#fdb48d;font-weight:700}}.debug-sub-group{background:linear-gradient(90deg,hsla(0,0%,100%,.1),rgba(0,0,0,.01));border:1px solid hsla(0,0%,100%,.16);border-radius:6px;box-shadow:0 0 10px rgba(0,0,0,.16);line-height:1.4;margin:8px 0;padding:6px 10px;b{color:#fdb48d;font-weight:700}}.debug-sub-group-title{color:#e3b096}.debug-item{align-items:center;color:#ccc;display:flex;font-weight:400;gap:10px;justify-content:space-between;transform:translateZ(0);width:100%;will-change:transform;b{color:#fdb48d;font-weight:700}}.boolean-true{background:green}.boolean-false,.boolean-true{border-radius:2px;line-height:1;margin:2px 0;padding:2px 4px}.boolean-false{background:red}.debug-folder{background:rgba(0,0,0,.5);border-bottom:1px solid hsla(0,0%,100%,.05);display:flex;flex-direction:column;width:100%}.debug-folder-title{align-items:center;background:linear-gradient(0deg,rgba(0,0,0,.95),hsla(0,0%,100%,.055));border-bottom:1px solid hsla(0,0%,100%,.025);border-top:1px solid hsla(0,0%,100%,.05);cursor:pointer;display:flex;font-size:12px;justify-content:space-between;line-height:1;padding:10px 8px;width:100%;b{color:#fdb48d;font-size:11px;font-weight:700}}.debug-item-title{color:#888}.debug-item-cache-key,.debug-item-title{font-weight:500;max-width:250px;overflow:hidden;text-overflow:ellipsis;text-shadow:1px 1px 0 rgba(0,0,0,.3)}.debug-item-cache-key{color:#fff;white-space:nowrap}.div-line{background:hsla(0,0%,100%,.06);border-bottom:1px solid transparent;height:1px;margin:10px 0;width:100%}.root-padding{padding:6px;width:100%}.color-box{border:1px solid hsla(0,0%,100%,.2);border-radius:4px;margin:2px;padding:3px}");const createDebugTitle=e=>`<div>${e}</div>`,makeColorDebug=(e,t)=>`\n<div class='debug-item'>\n\x3c!--\t<span class='debug-item-title'>${e}</span> --\x3e\n\t<span class='debug-item-title'></span> \n\t<div style="border:1px solid rgba(255,255,255,0.2);border-radius:4px;background:rgba(${t.rgba});padding:3px;margin:2px">${t.rgba}\n\t</div>\n</div>\n`,makeBooleanDebug=(e,t)=>`<span class="${t?"boolean-true":"boolean-false"}">${t?"true":"false"}</span>`,getDebugFormatValue=e=>"boolean"==typeof e?e.toString():"number"==typeof e?e.toLocaleString():e,updateDebugItemValue=(e,t,r,n,i="")=>{const s=e.querySelector(`.${t}`);if(!s)return;const a=`${getDebugFormatValue(r)}${i}`;s.innerHTML!==a&&(s.innerHTML=a,n&&(s.style.background=r?"green":"rgba(255,255,255,0.1)"))};let Cn=class{dom;#$o;#Xo=!1;constructor(e){this.#$o=e,this.dom=document.createElement("div"),this.dom.innerHTML=`<div class="debug-folder">\t<div class="debug-folder-title" style="display:flex;align-items:center;justify-content:space-between;cursor:pointer;">${createDebugTitle(`${e} Num:<span class="totalCount"></span> (<b class="targetVideoMemorySize"></b>)`)}<div class="onoff">${this.#Xo?"close":"open"}</div></div><div class="item-container" style="display:none"></div></div>\n`;const t=this.dom.querySelector(".debug-folder"),r=this.dom.querySelector(".item-container");t.addEventListener("click",(()=>{this.openYn=!this.openYn,r.style.display=this.#Xo?"":"none"}))}get openYn(){return this.#Xo}set openYn(e){this.#Xo=e,this.dom.querySelector(".onoff").innerHTML=this.openYn?"close":"open"}update(e,t){const{resourceManager:r}=t,n=r[`managed${this.#$o}State`],{table:i,videoMemory:s,length:a}=n;let o;switch(e.totalUsedVideoMemory+=s,updateDebugItemValue(this.dom,"totalCount",a),updateDebugItemValue(this.dom,"targetVideoMemorySize",formatBytes(s)),this.#$o){case"VertexBuffer":if(o=ResourceStateVertexBuffer,o){const{dirtyList:e}=o;e.length&&(this.#jo(e),e.length=0)}break;case"IndexBuffer":if(o=ResourceStateIndexBuffer,o){const{dirtyList:e}=o;e.length&&(this.#jo(e),e.length=0)}break;case"UniformBuffer":o=ResourceStateUniformBuffer,this.#jo(Object.values(i));break;case"StorageBuffer":o=ResourceStateStorageBuffer,this.#jo(Object.values(i))}}#jo(e){const t=this.dom.querySelector(".item-container"),r=new Set,n=this.#$o,i=new Map;t.querySelectorAll(".debug-group").forEach((e=>{const t=e.className.split(" ")[1].replace(`${n}_`,"");r.add(t),i.set(t,e)})),e.map(((e,s)=>{const{useNum:a,buffer:o}=e,{uuid:u,size:l,name:c}=o,h=`${n}_${u}`;let d=i.get(u);d?r.delete(u):(d=document.createElement("div"),d.className=`debug-group ${h}`,d.innerHTML=`<div class='debug-item'><div><div class='debug-item-title'><span style="white-space:nowrap">${s} <span class="name"></span></span></div><div style="font-size:10px">${u}</div></div><div style="display:flex;flex-direction:column;align-items:center;gap:4px;width:50px"><span class='useNum' style="padding:2px 4px;border-radius:4px;width:100%;text-align:center"></span><span style="white-space:nowrap"><b class="videoMemorySize"></b></span></div></div>`,t.appendChild(d)),updateDebugItemValue(d,"name",c),updateDebugItemValue(d,"useNum",a,!0),updateDebugItemValue(d,"videoMemorySize",formatBytes(l))}));for(let e of r)i.get(e).remove()}};class DebugBufferList{debugStatisticsDomService;constructor(e){this.debugStatisticsDomService=new Cn(e)}get dom(){return this.debugStatisticsDomService.dom}update(e,t){this.debugStatisticsDomService.update(e,t)}}class ADebugItem{debugStatisticsDomService;constructor(){}get dom(){return this.debugStatisticsDomService.dom}update(e,t,r){this.debugStatisticsDomService.update(e,t)}}class ADebugStatisticsDomService{dom;#Xo=!1;constructor(){}get openYn(){return this.#Xo}set openYn(e){this.#Xo=e,this.dom.querySelector(".onoff").innerHTML=this.openYn?"close":"open"}init(e,t=!1){this.#Xo=t,this.dom=document.createElement("div"),this.dom.innerHTML=`<div class="debug-folder">\t<div class="debug-folder-title">${e}<div class="onoff">${this.openYn?"close":"open"}</div></div><div class="item-container" style="display:${t?"":"none"}"></div></div>\n`;const r=this.dom.querySelector(".debug-folder-title"),n=this.dom.querySelector(".item-container");r.addEventListener("click",(e=>{this.openYn=!this.openYn,n.style.display=this.openYn?"":"none"}))}update(e,t){}}const Ln=["useMSAA","alphaMode","renderScale"];let Bn=class extends ADebugStatisticsDomService{constructor(){super(),this.init(`${createDebugTitle("RedGPUContext")}`,!0),this.#jo()}update(e,t){Ln.forEach((e=>this.#Yo(t,e))),this.#Zo(t)}#jo(){const e=this.dom.querySelector(".item-container"),t=['<div class="debug-group">',...Ln.map((e=>this.#qo(e))),this.#qo("width_height"),this.#qo("pixelRectArray"),this.#qo("backgroundColor"),"</div>"];e.innerHTML=t.join("")}#qo(e){return`<div class='debug-item'>${e}<span class='debug-item-title redGPUContext_${e}'/></div>`}#Yo(e,t){const r=e[t];updateDebugItemValue(this.dom,`redGPUContext_${t}`,"useMSAA"===t?makeBooleanDebug(0,r):getDebugFormatValue(r))}#Zo(e){const{sizeManager:t,width:r,height:n,backgroundColor:i}=e,{pixelRectArray:s}=t;updateDebugItemValue(this.dom,"redGPUContext_width_height",`${r},${n}`),updateDebugItemValue(this.dom,"redGPUContext_pixelRectArray",s),updateDebugItemValue(this.dom,"redGPUContext_backgroundColor",makeColorDebug("backgroundColor",i))}};class DebugRedGPUContext extends ADebugItem{constructor(){super(),this.debugStatisticsDomService=new Bn}}let In=class extends ADebugStatisticsDomService{#Wo;constructor(e){super(),this.#Wo=e,this.init(`${createDebugTitle((e?"CubeTexture":"BitmapTexture")+' Num:<span class="totalCount"></span> (<b class="targetVideoMemorySize"></b>)')}`)}update(e,t){const{resourceManager:r}=t,{managedBitmapTextureState:n,managedCubeTextureState:i}=r,{table:s,videoMemory:a,length:o}=this.#Wo?i:n;e.totalUsedVideoMemory+=a;const u=Object.values(s);updateDebugItemValue(this.dom,"totalCount",o),updateDebugItemValue(this.dom,"targetVideoMemorySize",formatBytes(a)),this.#jo(u)}getTargetSrc(e){if(e instanceof ResourceStateBitmapTexture){const{src:t}=e;return t?t.startsWith("data:")?"base64 texture":t:"null"}{const{srcList:t}=e;return`${t[0]}...`}}getUpdatedTdom(e,t,r,n,i,s){return e||((e=document.createElement("div")).className=`debug-group ${r}`,e.innerHTML=`<div class='debug-item'><div><div class='debug-item-title'>${n} <span class="targetSrc">${i}</span></div> <div class='debug-item-cache-key'>cacheKey:<span class="cacheKey">Place holder for cacheKey</span></div><div>mipLevelCount:<span class="mipLevelCount"></span>/useMipmap:<span class="useMipmap"></span></div><div>width:<span class="width"></span>/height:<span class="height"></span></div></div><div style="display:flex;flex-direction:column;align-items:center;gap:4px;width:50px"><span class='useNum' style="padding:2px 4px;border-radius:4px;width:100%;text-align:center"></span><span><b class="videoMemorySize"></b></span></div></div><div style="font-size:10px">${s}</div>`,t.appendChild(e)),e}updateDebugItems(e,t,r,n,i,s,a,o,u){updateDebugItemValue(e,"mipLevelCount",t),updateDebugItemValue(e,"useMipmap",r),updateDebugItemValue(e,"width",n),updateDebugItemValue(e,"height",i),updateDebugItemValue(e,"useNum",s,!0),updateDebugItemValue(e,"cacheKey",a),updateDebugItemValue(e,"targetSrc",o),updateDebugItemValue(e,"videoMemorySize",formatBytes(u))}#jo(e){const t=this.dom.querySelector(".item-container"),r=new Set,n=this.#Wo?"cube_texture":"bitmap_texture";t.querySelectorAll(".debug-group").forEach((e=>{const t=e.className.split(" ")[1].replace(`${n}_`,"");r.add(t)})),e.map(((e,i)=>{const{useNum:s,cacheKey:a,texture:o}=e;let u=this.getTargetSrc(e);const{mipLevelCount:l,useMipmap:c,gpuTexture:h,uuid:d,videoMemorySize:m}=o,{width:p,height:f}=h||{},g=`${n}_${o.uuid}`;let _=t.querySelector(`.${g}`);_=this.getUpdatedTdom(_,t,g,i,u,d),r.delete(o.uuid),this.updateDebugItems(_,l,c,p,f,s,a,u,m)}));for(let e of r)t.querySelector(`.${n}_${e}`).remove()}};class DebugTextureList extends ADebugItem{constructor(e=!1){super(),this.debugStatisticsDomService=new In(e)}}const Un=["totalNum3DGroups","totalNum3DObjects","totalNumInstances","totalNumDrawCalls","totalNumTriangles","totalNumPoints","totalUsedVideoMemory"];let An=class{dom;constructor(){this.dom=document.createElement("div"),this.#Jo()}update(e){Un.forEach((t=>{const r=e[t],n="totalUsedVideoMemory"===t?`<b>${formatBytes(r)}</b>`:r;updateDebugItemValue(this.dom,t,n)}))}#Jo(){const e=this.#jo();this.dom.innerHTML=`<div class="debug-group">${createDebugTitle("Total State")}<div>${e}</div> </div>`}#jo(){return Un.map((e=>"totalUsedVideoMemory"===e?`<div class='debug-item'>${e}<span class='debug-item-title'/><b class="${e}"></b></div>`:`<div class='debug-item'>${e}<span class='debug-item-title ${e}'/></div>`)).join("")}};class DebugTotalState extends ADebugItem{constructor(){super(),this.debugStatisticsDomService=new An}}const Dn=["usedVideoMemory","viewRenderTime","num3DGroups","num3DObjects","numInstances","numDrawCalls","numTriangles","numPoints"],Nn={viewRenderTime:"ms"},On={camera:"camera.name",scene:"scene.name",useBackgroundColor:"scene.useBackgroundColor",backgroundColor:"scene.backgroundColor",x_y:"x,y",width_height:"width,height"};let Gn=class extends ADebugStatisticsDomService{#Qo=0;constructor(){super(),this.init(`${createDebugTitle("ViewList")}`,!0)}update(e,t){const{viewList:r,numViews:n}=t;this.#Qo!==n&&(this.#eu(r),this.#Qo=n),r.forEach(((t,r)=>{Dn.forEach((n=>this.#Yo(t,r,n,e))),this.#Zo(t,r)}))}#qo(e,t){return`<div class='debug-item'>${On[t]||t}<span class='debug-item-title view${e}_${t}'/></div>`}#eu(e){const t=this.dom.querySelector(".item-container"),r=e.map(((e,t)=>{const{name:r}=e,n=Dn.map((e=>this.#qo(t,e)));return n.push('<div class="debug-sub-group">',this.#qo(t,"x_y"),this.#qo(t,"width_height"),this.#qo(t,"pixelRectArray"),this.#qo(t,"camera"),this.#qo(t,"scene"),this.#qo(t,"useBackgroundColor"),this.#qo(t,"backgroundColor"),"</div>"),`${createDebugTitle(`<div class="debug-sub-group-title">${r}</div>`)}${n.join("")}`}));return t.innerHTML=`<div class="debug-group">${r.join('<div class="div-line"></div>')}</div>`}#Yo(e,t,r,n){const{debugViewRenderState:i}=e,s=`total${r.charAt(0).toUpperCase()}${r.substring(1)}`,a=i[r],o="usedVideoMemory"===r?`<b>${formatBytes(a)}</b>`:a,u=Nn[r];n[s]+=a,updateDebugItemValue(this.dom,`view${t}_${r}`,o,!1,u)}#Zo(e,t){const{debugViewRenderState:r,rawCamera:n,scene:i}=e,{backgroundColor:s,useBackgroundColor:a}=i,{viewportSize:o}=r,{pixelRectArray:u,x:l,y:c,width:h,height:d}=o;updateDebugItemValue(this.dom,`view${t}_x_y`,`${l},${c}`),updateDebugItemValue(this.dom,`view${t}_width_height`,`${h},${d}`),updateDebugItemValue(this.dom,`view${t}_pixelRectArray`,u),updateDebugItemValue(this.dom,`view${t}_useBackgroundColor`,makeBooleanDebug(0,a)),updateDebugItemValue(this.dom,`view${t}_backgroundColor`,makeColorDebug("backgroundColor",s)),updateDebugItemValue(this.dom,`view${t}_camera`,n.name),updateDebugItemValue(this.dom,`view${t}_scene`,i.name)}};class DebugViewList extends ADebugItem{constructor(){super(),this.debugStatisticsDomService=new Gn}}class DebugStatisticsDomService{dom;constructor(){this.dom=document.createElement("div"),this.dom.style.cssText="z-index:1;position:sticky;top:0;background:#000;border-bottom:1px solid rgba(255,255,255,0.06);box-shadow:0 10px 10px rgba(0,0,0,0.5)",this.#Jo()}update(e,t,r){const n={elapsedSeconds:e,currentFps:t,averageFps:r};Object.entries(n).forEach((([e,t])=>this.#tu(e,t)))}#Jo(){this.dom.innerHTML='<div class="debug-group" ><div class=\'debug-item\'><span class=\'debug-item-title\'>Frame</span><span style="text-align:right"><div class="elapsedSeconds">elapsedSeconds</div><div class="currentFps">currentFps</div><div style="color:#fff" class="averageFps">averageFps</div></span></div></div>'}#tu(e,t){const r=this.dom.querySelector(`.${e}`);if(r){const e=t.toLocaleString();r.innerHTML!==e&&(r.innerHTML=e)}}}class Fps extends ADebugItem{#ru;#nu;#iu=0;#su=0;constructor(){super(),this.debugStatisticsDomService=new DebugStatisticsDomService,this.#nu=performance.now()}update(e,t,r){this.#au(r);const n=this.#ou(),{elapsedSeconds:i,currentFps:s,averageFps:a}=n;this.debugStatisticsDomService.update(`${i.toLocaleString()}ms`,`${s.toLocaleString()} fps`,`AVG:${a} fps`)}#au(e){this.#ru=e-this.#nu||16,this.#nu=e,this.#iu++}#ou(){const e=1/(this.#ru/1e3),t=Math.round(e);this.#su+=e;return{currentFps:t,averageFps:Math.round(this.#su/this.#iu),elapsedSeconds:this.#ru}}}class DebugRender{fps;debugTotalState;debugViewList;debugRedGPUContext;debugBitmapTextureList;debugCubeTextureList;debugIndexBufferList;debugVertexBufferList;debugUniformBufferList;debugStorageBufferList;totalNum3DGroups;totalNum3DObjects;totalNumDrawCalls;totalNumInstances;totalNumTriangles;totalNumPoints;totalUsedVideoMemory;#uu;constructor(){this.fps=new Fps,this.debugTotalState=new DebugTotalState,this.debugRedGPUContext=new DebugRedGPUContext,this.debugViewList=new DebugViewList,this.debugBitmapTextureList=new DebugTextureList,this.debugCubeTextureList=new DebugTextureList(!0),this.debugIndexBufferList=new DebugBufferList("IndexBuffer"),this.debugVertexBufferList=new DebugBufferList("VertexBuffer"),this.debugUniformBufferList=new DebugBufferList("UniformBuffer"),this.debugStorageBufferList=new DebugBufferList("StorageBuffer"),this.#lu()}render(e,t){e.useDebugPanel?(this.#cu(),this.fps.update(this,e,t),this.debugRedGPUContext.update(this,e,t),this.debugViewList.update(this,e,t),this.debugBitmapTextureList.update(this,e,t),this.debugCubeTextureList.update(this,e,t),this.debugIndexBufferList.update(this,e),this.debugVertexBufferList.update(this,e),this.debugUniformBufferList.update(this,e),this.debugStorageBufferList.update(this,e),this.debugTotalState.update(this,e,t)):this.#hu(),this.#lu()}#lu(){this.totalNum3DGroups=0,this.totalNum3DObjects=0,this.totalNumInstances=0,this.totalNumDrawCalls=0,this.totalNumTriangles=0,this.totalNumPoints=0,this.totalUsedVideoMemory=0}#cu(){this.#uu||(this.#uu=document.createElement("div"),this.#uu.className="RedGPUDebugPanel",document.body.appendChild(this.#uu),[this.fps.debugStatisticsDomService,this.debugTotalState.debugStatisticsDomService,this.debugRedGPUContext.debugStatisticsDomService,this.debugViewList.debugStatisticsDomService,this.debugVertexBufferList.debugStatisticsDomService,this.debugIndexBufferList.debugStatisticsDomService,this.debugUniformBufferList.debugStatisticsDomService,this.debugStorageBufferList.debugStatisticsDomService,this.debugBitmapTextureList.debugStatisticsDomService,this.debugCubeTextureList.debugStatisticsDomService].forEach((e=>this.#uu.appendChild(e.dom))))}#hu(){this.#uu&&(this.#uu.remove(),this.#uu=null)}}Object.freeze(DebugRender);const renderListForLayer=(e,t,r="pipeline")=>{let n=0;const i=e.length,{currentRenderPassEncoder:s}=t;for(;n<i;n++){const i=e[n];if(i.gpuRenderInfo){const e=i._geometry,n=i._material;e?t.num3DObjects++:t.num3DGroups++;const{gpuRenderInfo:a}=i,{vertexUniformBindGroup:o}=a;if(e&&a[r]){s.setPipeline(a[r]);const{gpuBuffer:u}=e.vertexBuffer,{fragmentUniformBindGroup:l}=n.gpuRenderInfo;if(t.prevVertexGpuBuffer!==u&&(s.setVertexBuffer(0,u),t.prevVertexGpuBuffer=u,i.particleBuffers&&(i.particleBuffers.forEach(((e,t)=>{s.setVertexBuffer(t+1,e)})),t.prevVertexGpuBuffer=null)),s.setBindGroup(1,o),t.prevFragmentUniformBindGroup!==l&&(s.setBindGroup(2,l),t.prevFragmentUniformBindGroup=l),t.numDrawCalls++,e.indexBuffer){const{indexBuffer:r}=e,{indexNum:n,triangleCount:a,gpuBuffer:o}=r;s.setIndexBuffer(o,"uint32"),i.particleBuffers?s.drawIndexed(n,i.particleNum,0,0,0):s.drawIndexed(n,1,0,0,0),t.numTriangles+=a,t.numPoints+=n}else{const{vertexBuffer:r}=e,{vertexCount:n,triangleCount:i}=r;s.draw(n,1,0,0),t.numTriangles+=i,t.numPoints+=n}}}}t.prevVertexGpuBuffer=null,t.prevFragmentUniformBindGroup=null,t.prevVertexGpuBuffer=null},renderList=(e,t)=>{let r=0;const n=e.length;for(;r<n;r++)e[r].render(t);t.prevVertexGpuBuffer=null,t.prevFragmentUniformBindGroup=null,t.prevVertexGpuBuffer=null};class Renderer{#du;#mu;#pu=new DebugRender;constructor(){}renderFrame(e,t){this.#mu||(this.#mu=new FinalRender);const r=[];{let n=0;const i=e.viewList.length;for(;n<i;n++){const i=e.viewList[n];r.push(this.renderView(i,t))}}this.#mu.render(e,r);{let t=0;const r=e.viewList.length;for(;t<r;t++)e.viewList[t].postEffectManager.clear()}}start(e,t){cancelAnimationFrame(e.currentRequestAnimationFrame);const HD_render=r=>{t?.(r),this.renderFrame(e,r),this.#pu.render(e,r),e.currentRequestAnimationFrame=requestAnimationFrame(HD_render)};e.currentRequestAnimationFrame=requestAnimationFrame(HD_render)}stop(e){cancelAnimationFrame(e.currentRequestAnimationFrame)}renderView(e,t){const{redGPUContext:r,camera:n,scene:i,pickingManager:s,pixelRectObject:a,axis:o,grid:u,debugViewRenderState:l}=e,{shadowManager:c}=i,{colorAttachment:h,depthStencilAttachment:d}=this.#fu(e),m={colorAttachments:[h],depthStencilAttachment:d};n.update?.(e);const p=r.gpuDevice.createCommandEncoder();if(e.debugViewRenderState.reset(null,t),a.width&&a.height){if(c.shadowDepthGPUTextureView){const t={colorAttachments:[],depthStencilAttachment:{view:c.shadowDepthGPUTextureView,depthClearValue:1,depthLoadOp:Ge.CLEAR,depthStoreOp:Ve.STORE}},r=p.beginRenderPass(t);this.#gu(e,r,!0,!1),((e,t)=>{const{debugViewRenderState:r,scene:n}=e;r.currentRenderPassEncoder=t;const{castingList:i}=n.shadowManager;renderListForLayer(i,r,"shadowPipeline")})(e,r),r.end(),c.resetCastingList()}{const t=p.beginRenderPass(m);this.#gu(e,t,!1,!0),((e,t)=>{const{debugViewRenderState:r,skybox:n,scene:i}=e;r.currentRenderPassEncoder=t;const{instanceMeshLayer:s}=r,{children:a}=i;n&&n.render(r),renderList(a,r),renderList(s,r)})(e,t),o&&o.render(l),u&&u.render(l),((e,t)=>{const{debugViewRenderState:r,rawCamera:n}=e;r.currentRenderPassEncoder=t;const{alphaLayer:i,transparentLayer:s,particleLayer:a}=r;renderListForLayer(i,r);const{x:o,y:u,z:l}=n;sortTransparentObjects({x:o,y:u,z:l},s),renderListForLayer(s,r),renderListForLayer(a,r)})(e,t),t.end()}if(e.debugViewRenderState.render2PathLayer.length){const{mipmapGenerator:t}=r.resourceManager;let n=e.viewRenderTextureManager.render2PathTexture;p.copyTextureToTexture({texture:e.viewRenderTextureManager.colorResolveTexture},{texture:n},{width:e.pixelRectObject.width,height:e.pixelRectObject.height,depthOrArrayLayers:1}),t.generateMipmap(n,e.viewRenderTextureManager.render2PathTextureDescriptor);const i=p.beginRenderPass({colorAttachments:[{...h,loadOp:"load"}],depthStencilAttachment:{...d,depthLoadOp:Ge.LOAD}});this.#gu(e,i,!1,!0,n),((e,t)=>{const{debugViewRenderState:r}=e;r.currentRenderPassEncoder=t;const{render2PathLayer:n}=r;renderListForLayer(n,r)})(e,i),i.end()}if(e.postEffectManager.effectList.length&&(m.colorAttachments[0].postEffectView=e.postEffectManager.render()),s){s.checkTexture(e);const t={colorAttachments:[{view:s.pickingGPUTextureView,clearValue:{r:0,g:0,b:0,a:0},loadOp:Ge.CLEAR,storeOp:Ve.STORE}],depthStencilAttachment:{view:s.pickingDepthGPUTextureView,depthClearValue:1,depthLoadOp:Ge.CLEAR,depthStoreOp:Ve.STORE}},r=p.beginRenderPass(t);this.#gu(e,r,!1,!1),((e,t)=>{const{debugViewRenderState:r,pickingManager:n}=e;r.currentRenderPassEncoder=t;const{castingList:i}=n;renderListForLayer(i,r,"pickingPipeline")})(e,r),r.end()}}return r.gpuDevice.queue.submit([p.finish()]),e.debugViewRenderState.viewRenderTime=performance.now()-e.debugViewRenderState.startTime,s.checkEvents(e,t),m}#fu(e){const{scene:t,redGPUContext:r,viewRenderTextureManager:n}=e,{depthTextureView:i,colorTextureView:s,colorResolveTextureView:a}=n,{useBackgroundColor:o,backgroundColor:u}=t,l=u.rgbaNormal,c={view:s,clearValue:o?{r:l[0]*l[3],g:l[1]*l[3],b:l[2]*l[3],a:l[3]}:{r:0,g:0,b:0,a:0},loadOp:Ge.CLEAR,storeOp:Ve.STORE};r.useMSAA&&(c.resolveTarget=a);return{colorAttachment:c,depthStencilAttachment:{view:i,depthClearValue:1,depthLoadOp:Ge.CLEAR,depthStoreOp:Ve.STORE}}}#gu(e,t,r=!1,n=!0,i=null){const{inverseProjectionMatrix:s,pixelRectObject:a,projectionMatrix:o,rawCamera:u,redGPUContext:l,scene:c}=e,{gpuDevice:h}=l,{modelMatrix:d,position:m}=u,p=e.systemUniform_Vertex_StructInfo,f=e.systemUniform_Vertex_UniformBuffer.gpuBuffer,{shadowManager:g,lightManager:_}=c,x=u instanceof Camera2D;if(r){const e=g.directionalLightShadowDepthTextureSize,r=g.directionalLightShadowDepthTextureSize;t.setViewport(0,0,e,r,0,1),t.setScissorRect(0,0,e,r)}else{const{width:e,height:r}=a;this.#du&&this.#du.width===e&&this.#du.height===r||(t.setViewport(0,0,e,r,0,1),t.setScissorRect(0,0,e,r),this.#du={width:e,height:r})}_.updateViewSystemUniforms(e),g.updateViewSystemUniforms(l),e.update(e,r,n,i),t.setBindGroup(0,e.systemUniform_Vertex_UniformBindGroup),[{key:"projectionMatrix",value:o},{key:"projectionCameraMatrix",value:multiply$5(Vn,o,d)},{key:"inverseProjectionMatrix",value:s},{key:"resolution",value:[e.pixelRectObject.width,e.pixelRectObject.height]}].forEach((({key:e,value:t})=>{h.queue.writeBuffer(f,p.members[e].uniformOffset,new p.members[e].View(t))})),[{key:"cameraMatrix",value:d},{key:"cameraPosition",value:m},{key:"nearClipping",value:[x?0:u.nearClipping]},{key:"farClipping",value:[x?0:u.farClipping]}].forEach((({key:e,value:t})=>{h.queue.writeBuffer(f,p.members.camera.members[e].uniformOffset,new p.members.camera.members[e].View(t))}))}}let Vn=create$5();var Fn=Object.freeze({__proto__:null,isHexColor:isHexColor,isUint:isUint,validateNumber:validateNumber,validateNumberRange:validateNumberRange,validatePositiveNumberRange:validatePositiveNumberRange,validateRedGPUContext:validateRedGPUContext,validateUintRange:validateUintRange});class MeshInfo_OBJ{name;groupName;materialKey;index;position;resultPosition;resultNormal;resultUV;resultInterleave;use;childrenInfo;ableUV;ableNormal;ableLight;mesh;constructor(e,t){this.name=e,this.groupName=t,this.index=[],this.position=[],this.resultPosition=[],this.resultNormal=[],this.resultUV=[],this.resultInterleave=[],this.use=!0,this.childrenInfo={}}createVertexBuffer(e,t){let r={};return this.resultPosition.length&&(r.aVertexPosition=InterleaveType.float32x3),this.resultNormal.length&&(r.aVertexNormal=InterleaveType.float32x3),this.resultUV.length&&(r.aTexcoord=InterleaveType.float32x2),new VertexBuffer(e,new Float32Array(this.resultInterleave.length?this.resultInterleave:this.resultPosition),new InterleavedStruct(r,`InterleavedStruct_${t}}`),void 0,`VertexBuffer_${t}`)}createBufferIndex(e,t){if(this.index.length)return new IndexBuffer(e,this.index,void 0,`IndexBuffer_${t}`)}createColorMaterial(e){return this.resultUV.length&&this.resultNormal.length||this.resultNormal.length?new ColorMaterial(e,"#00ff00"):new ColorMaterial(e,"#0000ff")}}Object.freeze(MeshInfo_OBJ);class TotalPointInfo_OBJ{position=[];normal=[];uv=[];points=[];normalPoints=[];uvPoints=[];constructor(){}}Object.freeze(TotalPointInfo_OBJ);class OBJMTLLoader{complete;parseData;#_u;#xu;#vu;constructor(e,t,r){this.#_u=getFilePath(t),this.#xu=getFileName(t),this.#vu=t,this.#Tu(t,r)}get path(){return this.#_u}get fileName(){return this.#xu}get url(){return this.#vu}#Tu(e,t){fetch(e,{method:"GET",headers:{"Content-Type":"application/x-www-form-urlencoded;charset=UTF-8"}}).then((e=>{if(!e.ok)throw new Error(`HTTP ! :${e.status}`);return e.text()})).then((e=>{this.complete=!0,this.parseData=function(e,t){let r;const n={},i={single:["newmtl","Ns","Ni","d","illum"],multi:["Ka","Kd","Ks"],maps:["map_Kd","map_Ns","map_bump"]};return(t=t.replace(/^\#[\s\S]+?\n/g,"")).split("\n").forEach((t=>{for(const s in i)for(const a of i[s])if(new RegExp(`^(${a} )`).test(t))switch(s){case"single":if("newmtl"===a){const e=t.replace("newmtl ","").trim();r={name:e},n[e]=r}else r[a]=+t.replace(`${a} `,"").trim();break;case"multi":r[a]=t.replace(`${a} `,"").split(" ");break;case"maps":r[a]=e.path+t.replace(`${a} `,"").trim()}})),n}(this,e),t?.(this.parseData)})).catch((e=>{this.complete=!0,this.parseData={},t?.(this.parseData)}))}}Object.freeze(OBJMTLLoader);const Hn=/^o/,zn=/v( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/,Kn=/f\s+(([\d]{1,}[\s]?){3,})+/,$n=/f\s+((([\d]{1,}\/[\d]{1,}[\s]?){3,})+)/,Xn=/f\s+((([\d]{1,}\/[\d]{1,}\/[\d]{1,}[\s]?){3,})+)/,jn=/f\s+((([\d]{1,}\/\/[\d]{1,}[\s]?){3,})+)/;let Yn,Zn;function processMaterialLibrary(e,t,r,n,i){i=new OBJMTLLoader(r,`${t.path}${e.split(" ")[1]}`,(e=>{t.mtlLoader=e,t.modelParsingComplete&&(((e,t,r)=>{let n,i,s,a;for(n in a={},t){let o,u;s=t[n];const{use:l,materialKey:c,mesh:h}=s,{ableLight:d,ableNormal:m}=s,{resultInterleave:p}=s;if(l&&p.length){let t,n,s;i=r.parseData[c],i&&(i.map_Kd?(a[i.map_Kd]?u=a[i.map_Kd]:(u=new BitmapTexture(e,i.map_Kd),a[i.map_Kd]=u),o=new BitmapMaterial(e,u)):i.Kd&&(t=255*i.Kd[0],n=255*i.Kd[1],s=255*i.Kd[2],o=new ColorMaterial(e,convertRgbToHex(t,n,s))),o&&(i.map_Ns&&(a[i.map_Ns]?u=a[i.map_Ns]:(u=new BitmapTexture(e,i.map_Ns),a[i.map_Ns]=u),o.specularTexture=u),i.map_bump&&(a[i.map_bump]?u=a[i.map_bump]:(u=new BitmapTexture(e,i.map_bump),a[i.map_bump]=u),o.normalTexture=u),void 0!==i.Ns&&(o.shininess=i.Ns),h.material=o))}}})(r,n,i),t.callback&&t.callback(t.result))})),t.mtlLoader=i}function processMaterialUsage(e,t,r){t[r].materialKey=e.split(" ").slice(1).join("").trim()}function processGroup(e,t,r,n){const i=e.split(" ").slice(1).join("").trim();t[r].use=!1;const s=new MeshInfo_OBJ(i,r);s.groupName=r,s.materialKey=i.replace(`${r}_`,""),s.position=Yn.position,n[i]=Yn=s,t[r].childrenInfo[i]=Yn}function processNewObject(e,t,r){const n=e.split(" ").slice(1).join("").trim(),i=new MeshInfo_OBJ(n,n);i.groupName=n,i.materialKey=n,t[n]=Yn=i,r[n]=Yn,Zn=n}function processVertexNormals(e,t,r){const n=e.split(" ");t.push(+n[1],+n[2],+n[3]),r[r.length]=[+n[1],+n[2],+n[3]]}function processTextureCoordinates(e,t,r){const n=e.split(" ");t.push(+n[1],1-n[2]),r[r.length]=[+n[1],1-n[2]]}function processVertex(e,t,r){const n=e.split(" ");t.push(+n[1],+n[2],+n[3]),Yn.position.push(+n[1],+n[2],+n[3]),r[r.length]=[+n[1],+n[2],+n[3]]}function processFaceVertexNormal(e,t,r,n,i){const s=3*(t.length+r.length);e.split(" ").slice(1,4).forEach((e=>{const[t,,r]=e.split("/").map((e=>Number(e)-1)),a=n[t],o=i[r],{index:u,resultInterleave:l}=Yn,{resultPosition:c,resultNormal:h,resultUV:d}=Yn;u.push(l.length/s),c.push(...a),h.push(...o),l.push(...a,...o)}))}function processFaceVertexTextureNormal(e,t,r,n,i,s,a){let o=e.split(" ").slice(1,5);if(4===o.length){let e=o[3];o[3]=o[0],o[4]=o[2],o[5]=e}o.forEach((e=>{const[o,u,l]=e.split("/").map(Number).map((e=>e-1)),c=i[o],h=a[u],d=s[l],m=(t.length?3:0)+(r.length?3:0)+(n.length?2:0),{index:p,resultInterleave:f}=Yn,{resultPosition:g,resultNormal:_,resultUV:x}=Yn;p.push(f.length/m),t.length&&(g.push(...c),f.push(...c)),r.length&&(_.push(...d),f.push(...d)),n.length&&(x.push(...h),f.push(...h))}))}function processFaceVertexTexture(e,t,r,n,i){e.split(" ").slice(1,4).forEach((e=>{const[s,a]=e.split("/").map(Number).map((e=>e-1)),o=n[s];let u;0!==i.length&&(u=i[a]);const l=(t.length?3:0)+(r.length?2:0);Yn.index.push(Yn.resultInterleave.length/l),t.length&&(Yn.resultPosition.push(...o),Yn.resultInterleave.push(...o)),r.length&&(Yn.resultUV.push(...u),Yn.resultInterleave.push(...u))}))}function processFaceVertex(e,t){let r=e.split(" ");Yn.resultInterleave=Yn.resultPosition=Yn.position,Yn.index.push(+r[1]-1,+r[2]-1,+r[3]-1),Yn.index.push(+r[1]-1,+r[3]-1,+r[4]-1)}const parserMesh_OBJ=(e,t,r)=>{for(let n in r){const i=r[n];let s;if(i.use){const t=i.createVertexBuffer(e,n),r=i.createBufferIndex(e,n),a=i.createColorMaterial(e);s=new Mesh(e,new Geometry(e,t,r),a),i.ableUV=Boolean(i.resultUV.length),i.ableNormal=Boolean(i.resultNormal.length),i.ableLight=i.ableUV&&i.ableNormal}else s=new Mesh(e);s.name=n,i.mesh=s,t.addChild(s),parserMesh_OBJ(e,s,i.childrenInfo)}},parserOBJ=(e,t,r)=>{const n=((e,t,r)=>{let n,i;const s=new TotalPointInfo_OBJ,{points:a,normalPoints:o,uvPoints:u}=s,{position:l,normal:c,uv:h}=s;let d,m;i={},n={};const p=r.length;for(d=0;d<p;d++)if(Hn.test(r[d])){m=!0;break}if(!m){const e="objModel"+createUUID();i[e]=Yn=new MeshInfo_OBJ(e,e),n[e]=Yn,Zn=e}const f=r.length;for(let s=0;s<f;s++){const d=r[s];d.startsWith("mtllib ")?processMaterialLibrary(d,t,e,n,void 0):d.startsWith("usemtl ")?processMaterialUsage(d,n,Zn):d.startsWith("g ")?processGroup(d,i,Zn,n):d.startsWith("o ")?processNewObject(d,i,n):d.startsWith("vn ")?processVertexNormals(d,c,o):d.startsWith("vt ")?processTextureCoordinates(d,h,u):zn.test(d)?processVertex(d,l,a):jn.test(d)?processFaceVertexNormal(d,l,c,a,o):Xn.test(d)?processFaceVertexTextureNormal(d,l,c,h,a,o,u):$n.test(d)?processFaceVertexTexture(d,l,h,a,u):Kn.test(d)&&processFaceVertex(d)}return{info:n,infoHierarchy:i}})(e,t,(r=r.replace(/^\#[\s\S]+?\n/g,"")).split("\n")),i=n.infoHierarchy;return parserMesh_OBJ(e,t.resultMesh,i),{...t,...n,parseInfoMaterial:t.mtlLoader}};class OBJLoader{modelParsingComplete=!1;resultMesh;result;callback;mtlLoader;#_u;#xu;#vu;constructor(e,t,r){validateRedGPUContext(e),t&&(fetch(t).then((e=>e.text())).then((t=>{this.result=parserOBJ(e,this,t),this.modelParsingComplete=!0,this.resultMesh=t,r&&(this.mtlLoader?this.mtlLoader.complete&&r(this.result):r(this.result))})).catch((e=>console.error("Error:",e))),this.#_u=getFilePath(t),this.#xu=getFileName(t),this.#vu=t,this.mtlLoader=null,this.callback=r,this.resultMesh=new Mesh(e),this.resultMesh.name="instanceOfOBJLoader_"+createUUID(),this.result=null)}get path(){return this.#_u}get fileName(){return this.#xu}get url(){return this.#vu}}Object.freeze(OBJLoader);class ASinglePassPostEffect{#yu;#bu;#Ba;#La;#qn;#Su;#Mu;#Ru=[];#wu=[];#_n=16;#xn=16;#vn=1;constructor(){}get storageInfo(){return this.#Mu}get uniformBuffer(){return this.#qn}get uniformInfo(){return this.#Su}get WORK_SIZE_X(){return this.#_n}set WORK_SIZE_X(e){this.#_n=e}get WORK_SIZE_Y(){return this.#xn}set WORK_SIZE_Y(e){this.#xn=e}get WORK_SIZE_Z(){return this.#vn}set WORK_SIZE_Z(e){this.#vn=e}get outputTextureView(){return this.#wu}getOutputTextureView(){return this.#wu[this.#wu.length-1]}clear(){this.#Ru&&(this.#Ru.forEach((e=>e.destroy())),this.#Ru.length=0,this.#wu.length=0)}init(e,t,r,n){const{resourceManager:i}=e;this.#yu=i.createGPUShaderModule(t,{code:r});const s=parseWGSL(r),a=s.storage,o=s.uniforms.uniforms;if(this.#Mu=a,o){this.#Su=o;const t=new ArrayBuffer(o.arrayBufferByteLength);this.#qn=new UniformBuffer(e,t,`${this.constructor.name}_UniformBuffer`)}this.#bu=n||e.resourceManager.getGPUBindGroupLayout(`${t}_BIND_GROUP_LAYOUT`)||e.resourceManager.createBindGroupLayout(`${t}_BIND_GROUP_LAYOUT`,getComputeBindGroupLayoutDescriptorFromShaderInfo(s,0))}execute(e,t,r){this.#La=e.createComputePipeline({layout:e.createPipelineLayout({bindGroupLayouts:[this.#bu]}),compute:{module:this.#yu,entryPoint:"main"}});const n=e.createCommandEncoder(),i=n.beginComputePass();i.setPipeline(this.#La),i.setBindGroup(0,this.#Ba),i.dispatchWorkgroups(Math.ceil(t/this.WORK_SIZE_X),Math.ceil(r/this.WORK_SIZE_Y)),i.end(),e.queue.submit([n.finish()])}render(e,t,r,...n){this.#Pu(e);const i=this.getOutputTextureView(),{redGPUContext:s}=e,{gpuDevice:a}=s,o=[];for(const e in this.#Mu){const t=this.#Mu[e],{binding:r,name:s}=t;o.push({binding:r,resource:"outputTexture"===s?i:n[r]})}return this.#qn&&o.push({binding:this.#Su.binding,resource:{buffer:this.#qn.gpuBuffer,offset:0,size:this.#qn.size}}),this.#Ba=a.createBindGroup({layout:this.#bu,entries:o}),this.execute(a,t,r),i}#Pu(e){const{redGPUContext:t,viewRenderTextureManager:r}=e,{colorTexture:n}=r,{gpuDevice:i}=t,{width:s,height:a}=n,o=i.createTexture({size:{width:s,height:a},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING});this.#Ru.push(o),this.#wu.push(o.createView())}}Object.freeze(ASinglePassPostEffect);class AMultiPassPostEffect extends ASinglePassPostEffect{#Eu=[];constructor(e){super(),this.#Eu.push(...e)}get passList(){return this.#Eu}clear(){this.#Eu.forEach((e=>e.clear()))}render(e,t,r,n){let i;return this.#Eu.forEach(((s,a)=>{a&&(n=i),i=s.render(e,t,r,n)})),i}}Object.freeze(AMultiPassPostEffect);const createPostEffectCode=(e,t,r="")=>{const{WORK_SIZE_X:n,WORK_SIZE_Y:i,WORK_SIZE_Z:s}=e;return`${r}@group(0) @binding(0) var sourceTexture:texture_storage_2d<rgba8unorm,read>;@group(0) @binding(1) var outputTexture:texture_storage_2d<rgba8unorm,write>;${r?"@group(0) @binding(2) var<uniform> uniforms:Uniforms;":""}@compute @workgroup_size(${n},${i},${s})fn main (@builtin(global_invocation_id) global_id:vec3<u32>,){${t}};`};Object.freeze(createPostEffectCode);class BrightnessContrast extends ASinglePassPostEffect{#ku=0;#Cu=0;constructor(e){super();const t=createPostEffectCode(this,"let index=vec2<u32>(global_id.xy );let dimensions:vec2<u32>=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let uv=\tvec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);var color:vec4<f32>=textureLoad(sourceTexture,index,);let brightness_value:f32=uniforms.brightness/255.0;let contrast_value:f32=uniforms.contrast/255.0;var tempColor:vec3<f32>;if ( contrast_value > 0.0 ) {tempColor=( color.rgb - 0.5 )/( 1.0 - contrast_value ) + 0.5;}else {tempColor=( color.rgb - 0.5 ) * ( 1.0 + contrast_value ) + 0.5;}color=vec4<f32>(tempColor + brightness_value,color.a);textureStore(outputTexture,index,color );","struct Uniforms {brightness:f32,contrast:f32};");this.init(e,"POST_EFFECT_BRIGHTNESS_CONTRAST",t)}get brightness(){return this.#ku}set brightness(e){validateNumberRange(e,-150,150),this.#ku=e,this.uniformBuffer.writeBuffer(this.uniformInfo.members.brightness,e)}get contrast(){return this.#Cu}set contrast(e){validateNumberRange(e,-50,100),this.#Cu=e,this.uniformBuffer.writeBuffer(this.uniformInfo.members.contrast,e)}}Object.freeze(BrightnessContrast);class Grayscale extends ASinglePassPostEffect{constructor(e){super();const t=createPostEffectCode(this,"let index=vec2<u32>(global_id.xy );let dimensions:vec2<u32>=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let uv=\tvec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);var color:vec4<f32>=textureLoad(sourceTexture,index,);let gray=(color.r + color.g + color.b)/3.0;textureStore(outputTexture,index,vec4<f32>( gray,gray,gray,1.0) );");this.init(e,"POST_EFFECT_GRAYSCALE",t)}}Object.freeze(Grayscale);class HueSaturation extends ASinglePassPostEffect{#Lu=0;#Bu=0;constructor(e){super();const t=createPostEffectCode(this,"let index=vec2<u32>(global_id.xy );let dimensions:vec2<u32>=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let uv=\tvec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);var color:vec4<f32>=textureLoad(sourceTexture,index,);let hue_value:f32=uniforms.hue/180.0;let saturation_value:f32=uniforms.saturation/100.0;let angle:f32=hue_value * 3.1415926535897932384626433832795;let s:f32=sin(angle);let c:f32=cos(angle);var weights:vec3<f32>=(vec3<f32>(2.0 * c,-sqrt(3.0) * s - c,sqrt(3.0) * s - c) + 1.0)/3.0;let len:f32=length(color.rgb);color=vec4<f32>(vec3<f32>(dot(color.rgb,weights.xyz),dot(color.rgb,weights.zxy),dot(color.rgb,weights.yzx)),color.a);let average:f32=(color.r + color.g + color.b)/3.0;if (saturation_value > 0.0) {color=vec4<f32>(color.rgb + (average - color.rgb) * (1.0 - 1.0/(1.001 - saturation_value)),color.a);} else {color=vec4<f32>(color.rgb + (average - color.rgb) * (-saturation_value),color.a);}textureStore(outputTexture,index,color );","struct Uniforms {hue:f32,saturation:f32};");this.init(e,"POST_EFFECT_HUE_SATURATION",t)}get hue(){return this.#Lu}set hue(e){validateNumberRange(e,-180,180),this.#Lu=e,this.uniformBuffer.writeBuffer(this.uniformInfo.members.hue,e)}get saturation(){return this.#Bu}set saturation(e){validateNumberRange(e,-100,100),this.#Bu=e,this.uniformBuffer.writeBuffer(this.uniformInfo.members.saturation,e)}}Object.freeze(HueSaturation);class Invert extends ASinglePassPostEffect{constructor(e){super();const t=createPostEffectCode(this,"let index=vec2<u32>(global_id.xy );let dimensions:vec2<u32>=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let uv=\tvec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);var color:vec4<f32>=textureLoad(sourceTexture,index,);color.r=1.0 - color.r;color.g=1.0 - color.g;color.b=1.0 - color.b;textureStore(outputTexture,index,color );");this.init(e,"POST_EFFECT_INVERT",t)}}Object.freeze(Invert);class Threshold extends ASinglePassPostEffect{#Iu=128;constructor(e){super();const t=createPostEffectCode(this,"let index=vec2<u32>(global_id.xy );let dimensions:vec2<u32>=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);var color:vec4<f32>=textureLoad(sourceTexture,index,);let threshold_value:f32=uniforms.threshold/255.0;var v=0.0;if( 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b >=threshold_value) {v=1.0;}color=vec4<f32>(v,v,v,color.a);textureStore(outputTexture,index,color );","struct Uniforms {threshold:f32};");this.init(e,"POST_EFFECT_THRESHOLD",t),this.threshold=this.#Iu}get threshold(){return this.#Iu}set threshold(e){validateNumberRange(e,1,255),this.#Iu=e,this.uniformBuffer.writeBuffer(this.uniformInfo.members.threshold,e)}}Object.freeze(Threshold);class BlurX extends ASinglePassPostEffect{#w=32;constructor(e){super();const t=createPostEffectCode(this,"let index=vec2<u32>(global_id.xy);let dimensions=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let size_value:f32=uniforms.size;var sum:vec4<f32>=vec4<f32>(0.0,0.0,0.0,0.0);var offset=random(global_id,0.0);var total=0.0;let loopSize=10.0;for (var t=-loopSize;t <=loopSize;t=t + 1.0) {var percent=(t + offset - 0.5)/loopSize;var weight=1.0 - abs(percent);var ix=clamp((f32(global_id.x) + f32(size_value * percent)),0.0,dimW - 1.0);let delta=vec2<i32>(i32(ix),i32(global_id.y));sum +=textureLoad(sourceTexture,delta).xyzw * weight;total +=weight;}sum/=total;textureStore(outputTexture,vec2<i32>(global_id.xy),sum);","struct Uniforms {size:f32,};fn random(id:vec3<u32>,delta:f32) -> f32 {let seed:u32=((id.x << 16) | (id.y & 0xFFFF)) ^ (id.z * 0x63641362);let t:vec3<f32>=vec3<f32>(f32(seed & 0xFF),f32((seed >> 8) & 0xFF),f32(seed >> 16));return delta + fract(sin(dot(t,vec3<f32>(12.9898,78.233,12.9898))) * 43758.5453);}");this.init(e,"POST_EFFECT_BLUR_X",t),this.size=this.#w}get size(){return this.#w}set size(e){validateNumberRange(e),this.#w=e,this.uniformBuffer.writeBuffer(this.uniformInfo.members.size,e)}}Object.freeze(BlurX);class BlurY extends ASinglePassPostEffect{#w=32;constructor(e){super();const t=createPostEffectCode(this,"let index=vec2<u32>(global_id.xy);let dimensions=textureDimensions(sourceTexture);let dimH=f32(dimensions.y);let size_value:f32=uniforms.size;var sum:vec4<f32>=vec4<f32>(0.0,0.0,0.0,0.0);var offset=random(global_id,0.0);var total=0.0;let loopSize=10.0;for (var t=-loopSize;t <=loopSize;t=t + 1.0) {var percent=(t + offset - 0.5)/loopSize;var weight=1.0 - abs(percent);var iy=clamp((f32(global_id.y) + f32(size_value * percent)),0.0,dimH - 1.0);let delta=vec2<i32>(i32(global_id.x),i32(iy));sum +=textureLoad(sourceTexture,delta).xyzw * weight;total +=weight;}sum/=total;textureStore(outputTexture,vec2<i32>(global_id.xy),sum);","struct Uniforms {size:f32,};fn random(id:vec3<u32>,delta:f32) -> f32 {let seed:u32=((id.x << 16) | (id.y & 0xFFFF)) ^ (id.z * 0x63641362);let t:vec3<f32>=vec3<f32>(f32(seed & 0xFF),f32((seed >> 8) & 0xFF),f32(seed >> 16));return delta + fract(sin(dot(t,vec3<f32>(12.9898,78.233,12.9898))) * 43758.5453);}");this.init(e,"POST_EFFECT_BLUR_Y",t),this.size=this.#w}get size(){return this.#w}set size(e){validateNumberRange(e),this.#w=e,this.uniformBuffer.writeBuffer(this.uniformInfo.members.size,e)}}Object.freeze(BlurY);class GaussianBlur extends AMultiPassPostEffect{#w=32;constructor(e){super([new BlurX(e),new BlurY(e)])}get size(){return this.#w}set size(e){this.#w=e,this.passList.forEach((t=>t.size=e))}}Object.freeze(GaussianBlur);class ZoomBlur extends ASinglePassPostEffect{#Uu=128;#vr=0;#Tr=0;constructor(e){super();const t=createPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let dimensionsVec=vec2<f32>(dimW,dimH);let amount=uniforms.amount/min(dimW,dimH);const loopSize=30.0;let offset=random(global_id,0.0);let center=vec2<f32>(dimW * 0.5 + uniforms.centerX,dimH * 0.5 + uniforms.centerY);let global_id_vec=vec2<f32>(f32(global_id.x),f32(global_id.y));let dir=(center - global_id_vec) * amount;var sum=vec4<f32>(0.0,0.0,0.0,0.0);var total=0.0;for (var t=-loopSize;t <=loopSize;t=t + 1.0) {var percent=1.0 - (t + offset - 0.5)/loopSize;var weight=3.0 * (percent - percent * percent);let deltaPercent=dir * percent;let delta=vec2<i32>(i32(clamp(global_id_vec.x + deltaPercent.x,0.0,dimW - 1.0)),i32(clamp(global_id_vec.y + deltaPercent.y,0.0,dimH - 1.0)));sum +=textureLoad(sourceTexture,delta).xyzw * weight;total +=weight;}textureStore(outputTexture,vec2<i32>(global_id.xy),sum/total);","struct Uniforms {amount:f32,centerX:f32,centerY:f32};fn random(id:vec3<u32>,delta:f32) -> f32 {let seed:u32=((id.x << 16) | (id.y & 0xFFFF)) ^ (id.z * 0x63641362);let t:vec3<f32>=vec3<f32>(f32(seed & 0xFF),f32((seed >> 8) & 0xFF),f32(seed >> 16));return delta + fract(sin(dot(t,vec3<f32>(12.9898,78.233,12.9898))) * 43758.5453);}");this.init(e,"POST_EFFECT_ZOOM_BLUR",t),this.amount=this.#Uu}get centerX(){return this.#vr}set centerX(e){validateNumber(e),this.#vr=e,this.uniformBuffer.writeBuffer(this.uniformInfo.members.centerX,e)}get centerY(){return this.#Tr}set centerY(e){validateNumber(e),this.#Tr=e,this.uniformBuffer.writeBuffer(this.uniformInfo.members.centerY,e)}get amount(){return this.#Uu}set amount(e){validateNumberRange(e,0),this.#Uu=e,this.uniformBuffer.writeBuffer(this.uniformInfo.members.amount,e)}}Object.freeze(ZoomBlur);const qn=[0,0,0,0,0,1,0,0,0,0,0,0],Wn=[0,-1,0,0,-1,5,-1,0,0,-1,0,0],Jn=[1,1,1,0,1,1,1,0,1,1,1,0],Qn=[0,1,0,0,1,-4,1,0,0,1,0,0],ei=[-2,-1,0,0,-1,1,1,0,0,1,2,0];class Convolution extends ASinglePassPostEffect{static NORMAL=qn;static SHARPEN=Wn;static BLUR=Jn;static EDGE=Qn;static EMBOSE=ei;#Au=Jn;constructor(e){super();const t=createPostEffectCode(this,"let index=vec2<i32>(global_id.xy );let dimensions:vec2<u32>=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let perPX=\tvec2<f32>(1.0/dimW,1.0/dimH);let uv=\tvec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);var color:vec4<f32>=vec4<f32>(0.0);let kernelWeight_value:f32=uniforms.kernelWeight;let kernel_value:mat3x3<f32>=uniforms.kernel;\ncolor +=textureLoad(sourceTexture,index + vec2<i32>(-1,-1)) * kernel_value[0][0] ;color +=textureLoad(sourceTexture,index + vec2<i32>(0,-1)) * kernel_value[0][1];color +=textureLoad(sourceTexture,index + vec2<i32>(1,-1)) * kernel_value[0][2];color +=textureLoad(sourceTexture,index + vec2<i32>(-1,0)) * kernel_value[1][0];color +=textureLoad(sourceTexture,index + vec2<i32>(0,0)) * kernel_value[1][1];color +=textureLoad(sourceTexture,index + vec2<i32>(1,0)) * kernel_value[1][2];color +=textureLoad(sourceTexture,index + vec2<i32>(-1,1)) * kernel_value[2][0];color +=textureLoad(sourceTexture,index + vec2<i32>(0,1)) * kernel_value[2][1];color +=textureLoad(sourceTexture,index + vec2<i32>(1,1)) * kernel_value[2][2];textureStore(outputTexture,index,vec4<f32>((color/kernelWeight_value).rgb,1.0) );\n","struct Uniforms {kernelWeight:f32,kernel:mat3x3<f32>};");this.init(e,"POST_EFFECT_CONVOLUTION",t),this.kernel=this.#Au}get kernel(){return this.#Au}set kernel(e){this.#Au=e;let t=0;for(const e in this.#Au)t+=this.#Au[e];this.uniformBuffer.writeBuffer(this.uniformInfo.members.kernelWeight,t),this.uniformBuffer.writeBuffer(this.uniformInfo.members.kernel,e)}}Object.freeze(Convolution);class OldBloomBlend extends ASinglePassPostEffect{#Du=1;#Nu=1;constructor(e){super();const{WORK_SIZE_X:t,WORK_SIZE_Y:r,WORK_SIZE_Z:n}=this,i=`struct Uniforms {bloomStrength:f32,exposure:f32};@group(0) @binding(0) var sourceTexture0:texture_storage_2d<rgba8unorm,read>;@group(0) @binding(1) var sourceTexture1:texture_storage_2d<rgba8unorm,read>;@group(0) @binding(2) var outputTexture:texture_storage_2d<rgba8unorm,write>;@group(0) @binding(3) var<uniform> uniforms:Uniforms;@compute @workgroup_size(${t},${r},${n})fn main (@builtin(global_invocation_id) global_id:vec3<u32>,){let index=vec2<u32>(global_id.xy );let dimensions:vec2<u32>=textureDimensions(sourceTexture0);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let uv=\tvec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);var diffuse:vec4<f32>=textureLoad(sourceTexture0,index,);var blur:vec4<f32>=textureLoad(sourceTexture1,index,);let finalColor=vec4<f32>((diffuse.rgb + blur.rgb * uniforms.bloomStrength ) * uniforms.exposure,diffuse.a);textureStore(outputTexture,index,finalColor );};`;this.init(e,"POST_EFFECT_OLD_BLOOM",i),this.exposure=this.#Nu,this.bloomStrength=this.#Du}get bloomStrength(){return this.#Du}set bloomStrength(e){this.#Du=e,this.uniformBuffer.writeBuffer(this.uniformInfo.members.bloomStrength,e)}get exposure(){return this.#Nu}set exposure(e){this.#Nu=e,this.uniformBuffer.writeBuffer(this.uniformInfo.members.exposure,e)}render(e,t,r,n,i){return super.render(e,t,r,n,i)}}Object.freeze(OldBloomBlend);class OldBloom extends AMultiPassPostEffect{#Ou;#Gu;#Vu;#Iu=156;#Fu=32;#Nu=1;#Du=1.2;constructor(e){super([new Threshold(e),new GaussianBlur(e),new OldBloomBlend(e)]),this.#Ou=this.passList[0],this.#Gu=this.passList[1],this.#Vu=this.passList[2],this.#Ou.threshold=this.#Iu,this.#Gu.size=this.#Fu,this.#Vu.exposure=this.#Nu,this.#Vu.bloomStrength=this.#Du}get threshold(){return this.#Iu}set threshold(e){this.#Iu=e,this.#Ou.threshold=e}get gaussianBlurSize(){return this.#Fu}set gaussianBlurSize(e){this.#Fu=e,this.#Gu.size=e}get exposure(){return this.#Nu}set exposure(e){this.#Nu=e,this.#Vu.exposure=e}get bloomStrength(){return this.#Du}set bloomStrength(e){this.#Du=e,this.#Vu.bloomStrength=e}render(e,t,r,n){const i=this.#Ou.render(e,t,r,n),s=this.#Gu.render(e,t,r,i);return this.#Vu.render(e,t,r,n,s)}}Object.freeze(OldBloom);class Vignetting extends ASinglePassPostEffect{#Hu=.2;#w=.5;constructor(e){super();const t=createPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);let dimW=f32(dimensions.x);let dimH=f32(dimensions.y);let index=vec2<u32>(global_id.xy);let uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);let smoothness=uniforms.smoothness;let size=uniforms.size;var color:vec4<f32>=textureLoad(sourceTexture,index);var diff=size - distance(uv,vec2<f32>(0.5));let vignette=smoothstep(-smoothness,smoothness,diff);color.r *=vignette;color.g *=vignette;color.b *=vignette;textureStore(outputTexture,index,color);","struct Uniforms {smoothness:f32,size:f32,};");this.init(e,"POST_EFFECT_VIGNETTING",t),this.smoothness=this.#Hu,this.size=this.#w}get size(){return this.#w}set size(e){validateNumberRange(e,0),this.#w=e,this.uniformBuffer.writeBuffer(this.uniformInfo.members.size,e)}get smoothness(){return this.#Hu}set smoothness(e){validateNumberRange(e,0,1),this.#Hu=e,this.uniformBuffer.writeBuffer(this.uniformInfo.members.smoothness,e)}}Object.freeze(Vignetting);var ti=Object.freeze({__proto__:null,AMultiPassPostEffect:AMultiPassPostEffect,ASinglePassPostEffect:ASinglePassPostEffect,BlurX:BlurX,BlurY:BlurY,BrightnessContrast:BrightnessContrast,Convolution:Convolution,GaussianBlur:GaussianBlur,Grayscale:Grayscale,HueSaturation:HueSaturation,Invert:Invert,OldBloom:OldBloom,PostEffectManager:PostEffectManager,Threshold:Threshold,Vignetting:Vignetting,ZoomBlur:ZoomBlur}),ri=Object.freeze({__proto__:null,PICKING_EVENT_TYPE:tr,PickingEvent:PickingEvent,PickingManager:PickingManager});const init=async(e,t,r,n,i="premultiplied",s={powerPreference:"high-performance",forceFallbackAdapter:!1})=>{const{gpu:a}=navigator,errorHandler=(e,t)=>{const n=generateErrorMessage(e,t);console.error("\n============\n",n,"\n============\n"),r?.(n)},validateAndRequestDevice=async t=>{const r=[];t.features.has("texture-compression-astc")&&r.push("texture-compression-astc");const n={requiredFeatures:r};try{const r=await t.requestDevice(n);validateAndInitializeContext(e,t,r)}catch(e){errorHandler(null,`Failed to request device. Adapter was ${t},error message is ${e.message}`)}},validateAndInitializeContext=(e,s,a)=>{const o=e.getContext("webgpu");if(o)try{const r=new RedGPUContext(e,s,a,o,i);t(r),a.addEventListener("uncapturederror",(e=>{console.warn("TODO A WebGPU error was not captured:",e),console.warn(e.error?.message),window.cancelAnimationFrame(r.currentRequestAnimationFrame)})),a.lost.then((e=>{console.warn(e),console.warn(`Device lost occurred:${e.message}`),"destroyed"===e.reason&&n?.(e)}))}catch(e){r(errorHandler(e,""))}else errorHandler(new Error(`Failed to get context from canvas:${e.id||e}`),"Failed to get webgpu initialize from canvas")},initializeWebGPU=async()=>{t instanceof Function?e instanceof HTMLCanvasElement?await(async e=>{e||errorHandler(null,"Cannot find navigator.gpu");try{const t=await e.requestAdapter(s);await validateAndRequestDevice(t)}catch(t){errorHandler(t,`Failed to request adapter or validate device with target GPU:${e},error message is ${t.message}`)}})(a):errorHandler(null,`Expected HTMLCanvasElement,but received:${e}`):errorHandler(null,`Expected onWebGPUInitialized,but received:${t}`)};try{await initializeWebGPU()}catch(e){errorHandler(e,`Unexpected error occurred during WebGPU initialization:${e.message}`)}},generateErrorMessage=(e,t)=>{let r=t;return e instanceof Error?(r=e.message??t,"string"==typeof e.stack&&(r+=`\nStack Trace:${e.stack}`)):console.warn("generateErrorMessage function expected an Error instance,but got:",e),r};class TextureLoaderData{src;texture;loadEnd;loadSuccess;srcInfo;idx;constructor(e,t,r){this.src=e,this.texture=null,this.loadEnd=!1,this.loadSuccess=!1,this.srcInfo=t,this.idx=r}}class TextureLoader{textures=[];#zu=0;#v;#Ku;#$u;#Xu;constructor(e,t=[],r,n){this.#v=e,this.#Ku=t,this.#$u=r,this.#Xu=n,this.#Ku.length?this.#Ku.forEach(((e,t)=>this.#ju(e,t))):this.#Yu()}getTextureByIndex(e){if(this.textures[e])return this.textures[e].texture}#ju(e,t){let r,n,i=BitmapTexture;n=e.hasOwnProperty("src")?e.src:e,n instanceof Array&&(i=CubeTexture),r=new TextureLoaderData(n,e,t);const onLoadHandler=()=>{r.loadSuccess=!0,r.loadEnd=!0,this.#Zu()},onErrorHandler=()=>{r.loadSuccess=!1,r.loadEnd=!0,this.#Zu()};r.texture=i===BitmapTexture?new i(this.#v,e,!0,onLoadHandler,onErrorHandler,e.format,!1):new i(this.#v,e,!0,onLoadHandler,onErrorHandler,e.format),this.textures.push(r)}#Zu(){this.#zu++,this.#Xu&&this.#Xu.call(this,{totalNum:this.#Ku.length,loaded:this.#zu}),this.#zu===this.#Ku.length&&this.#Yu()}#Yu(){requestAnimationFrame((()=>{this.#$u&&this.#$u.call(this,this)}))}}const arrayBufferLoader=(e,t,r)=>{fetch(e).then((e=>{if(!e.ok)throw new Error(`Network response was not ok ${e.statusText}`);return e.arrayBuffer()})).then((e=>{t&&t(e)})).catch((e=>{}))},ni={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array};Object.freeze(ni);class AccessorInfo_GLTF{accessor;bufferView;bufferGlTfId;buffer;bufferURIDataView;componentType;componentType_BYTES_PER_ELEMENT;getMethod;accessorBufferOffset;bufferViewOffset;bufferViewByteStride;startIndex;constructor(e,t,r){switch(this.accessor=t.accessors[r],this.bufferView=t.bufferViews[this.accessor.bufferView],this.bufferGlTfId=this.bufferView.buffer,this.buffer=t.buffers[this.bufferGlTfId],this.bufferURIDataView=null,this.buffer.uri&&(this.bufferURIDataView=e.parsingResult.uris.buffers[this.bufferGlTfId]),this.componentType=ni[this.accessor.componentType],this.componentType_BYTES_PER_ELEMENT=this.componentType.BYTES_PER_ELEMENT,this.componentType){case Float32Array:this.getMethod="getFloat32";break;case Uint32Array:this.getMethod="getUint32";break;case Uint16Array:this.getMethod="getUint16";break;case Int16Array:this.getMethod="getInt16";break;case Uint8Array:this.getMethod="getUint8";break;case Int8Array:this.getMethod="getInt8";break;default:consoleAndThrowError(" ",this.componentType)}this.accessorBufferOffset=this.accessor.byteOffset||0,this.bufferViewOffset=this.bufferView.byteOffset||0,this.bufferViewByteStride=this.bufferView.byteStride||0,this.startIndex=(this.bufferViewOffset+this.accessorBufferOffset)/this.componentType_BYTES_PER_ELEMENT}}class AnimationData_GLTF{gltfLoader;scenesData;accessorGlTfId;dataList;constructor(e,t,r){this.gltfLoader=e,this.scenesData=t,this.accessorGlTfId=r;const n=new AccessorInfo_GLTF(this.gltfLoader,this.scenesData,this.accessorGlTfId),{accessor:i,startIndex:s,componentType_BYTES_PER_ELEMENT:a,bufferURIDataView:o,getMethod:u}=n,{type:l,count:c}=i;let h=s,d=1;switch(l){case"SCALAR":d=1;break;case"VEC4":d=4;break;case"VEC3":d=3}this.dataList=[];let m=0;for(;m<c*d;h++,m++)this.dataList[m]=o[u](h*a,!0)}}class AniTrack_GLTF{key;timeAnimationInfo;aniDataAnimationInfo;interpolation;animationTargetMesh;weightMeshes;constructor(e,t,r,n,i,s){this.key=e,this.timeAnimationInfo=t,this.aniDataAnimationInfo=r,this.interpolation=n,this.animationTargetMesh=i,this.weightMeshes=s}}const parseAnimations=(e,t)=>new Promise((async r=>{t.animations||(t.animations=[]);const{parsingResult:n}=e,{animations:i}=n,{animations:s}=t;if(s.length){const r=s.map((async r=>{const{samplers:n,channels:s}=r,a=[];a.minTime=1e7,a.maxTime=-1,a.name=r.name,i.push(a),await Promise.all(s.map((async r=>((e,t,r,n,i)=>{let s,a;const{nodes:o,meshes:u}=i,l=[],{sampler:c,target:h}=r,d=n[c],{node:m,path:p}=h,f=o[m];if("mesh"in f){s=f.Mesh;const{primitives:e}=u[f.mesh];let t=e.length;for(;t--;)l.push(e[t].Mesh)}else{let t;if(!e.parsingResult.groups[m])return;t=e.parsingResult.groups[m],s=t}if("scale"!=p&&"rotation"!=p&&"translation"!=p&&"weights"!=p||(a=new AniTrack_GLTF(p,new AnimationData_GLTF(e,i,d.input),new AnimationData_GLTF(e,i,d.output),d.interpolation,s,l),t.push(a)),a){const{timeAnimationInfo:e}=a,{dataList:r}=e;t.minTime>r[0]&&(t.minTime=r[0]),t.maxTime<r[r.length-1]&&(t.maxTime=r[r.length-1])}})(e,a,r,n,t))))}));await Promise.all(r),i.length&&i.forEach((t=>e.playAnimation(t)))}r()}));let ii=new Float32Array(16),si=new Float32Array(16);class ParsedSkinInfo_GLTF{joints;inverseBindMatrices;skeletonMesh;isInverseBindMatrixUpdated=!1;vertexStorageInfo;vertexStorageBuffer;#qu;#Wu;constructor(){this.joints=[],this.inverseBindMatrices=null,this.skeletonMesh=null}update(e,t){const r=this.#Ju(t.modelMatrix),n=this.#Qu(this.joints,r);this.#el(e,t.animationInfo.skinInfo,n)}#Ju(e){return this.#qu=this.#qu||new Float32Array(e.length),this.#qu.set(e),invert$2(this.#qu,this.#qu),this.#qu}#Qu(e,t){const r=16*e.length;this.#Wu&&this.#Wu.length==r||(this.#Wu=new Float32Array(r));for(let r=0;r<e.length;r++){const n=multiply$5(ii,t,e[r].modelMatrix),i=multiply$5(si,n,this.inverseBindMatrices[r]);this.#Wu.set(i,16*r)}return this.#Wu}#el(e,t,r){const{vertexStorageBuffer:n,vertexStorageInfo:i}=t,{gpuBuffer:s}=n,{jointMatrix:a}=i.members;e.gpuDevice.queue.writeBuffer(s,a.uniformOffset,r)}}const parseJoint_GLTF=(e,t,r,n)=>{const i=r[n].Mesh;i?(t.joints.push(i),i.depthCompare=St.NEVER):requestAnimationFrame((function(){parseJoint_GLTF(e,t,r,n)}))},parseAttributeInfo_GLTF=function(e,t,r,n,i,s,a,o,u,l,c){const{accessor:h,startIndex:d,getMethod:m,bufferViewByteStride:p,bufferURIDataView:f,componentType_BYTES_PER_ELEMENT:g}=t,{type:_,count:x}=h;let v=0;const T=p/g;let y,b=d;switch(_){case"VEC4":if(p)for(y=b+x*(p/g);b<y;b++)v%T<4&&("WEIGHTS_0"==e?o.push(f[m](b*g,!0)):"JOINTS_0"==e?u.push(f[m](b*g,!0)):"COLOR_0"==e?l.push(f[m](b*g,!0)):"TANGENT"==e?c.push(f[m](b*g,!0)):consoleAndThrowError("VEC4     ",e)),v++;else for(y=b+4*x;b<y;b++)"WEIGHTS_0"==e?o.push(f[m](b*g,!0)):"JOINTS_0"==e?u.push(f[m](b*g,!0)):"COLOR_0"==e?l.push(f[m](b*g,!0)):"TANGENT"==e?c.push(f[m](b*g,!0)):consoleAndThrowError("VEC4     ",e),v++;break;case"VEC3":if(p)for(y=b+x*(p/g);b<y;b++)v%T<3&&("NORMAL"==e?a.push(f[m](b*g,!0)):"POSITION"==e?r.push(f[m](b*g,!0)):"COLOR_0"==e?(l.push(f[m](b*g,!0)),v%T==2&&l.push(1)):"TANGENT"==e?c.push(f[m](b*g,!0)):consoleAndThrowError("VEC3     ",e)),v++;else for(y=b+3*x;b<y;b++)"NORMAL"==e?a.push(f[m](b*g,!0)):"POSITION"==e?r.push(f[m](b*g,!0)):"COLOR_0"==e?(l.push(f[m](b*g,!0)),v%3==2&&l.push(1)):"TANGENT"==e?c.push(f[m](b*g,!0)):consoleAndThrowError("VEC3     ",e),v++;break;case"VEC2":if(p)for(y=b+x*(p/g);b<y;b++)v%T<2&&("TEXCOORD_0"==e?n.push(f[m](b*g,!0)):"TEXCOORD_1"==e?i.push(f[m](b*g,!0)):"TEXCOORD_2"==e?s.push(f[m](b*g,!0)):consoleAndThrowError("VEC2     ",e)),v++;else for(y=b+2*x;b<y;b++)"TEXCOORD_0"==e?n.push(f[m](b*g,!0)):"TEXCOORD_1"==e?i.push(f[m](b*g,!0)):"TEXCOORD_2"==e?s.push(f[m](b*g,!0)):consoleAndThrowError("VEC2     ",e),v++}},parseSparse_GLTF=(e,t,r,n,i)=>{const s=r.sparse;if(!s)return;const{values:a,indices:o,count:u}=s,l=n.bufferViews,c=l[a.bufferView],h=c.buffer,d=n.buffers,m=d[h],p=[],f=[],g=l[o.bufferView],_=g.buffer,x=d[_];let v;m.uri&&(v=e.parsingResult.uris.buffers[h]);const T=ni[r.componentType],{BYTES_PER_ELEMENT:y}=T;let b;switch(T){case Float32Array:b="getFloat32";break;case Uint32Array:b="getUint32";break;case Uint16Array:b="getUint16";break;case Int16Array:b="getInt16";break;case Uint8Array:b="getUint8";break;case Int8Array:b="getInt8"}const S=r.byteOffset||0;let M,R,w=((c.byteOffset||0)+S)/y;switch(r.type){case"VEC3":for(M=w+y*u/y*3;w<M;w++){const e=v[b](w*y,!0);"NORMAL"==t||"POSITION"==t&&p.push(e)}break;case"VEC2":for(M=w+y*u/y*2;w<M;w++)"TEXCOORD_0"==t&&f.push(v[b](w*y,!0))}x.uri&&(R=e.parsingResult.uris.buffers[_]);const P=ni[o.componentType],E=P.BYTES_PER_ELEMENT,k=P===Uint16Array?"getUint16":"getUint8",C=o.byteOffset||0;let L=((g.byteOffset||0)+C)/E;const B=L+E*u/E;let I=0;for(;L<B;L++){const e=R[k](L*E,!0);i[3*e]=p[3*I],i[3*e+1]=p[3*I+1],i[3*e+2]=p[3*I+2],I++}};class MorphInfoData_GLTF{vertices=[];verticesColor_0=[];normals=[];uvs=[];uvs1=[];uvs2=[];jointWeights=[];joints=[];tangents=[];interleaveData;constructor(e=[],t=[],r=[],n=[],i=[],s=[],a=[],o=[],u=[]){this.vertices=e,this.verticesColor_0=t,this.normals=r,this.uvs=n,this.uvs1=i,this.uvs2=i,this.jointWeights=a,this.joints=o,this.tangents=u}}class MorphInfo_GLTF{morphInfoDataList=[];weights;cacheData={};origin;constructor(e,t,r,n){r.targets&&(this.morphInfoDataList=r.targets.map((r=>{const n=new MorphInfoData_GLTF;for(let i in r){const{vertices:s,verticesColor_0:a,normals:o,uvs:u,uvs1:l,uvs2:c,jointWeights:h,joints:d,tangents:m}=n,p=r[i],f=new AccessorInfo_GLTF(e,t,p),{accessor:g}=f;parseAttributeInfo_GLTF(i,f,s,u,l,c,o,h,d,a,m),g.sparse&&parseSparse_GLTF(e,i,g,t,s)}return n}))),this.weights=n||[],this.origin=null}}const parseMaterialTexture=(e,t,r,n,i)=>{const{redGPUContext:s,gltfData:a}=e,{textureRawList:o}=e.parsingResult,u=r.index,l=a.textures[u],c=l.extensions?.EXT_texture_webp?.source||l.source,h=getURL(e,a,c);if(h){const u=l.sampler,d=getSamplerInfo(e,a,u),{parsedURI:m,cacheKey:p}=h,f=`${n}SourceGlTfId_${c}`;if(o[f]?(o[f].materialList.push(t),o[f].samplerList.push(new Sampler(s,d))):o[f]={src:m,cacheKey:p,targetTextureKey:n,targetSamplerKey:`${n}Sampler`,materialList:[t],samplerList:[new Sampler(s,d)],format:i||navigator.gpu.getPreferredCanvasFormat()},t[`${n}_texCoord_index`]=r.texCoord||0,"extensions"in r){const{extensions:e}=r,{KHR_texture_transform:i}=e;i&&((e,t,r)=>{e[`${t}_KHR_texture_transform_offset`]=r.offset||[0,0],e[`${t}_KHR_texture_transform_scale`]=r.scale||[1,1],e[`${t}_KHR_texture_transform_rotation`]=r.rotation||0,e[`use_${t}_KHR_texture_transform`]=!0})(t,n,i)}}},getURL=function(e,t,r){if(!t.images[r])return null;const{uri:n}=t.images[r];let i;const s=`${e.url}_${r}`;return i=n.indexOf("blob:http")>-1?n:(n.indexOf(";base64,")>-1?"":e.filePath)+n,{parsedURI:i,cacheKey:s}},getSamplerInfo=function(e,t,r){const n={magFilter:Ue.LINEAR,minFilter:Ue.LINEAR,mipmapFilter:Ue.LINEAR,addressModeU:Be.REPEAT,addressModeV:Be.REPEAT,addressModeW:Be.REPEAT},i={33071:Be.CLAMP_TO_EDGE,33648:Be.MIRRORED_REPEAT,10497:Be.REPEAT},s={9728:Ue.NEAREST,9729:Ue.LINEAR},a={9728:Ue.NEAREST,9729:Ue.LINEAR};if(t.samplers){let e=t.samplers[r];e&&("magFilter"in e&&(n.magFilter=s[e.magFilter]||Ue.LINEAR),"minFilter"in e&&(n.minFilter=a[e.minFilter]||Ue.LINEAR),"wrapS"in e&&(n.addressModeU=i[e.wrapS]),"wrapT"in e&&(n.addressModeV=i[e.wrapT]))}return n.string=JSON.stringify(n),n},parseMaterialInfo_GLTF=(e,t,r)=>{const{redGPUContext:n}=e;let i,s=!1,a="OPAQUE",o=.5;if("material"in r){i=new PBRMaterial(n);const u=r.material,l=t.materials[u];s=!!l.doubleSided,a=l.alphaMode??a,o=l.alphaCutoff??o;const{pbrMetallicRoughness:c,normalTexture:h,emissiveTexture:d,occlusionTexture:m}=l;if(i.emissiveFactor=l.emissiveFactor||[0,0,0],c){const{metallicRoughnessTexture:t,baseColorTexture:r}=c;let n,s;i.baseColorFactor=c.baseColorFactor||[1,1,1,1],"metallicFactor"in c&&(n=c.metallicFactor),"roughnessFactor"in c&&(s=c.roughnessFactor),i.metallicFactor=null!=n?n:1,i.roughnessFactor=null!=s?s:1,r&&parseMaterialTexture(e,i,r,"baseColorTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`),t&&parseMaterialTexture(e,i,t,"metallicRoughnessTexture")}if(h){parseMaterialTexture(e,i,h,"normalTexture");const{scale:t}=h;i.normalScale=null!=t?t:1}if(d&&parseMaterialTexture(e,i,d,"emissiveTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`),m&&(parseMaterialTexture(e,i,m,"occlusionTexture"),i.occlusionStrength=l.occlusionTexture.strength||1),"extensions"in l){const{extensions:t}=l,{KHR_materials_clearcoat:r,KHR_materials_emissive_strength:n,KHR_materials_transmission:s,KHR_materials_diffuse_transmission:o,KHR_materials_volume:u,KHR_materials_unlit:c,KHR_materials_ior:h,KHR_materials_sheen:d,KHR_materials_specular:m,KHR_materials_dispersion:p,KHR_materials_anisotropy:f,KHR_materials_iridescence:g}=t;if(g&&((e,t,r)=>{e.useKHR_materials_iridescence=!0,e.KHR_iridescenceFactor=t.iridescenceFactor||0,e.KHR_iridescenceIor=t.iridescenceIor||1.3,e.KHR_iridescenceThicknessMinimum=t.iridescenceThicknessMinimum||100,e.KHR_iridescenceThicknessMaximum=t.iridescenceThicknessMaximum||400,e.transparent=!0;{const{iridescenceTexture:n,iridescenceThicknessTexture:i}=t;n&&parseMaterialTexture(r,e,n,"KHR_iridescenceTexture"),i&&parseMaterialTexture(r,e,i,"KHR_iridescenceThicknessTexture")}})(i,g,e),f&&((e,t,r)=>{e.useKHR_materials_anisotropy=!0,e.KHR_anisotropyStrength=t.anisotropyStrength||0,e.KHR_anisotropyRotation=t.anisotropyRotation||0;const{anisotropyTexture:n}=t;n&&parseMaterialTexture(r,e,n,"KHR_anisotropyTexture")})(i,f,e),r&&((e,t,r)=>{e.KHR_clearcoatFactor=t.clearcoatFactor||0,e.KHR_clearcoatRoughnessFactor=t.clearcoatRoughnessFactor||0,e.useKHR_materials_clearcoat=!0;const{clearcoatTexture:n,clearcoatNormalTexture:i,clearcoatRoughnessTexture:s}=t;n&&parseMaterialTexture(r,e,n,"KHR_clearcoatTexture"),i&&parseMaterialTexture(r,e,i,"KHR_clearcoatNormalTexture"),s&&parseMaterialTexture(r,e,s,"KHR_clearcoatRoughnessTexture")})(i,r,e),n){const{emissiveStrength:e}=n;i.emissiveStrength=null!=e?e:1}if(s&&(((e,t,r)=>{e.useKHR_materials_transmission=!0,e.KHR_transmissionFactor=t.transmissionFactor||0,e.use2PathRender=!0;{const n=t.transmissionTexture;n&&parseMaterialTexture(r,e,n,"KHR_transmissionTexture")}})(i,s,e),i.transparent="BLEND"===a),o&&((e,t,r)=>{e.useKHR_materials_diffuse_transmission=!0,e.KHR_diffuseTransmissionFactor=t.diffuseTransmissionFactor||0,e.KHR_diffuseTransmissionColorFactor=t.diffuseTransmissionColorFactor||[1,1,1],e.transparent=!0;{const n=t.diffuseTransmissionTexture;n&&parseMaterialTexture(r,e,n,"KHR_diffuseTransmissionTexture");const i=t.diffuseTransmissionColorTexture;i&&parseMaterialTexture(r,e,i,"KHR_diffuseTransmissionColorTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`)}})(i,o,e),u&&(((e,t,r)=>{e.useKHR_materials_volume=!0,e.KHR_thicknessFactor=t.thicknessFactor||1,e.KHR_attenuationDistance=t.attenuationDistance||1,e.KHR_attenuationColor=t.attenuationColor||[1,1,1],e.use2PathRender=!0,e.transparent=!0;{const n=t.thicknessTexture;n&&parseMaterialTexture(r,e,n,"KHR_thicknessTexture")}})(i,u,e),a="BLEND"),c&&(i.useKHR_materials_unlit=!0),h){const{ior:e}=h;i.KHR_materials_ior=null!=e?e:1.5,i.use2PathRender=!0,i.transparent=!0}if(p){const{dispersion:e}=p;i.KHR_dispersion=e||0,i.use2PathRender=!0,i.transparent=!0}d&&((e,t,r)=>{e.KHR_sheenColorFactor=t.sheenColorFactor||[0,0,0],e.KHR_sheenRoughnessFactor=t.sheenRoughnessFactor||0,e.useKHR_materials_sheen=!0;const{sheenColorTexture:n,sheenRoughnessTexture:i}=t;n&&parseMaterialTexture(r,e,n,"KHR_sheenColorTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`),i&&parseMaterialTexture(r,e,i,"KHR_sheenRoughnessTexture")})(i,d,e),m&&((e,t,r)=>{e.useKHR_materials_specular=!0,e.KHR_specularFactor=t.specularFactor??1,e.KHR_specularColorFactor=t.specularColorFactor||[1,1,1];const{specularTexture:n,specularColorTexture:i}=t;n&&parseMaterialTexture(r,e,n,"KHR_specularTexture"),i&&parseMaterialTexture(r,e,i,"KHR_specularColorTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`)})(i,m,e)}}else i=new PBRMaterial(n);Object.hasOwn(r.attributes,"COLOR_0")&&(i.useVertexColor=!0),i.doubleSided=s,i.cutOff=o;const{blendColorState:u,blendAlphaState:l}=i;switch(a){case"BLEND":i.alphaBlend=2,u.srcFactor=lt.SRC_ALPHA,u.dstFactor=lt.ONE_MINUS_SRC_ALPHA,l.srcFactor=lt.SRC_ALPHA,l.dstFactor=lt.ONE_MINUS_SRC_ALPHA,i.transparent=!0;break;case"MASK":i.alphaBlend=1,i.useCutOff=!0,u.srcFactor=lt.ONE,u.dstFactor=lt.ZERO,l.srcFactor=lt.ONE,l.dstFactor=lt.ZERO;break;default:u.srcFactor=lt.ONE,u.dstFactor=lt.ZERO,l.srcFactor=lt.ONE,l.dstFactor=lt.ZERO,i.alphaBlend=0}return i},parseIndicesInfo_GLTF=(e,t)=>{const{accessor:r,startIndex:n,getMethod:i,bufferURIDataView:s,componentType_BYTES_PER_ELEMENT:a}=e,{type:o,count:u}=r;let l,c=n;if("SCALAR"===o)for(l=c+u;c<l;c++)t.push(s[i](c*a,!0))},parseInterleaveData_GLTF=(e,t,r,n,i,s,a,o,u,l)=>{let c,h,d,m,p,f,g,_,x,v=0,T=t.length/3,y=0;const b=t.length,S=n.length,M=s.length,R=a.length,w=r.length,P=o.length,E=u.length,k=l.length;for(c=d=f=0,h=m=g=1,p=_=2,x=3;v<T;v++)b&&(e[y++]=t[d],e[y++]=t[m],e[y++]=t[p]),S?(e[y++]=n[d],e[y++]=n[m],e[y++]=n[p]):(e[y++]=0,e[y++]=0,e[y++]=0),i.length||i.push(0,0),i.length&&(e[y++]=i[c],e[y++]=i[h]),R?(e[y++]=a[c],e[y++]=a[h]):M?(e[y++]=s[c],e[y++]=s[h]):i.length&&(e[y++]=i[c],e[y++]=i[h]),w?(e[y++]=r[f],e[y++]=r[g],e[y++]=r[_],e[y++]=r[x]):(e[y++]=0,e[y++]=0,e[y++]=0,e[y++]=0),P?(e[y++]=o[f],e[y++]=o[g],e[y++]=o[_],e[y++]=o[x]):(e[y++]=0,e[y++]=0,e[y++]=0,e[y++]=0),E?(e[y++]=u[f],e[y++]=u[g],e[y++]=u[_],e[y++]=u[x]):(e[y++]=0,e[y++]=0,e[y++]=0,e[y++]=0),k?(e[y++]=l[f],e[y++]=l[g],e[y++]=l[_],e[y++]=l[x]):(e[y++]=0,e[y++]=0,e[y++]=0,e[y++]=0),c+=2,h+=2,d+=3,m+=3,p+=3,f+=4,g+=4,_+=4,x+=4},ai=180/Math.PI,setMeshRotation=(e,t)=>{t.setRotation(-e[0]*ai,-e[1]*ai,-e[2]*ai)},parseTRSAndMATRIX_GLTF=(e,t)=>{const{matrix:r,rotation:n,translation:i,scale:s}=t;let a,o;if("matrix"in t){a=create$5(),o=create$4(),mat4ToEuler(r,o),setMeshRotation(o,e),e.setPosition(r[12],r[13],r[14]);const t=fromValues$4(1,1,1);getScaling(t,r),e.setScale(t[0],t[1],t[2])}"rotation"in t&&(a=create$5(),o=create$4(),quaternionToRotationMat4(n,a),mat4ToEuler(a,o),setMeshRotation(o,e)),"translation"in t&&e.setPosition(i[0],i[1],i[2]),"scale"in t&&(e.setScale(s[0],s[1],s[2]),(s[0]<0||s[1]<0||s[2]<0)&&(e.primitiveState.frontFace=Et.CW))},parseChildrenAndSkin=(e,t,r,n,i)=>{if("children"in n){const i=n.children,s=i.length;for(let n=0;n<s;n++)parseNode_GLTF(e,t,i[n],r)}"skin"in n&&((e,t,r,n)=>{const i=new ParsedSkinInfo_GLTF,s=[],{nodes:a}=t,{joints:o,skeleton:u}=r;{let t=0;const r=o.length;for(;t<r;t++){const r=o[t];parseJoint_GLTF(e,i,a,r)}}u&&(i.skeletonMesh=a[u].Mesh);const l=r.inverseBindMatrices,c=new AccessorInfo_GLTF(e,t,l),{startIndex:h,accessor:d,componentType_BYTES_PER_ELEMENT:m,bufferViewByteStride:p,bufferURIDataView:f,getMethod:g}=c,{type:_,count:x}=d;let v=0;const T=p/m;let y,b=h;if("MAT4"===_)if(p)for(y=b+x*(p/m);b<y;b++)v%T<16&&s.push(f[g](b*m,!0)),v++;else for(y=b+16*x;b<y;b++)s.push(f[g](b*m,!0)),v++;i.inverseBindMatrices=[];for(let e=0;e<o.length;e++)i.inverseBindMatrices.push(new Float32Array([s[16*e],s[16*e+1],s[16*e+2],s[16*e+3],s[16*e+4],s[16*e+5],s[16*e+6],s[16*e+7],s[16*e+8],s[16*e+9],s[16*e+10],s[16*e+11],s[16*e+12],s[16*e+13],s[16*e+14],s[16*e+15]]));n.animationInfo.skinInfo=i,n.material.useSkin=!!n.animationInfo.skinInfo})(e,t,i[n.skin],r)},parseNode_GLTF=(e,t,r,n)=>{const{redGPUContext:i,parsingResult:s}=e,{nodes:a,meshes:o,skins:u}=t,{groups:l,cameras:c}=s,h=a[r];if("mesh"in h){const r=function(e,t,r){const{redGPUContext:n}=e;let i;r.name&&(i=r.name);const s=[],{primitives:a}=r;let o=0;const u=a.length;for(;o<u;o++){const u=a[o];let l,c,h,d=[],m=[],p=[],f=[],g=[],_=[],x=[],v=[],T=[],y=[];const{attributes:b}=u;if(b)for(const r in b){const n=b[r],i=new AccessorInfo_GLTF(e,t,n);parseAttributeInfo_GLTF(r,i,m,f,g,_,x,v,T,p,y),i.accessor.sparse&&parseSparse_GLTF(e,r,i.accessor,t,m)}if("indices"in u){let r=u.indices,n=new AccessorInfo_GLTF(e,t,r);parseIndicesInfo_GLTF(n,d)}c=parseMaterialInfo_GLTF(e,t,u),c instanceof PBRMaterial&&e.parsingResult.materials.push(c);let S,M=!1;if("mode"in u)switch(u.mode){case 0:h=Ct.POINT_LIST;break;case 1:case 2:h=Ct.LINE_LIST;break;case 3:h=Ct.LINE_STRIP,M=!0;break;case 4:case 6:h=Ct.TRIANGLE_LIST;break;case 5:h=Ct.TRIANGLE_STRIP,M=!0}p.length&&(c.useVertexColor_0=!0),y.length&&(c.useVertexTangent=!0),S=x.length?x:calculateNormals(m,d);let R,w=[];parseInterleaveData_GLTF(w,m,p,S,f,g,_,v,T,y);let P={};if(m.length&&(P.aVertexPosition=InterleaveType.float32x3),S.length&&(P.aVertexNormal=InterleaveType.float32x3),f.length&&(P.aTexcoord=InterleaveType.float32x2),(_.length||g.length||f.length)&&(P.aTexcoord1=InterleaveType.float32x2),P.aVertexColor_0=InterleaveType.float32x4,P.aVertexWeight=InterleaveType.float32x4,P.aVertexJoint=InterleaveType.float32x4,P.aVertexTangent=InterleaveType.float32x4,R=new Geometry(n,new VertexBuffer(n,w,new InterleavedStruct(P)),!M&&d.length?new IndexBuffer(n,new Uint32Array(d)):null),c||consoleAndThrowError("  ",u),l=new Mesh(n,R,c),i&&(l.name=i,e.parsingOption))for(let t in e.parsingOption)i.toLowerCase().indexOf(t)>-1&&e.parsingOption[t](l);l.primitiveState.topology=h||Ct.TRIANGLE_LIST,l.material.doubleSided&&(l.primitiveState.cullMode=Pt.NONE),l.material.use2PathRender&&(l.primitiveState.cullMode=Pt.NONE,l.depthStencilState.depthCompare=St.LESS),2===l.material.alphaBlend&&(l.depthStencilState.depthCompare=St.LESS);{let n=new MorphInfo_GLTF(e,t,u,r.weights),i=0,s=n.morphInfoDataList;const a=s.length;for(;i<a;){const e=s[i],t=e.normals.length?e.normals:calculateNormals(e.vertices,d),r=[];parseInterleaveData_GLTF(r,e.vertices,e.verticesColor_0,t,e.uvs,e.uvs1,e.uvs2,e.jointWeights,e.joints,e.tangents),e.interleaveData=r,i++}l.animationInfo.morphInfo=n,l.animationInfo.morphInfo.origin=new Float32Array(w)}let E=l.geometry.vertexBuffer.data;l.gpuRenderInfo||l.initGPURenderInfos();let k=0;for(const e in P)k+=P[e].numElements;{const e=l.animationInfo.morphInfo.morphInfoDataList;let t=0;const r=e.length,n=E.length;for(;t<r;){const r=e[t].vertices;let i=0,s=n/k,a=null==l.animationInfo.morphInfo.weights[t]?.5:l.animationInfo.morphInfo.weights[t];for(;i<s;)E[i*k]+=r[3*i]*a,E[i*k+1]+=r[3*i+1]*a,E[i*k+2]+=r[3*i+2]*a,i++;t++}}l.geometry.vertexBuffer.updateAllData(E),l.animationInfo.morphInfo.origin=new Float32Array(E),u.Mesh=l,s.push(l)}return s}(e,t,o[h.mesh]),i=r.length;for(let s=0;s<i;s++){let i=r[s];n.addChild(h.Mesh=i),parseTRSAndMATRIX_GLTF(i,h),parseChildrenAndSkin(e,t,i,h,u)}}else{let s;l[r]?(s=l[r],h.Mesh=s):(s=new Mesh(i),n.addChild(s),h.Mesh=s,s.name=h.name,l[r]=s),parseTRSAndMATRIX_GLTF(s,h),parseChildrenAndSkin(e,t,s,h,u)}},parseGLTF=(e,t,r)=>{(e=>{const t=e?.asset;t||consoleAndThrowError("GLTFLoader - asset must be defined"),t.version||consoleAndThrowError("GLTFLoader - asset version must be defined");const r=parseFloat(t.version);isNaN(r)&&consoleAndThrowError("GLTFLoader - asset version must be a numerical value"),r<2&&consoleAndThrowError("GLTFLoader - asset version must be 2.0 or higher")})(t),((e,t,r)=>{const{parsingResult:n}=e,{uris:i}=n,s="buffers",a=i[s],o=t.buffers,u=o.length;let l=0;o.forEach(((t,n)=>{var i;function checkLoadingStatus(){l===u&&r&&r()}t._redURIkey=s,t._redURIIndex=n,t.uri instanceof ArrayBuffer?(i=new DataView(t.uri),l++,a[n]=i,checkLoadingStatus()):function(t){const r=t.startsWith("data:")?t:e.filePath+t;arrayBufferLoader(r,(function(e){l++,a[n]=new DataView(e),checkLoadingStatus()}))}(t.uri)}))})(e,t,(()=>{((e,t,r)=>{const{scenes:n}=t;n[0].nodes.forEach((r=>{parseNode_GLTF(e,t,r,e.resultMesh)})),r?.()})(e,t,(()=>{((e,t)=>{const{cameras:r}=t;r&&r.forEach((function(t){let r=new PerspectiveCamera;"orthographic"==t.type||(r.fieldOfView=180*t.perspective.yfieldOfView/Math.PI,r.farClipping=t.perspective.zfar,r.nearClipping=t.perspective.znear),e.parsingResult.cameras.push(r)}))})(e,t),new TextureLoader(e.redGPUContext,Object.values(e.parsingResult.textureRawList),(n=>{n.textures.forEach((e=>{const{targetTextureKey:t,targetSamplerKey:r,samplerList:n}=e.srcInfo;e.srcInfo.materialList.forEach(((i,s)=>{i[t]=e.texture,n[s]&&(i[r]=n[s])}))})),parseAnimations(e,t).then((e=>{r&&r()}))}))}))}))},parseFileGLB=async(e,t)=>{const r=e.filePath+e.fileName;await(async(e,t,r=()=>{})=>{try{const r=await fetch(e);t(await r.arrayBuffer())}catch(e){r(e)}})(r,(async r=>{const{content:n,binaryChunk:i}=parseBuffer(r);if(null===n)throw new Error("JSON content not found");const s=JSON.parse(n);processImagesIfExist(s,i),s.buffers[0].uri=i,e.gltfData=s,parseGLTF(e,s,t)}),(e=>{}))},parseBuffer=e=>{let t=null,r=null;const n=new DataView(e,12),i=n.byteLength;for(let s=0;s<i;){const i=n.getUint32(s,!0);s+=4;const a=n.getUint32(s,!0);switch(s+=4,a){case 1313821514:const n=new Uint8Array(e,12+s,i);t=convertUint8ArrayToString(n);break;case 5130562:const a=12+s;r=e.slice(a,a+i)}s+=i}return{content:t,binaryChunk:r}},processImagesIfExist=(e,t)=>{const{images:r,bufferViews:n}=e,i=["image/png","image/jpeg","image/gif","image/webp"];if(r)for(let e=0;e<r.length;e++){const s=r[e],{mimeType:a,bufferView:o}=s;if(i.includes(a)){const e=n[o].byteOffset||0,r=t.slice(e,e+n[o].byteLength),i=new Blob([new Uint8Array(r)],{type:a});s.uri=URL.createObjectURL(i)}}},convertUint8ArrayToString=e=>{let t="";for(let r of e)t+=String.fromCharCode(r);return t};class GLTFLoader{parsingResult;resultMesh;parsingOption;activeAnimations=[];#v;#tl;#xu;#vu;#rl;#nl;#ee;#te;#il;constructor(e,t,r,n){validateRedGPUContext(e),this.#v=e,this.#vu=t,this.#tl=getFilePath(t),this.#xu=getFileName(t),this.#rl=getFileExtension(t),this.#ee=r,this.#te=n,this.parsingResult={groups:[],materials:[],uris:{buffers:[]},textures:{},textureRawList:[],cameras:[],animations:[]},this.resultMesh=new Mesh(this.#v),this.resultMesh.gltfLoaderInfo=this,this.resultMesh.animationInfo.animationsList=this.parsingResult.animations,this.#sl()}get redGPUContext(){return this.#v}get filePath(){return this.#tl}get gltfData(){return this.#nl}set gltfData(e){this.#nl=e}get fileName(){return this.#xu}get url(){return this.#vu}stopAnimation(){const{activeAnimations:e}=this;let t=e.indexOf(this.#il);t>-1&&e.splice(t,1)}playAnimation(e){const{activeAnimations:t}=this;t.push(this.#il=new PlayAnimationInfo(performance.now(),e))}async#sl(){try{"glb"===this.#rl?await parseFileGLB(this,(()=>this.#ee(this))):"gltf"===this.#rl?await(async(e,t)=>{const r=await fetch(e.url);e.gltfData=await r.json(),parseGLTF(e,e.gltfData,t)})(this,(()=>this.#ee(this))):consoleAndThrowError("Unknown file extension:"+this.#rl)}catch(e){this.#te?.(e)}}}Object.freeze(GLTFLoader);class PlayAnimationInfo{startTime;targetAniTrackList;constructor(e,t){this.startTime=e,this.targetAniTrackList=t}}export{Qt as Camera,ColorRGB,ColorRGBA,Tn as Display,FinalRender,GLTFLoader,Be as GPU_ADDRESS_MODE,lt as GPU_BLEND_FACTOR,ct as GPU_BLEND_OPERATION,St as GPU_COMPARE_FUNCTION,Pt as GPU_CULL_MODE,Ie as GPU_FILTER_MODE,Et as GPU_FRONT_FACE,kt as GPU_INDEX_FORMAT,Ge as GPU_LOAD_OP,Ue as GPU_MIPMAP_FILTER_MODE,Ct as GPU_PRIMITIVE_TOPOLOGY,Ve as GPU_STORE_OP,Geometry,yn as Light,ar as Material,OBJLoader,OBJMTLLoader,ri as Picking,ti as PostEffect,bn as Primitive,RedGPUContext,RedGPUContextDetector,RedGPUContextSizeManager,RedGPUContextViewContainer,Mn as RenderState,Renderer,Sn as Resource,Fn as RuntimeChecker,He as SystemCode,br as Util,we as glMatrix,init};