const consoleAndThrowError=(...i)=>{const m=Array.prototype.slice.call(i).join(" ");throw new Error(m)},validatePositiveNumberRange=(i,m=0,g=Number.MAX_VALUE)=>("number"!=typeof i&&consoleAndThrowError("Only numbers allowed."),"number"!=typeof m&&consoleAndThrowError("Only numbers allowed."),"number"!=typeof g&&consoleAndThrowError("Only numbers allowed."),(m<0||i<0||i<m||i>g)&&consoleAndThrowError(`Only numbers within the range of [${m},${g}] are allowed.`),!0),isUint=i=>Number.isInteger(i)&&i>=0,validateUintRange=(i,m=0,g=4503599627370496)=>{const _=isUint(i),b=isUint(m),y=isUint(g),T="is not Uint!/value:",w=`(check range:${m}u ~ ${g}u)`;return _||consoleAndThrowError(`value ${T}${i}/${w}`),b||consoleAndThrowError(`min ${T}${m}/${w}`),y||consoleAndThrowError(`max ${T}${g}/${w}`),m>=g&&consoleAndThrowError(`maximum value is bigger than minimum value./${w}`),m>i&&consoleAndThrowError(`value is smaller than minimum value./value:${i}/${w}`),g<i&&consoleAndThrowError(`value is bigger than maximum value./value:${i}/${w}`),!0},isHexColor=i=>{const m=/^([A-Fa-f0-9]{3}){1,2}$/;return i.startsWith("#")?m.test(i.substring(1)):!!i.startsWith("0x")&&m.test(i.substring(2))},convertHexToRgb=(i,m=!1)=>{if("number"==typeof i&&(i=`#${i.toString(16)}`),isHexColor(i)){"#"===i.charAt(0)&&(i=i.substring(1)),3===i.length&&(i=i.charAt(0)+i.charAt(0)+i.charAt(1)+i.charAt(1)+i.charAt(2)+i.charAt(2));const g=parseInt("0x"+i),_=g>>16&255,b=g>>8&255,y=255&g;return m?[_,b,y]:{r:_,g:b,b:y}}throw Error(`from ${convertHexToRgb.constructor.name}:input value - ${i}/Only hex string allowed`)},convertRgbToHex=(i,m,g)=>{validateUintRange(i,0,255),validateUintRange(m,0,255),validateUintRange(g,0,255);return`#${i.toString(16).padStart(2,"0").toUpperCase()}${m.toString(16).padStart(2,"0").toUpperCase()}${g.toString(16).padStart(2,"0").toUpperCase()}`};class ColorRGB{#e;#t;#n;#r;constructor(i=255,m=255,g=255,_=void 0){this.#i(i,m,g),this.#a(i,m,g),_&&(this.#r=_)}get r(){return this.#e}set r(i){validateUintRange(i,0,255),this.#e=i,this.#r?.()}get g(){return this.#t}set g(i){validateUintRange(i,0,255),this.#t=i,this.#r?.()}get b(){return this.#n}set b(i){validateUintRange(i,0,255),this.#n=i,this.#r?.()}get rgb(){return[this.#e,this.#t,this.#n]}get rgbNormal(){return[this.#e/255,this.#t/255,this.#n/255]}get rgbNormalLinear(){return[Math.pow(this.#e/255,2.2),Math.pow(this.#t/255,2.2),Math.pow(this.#n/255,2.2)]}get hex(){return convertRgbToHex(this.#e,this.#t,this.#n)}setColorByRGB(i,m,g){this.#i(i,m,g),this.#a(i,m,g)}setColorByHEX(i){const{r:m,g:g,b:_}=convertHexToRgb(i);this.#a(m,g,_)}setColorByRGBString(i){const m=/rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(i);m||consoleAndThrowError(`유효하지 않은 rgb 색상 값입니다:${i}`);const[,g,_,b]=m.map(Number);this.#i(g,_,b),this.#a(g,_,b)}#a(i,m,g){this.#e=i,this.#t=m,this.#n=g,this.#r?.()}#i(i,m,g){validateUintRange(i,0,255),validateUintRange(m,0,255),validateUintRange(g,0,255)}}Object.freeze(ColorRGB);class ColorRGBA extends ColorRGB{#s;#r;constructor(i=255,m=255,g=255,_=1,b=void 0){super(i,m,g,b),validatePositiveNumberRange(_,0,1),this.#s=_,b&&(this.#r=b)}get a(){return this.#s}set a(i){validatePositiveNumberRange(i,0,1),this.#s=i,this.#r?.()}get rgba(){return[this.r,this.g,this.b,this.#s]}get rgbaNormal(){return[this.r/255,this.g/255,this.b/255,this.#s]}get rgbaNormalLinear(){return[Math.pow(this.r/255,2.2),Math.pow(this.g/255,2.2),Math.pow(this.b/255,2.2),this.#s]}setColorByRGBA(i,m,g,_){this.#o(i,m,g,_),this.r=i,this.g=m,this.b=g,this.#s=_,this.#r?.()}setColorByRGBAString(i){const m=/rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d*(?:\.\d+)?)\s*\)/.exec(i);if(!m)throw new Error(`유효하지 않은 rgba 색상 값입니다:${i}`);const[,g,_,b,y]=m.map(Number);this.#o(g,_,b,y),this.r=g,this.g=_,this.b=b,this.#s=y,this.#r?.()}#o(i,m,g,_){validateUintRange(i,0,255),validateUintRange(m,0,255),validateUintRange(g,0,255),validatePositiveNumberRange(_,0,1)}}const i={MOVE:"move",DOWN:"down",UP:"up",OVER:"over",OUT:"out",CLICK:"click"},copyGPUBuffer=(i,m,g)=>{const _=i.createCommandEncoder({label:"copyGPUBuffer_CommandEncoder"});_.copyBufferToBuffer(m,0,g,0,Math.min(m.size,g.size));const b=_.finish();i.queue.submit([b])};function getAbsoluteURL(i,m){try{return new URL(m,i).href}catch(i){return m}}const getFileExtension=i=>{if(!i||0===i.trim().length)throw new Error("URL must not be empty or undefined");const m=i.split("/"),g=m[m.length-1],_=g.lastIndexOf(".");return-1===_?"":g.substring(_+1).toLowerCase()},getFileName=(i,m=!0)=>{const g=i.substring(i.lastIndexOf("/")+1);return m?g:g.split(".").slice(0,-1).join(".")},getFilePath=i=>{if(!i||0===i.trim().length)throw new Error("URL must not be empty or undefined");return i.substring(0,i.lastIndexOf("/")+1)},calculateNormals=(i,m)=>{let g,_,b=[],y=m;const T=i.length/3;if(!m||0===m.length){m=[];for(let i=0;i<T;i++)y.push(i)}for(g=0;g<i.length;g+=3)b[g+0]=0,b[g+1]=0,b[g+2]=0;for(g=0;g<y.length;g+=3){let m,T,w,P,H=[],$=[],W=[];for(m=3*y[g],T=3*y[g+1],w=3*y[g+2],H[0]=i[w+0]-i[T+0],H[1]=i[w+1]-i[T+1],H[2]=i[w+2]-i[T+2],$[0]=i[m+0]-i[T+0],$[1]=i[m+1]-i[T+1],$[2]=i[m+2]-i[T+2],W[0]=H[1]*$[2]-H[2]*$[1],W[1]=H[2]*$[0]-H[0]*$[2],W[2]=H[0]*$[1]-H[1]*$[0],_=0;_<3;_++)P=3*y[g+_],b[P+0]=b[P+0]+W[0],b[P+1]=b[P+1]+W[1],b[P+2]=b[P+2]+W[2]}for(g=0;g<i.length;g+=3){let i=[];i[0]=b[g+0],i[1]=b[g+1],i[2]=b[g+2];let m=Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]);0===m&&(m=1),i[0]=i[0]/m,i[1]=i[1]/m,i[2]=i[2]/m,b[g+0]=i[0],b[g+1]=i[1],b[g+2]=i[2]}return b};var m=1e-6,g="undefined"!=typeof Float32Array?Float32Array:Array;function multiply$1(i,m,g){var _=m[0],b=m[1],y=m[2],T=m[3],w=m[4],P=m[5],H=m[6],$=m[7],W=m[8],q=g[0],ye=g[1],Ge=g[2],Ke=g[3],je=g[4],Xe=g[5],Ye=g[6],Ze=g[7],Je=g[8];return i[0]=q*_+ye*T+Ge*H,i[1]=q*b+ye*w+Ge*$,i[2]=q*y+ye*P+Ge*W,i[3]=Ke*_+je*T+Xe*H,i[4]=Ke*b+je*w+Xe*$,i[5]=Ke*y+je*P+Xe*W,i[6]=Ye*_+Ze*T+Je*H,i[7]=Ye*b+Ze*w+Je*$,i[8]=Ye*y+Ze*P+Je*W,i}function subtract$2(i,m,g){return i[0]=m[0]-g[0],i[1]=m[1]-g[1],i[2]=m[2]-g[2],i[3]=m[3]-g[3],i[4]=m[4]-g[4],i[5]=m[5]-g[5],i[6]=m[6]-g[6],i[7]=m[7]-g[7],i[8]=m[8]-g[8],i}var _=multiply$1,b=subtract$2,y=Object.freeze({__proto__:null,add:function(i,m,g){return i[0]=m[0]+g[0],i[1]=m[1]+g[1],i[2]=m[2]+g[2],i[3]=m[3]+g[3],i[4]=m[4]+g[4],i[5]=m[5]+g[5],i[6]=m[6]+g[6],i[7]=m[7]+g[7],i[8]=m[8]+g[8],i},adjoint:function(i,m){var g=m[0],_=m[1],b=m[2],y=m[3],T=m[4],w=m[5],P=m[6],H=m[7],$=m[8];return i[0]=T*$-w*H,i[1]=b*H-_*$,i[2]=_*w-b*T,i[3]=w*P-y*$,i[4]=g*$-b*P,i[5]=b*y-g*w,i[6]=y*H-T*P,i[7]=_*P-g*H,i[8]=g*T-_*y,i},clone:function(i){var m=new g(9);return m[0]=i[0],m[1]=i[1],m[2]=i[2],m[3]=i[3],m[4]=i[4],m[5]=i[5],m[6]=i[6],m[7]=i[7],m[8]=i[8],m},copy:function(i,m){return i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7],i[8]=m[8],i},create:function(){var i=new g(9);return g!=Float32Array&&(i[1]=0,i[2]=0,i[3]=0,i[5]=0,i[6]=0,i[7]=0),i[0]=1,i[4]=1,i[8]=1,i},determinant:function(i){var m=i[0],g=i[1],_=i[2],b=i[3],y=i[4],T=i[5],w=i[6],P=i[7],H=i[8];return m*(H*y-T*P)+g*(-H*b+T*w)+_*(P*b-y*w)},equals:function(i,g){var _=i[0],b=i[1],y=i[2],T=i[3],w=i[4],P=i[5],H=i[6],$=i[7],W=i[8],q=g[0],ye=g[1],Ge=g[2],Ke=g[3],je=g[4],Xe=g[5],Ye=g[6],Ze=g[7],Je=g[8];return Math.abs(_-q)<=m*Math.max(1,Math.abs(_),Math.abs(q))&&Math.abs(b-ye)<=m*Math.max(1,Math.abs(b),Math.abs(ye))&&Math.abs(y-Ge)<=m*Math.max(1,Math.abs(y),Math.abs(Ge))&&Math.abs(T-Ke)<=m*Math.max(1,Math.abs(T),Math.abs(Ke))&&Math.abs(w-je)<=m*Math.max(1,Math.abs(w),Math.abs(je))&&Math.abs(P-Xe)<=m*Math.max(1,Math.abs(P),Math.abs(Xe))&&Math.abs(H-Ye)<=m*Math.max(1,Math.abs(H),Math.abs(Ye))&&Math.abs($-Ze)<=m*Math.max(1,Math.abs($),Math.abs(Ze))&&Math.abs(W-Je)<=m*Math.max(1,Math.abs(W),Math.abs(Je))},exactEquals:function(i,m){return i[0]===m[0]&&i[1]===m[1]&&i[2]===m[2]&&i[3]===m[3]&&i[4]===m[4]&&i[5]===m[5]&&i[6]===m[6]&&i[7]===m[7]&&i[8]===m[8]},frob:function(i){return Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]+i[3]*i[3]+i[4]*i[4]+i[5]*i[5]+i[6]*i[6]+i[7]*i[7]+i[8]*i[8])},fromMat2d:function(i,m){return i[0]=m[0],i[1]=m[1],i[2]=0,i[3]=m[2],i[4]=m[3],i[5]=0,i[6]=m[4],i[7]=m[5],i[8]=1,i},fromMat4:function(i,m){return i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[4],i[4]=m[5],i[5]=m[6],i[6]=m[8],i[7]=m[9],i[8]=m[10],i},fromQuat:function(i,m){var g=m[0],_=m[1],b=m[2],y=m[3],T=g+g,w=_+_,P=b+b,H=g*T,$=_*T,W=_*w,q=b*T,ye=b*w,Ge=b*P,Ke=y*T,je=y*w,Xe=y*P;return i[0]=1-W-Ge,i[3]=$-Xe,i[6]=q+je,i[1]=$+Xe,i[4]=1-H-Ge,i[7]=ye-Ke,i[2]=q-je,i[5]=ye+Ke,i[8]=1-H-W,i},fromRotation:function(i,m){var g=Math.sin(m),_=Math.cos(m);return i[0]=_,i[1]=g,i[2]=0,i[3]=-g,i[4]=_,i[5]=0,i[6]=0,i[7]=0,i[8]=1,i},fromScaling:function(i,m){return i[0]=m[0],i[1]=0,i[2]=0,i[3]=0,i[4]=m[1],i[5]=0,i[6]=0,i[7]=0,i[8]=1,i},fromTranslation:function(i,m){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=1,i[5]=0,i[6]=m[0],i[7]=m[1],i[8]=1,i},fromValues:function(i,m,_,b,y,T,w,P,H){var $=new g(9);return $[0]=i,$[1]=m,$[2]=_,$[3]=b,$[4]=y,$[5]=T,$[6]=w,$[7]=P,$[8]=H,$},identity:function(i){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=1,i[5]=0,i[6]=0,i[7]=0,i[8]=1,i},invert:function(i,m){var g=m[0],_=m[1],b=m[2],y=m[3],T=m[4],w=m[5],P=m[6],H=m[7],$=m[8],W=$*T-w*H,q=-$*y+w*P,ye=H*y-T*P,Ge=g*W+_*q+b*ye;return Ge?(Ge=1/Ge,i[0]=W*Ge,i[1]=(-$*_+b*H)*Ge,i[2]=(w*_-b*T)*Ge,i[3]=q*Ge,i[4]=($*g-b*P)*Ge,i[5]=(-w*g+b*y)*Ge,i[6]=ye*Ge,i[7]=(-H*g+_*P)*Ge,i[8]=(T*g-_*y)*Ge,i):null},mul:_,multiply:multiply$1,multiplyScalar:function(i,m,g){return i[0]=m[0]*g,i[1]=m[1]*g,i[2]=m[2]*g,i[3]=m[3]*g,i[4]=m[4]*g,i[5]=m[5]*g,i[6]=m[6]*g,i[7]=m[7]*g,i[8]=m[8]*g,i},multiplyScalarAndAdd:function(i,m,g,_){return i[0]=m[0]+g[0]*_,i[1]=m[1]+g[1]*_,i[2]=m[2]+g[2]*_,i[3]=m[3]+g[3]*_,i[4]=m[4]+g[4]*_,i[5]=m[5]+g[5]*_,i[6]=m[6]+g[6]*_,i[7]=m[7]+g[7]*_,i[8]=m[8]+g[8]*_,i},normalFromMat4:function(i,m){var g=m[0],_=m[1],b=m[2],y=m[3],T=m[4],w=m[5],P=m[6],H=m[7],$=m[8],W=m[9],q=m[10],ye=m[11],Ge=m[12],Ke=m[13],je=m[14],Xe=m[15],Ye=g*w-_*T,Ze=g*P-b*T,Je=g*H-y*T,Qe=_*P-b*w,et=_*H-y*w,at=b*H-y*P,ht=$*Ke-W*Ge,ft=$*je-q*Ge,gt=$*Xe-ye*Ge,xt=W*je-q*Ke,vt=W*Xe-ye*Ke,bt=q*Xe-ye*je,yt=Ye*bt-Ze*vt+Je*xt+Qe*gt-et*ft+at*ht;return yt?(yt=1/yt,i[0]=(w*bt-P*vt+H*xt)*yt,i[1]=(P*gt-T*bt-H*ft)*yt,i[2]=(T*vt-w*gt+H*ht)*yt,i[3]=(b*vt-_*bt-y*xt)*yt,i[4]=(g*bt-b*gt+y*ft)*yt,i[5]=(_*gt-g*vt-y*ht)*yt,i[6]=(Ke*at-je*et+Xe*Qe)*yt,i[7]=(je*Je-Ge*at-Xe*Ze)*yt,i[8]=(Ge*et-Ke*Je+Xe*Ye)*yt,i):null},projection:function(i,m,g){return i[0]=2/m,i[1]=0,i[2]=0,i[3]=0,i[4]=-2/g,i[5]=0,i[6]=-1,i[7]=1,i[8]=1,i},rotate:function(i,m,g){var _=m[0],b=m[1],y=m[2],T=m[3],w=m[4],P=m[5],H=m[6],$=m[7],W=m[8],q=Math.sin(g),ye=Math.cos(g);return i[0]=ye*_+q*T,i[1]=ye*b+q*w,i[2]=ye*y+q*P,i[3]=ye*T-q*_,i[4]=ye*w-q*b,i[5]=ye*P-q*y,i[6]=H,i[7]=$,i[8]=W,i},scale:function(i,m,g){var _=g[0],b=g[1];return i[0]=_*m[0],i[1]=_*m[1],i[2]=_*m[2],i[3]=b*m[3],i[4]=b*m[4],i[5]=b*m[5],i[6]=m[6],i[7]=m[7],i[8]=m[8],i},set:function(i,m,g,_,b,y,T,w,P,H){return i[0]=m,i[1]=g,i[2]=_,i[3]=b,i[4]=y,i[5]=T,i[6]=w,i[7]=P,i[8]=H,i},str:function(i){return"mat3("+i[0]+","+i[1]+","+i[2]+","+i[3]+","+i[4]+","+i[5]+","+i[6]+","+i[7]+","+i[8]+")"},sub:b,subtract:subtract$2,translate:function(i,m,g){var _=m[0],b=m[1],y=m[2],T=m[3],w=m[4],P=m[5],H=m[6],$=m[7],W=m[8],q=g[0],ye=g[1];return i[0]=_,i[1]=b,i[2]=y,i[3]=T,i[4]=w,i[5]=P,i[6]=q*_+ye*T+H,i[7]=q*b+ye*w+$,i[8]=q*y+ye*P+W,i},transpose:function(i,m){if(i===m){var g=m[1],_=m[2],b=m[5];i[1]=m[3],i[2]=m[6],i[3]=g,i[5]=m[7],i[6]=_,i[7]=b}else i[0]=m[0],i[1]=m[3],i[2]=m[6],i[3]=m[1],i[4]=m[4],i[5]=m[7],i[6]=m[2],i[7]=m[5],i[8]=m[8];return i}});function create$2(){var i=new g(16);return g!=Float32Array&&(i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[11]=0,i[12]=0,i[13]=0,i[14]=0),i[0]=1,i[5]=1,i[10]=1,i[15]=1,i}function clone(i){var m=new g(16);return m[0]=i[0],m[1]=i[1],m[2]=i[2],m[3]=i[3],m[4]=i[4],m[5]=i[5],m[6]=i[6],m[7]=i[7],m[8]=i[8],m[9]=i[9],m[10]=i[10],m[11]=i[11],m[12]=i[12],m[13]=i[13],m[14]=i[14],m[15]=i[15],m}function copy$1(i,m){return i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7],i[8]=m[8],i[9]=m[9],i[10]=m[10],i[11]=m[11],i[12]=m[12],i[13]=m[13],i[14]=m[14],i[15]=m[15],i}function fromValues$1(i,m,_,b,y,T,w,P,H,$,W,q,ye,Ge,Ke,je){var Xe=new g(16);return Xe[0]=i,Xe[1]=m,Xe[2]=_,Xe[3]=b,Xe[4]=y,Xe[5]=T,Xe[6]=w,Xe[7]=P,Xe[8]=H,Xe[9]=$,Xe[10]=W,Xe[11]=q,Xe[12]=ye,Xe[13]=Ge,Xe[14]=Ke,Xe[15]=je,Xe}function identity(i){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i}function invert(i,m){var g=m[0],_=m[1],b=m[2],y=m[3],T=m[4],w=m[5],P=m[6],H=m[7],$=m[8],W=m[9],q=m[10],ye=m[11],Ge=m[12],Ke=m[13],je=m[14],Xe=m[15],Ye=g*w-_*T,Ze=g*P-b*T,Je=g*H-y*T,Qe=_*P-b*w,et=_*H-y*w,at=b*H-y*P,ht=$*Ke-W*Ge,ft=$*je-q*Ge,gt=$*Xe-ye*Ge,xt=W*je-q*Ke,vt=W*Xe-ye*Ke,bt=q*Xe-ye*je,yt=Ye*bt-Ze*vt+Je*xt+Qe*gt-et*ft+at*ht;return yt?(yt=1/yt,i[0]=(w*bt-P*vt+H*xt)*yt,i[1]=(b*vt-_*bt-y*xt)*yt,i[2]=(Ke*at-je*et+Xe*Qe)*yt,i[3]=(q*et-W*at-ye*Qe)*yt,i[4]=(P*gt-T*bt-H*ft)*yt,i[5]=(g*bt-b*gt+y*ft)*yt,i[6]=(je*Je-Ge*at-Xe*Ze)*yt,i[7]=($*at-q*Je+ye*Ze)*yt,i[8]=(T*vt-w*gt+H*ht)*yt,i[9]=(_*gt-g*vt-y*ht)*yt,i[10]=(Ge*et-Ke*Je+Xe*Ye)*yt,i[11]=(W*Je-$*et-ye*Ye)*yt,i[12]=(w*ft-T*xt-P*ht)*yt,i[13]=(g*xt-_*ft+b*ht)*yt,i[14]=(Ke*Ze-Ge*Qe-je*Ye)*yt,i[15]=($*Qe-W*Ze+q*Ye)*yt,i):null}function multiply(i,m,g){var _=m[0],b=m[1],y=m[2],T=m[3],w=m[4],P=m[5],H=m[6],$=m[7],W=m[8],q=m[9],ye=m[10],Ge=m[11],Ke=m[12],je=m[13],Xe=m[14],Ye=m[15],Ze=g[0],Je=g[1],Qe=g[2],et=g[3];return i[0]=Ze*_+Je*w+Qe*W+et*Ke,i[1]=Ze*b+Je*P+Qe*q+et*je,i[2]=Ze*y+Je*H+Qe*ye+et*Xe,i[3]=Ze*T+Je*$+Qe*Ge+et*Ye,Ze=g[4],Je=g[5],Qe=g[6],et=g[7],i[4]=Ze*_+Je*w+Qe*W+et*Ke,i[5]=Ze*b+Je*P+Qe*q+et*je,i[6]=Ze*y+Je*H+Qe*ye+et*Xe,i[7]=Ze*T+Je*$+Qe*Ge+et*Ye,Ze=g[8],Je=g[9],Qe=g[10],et=g[11],i[8]=Ze*_+Je*w+Qe*W+et*Ke,i[9]=Ze*b+Je*P+Qe*q+et*je,i[10]=Ze*y+Je*H+Qe*ye+et*Xe,i[11]=Ze*T+Je*$+Qe*Ge+et*Ye,Ze=g[12],Je=g[13],Qe=g[14],et=g[15],i[12]=Ze*_+Je*w+Qe*W+et*Ke,i[13]=Ze*b+Je*P+Qe*q+et*je,i[14]=Ze*y+Je*H+Qe*ye+et*Xe,i[15]=Ze*T+Je*$+Qe*Ge+et*Ye,i}function translate(i,m,g){var _,b,y,T,w,P,H,$,W,q,ye,Ge,Ke=g[0],je=g[1],Xe=g[2];return m===i?(i[12]=m[0]*Ke+m[4]*je+m[8]*Xe+m[12],i[13]=m[1]*Ke+m[5]*je+m[9]*Xe+m[13],i[14]=m[2]*Ke+m[6]*je+m[10]*Xe+m[14],i[15]=m[3]*Ke+m[7]*je+m[11]*Xe+m[15]):(_=m[0],b=m[1],y=m[2],T=m[3],w=m[4],P=m[5],H=m[6],$=m[7],W=m[8],q=m[9],ye=m[10],Ge=m[11],i[0]=_,i[1]=b,i[2]=y,i[3]=T,i[4]=w,i[5]=P,i[6]=H,i[7]=$,i[8]=W,i[9]=q,i[10]=ye,i[11]=Ge,i[12]=_*Ke+w*je+W*Xe+m[12],i[13]=b*Ke+P*je+q*Xe+m[13],i[14]=y*Ke+H*je+ye*Xe+m[14],i[15]=T*Ke+$*je+Ge*Xe+m[15]),i}function scale(i,m,g){var _=g[0],b=g[1],y=g[2];return i[0]=m[0]*_,i[1]=m[1]*_,i[2]=m[2]*_,i[3]=m[3]*_,i[4]=m[4]*b,i[5]=m[5]*b,i[6]=m[6]*b,i[7]=m[7]*b,i[8]=m[8]*y,i[9]=m[9]*y,i[10]=m[10]*y,i[11]=m[11]*y,i[12]=m[12],i[13]=m[13],i[14]=m[14],i[15]=m[15],i}function rotateX(i,m,g){var _=Math.sin(g),b=Math.cos(g),y=m[4],T=m[5],w=m[6],P=m[7],H=m[8],$=m[9],W=m[10],q=m[11];return m!==i&&(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[12]=m[12],i[13]=m[13],i[14]=m[14],i[15]=m[15]),i[4]=y*b+H*_,i[5]=T*b+$*_,i[6]=w*b+W*_,i[7]=P*b+q*_,i[8]=H*b-y*_,i[9]=$*b-T*_,i[10]=W*b-w*_,i[11]=q*b-P*_,i}function rotateY(i,m,g){var _=Math.sin(g),b=Math.cos(g),y=m[0],T=m[1],w=m[2],P=m[3],H=m[8],$=m[9],W=m[10],q=m[11];return m!==i&&(i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7],i[12]=m[12],i[13]=m[13],i[14]=m[14],i[15]=m[15]),i[0]=y*b-H*_,i[1]=T*b-$*_,i[2]=w*b-W*_,i[3]=P*b-q*_,i[8]=y*_+H*b,i[9]=T*_+$*b,i[10]=w*_+W*b,i[11]=P*_+q*b,i}function rotateZ(i,m,g){var _=Math.sin(g),b=Math.cos(g),y=m[0],T=m[1],w=m[2],P=m[3],H=m[4],$=m[5],W=m[6],q=m[7];return m!==i&&(i[8]=m[8],i[9]=m[9],i[10]=m[10],i[11]=m[11],i[12]=m[12],i[13]=m[13],i[14]=m[14],i[15]=m[15]),i[0]=y*b+H*_,i[1]=T*b+$*_,i[2]=w*b+W*_,i[3]=P*b+q*_,i[4]=H*b-y*_,i[5]=$*b-T*_,i[6]=W*b-w*_,i[7]=q*b-P*_,i}function fromRotationTranslation(i,m,g){var _=m[0],b=m[1],y=m[2],T=m[3],w=_+_,P=b+b,H=y+y,$=_*w,W=_*P,q=_*H,ye=b*P,Ge=b*H,Ke=y*H,je=T*w,Xe=T*P,Ye=T*H;return i[0]=1-(ye+Ke),i[1]=W+Ye,i[2]=q-Xe,i[3]=0,i[4]=W-Ye,i[5]=1-($+Ke),i[6]=Ge+je,i[7]=0,i[8]=q+Xe,i[9]=Ge-je,i[10]=1-($+ye),i[11]=0,i[12]=g[0],i[13]=g[1],i[14]=g[2],i[15]=1,i}function getScaling(i,m){var g=m[0],_=m[1],b=m[2],y=m[4],T=m[5],w=m[6],P=m[8],H=m[9],$=m[10];return i[0]=Math.sqrt(g*g+_*_+b*b),i[1]=Math.sqrt(y*y+T*T+w*w),i[2]=Math.sqrt(P*P+H*H+$*$),i}function perspectiveNO(i,m,g,_,b){var y=1/Math.tan(m/2);if(i[0]=y/g,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=y,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[11]=-1,i[12]=0,i[13]=0,i[15]=0,null!=b&&b!==1/0){var T=1/(_-b);i[10]=(b+_)*T,i[14]=2*b*_*T}else i[10]=-1,i[14]=-2*_;return i}var T=perspectiveNO;function orthoNO(i,m,g,_,b,y,T){var w=1/(m-g),P=1/(_-b),H=1/(y-T);return i[0]=-2*w,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=-2*P,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=2*H,i[11]=0,i[12]=(m+g)*w,i[13]=(b+_)*P,i[14]=(T+y)*H,i[15]=1,i}var w=orthoNO;function orthoZO(i,m,g,_,b,y,T){var w=1/(m-g),P=1/(_-b),H=1/(y-T);return i[0]=-2*w,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=-2*P,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=H,i[11]=0,i[12]=(m+g)*w,i[13]=(b+_)*P,i[14]=y*H,i[15]=1,i}function lookAt(i,g,_,b){var y,T,w,P,H,$,W,q,ye,Ge,Ke=g[0],je=g[1],Xe=g[2],Ye=b[0],Ze=b[1],Je=b[2],Qe=_[0],et=_[1],at=_[2];return Math.abs(Ke-Qe)<m&&Math.abs(je-et)<m&&Math.abs(Xe-at)<m?identity(i):(W=Ke-Qe,q=je-et,ye=Xe-at,y=Ze*(ye*=Ge=1/Math.sqrt(W*W+q*q+ye*ye))-Je*(q*=Ge),T=Je*(W*=Ge)-Ye*ye,w=Ye*q-Ze*W,(Ge=Math.sqrt(y*y+T*T+w*w))?(y*=Ge=1/Ge,T*=Ge,w*=Ge):(y=0,T=0,w=0),P=q*w-ye*T,H=ye*y-W*w,$=W*T-q*y,(Ge=Math.sqrt(P*P+H*H+$*$))?(P*=Ge=1/Ge,H*=Ge,$*=Ge):(P=0,H=0,$=0),i[0]=y,i[1]=P,i[2]=W,i[3]=0,i[4]=T,i[5]=H,i[6]=q,i[7]=0,i[8]=w,i[9]=$,i[10]=ye,i[11]=0,i[12]=-(y*Ke+T*je+w*Xe),i[13]=-(P*Ke+H*je+$*Xe),i[14]=-(W*Ke+q*je+ye*Xe),i[15]=1,i)}function targetTo(i,m,g,_){var b=m[0],y=m[1],T=m[2],w=_[0],P=_[1],H=_[2],$=b-g[0],W=y-g[1],q=T-g[2],ye=$*$+W*W+q*q;ye>0&&($*=ye=1/Math.sqrt(ye),W*=ye,q*=ye);var Ge=P*q-H*W,Ke=H*$-w*q,je=w*W-P*$;return(ye=Ge*Ge+Ke*Ke+je*je)>0&&(Ge*=ye=1/Math.sqrt(ye),Ke*=ye,je*=ye),i[0]=Ge,i[1]=Ke,i[2]=je,i[3]=0,i[4]=W*je-q*Ke,i[5]=q*Ge-$*je,i[6]=$*Ke-W*Ge,i[7]=0,i[8]=$,i[9]=W,i[10]=q,i[11]=0,i[12]=b,i[13]=y,i[14]=T,i[15]=1,i}function subtract$1(i,m,g){return i[0]=m[0]-g[0],i[1]=m[1]-g[1],i[2]=m[2]-g[2],i[3]=m[3]-g[3],i[4]=m[4]-g[4],i[5]=m[5]-g[5],i[6]=m[6]-g[6],i[7]=m[7]-g[7],i[8]=m[8]-g[8],i[9]=m[9]-g[9],i[10]=m[10]-g[10],i[11]=m[11]-g[11],i[12]=m[12]-g[12],i[13]=m[13]-g[13],i[14]=m[14]-g[14],i[15]=m[15]-g[15],i}var P=multiply,H=subtract$1,$=Object.freeze({__proto__:null,add:function(i,m,g){return i[0]=m[0]+g[0],i[1]=m[1]+g[1],i[2]=m[2]+g[2],i[3]=m[3]+g[3],i[4]=m[4]+g[4],i[5]=m[5]+g[5],i[6]=m[6]+g[6],i[7]=m[7]+g[7],i[8]=m[8]+g[8],i[9]=m[9]+g[9],i[10]=m[10]+g[10],i[11]=m[11]+g[11],i[12]=m[12]+g[12],i[13]=m[13]+g[13],i[14]=m[14]+g[14],i[15]=m[15]+g[15],i},adjoint:function(i,m){var g=m[0],_=m[1],b=m[2],y=m[3],T=m[4],w=m[5],P=m[6],H=m[7],$=m[8],W=m[9],q=m[10],ye=m[11],Ge=m[12],Ke=m[13],je=m[14],Xe=m[15],Ye=g*w-_*T,Ze=g*P-b*T,Je=g*H-y*T,Qe=_*P-b*w,et=_*H-y*w,at=b*H-y*P,ht=$*Ke-W*Ge,ft=$*je-q*Ge,gt=$*Xe-ye*Ge,xt=W*je-q*Ke,vt=W*Xe-ye*Ke,bt=q*Xe-ye*je;return i[0]=w*bt-P*vt+H*xt,i[1]=b*vt-_*bt-y*xt,i[2]=Ke*at-je*et+Xe*Qe,i[3]=q*et-W*at-ye*Qe,i[4]=P*gt-T*bt-H*ft,i[5]=g*bt-b*gt+y*ft,i[6]=je*Je-Ge*at-Xe*Ze,i[7]=$*at-q*Je+ye*Ze,i[8]=T*vt-w*gt+H*ht,i[9]=_*gt-g*vt-y*ht,i[10]=Ge*et-Ke*Je+Xe*Ye,i[11]=W*Je-$*et-ye*Ye,i[12]=w*ft-T*xt-P*ht,i[13]=g*xt-_*ft+b*ht,i[14]=Ke*Ze-Ge*Qe-je*Ye,i[15]=$*Qe-W*Ze+q*Ye,i},clone:clone,copy:copy$1,create:create$2,decompose:function(i,m,g,_){m[0]=_[12],m[1]=_[13],m[2]=_[14];var b=_[0],y=_[1],T=_[2],w=_[4],P=_[5],H=_[6],$=_[8],W=_[9],q=_[10];g[0]=Math.sqrt(b*b+y*y+T*T),g[1]=Math.sqrt(w*w+P*P+H*H),g[2]=Math.sqrt($*$+W*W+q*q);var ye=1/g[0],Ge=1/g[1],Ke=1/g[2],je=b*ye,Xe=y*Ge,Ye=T*Ke,Ze=w*ye,Je=P*Ge,Qe=H*Ke,et=$*ye,at=W*Ge,ht=q*Ke,ft=je+Je+ht,gt=0;return ft>0?(gt=2*Math.sqrt(ft+1),i[3]=.25*gt,i[0]=(Qe-at)/gt,i[1]=(et-Ye)/gt,i[2]=(Xe-Ze)/gt):je>Je&&je>ht?(gt=2*Math.sqrt(1+je-Je-ht),i[3]=(Qe-at)/gt,i[0]=.25*gt,i[1]=(Xe+Ze)/gt,i[2]=(et+Ye)/gt):Je>ht?(gt=2*Math.sqrt(1+Je-je-ht),i[3]=(et-Ye)/gt,i[0]=(Xe+Ze)/gt,i[1]=.25*gt,i[2]=(Qe+at)/gt):(gt=2*Math.sqrt(1+ht-je-Je),i[3]=(Xe-Ze)/gt,i[0]=(et+Ye)/gt,i[1]=(Qe+at)/gt,i[2]=.25*gt),i},determinant:function(i){var m=i[0],g=i[1],_=i[2],b=i[3],y=i[4],T=i[5],w=i[6],P=i[7],H=i[8],$=i[9],W=i[10],q=i[11],ye=i[12],Ge=i[13],Ke=i[14],je=m*T-g*y,Xe=m*w-_*y,Ye=g*w-_*T,Ze=H*Ge-$*ye,Je=H*Ke-W*ye,Qe=$*Ke-W*Ge;return P*(m*Qe-g*Je+_*Ze)-b*(y*Qe-T*Je+w*Ze)+i[15]*(H*Ye-$*Xe+W*je)-q*(ye*Ye-Ge*Xe+Ke*je)},equals:function(i,g){var _=i[0],b=i[1],y=i[2],T=i[3],w=i[4],P=i[5],H=i[6],$=i[7],W=i[8],q=i[9],ye=i[10],Ge=i[11],Ke=i[12],je=i[13],Xe=i[14],Ye=i[15],Ze=g[0],Je=g[1],Qe=g[2],et=g[3],at=g[4],ht=g[5],ft=g[6],gt=g[7],xt=g[8],vt=g[9],bt=g[10],yt=g[11],St=g[12],Tt=g[13],Mt=g[14],wt=g[15];return Math.abs(_-Ze)<=m*Math.max(1,Math.abs(_),Math.abs(Ze))&&Math.abs(b-Je)<=m*Math.max(1,Math.abs(b),Math.abs(Je))&&Math.abs(y-Qe)<=m*Math.max(1,Math.abs(y),Math.abs(Qe))&&Math.abs(T-et)<=m*Math.max(1,Math.abs(T),Math.abs(et))&&Math.abs(w-at)<=m*Math.max(1,Math.abs(w),Math.abs(at))&&Math.abs(P-ht)<=m*Math.max(1,Math.abs(P),Math.abs(ht))&&Math.abs(H-ft)<=m*Math.max(1,Math.abs(H),Math.abs(ft))&&Math.abs($-gt)<=m*Math.max(1,Math.abs($),Math.abs(gt))&&Math.abs(W-xt)<=m*Math.max(1,Math.abs(W),Math.abs(xt))&&Math.abs(q-vt)<=m*Math.max(1,Math.abs(q),Math.abs(vt))&&Math.abs(ye-bt)<=m*Math.max(1,Math.abs(ye),Math.abs(bt))&&Math.abs(Ge-yt)<=m*Math.max(1,Math.abs(Ge),Math.abs(yt))&&Math.abs(Ke-St)<=m*Math.max(1,Math.abs(Ke),Math.abs(St))&&Math.abs(je-Tt)<=m*Math.max(1,Math.abs(je),Math.abs(Tt))&&Math.abs(Xe-Mt)<=m*Math.max(1,Math.abs(Xe),Math.abs(Mt))&&Math.abs(Ye-wt)<=m*Math.max(1,Math.abs(Ye),Math.abs(wt))},exactEquals:function(i,m){return i[0]===m[0]&&i[1]===m[1]&&i[2]===m[2]&&i[3]===m[3]&&i[4]===m[4]&&i[5]===m[5]&&i[6]===m[6]&&i[7]===m[7]&&i[8]===m[8]&&i[9]===m[9]&&i[10]===m[10]&&i[11]===m[11]&&i[12]===m[12]&&i[13]===m[13]&&i[14]===m[14]&&i[15]===m[15]},frob:function(i){return Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]+i[3]*i[3]+i[4]*i[4]+i[5]*i[5]+i[6]*i[6]+i[7]*i[7]+i[8]*i[8]+i[9]*i[9]+i[10]*i[10]+i[11]*i[11]+i[12]*i[12]+i[13]*i[13]+i[14]*i[14]+i[15]*i[15])},fromQuat:function(i,m){var g=m[0],_=m[1],b=m[2],y=m[3],T=g+g,w=_+_,P=b+b,H=g*T,$=_*T,W=_*w,q=b*T,ye=b*w,Ge=b*P,Ke=y*T,je=y*w,Xe=y*P;return i[0]=1-W-Ge,i[1]=$+Xe,i[2]=q-je,i[3]=0,i[4]=$-Xe,i[5]=1-H-Ge,i[6]=ye+Ke,i[7]=0,i[8]=q+je,i[9]=ye-Ke,i[10]=1-H-W,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},fromQuat2:function(i,m){var _=new g(3),b=-m[0],y=-m[1],T=-m[2],w=m[3],P=m[4],H=m[5],$=m[6],W=m[7],q=b*b+y*y+T*T+w*w;return q>0?(_[0]=2*(P*w+W*b+H*T-$*y)/q,_[1]=2*(H*w+W*y+$*b-P*T)/q,_[2]=2*($*w+W*T+P*y-H*b)/q):(_[0]=2*(P*w+W*b+H*T-$*y),_[1]=2*(H*w+W*y+$*b-P*T),_[2]=2*($*w+W*T+P*y-H*b)),fromRotationTranslation(i,m,_),i},fromRotation:function(i,g,_){var b,y,T,w=_[0],P=_[1],H=_[2],$=Math.sqrt(w*w+P*P+H*H);return $<m?null:(w*=$=1/$,P*=$,H*=$,b=Math.sin(g),T=1-(y=Math.cos(g)),i[0]=w*w*T+y,i[1]=P*w*T+H*b,i[2]=H*w*T-P*b,i[3]=0,i[4]=w*P*T-H*b,i[5]=P*P*T+y,i[6]=H*P*T+w*b,i[7]=0,i[8]=w*H*T+P*b,i[9]=P*H*T-w*b,i[10]=H*H*T+y,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i)},fromRotationTranslation:fromRotationTranslation,fromRotationTranslationScale:function(i,m,g,_){var b=m[0],y=m[1],T=m[2],w=m[3],P=b+b,H=y+y,$=T+T,W=b*P,q=b*H,ye=b*$,Ge=y*H,Ke=y*$,je=T*$,Xe=w*P,Ye=w*H,Ze=w*$,Je=_[0],Qe=_[1],et=_[2];return i[0]=(1-(Ge+je))*Je,i[1]=(q+Ze)*Je,i[2]=(ye-Ye)*Je,i[3]=0,i[4]=(q-Ze)*Qe,i[5]=(1-(W+je))*Qe,i[6]=(Ke+Xe)*Qe,i[7]=0,i[8]=(ye+Ye)*et,i[9]=(Ke-Xe)*et,i[10]=(1-(W+Ge))*et,i[11]=0,i[12]=g[0],i[13]=g[1],i[14]=g[2],i[15]=1,i},fromRotationTranslationScaleOrigin:function(i,m,g,_,b){var y=m[0],T=m[1],w=m[2],P=m[3],H=y+y,$=T+T,W=w+w,q=y*H,ye=y*$,Ge=y*W,Ke=T*$,je=T*W,Xe=w*W,Ye=P*H,Ze=P*$,Je=P*W,Qe=_[0],et=_[1],at=_[2],ht=b[0],ft=b[1],gt=b[2],xt=(1-(Ke+Xe))*Qe,vt=(ye+Je)*Qe,bt=(Ge-Ze)*Qe,yt=(ye-Je)*et,St=(1-(q+Xe))*et,Tt=(je+Ye)*et,Mt=(Ge+Ze)*at,wt=(je-Ye)*at,Ct=(1-(q+Ke))*at;return i[0]=xt,i[1]=vt,i[2]=bt,i[3]=0,i[4]=yt,i[5]=St,i[6]=Tt,i[7]=0,i[8]=Mt,i[9]=wt,i[10]=Ct,i[11]=0,i[12]=g[0]+ht-(xt*ht+yt*ft+Mt*gt),i[13]=g[1]+ft-(vt*ht+St*ft+wt*gt),i[14]=g[2]+gt-(bt*ht+Tt*ft+Ct*gt),i[15]=1,i},fromScaling:function(i,m){return i[0]=m[0],i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=m[1],i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=m[2],i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},fromTranslation:function(i,m){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=m[0],i[13]=m[1],i[14]=m[2],i[15]=1,i},fromValues:fromValues$1,fromXRotation:function(i,m){var g=Math.sin(m),_=Math.cos(m);return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=_,i[6]=g,i[7]=0,i[8]=0,i[9]=-g,i[10]=_,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},fromYRotation:function(i,m){var g=Math.sin(m),_=Math.cos(m);return i[0]=_,i[1]=0,i[2]=-g,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=g,i[9]=0,i[10]=_,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},fromZRotation:function(i,m){var g=Math.sin(m),_=Math.cos(m);return i[0]=_,i[1]=g,i[2]=0,i[3]=0,i[4]=-g,i[5]=_,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},frustum:function(i,m,g,_,b,y,T){var w=1/(g-m),P=1/(b-_),H=1/(y-T);return i[0]=2*y*w,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=2*y*P,i[6]=0,i[7]=0,i[8]=(g+m)*w,i[9]=(b+_)*P,i[10]=(T+y)*H,i[11]=-1,i[12]=0,i[13]=0,i[14]=T*y*2*H,i[15]=0,i},getRotation:function(i,m){var _=new g(3);getScaling(_,m);var b=1/_[0],y=1/_[1],T=1/_[2],w=m[0]*b,P=m[1]*y,H=m[2]*T,$=m[4]*b,W=m[5]*y,q=m[6]*T,ye=m[8]*b,Ge=m[9]*y,Ke=m[10]*T,je=w+W+Ke,Xe=0;return je>0?(Xe=2*Math.sqrt(je+1),i[3]=.25*Xe,i[0]=(q-Ge)/Xe,i[1]=(ye-H)/Xe,i[2]=(P-$)/Xe):w>W&&w>Ke?(Xe=2*Math.sqrt(1+w-W-Ke),i[3]=(q-Ge)/Xe,i[0]=.25*Xe,i[1]=(P+$)/Xe,i[2]=(ye+H)/Xe):W>Ke?(Xe=2*Math.sqrt(1+W-w-Ke),i[3]=(ye-H)/Xe,i[0]=(P+$)/Xe,i[1]=.25*Xe,i[2]=(q+Ge)/Xe):(Xe=2*Math.sqrt(1+Ke-w-W),i[3]=(P-$)/Xe,i[0]=(ye+H)/Xe,i[1]=(q+Ge)/Xe,i[2]=.25*Xe),i},getScaling:getScaling,getTranslation:function(i,m){return i[0]=m[12],i[1]=m[13],i[2]=m[14],i},identity:identity,invert:invert,lookAt:lookAt,mul:P,multiply:multiply,multiplyScalar:function(i,m,g){return i[0]=m[0]*g,i[1]=m[1]*g,i[2]=m[2]*g,i[3]=m[3]*g,i[4]=m[4]*g,i[5]=m[5]*g,i[6]=m[6]*g,i[7]=m[7]*g,i[8]=m[8]*g,i[9]=m[9]*g,i[10]=m[10]*g,i[11]=m[11]*g,i[12]=m[12]*g,i[13]=m[13]*g,i[14]=m[14]*g,i[15]=m[15]*g,i},multiplyScalarAndAdd:function(i,m,g,_){return i[0]=m[0]+g[0]*_,i[1]=m[1]+g[1]*_,i[2]=m[2]+g[2]*_,i[3]=m[3]+g[3]*_,i[4]=m[4]+g[4]*_,i[5]=m[5]+g[5]*_,i[6]=m[6]+g[6]*_,i[7]=m[7]+g[7]*_,i[8]=m[8]+g[8]*_,i[9]=m[9]+g[9]*_,i[10]=m[10]+g[10]*_,i[11]=m[11]+g[11]*_,i[12]=m[12]+g[12]*_,i[13]=m[13]+g[13]*_,i[14]=m[14]+g[14]*_,i[15]=m[15]+g[15]*_,i},ortho:w,orthoNO:orthoNO,orthoZO:orthoZO,perspective:T,perspectiveFromFieldOfView:function(i,m,g,_){var b=Math.tan(m.upDegrees*Math.PI/180),y=Math.tan(m.downDegrees*Math.PI/180),T=Math.tan(m.leftDegrees*Math.PI/180),w=Math.tan(m.rightDegrees*Math.PI/180),P=2/(T+w),H=2/(b+y);return i[0]=P,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=H,i[6]=0,i[7]=0,i[8]=-(T-w)*P*.5,i[9]=(b-y)*H*.5,i[10]=_/(g-_),i[11]=-1,i[12]=0,i[13]=0,i[14]=_*g/(g-_),i[15]=0,i},perspectiveNO:perspectiveNO,perspectiveZO:function(i,m,g,_,b){var y=1/Math.tan(m/2);if(i[0]=y/g,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=y,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[11]=-1,i[12]=0,i[13]=0,i[15]=0,null!=b&&b!==1/0){var T=1/(_-b);i[10]=b*T,i[14]=b*_*T}else i[10]=-1,i[14]=-_;return i},rotate:function(i,g,_,b){var y,T,w,P,H,$,W,q,ye,Ge,Ke,je,Xe,Ye,Ze,Je,Qe,et,at,ht,ft,gt,xt,vt,bt=b[0],yt=b[1],St=b[2],Tt=Math.sqrt(bt*bt+yt*yt+St*St);return Tt<m?null:(bt*=Tt=1/Tt,yt*=Tt,St*=Tt,y=Math.sin(_),w=1-(T=Math.cos(_)),P=g[0],H=g[1],$=g[2],W=g[3],q=g[4],ye=g[5],Ge=g[6],Ke=g[7],je=g[8],Xe=g[9],Ye=g[10],Ze=g[11],Je=bt*bt*w+T,Qe=yt*bt*w+St*y,et=St*bt*w-yt*y,at=bt*yt*w-St*y,ht=yt*yt*w+T,ft=St*yt*w+bt*y,gt=bt*St*w+yt*y,xt=yt*St*w-bt*y,vt=St*St*w+T,i[0]=P*Je+q*Qe+je*et,i[1]=H*Je+ye*Qe+Xe*et,i[2]=$*Je+Ge*Qe+Ye*et,i[3]=W*Je+Ke*Qe+Ze*et,i[4]=P*at+q*ht+je*ft,i[5]=H*at+ye*ht+Xe*ft,i[6]=$*at+Ge*ht+Ye*ft,i[7]=W*at+Ke*ht+Ze*ft,i[8]=P*gt+q*xt+je*vt,i[9]=H*gt+ye*xt+Xe*vt,i[10]=$*gt+Ge*xt+Ye*vt,i[11]=W*gt+Ke*xt+Ze*vt,g!==i&&(i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15]),i)},rotateX:rotateX,rotateY:rotateY,rotateZ:rotateZ,scale:scale,set:function(i,m,g,_,b,y,T,w,P,H,$,W,q,ye,Ge,Ke,je){return i[0]=m,i[1]=g,i[2]=_,i[3]=b,i[4]=y,i[5]=T,i[6]=w,i[7]=P,i[8]=H,i[9]=$,i[10]=W,i[11]=q,i[12]=ye,i[13]=Ge,i[14]=Ke,i[15]=je,i},str:function(i){return"mat4("+i[0]+","+i[1]+","+i[2]+","+i[3]+","+i[4]+","+i[5]+","+i[6]+","+i[7]+","+i[8]+","+i[9]+","+i[10]+","+i[11]+","+i[12]+","+i[13]+","+i[14]+","+i[15]+")"},sub:H,subtract:subtract$1,targetTo:targetTo,translate:translate,transpose:function(i,m){if(i===m){var g=m[1],_=m[2],b=m[3],y=m[6],T=m[7],w=m[11];i[1]=m[4],i[2]=m[8],i[3]=m[12],i[4]=g,i[6]=m[9],i[7]=m[13],i[8]=_,i[9]=y,i[11]=m[14],i[12]=b,i[13]=T,i[14]=w}else i[0]=m[0],i[1]=m[4],i[2]=m[8],i[3]=m[12],i[4]=m[1],i[5]=m[5],i[6]=m[9],i[7]=m[13],i[8]=m[2],i[9]=m[6],i[10]=m[10],i[11]=m[14],i[12]=m[3],i[13]=m[7],i[14]=m[11],i[15]=m[15];return i}});function create$1(){var i=new g(3);return g!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0),i}function length(i){var m=i[0],g=i[1],_=i[2];return Math.sqrt(m*m+g*g+_*_)}function fromValues(i,m,_){var b=new g(3);return b[0]=i,b[1]=m,b[2]=_,b}function copy(i,m){return i[0]=m[0],i[1]=m[1],i[2]=m[2],i}function set(i,m,g,_){return i[0]=m,i[1]=g,i[2]=_,i}function subtract(i,m,g){return i[0]=m[0]-g[0],i[1]=m[1]-g[1],i[2]=m[2]-g[2],i}function distance(i,m){var g=m[0]-i[0],_=m[1]-i[1],b=m[2]-i[2];return Math.sqrt(g*g+_*_+b*b)}function normalize(i,m){var g=m[0],_=m[1],b=m[2],y=g*g+_*_+b*b;return y>0&&(y=1/Math.sqrt(y)),i[0]=m[0]*y,i[1]=m[1]*y,i[2]=m[2]*y,i}function dot(i,m){return i[0]*m[0]+i[1]*m[1]+i[2]*m[2]}function lerp$1(i,m,g,_){var b=m[0],y=m[1],T=m[2];return i[0]=b+_*(g[0]-b),i[1]=y+_*(g[1]-y),i[2]=T+_*(g[2]-T),i}function transformMat4(i,m,g){var _=m[0],b=m[1],y=m[2],T=g[3]*_+g[7]*b+g[11]*y+g[15];return T=T||1,i[0]=(g[0]*_+g[4]*b+g[8]*y+g[12])/T,i[1]=(g[1]*_+g[5]*b+g[9]*y+g[13])/T,i[2]=(g[2]*_+g[6]*b+g[10]*y+g[14])/T,i}create$1();var sqrDist=function(i,m){var g=m[0]-i[0],_=m[1]-i[1];return g*g+_*_};!function(){var i,m=(i=new g(2),g!=Float32Array&&(i[0]=0,i[1]=0),i)}();const W=create$2(),computeViewFrustumPlanes=(i,m)=>{multiply(W,i,m);const g=[[W[3]-W[0],W[7]-W[4],W[11]-W[8],W[15]-W[12]],[W[3]+W[0],W[7]+W[4],W[11]+W[8],W[15]+W[12]],[W[3]+W[1],W[7]+W[5],W[11]+W[9],W[15]+W[13]],[W[3]-W[1],W[7]-W[5],W[11]-W[9],W[15]-W[13]],[W[3]-W[2],W[7]-W[6],W[11]-W[10],W[15]-W[14]],[W[3]+W[2],W[7]+W[6],W[11]+W[10],W[15]+W[14]]];for(let i=0;i<6;i++){const m=g[i],_=Math.sqrt(m[0]*m[0]+m[1]*m[1]+m[2]*m[2]);m[0]/=_,m[1]/=_,m[2]/=_,m[3]/=_}return g},formatBytes=(i,m=2)=>{if(("number"!=typeof i||i<0||Number.isNaN(i)||!Number.isInteger(i))&&consoleAndThrowError("Invalid input:'bytes' must be a uint"),0===i)return"0 Bytes";const g=m<0?0:m,_=Math.floor(Math.log(i)/Math.log(1024));return parseFloat((i/Math.pow(1024,_)).toFixed(g))+" "+["Bytes","KB","MB","GB"][_]},mat4ToEuler=(i,m,g)=>{m=m||[0,0,0],g=g||"XYZ";let _=i[0],b=i[4],y=i[8],T=i[1],w=i[5],P=i[9],H=i[2],$=i[6],W=i[10];return"XYZ"===g?(m[1]=Math.asin(clamp(y,-1,1)),Math.abs(y)<.99999?(m[0]=Math.atan2(-P,W),m[2]=Math.atan2(-b,_)):(m[0]=Math.atan2($,w),m[2]=0)):"YXZ"===g?(m[0]=Math.asin(-clamp(P,-1,1)),Math.abs(P)<.99999?(m[1]=Math.atan2(y,W),m[2]=Math.atan2(T,w)):(m[1]=Math.atan2(-H,_),m[2]=0)):"ZXY"===g?(m[0]=Math.asin(clamp($,-1,1)),Math.abs($)<.99999?(m[1]=Math.atan2(-H,W),m[2]=Math.atan2(-b,w)):(m[1]=0,m[2]=Math.atan2(T,_))):"ZYX"===g?(m[1]=Math.asin(-clamp(H,-1,1)),Math.abs(H)<.99999?(m[0]=Math.atan2($,W),m[2]=Math.atan2(T,_)):(m[0]=0,m[2]=Math.atan2(-b,w))):"YZX"===g?(m[2]=Math.asin(clamp(T,-1,1)),Math.abs(T)<.99999?(m[0]=Math.atan2(-P,w),m[1]=Math.atan2(-H,_)):(m[0]=0,m[1]=Math.atan2(y,W))):"XZY"===g&&(m[2]=Math.asin(-clamp(b,-1,1)),Math.abs(b)<.99999?(m[0]=Math.atan2($,w),m[1]=Math.atan2(y,_)):(m[0]=Math.atan2(-P,W),m[1]=0)),m};let clamp=function(i,m,g){return Math.max(m,Math.min(g,i))};const quaternionToRotationMat4=(i,m)=>{let g=i[0],_=i[1],b=i[2],y=i[3],T=g+g,w=_+_,P=b+b,H=g*T,$=g*w,W=g*P,q=_*w,ye=_*P,Ge=b*P,Ke=y*T,je=y*w,Xe=y*P;return m[0]=1-(q+Ge),m[4]=$-Xe,m[8]=W+je,m[1]=$+Xe,m[5]=1-(H+Ge),m[9]=ye-Ke,m[2]=W-je,m[6]=ye+Ke,m[10]=1-(H+q),m[3]=0,m[7]=0,m[11]=0,m[12]=0,m[13]=0,m[14]=0,m[15]=1,m};function sortTransparentObjects(i,m){const g={},{x:_,y:b,z:y}=i;return m.sort((i,m)=>{if(i=i.mesh,m=m.mesh,!g[i.uuid]){const m=i.x-_,T=i.y-b,w=i.z-y;g[i.uuid]=m*m+T*T+w*w}if(!g[m.uuid]){const i=m.x-_,T=m.y-b,w=m.z-y;g[m.uuid]=i*i+T*T+w*w}return g[m.uuid]-g[i.uuid]})}const q=create$2(),ye={x:0,y:0,z:0,w:0},getScreenPoint=(i,m)=>{"View3D"!==i?.constructor?.name&&consoleAndThrowError("allow only View3D instance"),identity(q);const{noneJitterProjectionMatrix:g,rawCamera:_,pixelRectArray:b}=i;return multiply(q,g,_.modelMatrix),multiply(q,q,m),ye.z=q[14],ye.w=q[15],ye.x=.5*q[12]/ye.w+.5,ye.y=.5*q[13]/ye.w+.5,[(b[0]+ye.x*b[2])/window.devicePixelRatio,(b[1]+(1-ye.y)*b[3])/window.devicePixelRatio]},validateNumber=i=>"number"==typeof i||(consoleAndThrowError("Only numbers allowed."),!1),Ge=create$2(),localToWorld=(i,m,g,_)=>(validateNumber(m),validateNumber(g),validateNumber(_),identity(Ge),translate(Ge,Ge,[m,g,_]),multiply(Ge,i,Ge),[Ge[12],Ge[13],Ge[14]]);let Ke,je,Xe,Ye,Ze,Je,Qe=create$1(),et=create$2(),at=create$2();const screenToWorld=(i,m,g)=>{const{rawCamera:_,pixelRectArray:b}=g;return Ke=2*(i*window.devicePixelRatio+b[0])/b[2]-1,je=-2*(m*window.devicePixelRatio+b[1])/b[3]+1,Xe=1,multiply(at,g.noneJitterProjectionMatrix,_.modelMatrix),Je=clone(at),invert(Je,Je),Qe=fromValues(Ke,je,1),identity(et),translate(et,et,Qe),multiply(Je,Je,et),Qe[0]=Je[12],Qe[1]=Je[13],Qe[2]=Je[14],Ye=at[12]*Ke+at[13]*je+at[15],0!==Ye&&(Ze=1/Ye,Qe[0]/=Ze,Qe[1]/=Ze,Qe[2]/=Ze,Qe[0]=Qe[0]+_.x,Qe[1]=Qe[1]+_.y,Qe[2]=Qe[2]+_.z),[Qe[0],Qe[1],Qe[2]]},ht=create$2(),ft=create$1(),worldToLocal=(i,m,g,_)=>(validateNumber(m),validateNumber(g),validateNumber(_),invert(ht,i),set(ft,m,g,_),transformMat4(ft,ft,ht),[ft[0],ft[1],ft[2]]);function calculateTextureByteSize(i){const m={size:[i.width,i.height,i.depthOrArrayLayers],format:i.format,sampleCount:i.sampleCount,usage:i.usage};return function(i){switch(i){case"r8unorm":case"r8snorm":case"r8uint":case"r8sint":return 1;case"r16uint":case"r16sint":case"r16float":case"rg8unorm":case"rg8snorm":case"rg8uint":case"rg8sint":case"depth16unorm":return 2;case"r32uint":case"r32sint":case"r32float":case"rg16uint":case"rg16sint":case"rg16float":case"rgba8unorm":case"rgba8unorm-srgb":case"rgba8snorm":case"rgba8uint":case"rgba8sint":case"bgra8unorm":case"bgra8unorm-srgb":case"depth24plus":case"depth32float":return 4;case"rg32uint":case"rg32sint":case"rg32float":case"rgba16uint":case"rgba16sint":case"rgba16float":return 8;case"rgba32uint":case"rgba32sint":case"rgba32float":return 16;default:throw new Error(`Unrecognized texture format:${i}`)}}(m.format)*(m.size[0]*m.size[1]*(m.size[2]||1))*(m.sampleCount?m.sampleCount:1)}const getMipLevelCount=(i,m)=>Math.floor(Math.log2(Math.max(i,m)))+1,imageBitmapToGPUTexture=(i,m,g,_=!0)=>{const b=i.createTexture(g);for(let y=0;y<m.length;y++){const T=m[y],w={source:T},P={texture:b,origin:[0,0,y],premultipliedAlpha:_};g.format.includes("srgb")&&(P.colorSpace="srgb");const H=[T.width,T.height];i.queue.copyExternalImageToTexture(w,P,H)}return b};async function loadAndCreateBitmapImage(i,m="none",g="premultiply"){const _=await fetch(i),b=await _.blob();return createImageBitmap(b,{colorSpaceConversion:m,premultiplyAlpha:g})}const createUUID=()=>{const i="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");let m,g=0,_=["","","","","-","","","","-","4","","","-","","","","-","","","","","","-","","","","","","","","","","","",""];for(;g<36;)""===_[g]&&(m=16*Math.random()|0,_[g]=i[19===g?3&m|8:15&m]),g++;return _.join("")};class InstanceIdGenerator{static idMaps=new Map;static getNextId(i){let m=this.idMaps.get(i)||0;return this.idMaps.set(i,m+1),m}}Object.freeze(InstanceIdGenerator);const uuidToUint=i=>{const m=i.replace(/-/g,"").substring(0,8);return parseInt(m,16)},gt=console.log.bind(console);var xt=Object.freeze({__proto__:null,InstanceIdGenerator:InstanceIdGenerator,calculateNormals:calculateNormals,calculateTangents:(i,m,g,_,b)=>{const y=1e-6,T=i.length/3,w=_.length>0,P=w?_.length/3:T/3,H=new Float32Array(3*T),$=new Float32Array(3*T);for(let m=0;m<P;m++){const b=w?_[3*m]:3*m,T=w?_[3*m+1]:3*m+1,P=w?_[3*m+2]:3*m+2,W=i[3*b],q=i[3*b+1],ye=i[3*b+2],Ge=i[3*T],Ke=i[3*T+1],je=i[3*T+2],Xe=i[3*P],Ye=i[3*P+1],Ze=i[3*P+2],Je=g[2*b],Qe=g[2*b+1],et=g[2*T],at=g[2*T+1],ht=Ge-W,ft=Xe-W,gt=Ke-q,xt=Ye-q,vt=je-ye,bt=Ze-ye,yt=et-Je,St=g[2*P]-Je,Tt=at-Qe,Mt=g[2*P+1]-Qe,wt=yt*Mt-St*Tt,Ct=Math.abs(wt)<y?0:1/wt,Rt=(Mt*ht-Tt*ft)*Ct,Pt=(Mt*gt-Tt*xt)*Ct,Bt=(Mt*vt-Tt*bt)*Ct,It=(yt*ft-St*ht)*Ct,Et=(yt*xt-St*gt)*Ct,Dt=(yt*bt-St*vt)*Ct;H[3*b]+=Rt,H[3*b+1]+=Pt,H[3*b+2]+=Bt,H[3*T]+=Rt,H[3*T+1]+=Pt,H[3*T+2]+=Bt,H[3*P]+=Rt,H[3*P+1]+=Pt,H[3*P+2]+=Bt,$[3*b]+=It,$[3*b+1]+=Et,$[3*b+2]+=Dt,$[3*T]+=It,$[3*T+1]+=Et,$[3*T+2]+=Dt,$[3*P]+=It,$[3*P+1]+=Et,$[3*P+2]+=Dt}const W=[],q=b&&b.length>=4*T;for(let i=0;i<T;i++){if(q){const m=b[4*i],g=b[4*i+1],_=b[4*i+2];if(Math.sqrt(m*m+g*g+_*_)>y){W.push(m,g,_,b[4*i+3]);continue}}const g=m[3*i],_=m[3*i+1],T=m[3*i+2],w=H[3*i],P=H[3*i+1],ye=H[3*i+2],Ge=$[3*i],Ke=$[3*i+1],je=$[3*i+2],Xe=g*w+_*P+T*ye;let Ye=w-g*Xe,Ze=P-_*Xe,Je=ye-T*Xe,Qe=Math.sqrt(Ye*Ye+Ze*Ze+Je*Je);if(Qe<y){const i=Math.abs(g)<.9?[1,0,0]:[0,1,0];Ye=i[0]-g*(g*i[0]+_*i[1]+T*i[2]),Ze=i[1]-_*(g*i[0]+_*i[1]+T*i[2]),Je=i[2]-T*(g*i[0]+_*i[1]+T*i[2]),Qe=Math.sqrt(Ye*Ye+Ze*Ze+Je*Je)}Ye/=Qe,Ze/=Qe,Je/=Qe;const et=(_*Je-T*Ze)*Ge+(T*Ye-g*Je)*Ke+(g*Ze-_*Ye)*je<0?-1:1;W.push(Ye,Ze,Je,et)}return W},calculateTextureByteSize:calculateTextureByteSize,computeViewFrustumPlanes:computeViewFrustumPlanes,copyGPUBuffer:copyGPUBuffer,copyToTextureArray:function(i,m,g,_){const b=i.createCommandEncoder({label:"COPY_TO_TEXTURE_ARRAY"});b.copyTextureToTexture({texture:m},{texture:g,origin:[0,0,_]},[m.width,m.height,1]),i.queue.submit([b.finish()])},createUUID:createUUID,formatBytes:formatBytes,getAbsoluteURL:getAbsoluteURL,getFileExtension:getFileExtension,getFileName:getFileName,getFilePath:getFilePath,getMipLevelCount:getMipLevelCount,getScreenPoint:getScreenPoint,imageBitmapToGPUTexture:imageBitmapToGPUTexture,keepLog:gt,loadAndCreateBitmapImage:loadAndCreateBitmapImage,localToWorld:localToWorld,matToEuler:mat4ToEuler,quaternionToRotationMat4:quaternionToRotationMat4,screenToWorld:screenToWorld,sortTransparentObjects:sortTransparentObjects,uuidToUint:uuidToUint,worldToLocal:worldToLocal});const vt={CLAMP_TO_EDGE:"clamp-to-edge",REPEAT:"repeat",MIRRORED_REPEAT:"mirror-repeat"};Object.freeze(vt);const bt={NEAREST:"nearest",LINEAR:"linear"};Object.freeze(bt);const yt={NEAREST:"nearest",LINEAR:"linear"};Object.freeze(yt);const validateRedGPUContext=i=>{if("RedGPUContext"!==i?.constructor?.name){return consoleAndThrowError(`from ${i?.constructor?.name}:requires a RedGPUContext instance,but received:${i}`),!1}return!0};class ResourceBase{#u=createUUID();#l;#c;#h="";#f;#d;#m=[];#p;constructor(i,m){validateRedGPUContext(i),this.#p=m,this.#l=i,this.#c=i.gpuDevice}get cacheKey(){return this.#d}set cacheKey(i){this.#d=i}get resourceManagerKey(){return this.#p}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get uuid(){return this.#u}get gpuDevice(){return this.#c}get redGPUContext(){return this.#l}__addDirtyPipelineListener(i){this.#g(!0),this.#m.push(i)}__removeDirtyPipelineListener(i){const m=this.#m.indexOf(i);m>-1&&(this.#m.splice(m,1),this.#g(!1))}__fireListenerList(i=!1){for(const i of this.#m)i(this);i&&(this.#m.length=0)}#g(i){const{resourceManager:m}=this.#l;if("Sampler"!==this.constructor.name&&m){const g=m[this.#p];g||consoleAndThrowError("need managedStateKey",this.constructor.name);const _=g?.table.get(this.cacheKey);_&&(i?_.useNum++:_.useNum--)}}}const St=new Map,Tt=Object.values(bt),Mt=Object.values(vt),wt=Object.values(yt);class Sampler extends ResourceBase{#x;#_=bt.LINEAR;#v=bt.LINEAR;#b=yt.LINEAR;#y=vt.CLAMP_TO_EDGE;#S=vt.CLAMP_TO_EDGE;#T=vt.REPEAT;#M;#w;#C;#R=1;constructor(i,m){super(i),this.#P(m)}get addressModeU(){return this.#y}set addressModeU(i){this.#B(i,"addressModeU")}get addressModeV(){return this.#S}set addressModeV(i){this.#B(i,"addressModeV")}get addressModeW(){return this.#T}set addressModeW(i){this.#B(i,"addressModeW")}get mipmapFilter(){return this.#b}set mipmapFilter(i){this.#I(i,wt,"mipmapFilter")}get gpuSampler(){return this.#x}get magFilter(){return this.#_}set magFilter(i){this.#I(i,Tt,"magFilter")}get minFilter(){return this.#v}set minFilter(i){this.#I(i,Tt,"minFilter")}get maxAnisotropy(){return this.#R}set maxAnisotropy(i){validateUintRange(i,1,16),this.#R=i,this.#P()}get isAnisotropyValid(){return!this.#R||"linear"===this.#_&&"linear"===this.#v&&"linear"===this.#b}#E(){this.__fireListenerList()}#B(i,m){if(Mt.includes(i)){switch(m){case"addressModeU":this.#y=i;break;case"addressModeV":this.#S=i;break;case"addressModeW":this.#T=i}this.#P()}else consoleAndThrowError(`Invalid ${m} value. Must be one of ${Mt.join(",")},but received:${i}.`)}#I(i,m,g){if(m.includes(i)||null===i){switch(g){case"mipmapFilter":this.#b=i;break;case"magFilter":this.#_=i;break;case"minFilter":this.#v=i}this.#P()}else consoleAndThrowError(`Invalid ${g} value. Must be one of ${m.join(",")},but received:${i}.`)}#D(){return`${this.#_}:${this.#v}:${this.#b}:${this.#y}:${this.#S}:${this.#T}:${this.#M}:${this.#w}:${this.#C}:${this.#R}`}#P(i){i&&(i.magFilter&&(this.#_=i.magFilter),i.minFilter&&(this.#v=i.minFilter),i.mipmapFilter&&(this.#b=i.mipmapFilter),i.addressModeU&&(this.#y=i.addressModeU),i.addressModeV&&(this.#S=i.addressModeV),i.addressModeW&&(this.#T=i.addressModeW),void 0!==i.lodMinClamp&&(this.#M=i.lodMinClamp),void 0!==i.lodMaxClamp&&(this.#w=i.lodMaxClamp),i.compare&&(this.#C=i.compare),i.maxAnisotropy&&(this.#R=i.maxAnisotropy)),this.isAnisotropyValid||1===this.#R||(console.warn(`Invalid maxAnisotropy setting (${this.#R}) detected:magFilter(${this.#_}),minFilter(${this.#v}),mipmapFilter(${this.#b}) must all be set to 'linear' for anisotropic filtering to work. Falling back to default (1).`),this.#R=1);const m=this.#D();if(!St.has(m)){let i={};this.#_&&(i.magFilter=this.#_),this.#v&&(i.minFilter=this.#v),this.#b&&(i.mipmapFilter=this.#b),this.#y&&(i.addressModeU=this.#y),this.#S&&(i.addressModeV=this.#S),this.#T&&(i.addressModeW=this.#T),void 0!==this.#M&&(i.lodMinClamp=this.#M),void 0!==this.#w&&(i.lodMaxClamp=this.#w),this.#C&&(i.compare=this.#C),this.#R&&(i.maxAnisotropy=this.#R),St.set(m,this.redGPUContext.gpuDevice.createSampler(i))}this.#x=St.get(m),this.#E()}}Object.freeze(Sampler);class ManagementResourceBase extends ResourceBase{#L;constructor(i,m){super(i,m),m||consoleAndThrowError("need managedStateKey",this.constructor.name),this.#L=i.resourceManager[m],this.#L||consoleAndThrowError(m,"is not exist in RedGPUContext.resourceManager",this.constructor.name)}get targetResourceManagedState(){return this.#L}}class ResourceStateBitmapTexture{texture;src;cacheKey;useNum=0;uuid;constructor(i){this.texture=i,this.src=i.src,this.cacheKey=i.cacheKey,this.useNum=0,this.uuid=i.uuid}}class BitmapTexture extends ManagementResourceBase{#U;#A;#O;#k;#G;#F=0;#N=!0;#V;#z;#H;constructor(i,m,g=!0,_,b,y,T=!1){if(super(i,"managedBitmapTextureState"),this.#z=_,this.#H=b,this.#N=T,this.#k=g,this.#V=y||`${navigator.gpu.getPreferredCanvasFormat()}-srgb`,m){this.#A=this.#$(m),this.cacheKey=this.#K(m);const{table:i}=this.targetResourceManagedState;let g=i.get(this.cacheKey);if(g){const i=g.texture;return this.#z?.(i),i}this.src=m,this.#W()}}get width(){return this.#G?.width||0}get height(){return this.#G?.height||0}get usePremultiplyAlpha(){return this.#N}get videoMemorySize(){return this.#F}get gpuTexture(){return this.#U}get mipLevelCount(){return this.#O}get src(){return this.#A}set src(i){this.#A=this.#$(i),this.cacheKey=this.#K(i),this.#A&&this.#j(this.#A)}get useMipmap(){return this.#k}set useMipmap(i){this.#k=i,this.#X()}destroy(){const i=this.#U;this.#q(null),this.__fireListenerList(!0),this.#Y(),this.cacheKey=null,this.#A=null,i&&i.destroy()}#K(i){return i?"string"==typeof i?getAbsoluteURL(window.location.href,i):i.cacheKey||getAbsoluteURL(window.location.href,i.src):this.uuid}#$(i){return"string"==typeof i?i:i.src}#q(i){this.#U=i,i||(this.#G=null),this.__fireListenerList()}#W(){this.redGPUContext.resourceManager.registerManagementResource(this,new ResourceStateBitmapTexture(this))}#Y(){this.redGPUContext.resourceManager.unregisterManagementResource(this)}#X(){const{gpuDevice:i,resourceManager:m}=this.redGPUContext,{mipmapGenerator:g}=m;this.#U&&(this.#U.destroy(),this.#U=null),this.targetResourceManagedState.videoMemory-=this.#F,this.#F=0;const{width:_,height:b}=this.#G;this.#O=1;const y={size:[_,b],format:this.#V,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,label:this.#A};this.#k&&(this.#O=getMipLevelCount(_,b),y.mipLevelCount=this.#O,y.usage|=GPUTextureUsage.RENDER_ATTACHMENT);const T=imageBitmapToGPUTexture(i,[this.#G],y,this.#N);this.#F=calculateTextureByteSize(T),this.targetResourceManagedState.videoMemory+=this.#F,this.#k&&g.generateMipmap(T,y),this.#q(T)}async#Z(i){return new Promise((m,g)=>{const _=new Image;_.src=i,_.onload=()=>{const i=document.createElement("canvas");i.width=_.width||512,i.height=_.height||512;const b=i.getContext("2d");b?(b.fillStyle="rgba(0,0,0,0)",b.fillRect(0,0,i.width,i.height),b.drawImage(_,0,0,i.width,i.height),createImageBitmap(i,{colorSpaceConversion:"none",premultiplyAlpha:this.#N?"premultiply":"none"}).then(m).catch(g)):g(new Error("Canvas context could not be created."))},_.onerror=i=>{g(new Error(`Failed to load SVG:${i}`))}})}async#j(i){try{i.endsWith(".svg")?this.#G=await this.#Z(i):this.#G=await loadAndCreateBitmapImage(i,"none",this.#N?"premultiply":"none"),this.#X(),this.#z?.(this)}catch(i){console.error(i),this.#H?.(i)}}}Object.freeze(BitmapTexture);class DownSampleCubeMapGenerator{#l;#J=new Map;#Q=new Map;#ee=null;#te=null;#ne=null;#re=null;#ie=8;#ae=8;#se=new Map;#oe=new Map;constructor(i){this.#l=i}createSourceTextureView(i,m){const g=`DOWN_SAMPLE_CUBE_GENERATOR_SOURCE_VIEW_${i.label}_${m}`;if(!this.#se.has(g)){const _=i.createView({label:g,dimension:"cube",baseMipLevel:m,mipLevelCount:1});this.#se.set(g,_)}return this.#se.get(g)}createTargetTextureView(i,m){const g=`DOWN_SAMPLE_CUBE_GENERATOR_TARGET_VIEW_${i.label}_${m}`;if(!this.#se.has(g)){const _=i.createView({label:g,dimension:"2d-array",baseMipLevel:m,mipLevelCount:1,arrayLayerCount:6});this.#se.set(g,_)}return this.#se.get(g)}createBindGroup(i,m,g){const _=`DOWN_SAMPLE_CUBE_GENERATOR_BIND_GROUP_${m.label}_${g.label}`;if(!this.#oe.has(_)){const{gpuDevice:b}=this.#l,y=b.createBindGroup({label:_,layout:i,entries:[{binding:0,resource:m},{binding:1,resource:g},{binding:2,resource:this.#re},{binding:3,resource:{buffer:this.#te}}]});this.#oe.set(_,y)}return this.#oe.get(_)}async downsampleCubemap(i,m=256,g="rgba16float"){try{this.#ue(),this.#le();const{gpuDevice:_,resourceManager:b}=this.#l;if(!i)throw new Error("Invalid source cubemap texture");if(m<=0||!Number.isInteger(m))throw new Error("Target size must be a positive integer");const y=i.mipLevelCount,T=getMipLevelCount(m,m),w=b.createManagedTexture({size:[m,m,6],format:g,usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,dimension:"2d",mipLevelCount:T,label:`DOWN_SAMPLE_CUBE_GENERATOR_TEXTURE_${m}x${m}_${T}mips_${Date.now()}`});for(let _=0;_<T;_++){const b=Math.max(1,m>>_),T=this.#ce(i.width,m,_,y);await this.#he(i,w,T,_,b,g)}return this.#ue(),w}catch(i){throw console.error("큐브맵 다운샘플링 실패:",i),this.#ue(),i}}destroy(){this.#ue(),this.#te&&(this.#te.destroy(),this.#te=null),this.#J.clear(),this.#Q.clear(),this.#ee=null,this.#re=null}#ue(){this.#se.clear(),this.#oe.clear()}#le(){if(this.#ee)return;const{gpuDevice:i,resourceManager:m}=this.#l;this.#re=new Sampler(this.#l,{minFilter:"linear",magFilter:"linear",mipmapFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge"}).gpuSampler,this.#ee=m.createGPUShaderModule("DOWN_SAMPLE_CUBE_GENERATOR_COMPUTE_SHADER",{code:"\nstruct Uniforms { targetSize:f32, sourceMipLevel:f32, targetMipLevel:f32, padding:f32,\n};\n@group(0) @binding(0) var sourceCubemap:texture_cube<f32>;\n@group(0) @binding(1) var targetCubemap:texture_storage_2d_array<rgba16float,write>;\n@group(0) @binding(2) var cubemapSampler:sampler;\n@group(0) @binding(3) var<uniform> uniforms:Uniforms;\nfn cubemapUVToDirection(uv:vec2<f32>,face:u32) -> vec3<f32> { let u=uv.x * 2.0 - 1.0; let v=uv.y * 2.0 - 1.0; switch face { case 0u:{ return vec3<f32>(1.0,-v,-u); } case 1u:{ return vec3<f32>(-1.0,-v,u); } case 2u:{ return vec3<f32>(u,1.0,v); } case 3u:{ return vec3<f32>(u,-1.0,-v); } case 4u:{ return vec3<f32>(u,-v,1.0); } case 5u:{ return vec3<f32>(-u,-v,-1.0); } default:{ return vec3<f32>(0.0,0.0,1.0); } }\n}\nfn gaussianWeight(x:f32,y:f32,sigma:f32) -> f32 { let sigmaSq=sigma * sigma; return exp(-(x * x + y * y)/(2.0 * sigmaSq))/(2.0 * 3.14159265359 * sigmaSq);\n}\nfn clampCubemapUV(uv:vec2<f32>) -> vec2<f32> { return clamp(uv,vec2<f32>(0.0),vec2<f32>(1.0));\n}\n@compute @workgroup_size(8,8,1)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>) { let face=global_id.z; let coord=vec2<u32>(global_id.xy); let targetSize=u32(uniforms.targetSize); if (coord.x >=targetSize || coord.y >=targetSize || face >=6u) { return; } let uv=(vec2<f32>(coord) + 0.5)/f32(targetSize); let direction=normalize(cubemapUVToDirection(uv,face)); let sourceMipLevel=uniforms.sourceMipLevel; let targetMipLevel=uniforms.targetMipLevel; var color=vec4<f32>(0.0); if (sourceMipLevel==0.0 && targetSize > 64u) { let sampleCount=16u; let sampleRadius=1.0/f32(targetSize); var totalWeight=0.0; for (var i=0u;i < sampleCount;i++) { let angle=2.0 * 3.14159265359 * f32(i)/f32(sampleCount); let radius=sampleRadius * (0.5 + 0.5 * f32(i % 4u)/4.0); let offsetUV=clampCubemapUV(uv + vec2<f32>( cos(angle) * radius, sin(angle) * radius )); let sampleDir=normalize(cubemapUVToDirection(offsetUV,face)); let sampleColor=textureSampleLevel(sourceCubemap,cubemapSampler,sampleDir,sourceMipLevel); let weight=gaussianWeight( cos(angle) * radius * f32(targetSize), sin(angle) * radius * f32(targetSize), 0.8 ); color +=sampleColor * weight; totalWeight +=weight; } if (totalWeight > 0.0) { color=color/totalWeight; } } else if (sourceMipLevel==0.0 && targetSize > 16u) { let sampleCount=4u; let invSampleCount=1.0/f32(sampleCount * sampleCount); let sampleOffset=0.5/f32(targetSize); for (var x=0u;x < sampleCount;x++) { for (var y=0u;y < sampleCount;y++) { let offset=vec2<f32>( (f32(x) - 1.5) * sampleOffset, (f32(y) - 1.5) * sampleOffset ); let offsetUV=clampCubemapUV(uv + offset); let sampleDir=normalize(cubemapUVToDirection(offsetUV,face)); color +=textureSampleLevel(sourceCubemap,cubemapSampler,sampleDir,sourceMipLevel); } } color *=invSampleCount; } else if (targetSize > 4u) { let sampleCount=2u; let invSampleCount=1.0/f32(sampleCount * sampleCount); let sampleOffset=0.25/f32(targetSize); for (var x=0u;x < sampleCount;x++) { for (var y=0u;y < sampleCount;y++) { let offset=vec2<f32>( (f32(x) - 0.5) * sampleOffset, (f32(y) - 0.5) * sampleOffset ); let offsetUV=clampCubemapUV(uv + offset); let sampleDir=normalize(cubemapUVToDirection(offsetUV,face)); color +=textureSampleLevel(sourceCubemap,cubemapSampler,sampleDir,sourceMipLevel); } } color *=invSampleCount; } else { color=textureSampleLevel(sourceCubemap,cubemapSampler,direction,sourceMipLevel); } if (targetMipLevel > 0.0) { let luminance=dot(color.rgb,vec3<f32>(0.299,0.587,0.114)); let saturation=0.9 + 0.1/(1.0 + targetMipLevel * 0.1); color=vec4<f32>(mix(vec3<f32>(luminance),color.rgb,saturation),color.a); } textureStore(targetCubemap,vec2<i32>(coord),i32(face),color);\n}\n"}),this.#fe()}#de(i){if(!this.#J.has(i)){const{gpuDevice:m,resourceManager:g}=this.#l,_=g.createBindGroupLayout(`DOWN_SAMPLE_CUBE_GENERATOR_BIND_GROUP_LAYOUT_${i}`,{entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{viewDimension:"cube",sampleType:"float"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:i,viewDimension:"2d-array"}},{binding:2,visibility:GPUShaderStage.COMPUTE,sampler:{type:"filtering"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),b=m.createComputePipeline({label:`DOWN_SAMPLE_CUBE_GENERATOR_COMPUTE_PIPELINE_${i}`,layout:m.createPipelineLayout({label:`DOWN_SAMPLE_CUBE_GENERATOR_PIPELINE_LAYOUT_${i}`,bindGroupLayouts:[_]}),compute:{module:this.#ee,entryPoint:"main"}});this.#Q.set(i,_),this.#J.set(i,b)}return this.#J.get(i)}#fe(){const{gpuDevice:i,resourceManager:m}=this.#l;this.#ne={arrayBufferByteLength:16,properties:{targetSize:{byteOffset:0,size:4},sourceMipLevel:{byteOffset:4,size:4},targetMipLevel:{byteOffset:8,size:4},padding:{byteOffset:12,size:4}}},this.#te=i.createBuffer({size:this.#ne.arrayBufferByteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"DOWN_SAMPLE_CUBE_GENERATOR_UNIFORM_BUFFER"})}#ce(i,m,g,_){const b=i/Math.max(1,m>>g),y=Math.max(0,Math.floor(Math.log2(b)));return Math.min(y,_-1)}async#he(i,m,g,_,b,y){const{gpuDevice:T}=this.#l,w=this.#de(y),P=this.#Q.get(y),H=this.createSourceTextureView(i,g),$=this.createTargetTextureView(m,_),W=this.createBindGroup(P,H,$);this.#me(g,_,b);const q=T.createCommandEncoder({label:`DOWN_SAMPLE_CUBE_GENERATOR_COMMAND_ENCODER_MIP${_}`}),ye=q.beginComputePass({label:`DOWN_SAMPLE_CUBE_GENERATOR_COMPUTE_PASS_MIP${_}`});ye.setPipeline(w),ye.setBindGroup(0,W),ye.dispatchWorkgroups(Math.ceil(b/this.#ie),Math.ceil(b/this.#ae),6),ye.end();const Ge=q.finish();T.queue.submit([Ge]),await T.queue.onSubmittedWorkDone()}#me(i,m,g){const{gpuDevice:_}=this.#l,b=new Float32Array([g,i,m,0]);_.queue.writeBuffer(this.#te,0,b)}}Object.freeze(DownSampleCubeMapGenerator);const Ct={LOAD:"load",CLEAR:"clear"};Object.freeze(Ct);const Rt={STORE:"store",DISCARD:"discard"};Object.freeze(Rt);class MipmapGenerator{#l;#pe;#ge;#xe;#_e;#ve;#se=new Map;#oe=new Map;#be=new WeakMap;#ye=new WeakMap;constructor(i){this.#l=i,this.#pe=new Sampler(i,{minFilter:"linear"}).gpuSampler,this.#xe={}}createTextureView(i,m,g,_=!1){const b=`${m}_${g}`;if(_){let _=this.#ye.get(i);if(_||(_=new Map,this.#ye.set(i,_)),_.has(b))return _.get(b);const y=i.createView({baseMipLevel:m,mipLevelCount:1,dimension:"2d",baseArrayLayer:g,arrayLayerCount:1,label:`MIPMAP_GENERATOR_CACHED_${i.label}_${b}`});return _.set(b,y),y}{const _=`MIPMAP_GENERATOR_${i.label}_${m}_${g}`;if(!this.#se.has(_)){const b=i.createView({baseMipLevel:m,mipLevelCount:1,dimension:"2d",baseArrayLayer:g,arrayLayerCount:1,label:_});this.#se.set(_,b)}return this.#se.get(_)}}createBindGroup(i,m,g=!1){const{gpuDevice:_}=this.#l;if(g){let g=this.#be.get(i);g||(g=new Map,this.#be.set(i,g));const b=m.label||"unlabeled";if(g.has(b))return g.get(b);const y=_.createBindGroup({label:`MIPMAP_GENERATOR_BIND_GROUP_CACHED_${i.label}_${b}`,layout:this.#_e,entries:[{binding:0,resource:this.#pe},{binding:1,resource:m}]});return g.set(b,y),y}{const g=`${i.label}_${m.label}`;if(this.#oe.has(g))return this.#oe.get(g);const b=_.createBindGroup({label:`MIPMAP_GENERATOR_BIND_GROUP_TEMP_${g}`,layout:this.#_e,entries:[{binding:0,resource:this.#pe},{binding:1,resource:m}]});return this.#oe.set(g,b),b}}getMipmapPipeline(i){const{gpuDevice:m,resourceManager:g}=this.#l;let _=this.#xe[i];return _||(this.#ve||(this.#ve=g.createGPUShaderModule("MIPMAP_GENERATOR_SHADER_MODULE",{code:"\nvar<private> pos:array<vec2<f32>,3>=array<vec2<f32>,3>( vec2<f32>(-1.0,-1.0), vec2<f32>(-1.0,3.0), vec2<f32>(3.0,-1.0)\n);\nstruct VertexOutput { @builtin(position) position:vec4<f32>, @location(0) texCoord:vec2<f32>,\n};\n@vertex\nfn vertexMain(@builtin(vertex_index) vertexIndex:u32) -> VertexOutput { var output:VertexOutput; output.texCoord=pos[vertexIndex] * vec2<f32>(0.5,-0.5) + vec2<f32>(0.5); output.position=vec4<f32>(pos[vertexIndex],0.0,1.0); return output;\n}\n@group(0) @binding(0)\nvar imgSampler:sampler;\n@group(0) @binding(1)\nvar img:texture_2d<f32>;\n@fragment\nfn fragmentMain(@location(0) texCoord:vec2<f32>) -> @location(0) vec4<f32> { return textureSample(img,imgSampler,texCoord);\n}\n"}),this.#_e=g.createBindGroupLayout("MIPMAP_GENERATOR_FRAGMENT_BIND_GROUP_LAYOUT",{entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}}]}),this.#ge=g.createGPUPipelineLayout("MIPMAP_GENERATOR_PIPELINE_LAYOUT",{bindGroupLayouts:[this.#_e]})),_=m.createRenderPipeline({label:`MIPMAP_GENERATOR_PIPELINE_${i}`,layout:this.#ge,vertex:{module:this.#ve,entryPoint:"vertexMain"},fragment:{module:this.#ve,entryPoint:"fragmentMain",targets:[{format:i}]}}),this.#xe[i]=_),_}generateMipmap(i,m,g=!1){g||this.#ue();const{gpuDevice:_,resourceManager:b}=this.#l,y=this.getMipmapPipeline(m.format);if("3d"==m.dimension||"1d"==m.dimension)throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");let T=i;const w=m.size[0],P=m.size[1],H=m.size[2]||1,$=m.usage&GPUTextureUsage.RENDER_ATTACHMENT;if(!$){const i={size:{width:Math.max(1,w>>>1),height:Math.max(1,P>>>1),depthOrArrayLayers:H},format:m.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:m.mipLevelCount-1};T=b.createManagedTexture(i)}const W=_.createCommandEncoder({});for(let _=0;_<H;++_){let b=this.createTextureView(i,0,_,g),w=$?1:0;for(let P=1;P<m.mipLevelCount;++P){const m=this.createTextureView(T,w++,_,g),P=W.beginRenderPass({colorAttachments:[{view:m,clearValue:{r:0,g:0,b:0,a:0},loadOp:Ct.CLEAR,storeOp:Rt.STORE}]}),H=this.createBindGroup(i,b,g);P.setPipeline(y),P.setBindGroup(0,H),P.draw(3,1,0,0),P.end(),b=m}}if(!$){const g={width:Math.max(1,w>>>1),height:Math.max(1,P>>>1),depthOrArrayLayers:H};for(let _=1;_<m.mipLevelCount;++_)W.copyTextureToTexture({texture:T,mipLevel:_-1},{texture:i,mipLevel:_},g),g.width=Math.max(1,g.width>>>1),g.height=Math.max(1,g.height>>>1)}return _.queue.submit([W.finish()]),$||T.destroy(),g||this.#ue(),i}destroy(){this.#ue()}#ue(){this.#se.clear(),this.#oe.clear()}}Object.freeze(MipmapGenerator);class ResourceStateCubeTexture{texture;srcList;cacheKey;useNum=0;uuid;constructor(i){this.texture=i,this.srcList=i instanceof CubeTexture?i.srcList:void 0,this.cacheKey=i.cacheKey,this.useNum=0,this.uuid=i.uuid}}class CubeTexture extends ManagementResourceBase{static defaultViewDescriptor={dimension:"cube",aspect:"all",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:0,arrayLayerCount:6};#U;#Se;#O;#k;#Te;#F=0;#V;#z;#H;constructor(i,m,g=!0,_,b,y){super(i,"managedCubeTextureState"),this.#z=_,this.#H=b,this.#k=g,this.#V=y||`${navigator.gpu.getPreferredCanvasFormat()}-srgb`,this.#Se=this.#$(m),this.cacheKey=this.#K(m);const{table:T}=this.targetResourceManagedState;if(m){let i=T.get(this.cacheKey);if(i){const m=i.texture;return this.#z?.(m),m}this.srcList=m,this.#W()}}get viewDescriptor(){return{...CubeTexture.defaultViewDescriptor,mipLevelCount:this.#O}}get videoMemorySize(){return this.#F}get gpuTexture(){return this.#U}get mipLevelCount(){return this.#O}get srcList(){return this.#Se}set srcList(i){this.#Se=this.#$(i),this.cacheKey=this.#K(i),this.#Se?.length&&this.#j(this.#Se)}get useMipmap(){return this.#k}set useMipmap(i){this.#k=i,this.#X()}destroy(){const i=this.#U;this.#q(null),this.__fireListenerList(!0),this.#Y(),this.#Se=null,this.cacheKey=null,i&&i.destroy()}setGPUTextureDirectly(i,m,g=!0){this.#U&&(this.#U.destroy(),this.targetResourceManagedState.videoMemory-=this.#F),this.#U=i,this.#k=g,this.#O=i.mipLevelCount,this.cacheKey=m||`direct_${this.uuid}`,this.#F=calculateTextureByteSize(i),this.targetResourceManagedState.videoMemory+=this.#F,this.__fireListenerList()}#K(i){return i?i instanceof Array?i.length?i.toString():this.uuid:i.cacheKey||i.srcList.toString():this.uuid}#$(i){return i instanceof Array?i:i?.srcList}#q(i){this.#U=i,i||(this.#Te=null),this.__fireListenerList()}#W(){this.redGPUContext.resourceManager.registerManagementResource(this,new ResourceStateCubeTexture(this))}#Y(){this.redGPUContext.resourceManager.unregisterManagementResource(this)}#X(){const{gpuDevice:i,resourceManager:m}=this.redGPUContext,{mipmapGenerator:g}=m;this.#U&&(this.#U.destroy(),this.#U=null),this.#O=1;{const m=this.#Te,_=m[0],{width:b,height:y}=_,T={size:[b,y,6],format:this.#V,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,label:`cubeTexture_${this.#Se?.toString()||this.uuid}`};this.#k&&(this.#O=getMipLevelCount(b,y),T.mipLevelCount=this.#O,T.usage|=GPUTextureUsage.RENDER_ATTACHMENT);const w=imageBitmapToGPUTexture(i,m,T);this.targetResourceManagedState.videoMemory-=this.#F,this.#F=calculateTextureByteSize(w),this.targetResourceManagedState.videoMemory+=this.#F,this.#k&&g.generateMipmap(w,T),this.#q(w)}}async#j(i){this.#Te=await async function(i){const m=i.map(i=>loadAndCreateBitmapImage(i));return await Promise.all(m)}(i);try{this.#X(),this.#z?.(this)}catch(i){console.error(i),this.#H?.(i)}}}Object.freeze(CubeTexture);const Pt={TILE_COUNT_X:32,TILE_COUNT_Y:32,TILE_COUNT_Z:48,WORKGROUP_SIZE_X:8,WORKGROUP_SIZE_Y:4,WORKGROUP_SIZE_Z:8,MAX_LIGHTS_PER_CLUSTER:100,MAX_CLUSTER_LIGHTS:1024,getTotalTileSize:()=>Pt.TILE_COUNT_X*Pt.TILE_COUNT_Y*Pt.TILE_COUNT_Z,getClusterLightsBufferSize:()=>{const i=Pt.getTotalTileSize();return 8*i+8*Pt.MAX_LIGHTS_PER_CLUSTER*i+4},getDispatchSize:()=>[Math.ceil(Pt.TILE_COUNT_X/Pt.WORKGROUP_SIZE_X),Math.ceil(Pt.TILE_COUNT_Y/Pt.WORKGROUP_SIZE_Y),Math.ceil(Pt.TILE_COUNT_Z/Pt.WORKGROUP_SIZE_Z)]};Object.freeze(Pt);const Bt=Object.freeze({calcTintBlendMode:"\nfn rgbToHsl(rgb:vec3<f32>) -> vec3<f32> { let maxVal:f32=max(max(rgb.r,rgb.g),rgb.b); let minVal:f32=min(min(rgb.r,rgb.g),rgb.b); let delta:f32=maxVal - minVal; let eps=1e-6; let lightness:f32=(maxVal + minVal) * 0.5; if (delta < eps) { return vec3<f32>(0.0,0.0,lightness); } var saturation:f32; if (lightness < 0.5) { saturation=delta/(maxVal + minVal + eps); } else { saturation=delta/(2.0 - maxVal - minVal + eps); } var hue:f32=0.0; if (abs(rgb.r - maxVal) < eps) { hue=(rgb.g - rgb.b)/delta; if (rgb.g < rgb.b) { hue +=6.0; } } else if (abs(rgb.g - maxVal) < eps) { hue=(rgb.b - rgb.r)/delta + 2.0; } else { hue=(rgb.r - rgb.g)/delta + 4.0; } hue=hue/6.0; return vec3<f32>(hue,saturation,lightness);\n}\nfn hslToRgb(hsl:vec3<f32>) -> vec3<f32> { let h=hsl.x; let s=hsl.y; let l=hsl.z; if (s==0.0) { return vec3<f32>(l,l,l); } var q:f32; if (l < 0.5) { q=l * (1.0 + s); } else { q=l + s - l * s; } let p=2.0 * l - q; var r:f32; var g:f32; var b:f32; for (var i:i32=0;i < 3;i=i + 1) { var t:f32; if (i==0) { t=h + 1.0/3.0; } else if (i==1) { t=h; } else { t=h - 1.0/3.0; } if (t < 0.0) { t=t + 1.0; } if (t > 1.0) { t=t - 1.0; } var color:f32; if (t < 1.0/6.0) { color=p + (q - p) * 6.0 * t; } else if (t < 1.0/2.0) { color=q; } else if (t < 2.0/3.0) { color=p + (q - p) * (2.0/3.0 - t) * 6.0; } else { color=p; } if (i==0) { r=color; } else if (i==1) { g=color; } else { b=color; } } return vec3<f32>(r,g,b);\n}\nfn calcTintBlendMode(baseColor:vec4<f32>,tintBlendMode:u32,tint:vec4<f32>) -> vec4<f32> { var tintedColor:vec3<f32>; let eps=1e-6; switch (tintBlendMode) { case 0u:{  tintedColor=mix(baseColor.rgb,tint.rgb,tint.a); } case 1u:{  tintedColor=baseColor.rgb * tint.rgb; } case 2u:{  tintedColor=max(baseColor.rgb,tint.rgb); } case 3u:{  tintedColor=1.0 - (1.0 - baseColor.rgb) * (1.0 - tint.rgb); } case 4u:{  tintedColor=clamp(baseColor.rgb + tint.rgb,vec3<f32>(0.0),vec3<f32>(1.0)); } case 5u:{  tintedColor=clamp(baseColor.rgb - tint.rgb,vec3<f32>(0.0),vec3<f32>(1.0)); } case 6u:{  tintedColor=min(baseColor.rgb,tint.rgb); } case 7u:{  tintedColor=mix( 2.0 * baseColor.rgb * tint.rgb, 1.0 - 2.0 * (1.0 - baseColor.rgb) * (1.0 - tint.rgb), step(vec3<f32>(0.5),baseColor.rgb) ); } case 8u:{  tintedColor=clamp(baseColor.rgb/(1.0 - tint.rgb + eps),vec3<f32>(0.0),vec3<f32>(1.0)); } case 9u:{  tintedColor=1.0 - clamp((1.0 - baseColor.rgb)/(tint.rgb + eps),vec3<f32>(0.0),vec3<f32>(1.0)); } case 10u:{  tintedColor=mix( 2.0 * baseColor.rgb * tint.rgb, 1.0 - 2.0 * (1.0 - baseColor.rgb) * (1.0 - tint.rgb), step(vec3<f32>(0.5),tint.rgb) ); } case 11u:{  tintedColor=mix( baseColor.rgb * (tint.rgb + tint.rgb - vec3<f32>(1.0)), baseColor.rgb + tint.rgb - baseColor.rgb * tint.rgb, step(vec3<f32>(0.5),tint.rgb) ); } case 12u:{  tintedColor=abs(baseColor.rgb - tint.rgb); } case 13u:{  tintedColor=baseColor.rgb + tint.rgb - 2.0 * baseColor.rgb * tint.rgb; } case 14u:{  tintedColor=clamp(baseColor.rgb/(tint.rgb + eps),vec3<f32>(0.0),vec3<f32>(1.0)); } case 15u:{  tintedColor=mix( clamp(baseColor.rgb/(1.0 - (tint.rgb - vec3<f32>(0.5)) * 2.0 + eps),vec3<f32>(0.0),vec3<f32>(1.0)), 1.0 - clamp((1.0 - baseColor.rgb)/(tint.rgb * 2.0 + eps),vec3<f32>(0.0),vec3<f32>(1.0)), step(vec3<f32>(0.5),tint.rgb) ); } case 16u:{  tintedColor=clamp(baseColor.rgb + tint.rgb - vec3<f32>(1.0),vec3<f32>(0.0),vec3<f32>(1.0)); } case 17u:{  tintedColor=mix( min(baseColor.rgb,2.0 * tint.rgb), max(baseColor.rgb,2.0 * tint.rgb - vec3<f32>(1.0)), step(vec3<f32>(0.5),tint.rgb) ); } case 18u:{  let baseHsl=rgbToHsl(baseColor.rgb); let tintHsl=rgbToHsl(tint.rgb); tintedColor=hslToRgb(vec3<f32>(baseHsl.x,tintHsl.y,baseHsl.z)); } case 19u:{  let baseHsl=rgbToHsl(baseColor.rgb); let tintHsl=rgbToHsl(tint.rgb); tintedColor=hslToRgb(vec3<f32>(tintHsl.x,baseHsl.y,baseHsl.z)); } case 20u:{  let baseHsl=rgbToHsl(baseColor.rgb); let tintHsl=rgbToHsl(tint.rgb); tintedColor=hslToRgb(vec3<f32>(baseHsl.x,baseHsl.y,tintHsl.z)); } case 21u:{  let baseHsl=rgbToHsl(baseColor.rgb); let tintHsl=rgbToHsl(tint.rgb); tintedColor=hslToRgb(vec3<f32>(tintHsl.x,tintHsl.y,baseHsl.z)); } case 22u:{  tintedColor=1.0 - abs(1.0 - baseColor.rgb - tint.rgb); } default:{ tintedColor=baseColor.rgb; } } return vec4<f32>(tintedColor,baseColor.a * tint.a);\n}\n",calcDirectionalShadowVisibility:"fn calcDirectionalShadowVisibility( directionalShadowMap:texture_depth_2d, directionalShadowMapSampler:sampler_comparison, shadowDepthTextureSize:u32, bias:f32, shadowPos:vec3<f32>\n) -> f32 { let oneOverShadowDepthTextureSize=1.0/f32(shadowDepthTextureSize); let shadowDepth=clamp(shadowPos.z,0.0,1.0); var visibility:f32=0.0; for (var y=-1;y <=1;y++) { for (var x=-1;x <=1;x++) { let offset=vec2f(vec2(x,y)) * oneOverShadowDepthTextureSize; let tUV=shadowPos.xy + offset; let sampleVisibility=textureSampleCompare( directionalShadowMap, directionalShadowMapSampler, tUV, shadowDepth - bias ); if (tUV.x < 0.0 || tUV.x > 1.0 || tUV.y < 0.0 || tUV.y > 1.0) { visibility +=1.0; } else { visibility +=sampleVisibility; } } } visibility/=9.0; let depthFactor=shadowDepth; let minVisibility=0.2 + depthFactor * 0.6; return max(visibility,minVisibility);\n}\n",drawDirectionalShadowDepth:"struct OutputShadowData { @builtin(position) position:vec4<f32>,\n};\n@vertex\nfn drawDirectionalShadowDepth(inputData:InputData) -> OutputShadowData { var output:OutputShadowData; let u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let input_position=inputData.position; let input_vertexNormal=inputData.vertexNormal; let input_uv=inputData.uv; var position:vec4<f32>; position=u_modelMatrix * vec4<f32>(input_position,1.0); #redgpu_if useDisplacementTexture { let distance=distance(position.xyz,u_cameraPosition); let mipLevel=(distance/maxDistance) * maxMipLevel; let displacedPosition=calcDisplacementPosition( input_position, input_vertexNormal, displacementTexture, displacementTextureSampler, vertexUniforms.displacementScale, input_uv, mipLevel ); position=u_modelMatrix * vec4<f32>(displacedPosition,1.0); } #redgpu_endIf output.position=u_directionalLightProjectionViewMatrix * position; return output;\n}\n",normalFunctions:"\nfn cotangent_frame( N:vec3<f32>,p:vec3<f32>,uv:vec2<f32>) -> mat3x3<f32>{ let dp1:vec3<f32>=dpdx( p ); let dp2:vec3<f32>=dpdy( p ); let duv1:vec2<f32>=dpdx( uv ); let duv2:vec2<f32>=dpdy( uv ); let dp2perp:vec3<f32>=cross( dp2,N ); let dp1perp:vec3<f32>=cross( N,dp1 ); let T:vec3<f32>=dp2perp * duv1.x + dp1perp * duv2.x; let B:vec3<f32>=dp2perp * duv1.y + dp1perp * duv2.y; return mat3x3<f32>( normalize(T),normalize(B),N );\n}\nfn perturb_normal( N:vec3<f32>,position:vec3<f32>,texcoord:vec2<f32>,normalColor:vec3<f32>,normalPower:f32 ) -> vec3<f32> { var map:vec3<f32>=normalColor; map=normalColor * 2.0 - 1.0; map=vec3<f32>(map.xy * -normalPower,map.z); let TBN:mat3x3<f32>=cotangent_frame(N,position,texcoord); return normalize(TBN * map);\n}\n",calcPrePathBackground:"fn calcPrePathBackground( u_useKHR_materials_volume:bool,thicknessParameter:f32,u_KHR_dispersion:f32,u_KHR_attenuationDistance:f32,u_KHR_attenuationColor:vec3<f32>, ior:f32,roughnessParameter:f32,albedo:vec3<f32>, projectionCameraMatrix:mat4x4<f32>,input_vertexPosition:vec3<f32>,input_ndcPosition:vec3<f32>, V:vec3<f32>,N:vec3<f32>, renderPath1ResultTexture:texture_2d<f32>,renderPath1ResultTextureSampler:sampler\n) -> vec3<f32> { var prePathBackground=vec3<f32>(0.0); let maxMipLevel=f32(textureNumLevels(renderPath1ResultTexture) - 1); let transmissionMipLevel=clamp(roughnessParameter * maxMipLevel,0.0,maxMipLevel); if(u_useKHR_materials_volume){ var iorR:f32=ior; var iorG:f32=ior; var iorB:f32=ior; if(u_KHR_dispersion > 0.0){ let halfSpread:f32=(ior - 1.0) * 0.025 * u_KHR_dispersion; iorR=ior + halfSpread; iorG=ior; iorB=ior - halfSpread; } iorR=max(iorR,1.0001); iorG=max(iorG,1.0001); iorB=max(iorB,1.0001); let refractedVecR:vec3<f32>=refract(-V,N,1.0/iorR); let refractedVecG:vec3<f32>=refract(-V,N,1.0/iorG); let refractedVecB:vec3<f32>=refract(-V,N,1.0/iorB); let validR=dot(refractedVecR,refractedVecR) > 0.0; let validG=dot(refractedVecG,refractedVecG) > 0.0; let validB=dot(refractedVecB,refractedVecB) > 0.0; let finalRefractR=select(reflect(-V,N),refractedVecR,validR); let finalRefractG=select(reflect(-V,N),refractedVecG,validG); let finalRefractB=select(reflect(-V,N),refractedVecB,validB); let safeThickness=clamp(thicknessParameter,0.0,100.0); let worldPosR:vec3<f32>=input_vertexPosition + finalRefractR * safeThickness; let worldPosG:vec3<f32>=input_vertexPosition + finalRefractG * safeThickness; let worldPosB:vec3<f32>=input_vertexPosition + finalRefractB * safeThickness; let clipPosR:vec4<f32>=projectionCameraMatrix * vec4<f32>(worldPosR,1.0); let clipPosG:vec4<f32>=projectionCameraMatrix * vec4<f32>(worldPosG,1.0); let clipPosB:vec4<f32>=projectionCameraMatrix * vec4<f32>(worldPosB,1.0); let wR=max(abs(clipPosR.w),0.0001); let wG=max(abs(clipPosG.w),0.0001); let wB=max(abs(clipPosB.w),0.0001); let ndcR:vec2<f32>=clipPosR.xy/wR * 0.5 + 0.5; let ndcG:vec2<f32>=clipPosG.xy/wG * 0.5 + 0.5; let ndcB:vec2<f32>=clipPosB.xy/wB * 0.5 + 0.5; let finalUV_R:vec2<f32>=clamp(vec2<f32>(ndcR.x,1.0 - ndcR.y),vec2<f32>(0.0),vec2<f32>(1.0)); let finalUV_G:vec2<f32>=clamp(vec2<f32>(ndcG.x,1.0 - ndcG.y),vec2<f32>(0.0),vec2<f32>(1.0)); let finalUV_B:vec2<f32>=clamp(vec2<f32>(ndcB.x,1.0 - ndcB.y),vec2<f32>(0.0),vec2<f32>(1.0)); let sampledR=textureSampleLevel(renderPath1ResultTexture,renderPath1ResultTextureSampler,finalUV_R,transmissionMipLevel).r; let sampledG=textureSampleLevel(renderPath1ResultTexture,renderPath1ResultTextureSampler,finalUV_G,transmissionMipLevel).g; let sampledB=textureSampleLevel(renderPath1ResultTexture,renderPath1ResultTextureSampler,finalUV_B,transmissionMipLevel).b; prePathBackground.r=select(0.0,sampledR,isFiniteScalar(sampledR)); prePathBackground.g=select(0.0,sampledG,isFiniteScalar(sampledG)); prePathBackground.b=select(0.0,sampledB,isFiniteScalar(sampledB)); } else { let safeIor=max(ior,1.0001); let refractedVec:vec3<f32>=refract(-V,N,1.0/safeIor); let valid=dot(refractedVec,refractedVec) > 0.0; let finalRefract=select(reflect(-V,N),refractedVec,valid); let safeThickness=clamp(thicknessParameter,0.0,100.0); let worldPos:vec3<f32>=input_vertexPosition + finalRefract * safeThickness; let clipPos:vec4<f32>=projectionCameraMatrix * vec4<f32>(worldPos,1.0); let w=max(abs(clipPos.w),0.0001); let ndc:vec2<f32>=clipPos.xy/w * 0.5 + 0.5; let finalUV:vec2<f32>=clamp(vec2<f32>(ndc.x,1.0 - ndc.y),vec2<f32>(0.0),vec2<f32>(1.0)); let sampled=textureSampleLevel(renderPath1ResultTexture,renderPath1ResultTextureSampler,finalUV,transmissionMipLevel).rgb; prePathBackground=select(vec3<f32>(0.0),sampled,all(isFiniteVec3(sampled))); } let safeAlbedo=clamp(albedo,vec3<f32>(0.0),vec3<f32>(1.0)); prePathBackground *=safeAlbedo; prePathBackground=select(vec3<f32>(0.0),prePathBackground,all(isFiniteVec3(prePathBackground))); return prePathBackground;\n}\nfn isFiniteScalar(x:f32) -> bool { return x==x && abs(x) < 1e30;\n}\nfn isFiniteVec3(v:vec3<f32>) -> vec3<bool> { return vec3<bool>( v.x==v.x && abs(v.x) < 1e30, v.y==v.y && abs(v.y) < 1e30, v.z==v.z && abs(v.z) < 1e30 );\n}",calculateMotionVector:"fn calculateMotionVector( currentClipPos:vec4<f32>, prevClipPos:vec4<f32>,\n) -> vec2<f32> { let currentNDC=currentClipPos.xy/max(currentClipPos.w,1e-6); let prevNDC=prevClipPos.xy/max(prevClipPos.w,1e-6); var motionVector=currentNDC - prevNDC; motionVector.y=-motionVector.y; let uvMotionVector=motionVector * 0.5; return uvMotionVector;\n}\n",FragmentOutput:"struct FragmentOutput { @location(0) color:vec4<f32>, @location(1) gBufferNormal:vec4<f32>, @location(2) gBufferMotionVector:vec4<f32>,\n}\n",picking:"@vertex\nfn picking(inputData:InputData) -> OutputData { var output:OutputData; let input_position=inputData.position; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; var position:vec4<f32>=u_modelMatrix * vec4<f32>(input_position,1.0); output.position=u_projectionCameraMatrix * position; output.pickingId=unpack4x8unorm(vertexUniforms.pickingId); return output;\n}\n",drawPicking:"\n@fragment\nfn picking(inputData:InputData) -> @location(0) vec4<f32> { var finalColor:vec4<f32>=inputData.pickingId; return finalColor;\n}\n"});Object.freeze(Bt);const It=Object.freeze({calcDisplacements:"fn calcDisplacementPosition(input_position:vec3<f32>,input_vertexNormal:vec3<f32>,displacementTexture:texture_2d<f32>,displacementTextureSampler:sampler,displacementScale:f32,input_uv:vec2<f32>,mipLevel:f32) -> vec3<f32> { let displacementSample=textureSampleLevel(displacementTexture,displacementTextureSampler,input_uv,mipLevel).r; let scaledDisplacement=(displacementSample - 0.5) * displacementScale; let displacedPosition=input_position + input_vertexNormal * scaledDisplacement; return displacedPosition;\n}\nfn calcDisplacementNormal( input_vertexNormal:vec3<f32>, displacementTexture:texture_2d<f32>, displacementTextureSampler:sampler, displacementScale:f32, input_uv:vec2<f32>, mipLevel:f32\n) -> vec3<f32> { let textureDimensions=vec2<f32>(textureDimensions(displacementTexture,0)); let adaptiveOffset=vec2<f32>(1.0)/textureDimensions; let actualMipLevel=mipLevel; let center=textureSampleLevel(displacementTexture,displacementTextureSampler,input_uv,actualMipLevel).r; let left=textureSampleLevel(displacementTexture,displacementTextureSampler,input_uv - vec2<f32>(adaptiveOffset.x,0.0),actualMipLevel).r; let right=textureSampleLevel(displacementTexture,displacementTextureSampler,input_uv + vec2<f32>(adaptiveOffset.x,0.0),actualMipLevel).r; let down=textureSampleLevel(displacementTexture,displacementTextureSampler,input_uv - vec2<f32>(0.0,adaptiveOffset.y),actualMipLevel).r; let up=textureSampleLevel(displacementTexture,displacementTextureSampler,input_uv + vec2<f32>(0.0,adaptiveOffset.y),actualMipLevel).r; let ddx=((right - 0.5) - (left - 0.5)) * displacementScale/(2.0 * adaptiveOffset.x); let ddy=((up - 0.5) - (down - 0.5)) * displacementScale/(2.0 * adaptiveOffset.y); let tangentSpaceNormal=normalize(vec3<f32>(-ddx,-ddy,1.0)); let worldNormal=normalize(input_vertexNormal); let normalStrength=clamp(1.0 - mipLevel * 0.1,0.2,1.0); let blendedNormal=normalize(mix(worldNormal,tangentSpaceNormal,normalStrength * 0.3)); return blendedNormal;\n}\n",getBillboardMatrix:"fn getBillboardMatrix(cameraMatrix:mat4x4<f32>,modelMatrix:mat4x4<f32>) -> mat4x4<f32> { let scaleX=length(vec3<f32>(modelMatrix[0].xyz)); let scaleY=length(vec3<f32>(modelMatrix[1].xyz)); let scaleZ=length(vec3<f32>(modelMatrix[2].xyz)); let scaleMatrix=mat4x4<f32>( vec4<f32>(scaleX,0.0,0.0,0.0), vec4<f32>(0.0,scaleY,0.0,0.0), vec4<f32>(0.0,0.0,scaleZ,0.0), vec4<f32>(0.0,0.0,0.0,1.0) ); var resultMatrix=cameraMatrix * modelMatrix; resultMatrix[0][0]=1.0;resultMatrix[0][1]=0.0;resultMatrix[0][2]=0.0; resultMatrix[1][0]=0.0;resultMatrix[1][1]=1.0;resultMatrix[1][2]=0.0; resultMatrix[2][0]=0.0;resultMatrix[2][1]=0.0;resultMatrix[2][2]=1.0; return resultMatrix * scaleMatrix;\n}\nfn getBillboardMatrixNoScaleRatio( cameraMatrix:mat4x4<f32>,modelMatrix:mat4x4<f32>)-> mat4x4<f32>{ var resultMatrix=cameraMatrix * modelMatrix; resultMatrix[0][0]=modelMatrix[0][0];resultMatrix[0][1]=0.0;resultMatrix[0][2]=0.0; resultMatrix[1][0]=0.0;resultMatrix[1][1]=modelMatrix[1][1];resultMatrix[1][2]=0.0; resultMatrix[2][0]=0.0;resultMatrix[2][1]=0.0;resultMatrix[2][2]=modelMatrix[2][2]; return resultMatrix;\n}\n",extractScaleAndTranslation:"fn extractScaleAndTranslation(modelMatrix:mat4x4<f32>) -> mat4x4<f32> { let scaleX=length(vec3<f32>(modelMatrix[0].xyz)); let scaleY=length(vec3<f32>(modelMatrix[1].xyz)); let scaleZ=length(vec3<f32>(modelMatrix[2].xyz)); let scaleMatrix=mat4x4<f32>( vec4<f32>(scaleX,0.0,0.0,0.0), vec4<f32>(0.0,scaleY,0.0,0.0), vec4<f32>(0.0,0.0,scaleZ,0.0), vec4<f32>(0.0,0.0,0.0,1.0) ); return mat4x4<f32>( scaleMatrix[0], scaleMatrix[1], scaleMatrix[2], modelMatrix[3]  );\n}\n",meshVertexBasicUniform:"struct MatrixList{ localMatrix:mat4x4<f32>, modelMatrix:mat4x4<f32>, prevModelMatrix:mat4x4<f32>, normalModelMatrix:mat4x4<f32>,\n}\nstruct VertexUniforms { matrixList:MatrixList, pickingId:u32, receiveShadow:f32, combinedOpacity:f32, useDisplacementTexture:u32, displacementScale:f32, disableJitter:u32,\n};"});Object.freeze(It);const Et=Object.freeze({SYSTEM_UNIFORM:"struct DirectionalLight { direction:vec3<f32>, color:vec3<f32>, intensity:f32,\n};\nstruct AmbientLight { color:vec3<f32>, intensity:f32\n};\nstruct Camera { cameraMatrix:mat4x4<f32>, cameraPosition:vec3<f32>, nearClipping:f32, farClipping:f32\n};\nstruct SystemUniform { projectionMatrix:mat4x4<f32>, projectionCameraMatrix:mat4x4<f32>, noneJitterProjectionMatrix:mat4x4<f32>, noneJitterProjectionCameraMatrix:mat4x4<f32>, inverseProjectionMatrix:mat4x4<f32>, prevNoneJitterProjectionCameraMatrix:mat4x4<f32>, resolution:vec2<f32>, camera:Camera, time:f32, useIblTexture:u32, isView3D:u32, shadowDepthTextureSize:u32, bias:f32, directionalLightCount:u32, directionalLightProjectionViewMatrix:mat4x4<f32>, directionalLightProjectionMatrix:mat4x4<f32>, directionalLightViewMatrix:mat4x4<f32>, directionalLights:array<DirectionalLight,3>, ambientLight:AmbientLight,\n};\n@group(0) @binding(0) var<uniform> systemUniforms:SystemUniform;\n@group(0) @binding(1) var directionalShadowMapSampler:sampler_comparison;\n@group(0) @binding(2) var directionalShadowMap:texture_depth_2d;\n@group(0) @binding(3) var iblTextureSampler:sampler;\n@group(0) @binding(7) var renderPath1ResultTextureSampler:sampler;\n@group(0) @binding(8) var renderPath1ResultTexture:texture_2d<f32>;\n@group(0) @binding(9) var packedTextureSampler:sampler;\n@group(0) @binding(10) var ibl_environmentTexture:texture_cube<f32>;\n@group(0) @binding(11) var ibl_irradianceTexture:texture_cube<f32>;\nconst clusterLight_indicesLength:u32=u32(REDGPU_DEFINE_MAX_LIGHTS_PER_CLUSTERu * REDGPU_DEFINE_TOTAL_TILESu);\nconst clusterLight_tileCount=vec3<u32>(REDGPU_DEFINE_TILE_COUNT_Xu,REDGPU_DEFINE_TILE_COUNT_Yu,REDGPU_DEFINE_TILE_COUNT_Zu);\nstruct ClusterLights { offset:u32, count:u32\n};\nstruct ClusterLightsGroup { offset:atomic<u32>, lights:array<ClusterLights,REDGPU_DEFINE_TOTAL_TILES>, indices:array<u32,clusterLight_indicesLength>\n};\nstruct ClusterLight_ClusterCube { minAABB:vec4<f32>, maxAABB:vec4<f32> };\nstruct ClusterLight_Clusters { cubeList:array<ClusterLight_ClusterCube,REDGPU_DEFINE_TOTAL_TILES>\n};\nfn linearDepth(depthSample:f32) -> f32 { return systemUniforms.camera.farClipping*systemUniforms.camera.nearClipping/fma(depthSample,systemUniforms.camera.nearClipping-systemUniforms.camera.farClipping,systemUniforms.camera.farClipping);\n}\nfn getClusterLightClusterIndex(fragCoord:vec4<f32>) -> u32 { let tile=getClusterLightTile(fragCoord); return tile.x + tile.y * clusterLight_tileCount.x + tile.z * clusterLight_tileCount.x * clusterLight_tileCount.y;\n}\nfn getClusterLightTile(fragCoord:vec4<f32>) -> vec3<u32> { let sliceScale=f32(clusterLight_tileCount.z)/log2(systemUniforms.camera.farClipping/systemUniforms.camera.nearClipping); let sliceBias=-(f32(clusterLight_tileCount.z) * log2(systemUniforms.camera.nearClipping)/log2(systemUniforms.camera.farClipping/systemUniforms.camera.nearClipping)); let zTile=u32(max(log2(linearDepth(fragCoord.z)) * sliceScale + sliceBias,0.0)); return vec3<u32>(u32(fragCoord.x/(systemUniforms.resolution.x/f32(clusterLight_tileCount.x))), u32(fragCoord.y/(systemUniforms.resolution.y/f32(clusterLight_tileCount.y))), zTile);\n}\nstruct ClusterLight { position:vec3<f32>,radius:f32, color:vec3<f32>,intensity:f32, isSpotLight:f32,directionX:f32,directionY:f32,directionZ:f32, outerCutoff:f32,innerCutoff:f32,\n};\nstruct ClusterLightList { count:vec4<f32>, lights:array<ClusterLight>\n};\n@group(0) @binding(5) var<storage> clusterLightList:ClusterLightList;\n@group(0) @binding(6) var<storage,read_write> clusterLightGroup:ClusterLightsGroup;\n",...It,...Bt});Object.freeze(Et);class ShaderVariantGenerator{#Me=new Map;#we;#Ce;constructor(i,m){this.#we=i,this.#Ce=m}getVariant(i){if(this.#Me.has(i))return this.#Me.get(i);const m="none"===i?[]:i.split("+"),g=this.#Re(m);return this.#Me.set(i,g),g}getCachedVariants(){return Array.from(this.#Me.keys())}#Re(i){let m=this.#we;for(let g=this.#Ce.length-1;g>=0;g--){const _=this.#Ce[g];m=i.includes(_.uniformName)?m.replace(_.fullMatch,_.ifBlock):m.replace(_.fullMatch,_.elseBlock||"")}return m}}const Dt=Object.keys(Et).join("|"),Lt=new RegExp(`#redgpu_include (${Dt})`,"g"),Ut=/REDGPU_DEFINE_(?:TILE_COUNT_[XYZ]|TOTAL_TILES|WORKGROUP_SIZE_[XYZ]|MAX_LIGHTS_PER_CLUSTER)/g,At={REDGPU_DEFINE_TILE_COUNT_X:Pt.TILE_COUNT_X.toString(),REDGPU_DEFINE_TILE_COUNT_Y:Pt.TILE_COUNT_Y.toString(),REDGPU_DEFINE_TILE_COUNT_Z:Pt.TILE_COUNT_Z.toString(),REDGPU_DEFINE_TOTAL_TILES:Pt.getTotalTileSize().toString(),REDGPU_DEFINE_WORKGROUP_SIZE_X:Pt.WORKGROUP_SIZE_X.toString(),REDGPU_DEFINE_WORKGROUP_SIZE_Y:Pt.WORKGROUP_SIZE_Y.toString(),REDGPU_DEFINE_WORKGROUP_SIZE_Z:Pt.WORKGROUP_SIZE_Z.toString(),REDGPU_DEFINE_MAX_LIGHTS_PER_CLUSTER:Pt.MAX_LIGHTS_PER_CLUSTER.toString()},Ot=/#redgpu_if\s+(\w+)\b([\s\S]*?)(?:#redgpu_else([\s\S]*?))?#redgpu_endIf/g,kt=new Map,preprocessWGSL=i=>{const m=(i=>{let m=0;for(let g=0;g<i.length;g++)m=(m<<5)-m+i.charCodeAt(g),m&=m;return m.toString(36)})(i),g=kt.get(m);if(g)return g;const _=(i=>i.replace(Lt,(i,m)=>Et[m]||i))(i),b=(i=>i.replace(Ut,i=>At[i]||i))(_),y=(i=>{const m=[];let g,_=0;for(Ot.lastIndex=0;null!==(g=Ot.exec(i));){const[i,b,y,T]=g;m.push({uniformName:b,ifBlock:y.trim(),elseBlock:T?.trim(),fullMatch:i,blockIndex:_++})}return m})(b);(i=>{if(!i.length)return;const m=new Map;i.forEach(i=>{m.set(i.uniformName,(m.get(i.uniformName)||0)+1)}),Array.from(m.entries()).filter(([i,m])=>m>1).length})(y);const T=((i,m)=>{let g=i;for(let i=m.length-1;i>=0;i--){const _=m[i];g=g.replace(_.fullMatch,_.ifBlock)}return g})(b,y),w=[...new Set(y.map(i=>i.uniformName))],P={cacheKey:m,defaultSource:T,shaderSourceVariant:new ShaderVariantGenerator(b,y),conditionalBlocks:w};return Math.pow(2,w.length),kt.set(m,P),P};class ResourceStatusInfo{table=new Map;videoMemory=0;constructor(){}}var Gt;Object.freeze(ResourceStatusInfo),function(i){i.GPUShaderModule="GPUShaderModule",i.GPUBindGroupLayout="GPUBindGroupLayout",i.GPUPipelineLayout="GPUPipelineLayout",i.GPUBuffer="GPUBuffer"}(Gt||(Gt={}));class ResourceManager{static PRESET_GPUBindGroupLayout_System="PRESET_GPUBindGroupLayout_System";static PRESET_VERTEX_GPUBindGroupLayout_Instancing="PRESET_VERTEX_GPUBindGroupLayout_Instancing";static PRESET_VERTEX_GPUBindGroupLayout="PRESET_VERTEX_GPUBindGroupLayout";static PRESET_VERTEX_GPUBindGroupLayout_SKIN="PRESET_VERTEX_GPUBindGroupLayout_SKIN";#Pe=0;#Be=new ImmutableKeyMap([[Gt.GPUShaderModule,new Map],[Gt.GPUBindGroupLayout,new Map],[Gt.GPUPipelineLayout,new Map],[Gt.GPUBuffer,new MemoryTrackingMap]]);#Ie=new ResourceStatusInfo;#Ee=new ResourceStatusInfo;#De=new ResourceStatusInfo;#Le=new ResourceStatusInfo;#Ue=new ResourceStatusInfo;#Ae=new ResourceStatusInfo;#Oe=new ResourceStatusInfo;#ke={};#Ge;#Fe;#Ne;#Ve;#ze;#He=new WeakMap;#$e=new WeakMap;#l;#c;constructor(i){this.#l=i,this.#c=i.gpuDevice,this.#Ne=new MipmapGenerator(i),this.#Ve=new DownSampleCubeMapGenerator(i),this.#Ke()}get redGPUContext(){return this.#l}get gpuDevice(){return this.#c}get basicSampler(){return this.#ze}get mipmapGenerator(){return this.#Ne}get downSampleCubeMapGenerator(){return this.#Ve}get cachedBufferState(){return this.#ke}get emptyBitmapTextureView(){return this.#Ge}get emptyCubeTextureView(){return this.#Fe}get managedBitmapTextureState(){return this.#Ie}get managedCubeTextureState(){return this.#Ee}get managedHDRTextureState(){return this.#De}get managedUniformBufferState(){return this.#Le}get managedVertexBufferState(){return this.#Ue}get managedIndexBufferState(){return this.#Ae}get managedStorageBufferState(){return this.#Oe}get resources(){return this.#Be}registerManagementResource(i,m){const{cacheKey:g,targetResourceManagedState:_}=i,{table:b}=_;b.get(g)?gt(`Resource with cacheKey ${g} is already registered.`):(b.set(g,m),_.videoMemory+=i.videoMemorySize)}unregisterManagementResource(i){const{cacheKey:m,targetResourceManagedState:g}=i,{table:_}=g;_.get(m)&&(g.videoMemory-=i.videoMemorySize,_.delete(m))}createManagedTexture(i){const m=this.gpuDevice.createTexture(i),g=m.destroy.bind(m);return m.destroy=()=>{this.#We(m,i),g()},m}getGPUResourceBitmapTextureView(i,m){const g=i instanceof GPUTexture?i:i?.gpuTexture;if(!g)return this.#Ge;let _=this.#He.get(g);_||(_=new Map,this.#He.set(g,_));const b=this.#je(m);let y=_.get(b);if(!y){const i=m?{...m,label:m.label||g.label}:{label:g.label};y=g.createView(i),_.set(b,y)}return y}getGPUResourceCubeTextureView(i,m){const g=i instanceof GPUTexture?i:i?.gpuTexture;if(!g)return this.#Fe;let _=this.#$e.get(g);_||(_=new Map,this.#$e.set(g,_)),i instanceof GPUTexture||m||(m=i.viewDescriptor);const b=m||CubeTexture.defaultViewDescriptor,y=this.#je(b);let T=_.get(y);if(!T){const i={...b,label:g.label};T=g.createView(i),_.set(y,T)}return T}createGPUShaderModule(i,m){return this.#Xe(i,m,m=>this.#qe(i,m),Gt.GPUShaderModule)}getGPUShaderModule(i){return this.#Ye(i,Gt.GPUShaderModule)}deleteGPUShaderModule(i){this.#Ze(i,Gt.GPUShaderModule)}createBindGroupLayout(i,m){return this.#Xe(i,m,m=>(m.label||(m.label=i),this.redGPUContext.gpuDevice.createBindGroupLayout(m)),Gt.GPUBindGroupLayout)}getGPUBindGroupLayout(i){return this.#Ye(i,Gt.GPUBindGroupLayout)}deleteGPUBindGroupLayout(i){this.#Ze(i,Gt.GPUBindGroupLayout)}createGPUPipelineLayout(i,m){return this.#Xe(i,m,m=>(m.label||(m.label=i),this.redGPUContext.gpuDevice.createPipelineLayout(m)),Gt.GPUPipelineLayout)}createGPUBuffer(i,m){return this.#Xe(i,m,m=>(m.label||(m.label=i),this.gpuDevice.createBuffer(m)),Gt.GPUBuffer)}#We(i,m){const g="3d"===m.dimension?this.#$e:this.#He;g.get(i)?.clear(),g.delete(i)}#je(i){return i?JSON.stringify(i):"default"}#Ke(){const{gpuDevice:i}=this.redGPUContext;{const m=i.createTexture({size:{width:1,height:1,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING,label:"EMPTY_BITMAP_TEXTURE"});this.#Ge=m.createView({label:m.label});const g=new Uint8Array([0,0,0,0]);i.queue.writeTexture({texture:m},g,{bytesPerRow:4,rowsPerImage:1},{width:1,height:1,depthOrArrayLayers:1});const _=i.createTexture({size:{width:1,height:1,depthOrArrayLayers:6},format:"rgba8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,label:"EMPTY_CUBE_TEXTURE"});this.#Fe=_.createView(CubeTexture.defaultViewDescriptor);const b=new Uint8Array([0,0,0,0]);for(let m=0;m<6;m++)i.queue.writeTexture({texture:_,origin:{x:0,y:0,z:m}},b,{bytesPerRow:4,rowsPerImage:1},{width:1,height:1,depthOrArrayLayers:1});this.#ze=new Sampler(this.redGPUContext)}this.createBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System,{entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{type:"comparison"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"depth"}},{binding:3,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:5,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:6,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:7,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:8,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:9,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:10,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube"}},{binding:11,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube"}}]}),this.createBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout,{entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX,sampler:{type:"filtering"}},{binding:2,visibility:GPUShaderStage.VERTEX,texture:{}}]}),this.createBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_SKIN,{entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX,sampler:{type:"filtering"}},{binding:2,visibility:GPUShaderStage.VERTEX,texture:{}},{binding:3,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}}]}),this.createBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_Instancing,{entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.VERTEX,sampler:{type:"filtering"}},{binding:2,visibility:GPUShaderStage.VERTEX,texture:{}},{binding:3,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}}]})}#Je(i){return this.#Be.get(i)}#qe(i,m){const{code:g}=m,_=preprocessWGSL(g).defaultSource,b=this.redGPUContext.gpuDevice.createShaderModule({...m,code:_});return this.#Je(Gt.GPUShaderModule).set(i,b),b}#Qe(i,m){if(!i)throw new Error("Name is required");return this.#Je(m)}#Xe(i,m,g,_){const b=this.#Qe(i,_);if(b.has(i))return b.get(i);m.label||(m.label=i);const y=g(m);return b.set(i,y),y}#Ye(i,m){return this.#Qe(i,m).get(i)}#Ze(i,m){const g=this.#Qe(i,m);if(!g.has(i))throw new Error(`${m} with name ${i} doesn't exist.`);g.delete(i)}}Object.freeze(BitmapTexture);class ImmutableKeyMap extends Map{constructor(i=[]){super(),i?.forEach(([i,m])=>super.set(i,m))}set(i,m){if(this.has(i))throw new Error("Cannot change the value of an existing key");return super.set(i,m)}}class MemoryTrackingMap extends Map{#et=0;constructor(){super()}get videoMemory(){return this.#et}set(i,m){const g=m&&"videoMemorySize"in m?"videoMemorySize":m&&"size"in m?"size":void 0;if(this.has(i)){const m=this.get(i);m&&m[g]&&(this.#et-=m[g])}m&&m&&(this.#et+=m[g]);return super.set(i,m)}delete(i){if(this.has(i)){const m=this.get(i),g=m&&"videoMemorySize"in m?"videoMemorySize":m&&"size"in m?"size":void 0;m&&m[g]&&(this.#et-=m[g])}return super.delete(i)}clear(){this.#et=0,super.clear()}}class AntialiasingManager{#l;#tt;#nt=!0;#rt=!1;#it=!1;#at=!0;constructor(i){this.#l=i,window.devicePixelRatio>1?this.useTAA=!0:this.useMSAA=!0}get useTAA(){return this.#it}set useTAA(i){this.#it!==i&&(this.#st(),this.#it=i)}get useMSAA(){return this.#nt}set useMSAA(i){this.#nt!==i&&(this.#st(),this.#tt=createUUID(),this.#nt=i,this.#at=!0)}get useFXAA(){return this.#rt}set useFXAA(i){this.#rt!==i&&(this.#st(),this.#rt=i)}get changedMSAA(){return this.#at}set changedMSAA(i){this.#at=i}get msaaID(){return this.#tt}#st(){this.#nt=!1,this.#rt=!1,this.#it=!1}}Object.freeze(AntialiasingManager);class RedGPUContextDetector{#ot;#ut;#lt;#ct;#ht;constructor(i){this.#ft(i.gpuAdapter)}get adapterInfo(){return this.#ot}get limits(){return this.#ut}get isFallbackAdapter(){return this.#lt}get groupedLimits(){return this.#ct}get userAgent(){return this.#ht}get isMobile(){return/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Windows Phone|Kindle|Silk|PlayBook/i.test(navigator.userAgent)}#ft(i){this.#ht=navigator.userAgent,this.#dt(i),this.#mt()}#dt(i){if(i){const{limits:m,info:g}=i,{isFallbackAdapter:_}=g;this.#ot=g,this.#lt=_,this.#ut=m}}#mt(){const i={TextureLimits:["maxTextureDimension1D","maxTextureDimension2D","maxTextureDimension3D","maxTextureArrayLayers","maxSampledTexturesPerShaderStage","maxSamplersPerShaderStage"],BufferLimits:["maxBindGroups","maxBindGroupsPlusVertexBuffers","maxBindingsPerBindGroup","maxDynamicUniformBuffersPerPipelineLayout","maxDynamicStorageBuffersPerPipelineLayout","maxStorageBuffersPerShaderStage","maxStorageTexturesPerShaderStage","maxUniformBuffersPerShaderStage","maxUniformBufferBindingSize","maxStorageBufferBindingSize","minUniformBufferOffsetAlignment","minStorageBufferOffsetAlignment","maxBufferSize"],PipelineAndShaderLimits:["maxVertexBuffers","maxVertexAttributes","maxVertexBufferArrayStride","maxInterStageShaderComponents","maxInterStageShaderVariables"],ComputeLimits:["maxComputeWorkgroupStorageSize","maxComputeInvocationsPerWorkgroup","maxComputeWorkgroupSizeX","maxComputeWorkgroupSizeY","maxComputeWorkgroupSizeZ","maxComputeWorkgroupsPerDimension"],ColorLimits:["maxColorAttachments","maxColorAttachmentBytesPerSample"]},m={TextureLimits:{},BufferLimits:{},PipelineAndShaderLimits:{},ComputeLimits:{},ColorLimits:{},EtcLimit:{}};for(const g in this.#ut){let _=!1;for(const b in i)if(i[b].includes(g)){m[b][g]=this.#ut[g],_=!0;break}_||(m.EtcLimit[g]=this.#ut[g])}this.#ct=m}}class RedGPUContextSizeManager{#pt;#gt;#l;#xt=[0,0,0,0];#_t;#vt=1;constructor(i,m="100%",g="100%"){this.#l=i,this.#_t=i.htmlCanvas,this.#_t.style.boxSizing="border-box",this.#pt=m,this.#gt=g}get renderScale(){return this.#vt}set renderScale(i){validateNumber(i),i<=0&&(i=.01),this.#vt=i,this.setSize()}get width(){return this.#pt}set width(i){this.setSize(i,this.#gt)}get height(){return this.#gt}set height(i){this.setSize(this.#pt,i)}get pixelRectArray(){return this.#xt}get pixelRectObject(){return{x:this.#xt[0],y:this.#xt[1],width:this.#xt[2],height:this.#xt[3]}}get parentDomRect(){return(this.#_t.parentNode||document.body).getBoundingClientRect()}get screenRectObject(){return{x:this.#xt[0]/devicePixelRatio,y:this.#xt[1]/devicePixelRatio,width:this.#xt[2]/devicePixelRatio,height:this.#xt[3]/devicePixelRatio}}static validateSizeValue=i=>{switch(typeof i){case"number":validatePositiveNumberRange(i);break;case"string":new RegExp(/^[+]?^[.]?(\d+)(\.\d+)?(?:px|%|$)/gm).test(i)||consoleAndThrowError(`allow positive number,%,px model/input:${i}`);break;default:consoleAndThrowError(`positive number,%,px model/input:${i}`)}};static validatePositionValue=i=>{switch(typeof i){case"number":validateNumber(i);break;case"string":new RegExp(/^-?\d+(\.\d+)?(px|%)?$/).test(i)||consoleAndThrowError(`allow number,%,px model /input:${i}`);break;default:consoleAndThrowError(`number,%,px model/input:${i}`)}};static getPixelDimension(i,m,g){return"number"==typeof g?g:RedGPUContextSizeManager.calculateSizeFromString(i,m,g)}static calculateSizeFromString(i,m,g){return g.includes("%")?Math.floor(i[m]*+g.replace("%","")/100):+g.replace("px","")}setSize(i=this.#pt,m=this.#gt){RedGPUContextSizeManager.validateSizeValue(i),RedGPUContextSizeManager.validateSizeValue(m),this.#pt=i,this.#gt=m;const g=RedGPUContextSizeManager.getPixelDimension(this.parentDomRect,"width",i),_=RedGPUContextSizeManager.getPixelDimension(this.parentDomRect,"height",m);this.#bt(g,_),this.#yt(g,_),this.#St()}#yt(i,m){this.#xt[2]=Math.floor(i*this.#vt*window.devicePixelRatio),this.#xt[3]=Math.floor(m*this.#vt*window.devicePixelRatio)}#St(){this.#l.onResize&&this.#l.onResize(this.screenRectObject.width,this.screenRectObject.height),this.#l.viewList.forEach(i=>{i.setSize(),i.setPosition()})}#bt(i,m){const g=this.#_t,{style:_}=g;g.width=i*this.#vt*window.devicePixelRatio,g.height=m*this.#vt*window.devicePixelRatio,_.width=`${i}px`,_.height=`${m}px`}}class Camera2D{#f;#Tt=create$2();#Mt=0;#wt=0;#Ct=0;#h;constructor(){}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get modelMatrix(){return this.#Tt}get z(){return this.#Ct}get x(){return this.#Mt}set x(i){this.#Mt=i,this.#Tt[12]=i}get y(){return this.#wt}set y(i){this.#wt=i,this.#Tt[13]=i}get position(){return[this.#Mt,this.#wt]}setPosition(i,m){Array.isArray(i)?[this.#Mt,this.#wt]=i:(this.#Mt=i,this.#wt=m),[this.#Tt[12],this.#Tt[13],this.#Tt[14]]=[this.#Mt,this.#wt,0]}}const Ft={NEVER:"never",LESS:"less",EQUAL:"equal",LESS_EQUAL:"less-equal",GREATER:"greater",NOT_EQUAL:"not-equal",GREATER_EQUAL:"greater-equal",ALWAYS:"always"};Object.freeze(Ft);class e{constructor(i,m){this.name=i,this.attributes=m,this.size=0}get isArray(){return!1}get isStruct(){return!1}get isTemplate(){return!1}get isPointer(){return!1}getTypeName(){return this.name}}class t{constructor(i,m,g){this.name=i,this.type=m,this.attributes=g,this.offset=0,this.size=0}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class n extends e{constructor(i,m){super(i,m),this.members=[],this.align=0,this.startLine=-1,this.endLine=-1,this.inUse=!1}get isStruct(){return!0}}class s extends e{constructor(i,m){super(i,m),this.count=0,this.stride=0}get isArray(){return!0}getTypeName(){return`array<${this.format.getTypeName()},${this.count}>`}}class r extends e{constructor(i,m,g){super(i,g),this.format=m}get isPointer(){return!0}getTypeName(){return`&${this.format.getTypeName()}`}}class a extends e{constructor(i,m,g,_){super(i,g),this.format=m,this.access=_}get isTemplate(){return!0}getTypeName(){let i=this.name;if(null!==this.format){if("vec2"===i||"vec3"===i||"vec4"===i||"mat2x2"===i||"mat2x3"===i||"mat2x4"===i||"mat3x2"===i||"mat3x3"===i||"mat3x4"===i||"mat4x2"===i||"mat4x3"===i||"mat4x4"===i){if("f32"===this.format.name)return i+="f",i;if("i32"===this.format.name)return i+="i",i;if("u32"===this.format.name)return i+="u",i;if("bool"===this.format.name)return i+="b",i;if("f16"===this.format.name)return i+="h",i}i+=`<${this.format.name}>`}else if("vec2"===i||"vec3"===i||"vec4"===i)return i;return i}}var Nt;(i=>{i[i.Uniform=0]="Uniform",i[i.Storage=1]="Storage",i[i.Texture=2]="Texture",i[i.Sampler=3]="Sampler",i[i.StorageTexture=4]="StorageTexture"})(Nt||(Nt={}));class o{constructor(i,m,g,_,b,y,T){this.name=i,this.type=m,this.group=g,this.binding=_,this.attributes=b,this.resourceType=y,this.access=T}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get size(){return this.type.size}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class l{constructor(i,m){this.name=i,this.type=m}}class c{constructor(i,m,g,_){this.name=i,this.type=m,this.locationType=g,this.location=_,this.interpolation=null}}class u{constructor(i,m,g,_){this.name=i,this.type=m,this.locationType=g,this.location=_}}class h{constructor(i,m,g,_){this.name=i,this.type=m,this.attributes=g,this.id=_}}class f{constructor(i,m,g){this.name=i,this.type=m,this.attributes=g}}class p{constructor(i,m=null,g){this.stage=null,this.inputs=[],this.outputs=[],this.arguments=[],this.returnType=null,this.resources=[],this.overrides=[],this.startLine=-1,this.endLine=-1,this.inUse=!1,this.calls=new Set,this.name=i,this.stage=m,this.attributes=g}}class d{constructor(){this.vertex=[],this.fragment=[],this.compute=[]}}const Vt=new Float32Array(1),zt=new Int32Array(Vt.buffer),Ht=new Uint16Array(1);function x(i){Vt[0]=i;const m=zt[0],g=m>>31&1;let _=m>>23&255,b=8388607&m;if(255===_)return Ht[0]=g<<15|31744|(0!==b?512:0),Ht[0];if(0===_){if(0===b)return Ht[0]=g<<15,Ht[0];b|=8388608;let i=113;for(;!(8388608&b);)b<<=1,i--;return _=127-i,b&=8388607,_>0?(b=(b>>126-_)+(b>>127-_&1),Ht[0]=g<<15|_<<10|b>>13,Ht[0]):(Ht[0]=g<<15,Ht[0])}return _=_-127+15,_>=31?(Ht[0]=g<<15|31744,Ht[0]):_<=0?_<-10?(Ht[0]=g<<15,Ht[0]):(b=(8388608|b)>>1-_,Ht[0]=g<<15|b>>13,Ht[0]):(b>>=13,Ht[0]=g<<15|_<<10|b,Ht[0])}const $t=new Uint32Array(1),Kt=new Float32Array($t.buffer,0,1);function v(i){const m=112+(i>>6&31)<<23|(63&i)<<17;return $t[0]=m,Kt[0]}function k(i,m,g,_){const b=[0,0,0,0];for(let H=0;H<_;++H)switch(g){case"8unorm":b[H]=i[m]/255,m++;break;case"8snorm":b[H]=i[m]/255*2-1,m++;break;case"8uint":b[H]=i[m],m++;break;case"8sint":b[H]=i[m]-127,m++;break;case"16uint":b[H]=i[m]|i[m+1]<<8,m+=2;break;case"16sint":b[H]=(i[m]|i[m+1]<<8)-32768,m+=2;break;case"16float":b[H]=(void 0,void 0,void 0,T=(32768&(y=i[m]|i[m+1]<<8))>>15,P=1023&y,0==(w=(31744&y)>>10)?(T?-1:1)*Math.pow(2,-14)*(P/Math.pow(2,10)):31==w?P?NaN:1/0*(T?-1:1):(T?-1:1)*Math.pow(2,w-15)*(1+P/Math.pow(2,10))),m+=2;break;case"32uint":case"32sint":b[H]=i[m]|i[m+1]<<8|i[m+2]<<16|i[m+3]<<24,m+=4;break;case"32float":b[H]=new Float32Array(i.buffer,m,1)[0],m+=4}var y,T,w,P;return b}function I(i,m,g,_,b){for(let y=0;y<_;++y)switch(g){case"8unorm":i[m]=255*b[y],m++;break;case"8snorm":i[m]=.5*(b[y]+1)*255,m++;break;case"8uint":i[m]=b[y],m++;break;case"8sint":i[m]=b[y]+127,m++;break;case"16uint":new Uint16Array(i.buffer,m,1)[0]=b[y],m+=2;break;case"16sint":new Int16Array(i.buffer,m,1)[0]=b[y],m+=2;break;case"16float":{const g=x(b[y]);new Uint16Array(i.buffer,m,1)[0]=g,m+=2;break}case"32uint":new Uint32Array(i.buffer,m,1)[0]=b[y],m+=4;break;case"32sint":new Int32Array(i.buffer,m,1)[0]=b[y],m+=4;break;case"32float":new Float32Array(i.buffer,m,1)[0]=b[y],m+=4}return b}const Wt={r8unorm:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8snorm:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8uint:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8sint:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg8unorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8snorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8uint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8sint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba8unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},"rgba8unorm-srgb":{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8snorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},bgra8unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},"bgra8unorm-srgb":{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},r16uint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r16sint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r16float:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg16uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg16sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg16float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba16uint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba16sint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba16float:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},r32uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r32sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r32float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg32uint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg32sint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg32float:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba32uint:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba32sint:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba32float:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgb10a2uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgb10a2unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rg11b10ufloat:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},stencil8:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!1,hasStencil:!0,channels:1},depth16unorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,channels:1},depth24plus:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,depthOnlyFormat:"depth32float",channels:1},"depth24plus-stencil8":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!0,depthOnlyFormat:"depth32float",channels:1},depth32float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,channels:1},"depth32float-stencil8":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!0,stencilOnlyFormat:"depth32float",channels:1},rgb9e5ufloat:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},"bc1-rgba-unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc1-rgba-unorm-srgb":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc2-rgba-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc2-rgba-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc3-rgba-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc3-rgba-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc4-r-unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:1},"bc4-r-snorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:1},"bc5-rg-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:2},"bc5-rg-snorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:2},"bc6h-rgb-ufloat":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc6h-rgb-float":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc7-rgba-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc7-rgba-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8unorm-srgb":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8a1unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8a1unorm-srgb":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgba8unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgba8unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"eac-r11unorm":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!0,channels:1},"eac-r11snorm":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!0,channels:1},"eac-rg11unorm":{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!0,channels:2},"eac-rg11snorm":{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!0,channels:2},"astc-4x4-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"astc-4x4-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"astc-5x4-unorm":{bytesPerBlock:16,blockWidth:5,blockHeight:4,isCompressed:!0,channels:4},"astc-5x4-unorm-srgb":{bytesPerBlock:16,blockWidth:5,blockHeight:4,isCompressed:!0,channels:4},"astc-5x5-unorm":{bytesPerBlock:16,blockWidth:5,blockHeight:5,isCompressed:!0,channels:4},"astc-5x5-unorm-srgb":{bytesPerBlock:16,blockWidth:5,blockHeight:5,isCompressed:!0,channels:4},"astc-6x5-unorm":{bytesPerBlock:16,blockWidth:6,blockHeight:5,isCompressed:!0,channels:4},"astc-6x5-unorm-srgb":{bytesPerBlock:16,blockWidth:6,blockHeight:5,isCompressed:!0,channels:4},"astc-6x6-unorm":{bytesPerBlock:16,blockWidth:6,blockHeight:6,isCompressed:!0,channels:4},"astc-6x6-unorm-srgb":{bytesPerBlock:16,blockWidth:6,blockHeight:6,isCompressed:!0,channels:4},"astc-8x5-unorm":{bytesPerBlock:16,blockWidth:8,blockHeight:5,isCompressed:!0,channels:4},"astc-8x5-unorm-srgb":{bytesPerBlock:16,blockWidth:8,blockHeight:5,isCompressed:!0,channels:4},"astc-8x6-unorm":{bytesPerBlock:16,blockWidth:8,blockHeight:6,isCompressed:!0,channels:4},"astc-8x6-unorm-srgb":{bytesPerBlock:16,blockWidth:8,blockHeight:6,isCompressed:!0,channels:4},"astc-8x8-unorm":{bytesPerBlock:16,blockWidth:8,blockHeight:8,isCompressed:!0,channels:4},"astc-8x8-unorm-srgb":{bytesPerBlock:16,blockWidth:8,blockHeight:8,isCompressed:!0,channels:4},"astc-10x5-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:5,isCompressed:!0,channels:4},"astc-10x5-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:5,isCompressed:!0,channels:4},"astc-10x6-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:6,isCompressed:!0,channels:4},"astc-10x6-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:6,isCompressed:!0,channels:4},"astc-10x8-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:8,isCompressed:!0,channels:4},"astc-10x8-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:8,isCompressed:!0,channels:4},"astc-10x10-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:10,isCompressed:!0,channels:4},"astc-10x10-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:10,isCompressed:!0,channels:4},"astc-12x10-unorm":{bytesPerBlock:16,blockWidth:12,blockHeight:10,isCompressed:!0,channels:4},"astc-12x10-unorm-srgb":{bytesPerBlock:16,blockWidth:12,blockHeight:10,isCompressed:!0,channels:4},"astc-12x12-unorm":{bytesPerBlock:16,blockWidth:12,blockHeight:12,isCompressed:!0,channels:4},"astc-12x12-unorm-srgb":{bytesPerBlock:16,blockWidth:12,blockHeight:12,isCompressed:!0,channels:4}};class S{constructor(){this.id=S._id++,this.line=0}get isAstNode(){return!0}get astNodeType(){return""}search(i){i(this)}searchBlock(i,m){if(i){m(A.instance);for(const g of i)g instanceof Array?this.searchBlock(g,m):g.search(m);m(E.instance)}}constEvaluate(i,m){throw new Error("Cannot evaluate node")}constEvaluateString(i){return this.constEvaluate(i).toString()}}S._id=0;class A extends S{}A.instance=new A;class E extends S{}E.instance=new E;const jt=new Set(["all","all","any","select","arrayLength","abs","acos","acosh","asin","asinh","atan","atanh","atan2","ceil","clamp","cos","cosh","countLeadingZeros","countOneBits","countTrailingZeros","cross","degrees","determinant","distance","dot","dot4U8Packed","dot4I8Packed","exp","exp2","extractBits","faceForward","firstLeadingBit","firstTrailingBit","floor","fma","fract","frexp","insertBits","inverseSqrt","ldexp","length","log","log2","max","min","mix","modf","normalize","pow","quantizeToF16","radians","reflect","refract","reverseBits","round","saturate","sign","sin","sinh","smoothStep","sqrt","step","tan","tanh","transpose","trunc","dpdx","dpdxCoarse","dpdxFine","dpdy","dpdyCoarse","dpdyFine","fwidth","fwidthCoarse","fwidthFine","textureDimensions","textureGather","textureGatherCompare","textureLoad","textureNumLayers","textureNumLevels","textureNumSamples","textureSample","textureSampleBias","textureSampleCompare","textureSampleCompareLevel","textureSampleGrad","textureSampleLevel","textureSampleBaseClampToEdge","textureStore","atomicLoad","atomicStore","atomicAdd","atomicSub","atomicMax","atomicMin","atomicAnd","atomicOr","atomicXor","atomicExchange","atomicCompareExchangeWeak","pack4x8snorm","pack4x8unorm","pack4xI8","pack4xU8","pack4x8Clamp","pack4xU8Clamp","pack2x16snorm","pack2x16unorm","pack2x16float","unpack4x8snorm","unpack4x8unorm","unpack4xI8","unpack4xU8","unpack2x16snorm","unpack2x16unorm","unpack2x16float","storageBarrier","textureBarrier","workgroupBarrier","workgroupUniformLoad","subgroupAdd","subgroupExclusiveAdd","subgroupInclusiveAdd","subgroupAll","subgroupAnd","subgroupAny","subgroupBallot","subgroupBroadcast","subgroupBroadcastFirst","subgroupElect","subgroupMax","subgroupMin","subgroupMul","subgroupExclusiveMul","subgroupInclusiveMul","subgroupOr","subgroupShuffle","subgroupShuffleDown","subgroupShuffleUp","subgroupShuffleXor","subgroupXor","quadBroadcast","quadSwapDiagonal","quadSwapX","quadSwapY"]);class L extends S{constructor(){super()}}class C extends L{constructor(i,m,g,_,b,y){super(),this.calls=new Set,this.name=i,this.args=m,this.returnType=g,this.body=_,this.startLine=b,this.endLine=y}get astNodeType(){return"function"}search(i){if(this.attributes)for(const m of this.attributes)i(m);i(this);for(const m of this.args)i(m);this.searchBlock(this.body,i)}}class D extends L{constructor(i){super(),this.expression=i}get astNodeType(){return"staticAssert"}search(i){this.expression.search(i)}}class N extends L{constructor(i,m){super(),this.condition=i,this.body=m}get astNodeType(){return"while"}search(i){this.condition.search(i),this.searchBlock(this.body,i)}}class V extends L{constructor(i,m){super(),this.body=i,this.loopId=m}get astNodeType(){return"continuing"}search(i){this.searchBlock(this.body,i)}}class O extends L{constructor(i,m,g,_){super(),this.init=i,this.condition=m,this.increment=g,this.body=_}get astNodeType(){return"for"}search(i){var m,g,_;null===(m=this.init)||void 0===m||m.search(i),null===(g=this.condition)||void 0===g||g.search(i),null===(_=this.increment)||void 0===_||_.search(i),this.searchBlock(this.body,i)}}class B extends L{constructor(i,m,g,_,b){super(),this.attributes=null,this.name=i,this.type=m,this.storage=g,this.access=_,this.value=b}get astNodeType(){return"var"}search(i){var m;i(this),null===(m=this.value)||void 0===m||m.search(i)}}class F extends L{constructor(i,m,g){super(),this.attributes=null,this.name=i,this.type=m,this.value=g}get astNodeType(){return"override"}search(i){var m;null===(m=this.value)||void 0===m||m.search(i)}}class M extends L{constructor(i,m,g,_,b){super(),this.attributes=null,this.name=i,this.type=m,this.storage=g,this.access=_,this.value=b}get astNodeType(){return"let"}search(i){var m;i(this),null===(m=this.value)||void 0===m||m.search(i)}}class U extends L{constructor(i,m,g,_,b){super(),this.attributes=null,this.name=i,this.type=m,this.storage=g,this.access=_,this.value=b}get astNodeType(){return"const"}constEvaluate(i,m){return this.value.constEvaluate(i,m)}search(i){var m;i(this),null===(m=this.value)||void 0===m||m.search(i)}}var Xt,qt,Yt,Zt;(i=>{i.increment="++",i.decrement="--"})(Xt||(Xt={})),(i=>{i.parse=function(m){const g=m;if("parse"==g)throw new Error("Invalid value for IncrementOperator");return i[g]}})(Xt||(Xt={}));class z extends L{constructor(i,m){super(),this.operator=i,this.variable=m}get astNodeType(){return"increment"}search(i){this.variable.search(i)}}(i=>{i.assign="=",i.addAssign="+=",i.subtractAssin="-=",i.multiplyAssign="*=",i.divideAssign="/=",i.moduloAssign="%=",i.andAssign="&=",i.orAssign="|=",i.xorAssign="^=",i.shiftLeftAssign="<<=",i.shiftRightAssign=">>="})(qt||(qt={})),(qt||(qt={})).parse=function(i){const m=i;if("parse"==m)throw new Error("Invalid value for AssignOperator");return m};class R extends L{constructor(i,m,g){super(),this.operator=i,this.variable=m,this.value=g}get astNodeType(){return"assign"}search(i){this.variable.search(i),this.value.search(i)}}class G extends L{constructor(i,m){super(),this.name=i,this.args=m}get astNodeType(){return"call"}isBuiltin(){return jt.has(this.name)}search(i){for(const m of this.args)m.search(i);i(this)}}class X extends L{constructor(i,m){super(),this.body=i,this.continuing=m}get astNodeType(){return"loop"}}class j extends L{constructor(i,m){super(),this.condition=i,this.cases=m}get astNodeType(){return"switch"}search(i){i(this);for(const m of this.cases)m.search(i)}}class Z extends L{constructor(i,m,g,_){super(),this.condition=i,this.body=m,this.elseif=g,this.else=_}get astNodeType(){return"if"}search(i){this.condition.search(i),this.searchBlock(this.body,i),this.searchBlock(this.elseif,i),this.searchBlock(this.else,i)}}class Q extends L{constructor(i){super(),this.value=i}get astNodeType(){return"return"}search(i){var m;null===(m=this.value)||void 0===m||m.search(i)}}class Y extends L{constructor(i){super(),this.name=i}get astNodeType(){return"enable"}}class K extends L{constructor(i){super(),this.extensions=i}get astNodeType(){return"requires"}}class J extends L{constructor(i,m){super(),this.severity=i,this.rule=m}get astNodeType(){return"diagnostic"}}class ee extends L{constructor(i,m){super(),this.name=i,this.type=m}get astNodeType(){return"alias"}}class te extends L{constructor(){super()}get astNodeType(){return"discard"}}class ne extends L{constructor(){super(),this.condition=null,this.loopId=-1}get astNodeType(){return"break"}}class se extends L{constructor(){super(),this.loopId=-1}get astNodeType(){return"continue"}}class re extends L{constructor(i){super(),this.attributes=null,this.name=i}get astNodeType(){return"type"}get isStruct(){return!1}get isArray(){return!1}static maxFormatType(i){let m=i[0];if("f32"===m.name)return m;for(let g=1;g<i.length;++g){const _=re._priority.get(m.name);re._priority.get(i[g].name)<_&&(m=i[g])}return"x32"===m.name?re.i32:m}getTypeName(){return this.name}}re.x32=new re("x32"),re.f32=new re("f32"),re.i32=new re("i32"),re.u32=new re("u32"),re.f16=new re("f16"),re.bool=new re("bool"),re.void=new re("void"),re._priority=new Map([["f32",0],["f16",1],["u32",2],["i32",3],["x32",3]]);class ae extends re{constructor(i){super(i)}}class ie extends re{constructor(i,m,g,_){super(i),this.members=m,this.startLine=g,this.endLine=_}get astNodeType(){return"struct"}get isStruct(){return!0}getMemberIndex(i){for(let m=0;m<this.members.length;m++)if(this.members[m].name==i)return m;return-1}search(i){for(const m of this.members)i(m)}}class oe extends re{constructor(i,m,g){super(i),this.format=m,this.access=g}get astNodeType(){return"template"}getTypeName(){let i=this.name;if(null!==this.format){if("vec2"===i||"vec3"===i||"vec4"===i||"mat2x2"===i||"mat2x3"===i||"mat2x4"===i||"mat3x2"===i||"mat3x3"===i||"mat3x4"===i||"mat4x2"===i||"mat4x3"===i||"mat4x4"===i){if("f32"===this.format.name)return i+="f",i;if("i32"===this.format.name)return i+="i",i;if("u32"===this.format.name)return i+="u",i;if("bool"===this.format.name)return i+="b",i;if("f16"===this.format.name)return i+="h",i}i+=`<${this.format.name}>`}else if("vec2"===i||"vec3"===i||"vec4"===i)return i;return i}}oe.vec2f=new oe("vec2",re.f32,null),oe.vec3f=new oe("vec3",re.f32,null),oe.vec4f=new oe("vec4",re.f32,null),oe.vec2i=new oe("vec2",re.i32,null),oe.vec3i=new oe("vec3",re.i32,null),oe.vec4i=new oe("vec4",re.i32,null),oe.vec2u=new oe("vec2",re.u32,null),oe.vec3u=new oe("vec3",re.u32,null),oe.vec4u=new oe("vec4",re.u32,null),oe.vec2h=new oe("vec2",re.f16,null),oe.vec3h=new oe("vec3",re.f16,null),oe.vec4h=new oe("vec4",re.f16,null),oe.vec2b=new oe("vec2",re.bool,null),oe.vec3b=new oe("vec3",re.bool,null),oe.vec4b=new oe("vec4",re.bool,null),oe.mat2x2f=new oe("mat2x2",re.f32,null),oe.mat2x3f=new oe("mat2x3",re.f32,null),oe.mat2x4f=new oe("mat2x4",re.f32,null),oe.mat3x2f=new oe("mat3x2",re.f32,null),oe.mat3x3f=new oe("mat3x3",re.f32,null),oe.mat3x4f=new oe("mat3x4",re.f32,null),oe.mat4x2f=new oe("mat4x2",re.f32,null),oe.mat4x3f=new oe("mat4x3",re.f32,null),oe.mat4x4f=new oe("mat4x4",re.f32,null),oe.mat2x2h=new oe("mat2x2",re.f16,null),oe.mat2x3h=new oe("mat2x3",re.f16,null),oe.mat2x4h=new oe("mat2x4",re.f16,null),oe.mat3x2h=new oe("mat3x2",re.f16,null),oe.mat3x3h=new oe("mat3x3",re.f16,null),oe.mat3x4h=new oe("mat3x4",re.f16,null),oe.mat4x2h=new oe("mat4x2",re.f16,null),oe.mat4x3h=new oe("mat4x3",re.f16,null),oe.mat4x4h=new oe("mat4x4",re.f16,null),oe.mat2x2i=new oe("mat2x2",re.i32,null),oe.mat2x3i=new oe("mat2x3",re.i32,null),oe.mat2x4i=new oe("mat2x4",re.i32,null),oe.mat3x2i=new oe("mat3x2",re.i32,null),oe.mat3x3i=new oe("mat3x3",re.i32,null),oe.mat3x4i=new oe("mat3x4",re.i32,null),oe.mat4x2i=new oe("mat4x2",re.i32,null),oe.mat4x3i=new oe("mat4x3",re.i32,null),oe.mat4x4i=new oe("mat4x4",re.i32,null),oe.mat2x2u=new oe("mat2x2",re.u32,null),oe.mat2x3u=new oe("mat2x3",re.u32,null),oe.mat2x4u=new oe("mat2x4",re.u32,null),oe.mat3x2u=new oe("mat3x2",re.u32,null),oe.mat3x3u=new oe("mat3x3",re.u32,null),oe.mat3x4u=new oe("mat3x4",re.u32,null),oe.mat4x2u=new oe("mat4x2",re.u32,null),oe.mat4x3u=new oe("mat4x3",re.u32,null),oe.mat4x4u=new oe("mat4x4",re.u32,null);class le extends re{constructor(i,m,g,_){super(i),this.storage=m,this.type=g,this.access=_}get astNodeType(){return"pointer"}}class ce extends re{constructor(i,m,g,_){super(i),this.attributes=m,this.format=g,this.count=_}get astNodeType(){return"array"}get isArray(){return!0}}class ue extends re{constructor(i,m,g){super(i),this.format=m,this.access=g}get astNodeType(){return"sampler"}}class he extends S{constructor(){super(),this.postfix=null}}class fe extends he{constructor(i){super(),this.value=i}get astNodeType(){return"stringExpr"}toString(){return this.value}constEvaluateString(){return this.value}}class pe extends he{constructor(i,m){super(),this.type=i,this.args=m}get astNodeType(){return"createExpr"}search(i){if(i(this),this.args)for(const m of this.args)m.search(i)}constEvaluate(i,m){return m&&(m[0]=this.type),i.evalExpression(this,i.context)}}class de extends he{constructor(i,m){super(),this.cachedReturnValue=null,this.name=i,this.args=m}get astNodeType(){return"callExpr"}setCachedReturnValue(i){this.cachedReturnValue=i}get isBuiltin(){return jt.has(this.name)}constEvaluate(i,m){return i.evalExpression(this,i.context)}search(i){for(const m of this.args)m.search(i);i(this)}}class me extends he{constructor(i){super(),this.name=i}get astNodeType(){return"varExpr"}search(i){i(this),this.postfix&&this.postfix.search(i)}constEvaluate(i,m){return i.evalExpression(this,i.context)}}class _e extends he{constructor(i,m){super(),this.name=i,this.initializer=m}get astNodeType(){return"constExpr"}constEvaluate(i,m){if(this.initializer){const m=i.evalExpression(this.initializer,i.context);return null!==m&&this.postfix?m.getSubData(i,this.postfix,i.context):m}return null}search(i){this.initializer.search(i)}}class ge extends he{constructor(i,m){super(),this.value=i,this.type=m}get astNodeType(){return"literalExpr"}constEvaluate(i,m){return void 0!==m&&(m[0]=this.type),this.value}get isScalar(){return this.value instanceof Oe}get isVector(){return this.value instanceof Fe||this.value instanceof Me}get scalarValue(){return this.value instanceof Oe?this.value.value:(console.error("Value is not scalar."),0)}get vectorValue(){return this.value instanceof Fe||this.value instanceof Me?this.value.data:(console.error("Value is not a vector or matrix."),new Float32Array(0))}}class xe extends he{constructor(i,m){super(),this.type=i,this.value=m}get astNodeType(){return"bitcastExpr"}search(i){this.value.search(i)}}class be extends he{constructor(i){super(),this.index=i}search(i){this.index.search(i)}}class ve extends he{constructor(){super()}}class we extends ve{constructor(i,m){super(),this.operator=i,this.right=m}get astNodeType(){return"unaryOp"}constEvaluate(i,m){return i.evalExpression(this,i.context)}search(i){this.right.search(i)}}class ke extends ve{constructor(i,m,g){super(),this.operator=i,this.left=m,this.right=g}get astNodeType(){return"binaryOp"}_getPromotedType(i,m){return i.name===m.name?i:"f32"===i.name||"f32"===m.name?re.f32:"u32"===i.name||"u32"===m.name?re.u32:re.i32}constEvaluate(i,m){return i.evalExpression(this,i.context)}search(i){this.left.search(i),this.right.search(i)}}class Ie extends S{constructor(i){super(),this.body=i}search(i){i(this),this.searchBlock(this.body,i)}}class Te extends he{constructor(){super()}get astNodeType(){return"default"}}class Se extends Ie{constructor(i,m){super(m),this.selectors=i}get astNodeType(){return"case"}search(i){this.searchBlock(this.body,i)}}class Ae extends Ie{constructor(i){super(i)}get astNodeType(){return"default"}search(i){this.searchBlock(this.body,i)}}class Ee extends S{constructor(i,m,g){super(),this.name=i,this.type=m,this.attributes=g}get astNodeType(){return"argument"}}class $e extends S{constructor(i,m){super(),this.condition=i,this.body=m}get astNodeType(){return"elseif"}search(i){this.condition.search(i),this.searchBlock(this.body,i)}}class Le extends S{constructor(i,m,g){super(),this.name=i,this.type=m,this.attributes=g}get astNodeType(){return"member"}}class Ce extends S{constructor(i,m){super(),this.name=i,this.value=m}get astNodeType(){return"attribute"}}class De{constructor(i,m){this.parent=null,this.typeInfo=i,this.parent=m,this.id=De._id++}clone(){throw`Clone:Not implemented for ${this.constructor.name}`}setDataValue(i,m,g,_){console.error(`SetDataValue:Not implemented for ${this.constructor.name}`)}getSubData(i,m,g){return console.error(`GetDataValue:Not implemented for ${this.constructor.name}`),null}toString(){return`<${this.typeInfo.getTypeName()}>`}}De._id=0;class Ne extends De{constructor(){super(new e("void",null),null)}toString(){return"void"}}Ne.void=new Ne;class Ve extends De{constructor(i){super(new r("pointer",i.typeInfo,null),null),this.reference=i}clone(){return this}setDataValue(i,m,g,_){this.reference.setDataValue(i,m,g,_)}getSubData(i,m,g){return m?this.reference.getSubData(i,m,g):this}toString(){return`&${this.reference.toString()}`}}class Oe extends De{constructor(i,m,g=null){super(m,g),i instanceof Int32Array||i instanceof Uint32Array||i instanceof Float32Array?this.data=i:"x32"===this.typeInfo.name?i-Math.floor(i)!=0?this.data=new Float32Array([i]):this.data=i>=0?new Uint32Array([i]):new Int32Array([i]):"i32"===this.typeInfo.name||"bool"===this.typeInfo.name?this.data=new Int32Array([i]):"u32"===this.typeInfo.name?this.data=new Uint32Array([i]):"f32"===this.typeInfo.name||"f16"===this.typeInfo.name?this.data=new Float32Array([i]):console.error("ScalarData2:Invalid type",m)}clone(){if(this.data instanceof Float32Array)return new Oe(new Float32Array(this.data),this.typeInfo,null);if(this.data instanceof Int32Array)return new Oe(new Int32Array(this.data),this.typeInfo,null);if(this.data instanceof Uint32Array)return new Oe(new Uint32Array(this.data),this.typeInfo,null);throw"ScalarData:Invalid data type"}get value(){return this.data[0]}set value(i){this.data[0]=i}setDataValue(i,m,g,_){if(g)return void console.error("SetDataValue:Scalar data does not support postfix",g);if(!(m instanceof Oe))return void console.error("SetDataValue:Invalid value",m);let b=m.data[0];"i32"===this.typeInfo.name||"u32"===this.typeInfo.name?b=Math.floor(b):"bool"===this.typeInfo.name&&(b=b?1:0),this.data[0]=b}getSubData(i,m,g){return m?(console.error("getSubData:Scalar data does not support postfix",m),null):this}toString(){return`${this.value}`}}function Be(i,m,g){const _=m.length;return 2===_?"f32"===g?new Fe(new Float32Array(m),i.getTypeInfo("vec2f")):"i32"===g||"bool"===g?new Fe(new Int32Array(m),i.getTypeInfo("vec2i")):"u32"===g?new Fe(new Uint32Array(m),i.getTypeInfo("vec2u")):"f16"===g?new Fe(new Float32Array(m),i.getTypeInfo("vec2h")):(console.error(`getSubData:Unknown format ${g}`),null):3===_?"f32"===g?new Fe(new Float32Array(m),i.getTypeInfo("vec3f")):"i32"===g||"bool"===g?new Fe(new Int32Array(m),i.getTypeInfo("vec3i")):"u32"===g?new Fe(new Uint32Array(m),i.getTypeInfo("vec3u")):"f16"===g?new Fe(new Float32Array(m),i.getTypeInfo("vec3h")):(console.error(`getSubData:Unknown format ${g}`),null):4===_?"f32"===g?new Fe(new Float32Array(m),i.getTypeInfo("vec4f")):"i32"===g||"bool"===g?new Fe(new Int32Array(m),i.getTypeInfo("vec4i")):"u32"===g?new Fe(new Uint32Array(m),i.getTypeInfo("vec4u")):"f16"===g?new Fe(new Float32Array(m),i.getTypeInfo("vec4h")):(console.error(`getSubData:Unknown format ${g}`),null):(console.error(`getSubData:Invalid vector size ${m.length}`),null)}class Fe extends De{constructor(i,m,g=null){if(super(m,g),i instanceof Float32Array||i instanceof Uint32Array||i instanceof Int32Array)this.data=i;else{const m=this.typeInfo.name;"vec2f"===m||"vec3f"===m||"vec4f"===m?this.data=new Float32Array(i):"vec2i"===m||"vec3i"===m||"vec4i"===m?this.data=new Int32Array(i):"vec2u"===m||"vec3u"===m||"vec4u"===m?this.data=new Uint32Array(i):"vec2h"===m||"vec3h"===m||"vec4h"===m?this.data=new Float32Array(i):"vec2b"===m||"vec3b"===m||"vec4b"===m?this.data=new Int32Array(i):"vec2"===m||"vec3"===m||"vec4"===m?this.data=new Float32Array(i):console.error(`VectorData:Invalid type ${m}`)}}clone(){if(this.data instanceof Float32Array)return new Fe(new Float32Array(this.data),this.typeInfo,null);if(this.data instanceof Int32Array)return new Fe(new Int32Array(this.data),this.typeInfo,null);if(this.data instanceof Uint32Array)return new Fe(new Uint32Array(this.data),this.typeInfo,null);throw"VectorData:Invalid data type"}setDataValue(i,m,g,_){g instanceof fe?console.error("TODO:Set vector postfix"):m instanceof Fe?this.data=m.data:console.error("SetDataValue:Invalid value",m)}getSubData(i,m,g){if(null===m)return this;let _=i.getTypeInfo("f32");if(this.typeInfo instanceof a)_=this.typeInfo.format||_;else{const m=this.typeInfo.name;"vec2f"===m||"vec3f"===m||"vec4f"===m?_=i.getTypeInfo("f32"):"vec2i"===m||"vec3i"===m||"vec4i"===m?_=i.getTypeInfo("i32"):"vec2b"===m||"vec3b"===m||"vec4b"===m?_=i.getTypeInfo("bool"):"vec2u"===m||"vec3u"===m||"vec4u"===m?_=i.getTypeInfo("u32"):"vec2h"===m||"vec3h"===m||"vec4h"===m?_=i.getTypeInfo("f16"):console.error(`GetSubData:Unknown type ${m}`)}let b=this;for(;null!==m&&null!==b;){if(m instanceof be){const y=m.index;let T=-1;if(y instanceof ge){if(!(y.value instanceof Oe))return console.error(`GetSubData:Invalid array index ${y.value}`),null;T=y.value.value}else{const m=i.evalExpression(y,g);if(!(m instanceof Oe))return console.error("GetSubData:Unknown index type",y),null;T=m.value}if(T<0||T>=b.data.length)return console.error("GetSubData:Index out of range",T),null;if(b.data instanceof Float32Array){const i=new Float32Array(b.data.buffer,b.data.byteOffset+4*T,1);return new Oe(i,_)}if(b.data instanceof Int32Array){const i=new Int32Array(b.data.buffer,b.data.byteOffset+4*T,1);return new Oe(i,_)}if(b.data instanceof Uint32Array){const i=new Uint32Array(b.data.buffer,b.data.byteOffset+4*T,1);return new Oe(i,_)}throw"GetSubData:Invalid data type"}if(!(m instanceof fe))return console.error("GetSubData:Unknown postfix",m),null;{const g=m.value.toLowerCase();if(1===g.length){let i=0;if("x"===g||"r"===g)i=0;else if("y"===g||"g"===g)i=1;else if("z"===g||"b"===g)i=2;else{if("w"!==g&&"a"!==g)return console.error(`GetSubData:Unknown member ${g}`),null;i=3}if(this.data instanceof Float32Array){let m=new Float32Array(this.data.buffer,this.data.byteOffset+4*i,1);return new Oe(m,_,this)}if(this.data instanceof Int32Array){let m=new Int32Array(this.data.buffer,this.data.byteOffset+4*i,1);return new Oe(m,_,this)}if(this.data instanceof Uint32Array){let m=new Uint32Array(this.data.buffer,this.data.byteOffset+4*i,1);return new Oe(m,_,this)}}const y=[];for(const i of g)"x"===i||"r"===i?y.push(this.data[0]):"y"===i||"g"===i?y.push(this.data[1]):"z"===i||"b"===i?y.push(this.data[2]):"w"===i||"a"===i?y.push(this.data[3]):console.error(`GetDataValue:Unknown member ${i}`);b=Be(i,y,_.name)}m=m.postfix}return b}toString(){let i=`${this.data[0]}`;for(let m=1;m<this.data.length;++m)i+=`,${this.data[m]}`;return i}}class Me extends De{constructor(i,m,g=null){super(m,g),i instanceof Float32Array?this.data=i:this.data=new Float32Array(i)}clone(){return new Me(new Float32Array(this.data),this.typeInfo,null)}setDataValue(i,m,g,_){g instanceof fe?console.error("TODO:Set matrix postfix"):m instanceof Me?this.data=m.data:console.error("SetDataValue:Invalid value",m)}getSubData(i,m,g){if(null===m)return this;const _=this.typeInfo.name;if(i.getTypeInfo("f32"),this.typeInfo instanceof a)this.typeInfo.format;else if(_.endsWith("f"))i.getTypeInfo("f32");else if(_.endsWith("i"))i.getTypeInfo("i32");else if(_.endsWith("u"))i.getTypeInfo("u32");else{if(!_.endsWith("h"))return console.error(`GetDataValue:Unknown type ${_}`),null;i.getTypeInfo("f16")}if(m instanceof be){const b=m.index;let y=-1;if(b instanceof ge){if(!(b.value instanceof Oe))return console.error(`GetDataValue:Invalid array index ${b.value}`),null;y=b.value.value}else{const m=i.evalExpression(b,g);if(!(m instanceof Oe))return console.error("GetDataValue:Unknown index type",b),null;y=m.value}if(y<0||y>=this.data.length)return console.error("GetDataValue:Index out of range",y),null;const T=_.endsWith("h")?"h":"f";let w;if("mat2x2"===_||"mat2x2f"===_||"mat2x2h"===_||"mat3x2"===_||"mat3x2f"===_||"mat3x2h"===_||"mat4x2"===_||"mat4x2f"===_||"mat4x2h"===_)w=new Fe(new Float32Array(this.data.buffer,this.data.byteOffset+2*y*4,2),i.getTypeInfo(`vec2${T}`));else if("mat2x3"===_||"mat2x3f"===_||"mat2x3h"===_||"mat3x3"===_||"mat3x3f"===_||"mat3x3h"===_||"mat4x3"===_||"mat4x3f"===_||"mat4x3h"===_)w=new Fe(new Float32Array(this.data.buffer,this.data.byteOffset+3*y*4,3),i.getTypeInfo(`vec3${T}`));else{if("mat2x4"!==_&&"mat2x4f"!==_&&"mat2x4h"!==_&&"mat3x4"!==_&&"mat3x4f"!==_&&"mat3x4h"!==_&&"mat4x4"!==_&&"mat4x4f"!==_&&"mat4x4h"!==_)return console.error(`GetDataValue:Unknown type ${_}`),null;w=new Fe(new Float32Array(this.data.buffer,this.data.byteOffset+4*y*4,4),i.getTypeInfo(`vec4${T}`))}return m.postfix?w.getSubData(i,m.postfix,g):w}return console.error("GetDataValue:Invalid postfix",m),null}toString(){let i=`${this.data[0]}`;for(let m=1;m<this.data.length;++m)i+=`,${this.data[m]}`;return i}}class Ue extends De{constructor(i,m,g=0,_=null){super(m,_),this.buffer=i instanceof ArrayBuffer?i:i.buffer,this.offset=g}clone(){const i=new Uint8Array(new Uint8Array(this.buffer,this.offset,this.typeInfo.size));return new Ue(i.buffer,this.typeInfo,0,null)}setDataValue(i,m,g,_){if(null===m)return void console.log("setDataValue:NULL data.");let b=this.offset,y=this.typeInfo;for(;g;){if(g instanceof be)if(y instanceof s){const m=g.index;if(m instanceof ge){if(!(m.value instanceof Oe))return void console.error(`SetDataValue:Invalid index type ${m.value}`);b+=m.value.value*y.stride}else{const g=i.evalExpression(m,_);if(!(g instanceof Oe))return void console.error("SetDataValue:Unknown index type",m);b+=g.value*y.stride}y=y.format}else console.error(`SetDataValue:Type ${y.getTypeName()} is not an array`);else{if(!(g instanceof fe))return void console.error("SetDataValue:Unknown postfix type",g);{const i=g.value;if(y instanceof n){let m=!1;for(const g of y.members)if(g.name===i){b+=g.offset,y=g.type,m=!0;break}if(!m)return void console.error(`SetDataValue:Member ${i} not found`)}else if(y instanceof e){const g=y.getTypeName();let _=0;if("x"===i||"r"===i)_=0;else if("y"===i||"g"===i)_=1;else if("z"===i||"b"===i)_=2;else{if("w"!==i&&"a"!==i)return void console.error(`SetDataValue:Unknown member ${i}`);_=3}if(!(m instanceof Oe))return void console.error("SetDataValue:Invalid value",m);const T=m.value;return"vec2f"===g?void(new Float32Array(this.buffer,b,2)[_]=T):"vec3f"===g?void(new Float32Array(this.buffer,b,3)[_]=T):"vec4f"===g?void(new Float32Array(this.buffer,b,4)[_]=T):"vec2i"===g?void(new Int32Array(this.buffer,b,2)[_]=T):"vec3i"===g?void(new Int32Array(this.buffer,b,3)[_]=T):"vec4i"===g?void(new Int32Array(this.buffer,b,4)[_]=T):"vec2u"===g?void(new Uint32Array(this.buffer,b,2)[_]=T):"vec3u"===g?void(new Uint32Array(this.buffer,b,3)[_]=T):"vec4u"===g?void(new Uint32Array(this.buffer,b,4)[_]=T):void console.error(`SetDataValue:Type ${g} is not a struct`)}}}g=g.postfix}this.setData(i,m,y,b,_)}setData(i,m,g,_,b){const y=g.getTypeName();if("f32"!==y&&"f16"!==y)if("i32"!==y&&"atomic<i32>"!==y&&"x32"!==y)if("u32"!==y&&"atomic<u32>"!==y)if("bool"!==y)if("vec2f"!==y&&"vec2h"!==y)if("vec3f"!==y&&"vec3h"!==y)if("vec4f"!==y&&"vec4h"!==y)if("vec2i"!==y)if("vec3i"!==y)if("vec4i"!==y)if("vec2u"!==y)if("vec3u"!==y)if("vec4u"!==y)if("vec2b"!==y)if("vec3b"!==y)if("vec4b"!==y)if("mat2x2f"!==y&&"mat2x2h"!==y)if("mat2x3f"!==y&&"mat2x3h"!==y)if("mat2x4f"!==y&&"mat2x4h"!==y)if("mat3x2f"!==y&&"mat3x2h"!==y)if("mat3x3f"!==y&&"mat3x3h"!==y)if("mat3x4f"!==y&&"mat3x4h"!==y)if("mat4x2f"!==y&&"mat4x2h"!==y)if("mat4x3f"!==y&&"mat4x3h"!==y)if("mat4x4f"!==y&&"mat4x4h"!==y)if(m instanceof Ue){if(g===m.typeInfo)return void new Uint8Array(this.buffer,_,m.buffer.byteLength).set(new Uint8Array(m.buffer));console.error("SetDataValue:Type mismatch",y,m.typeInfo.getTypeName())}else console.error(`SetData:Unknown type ${y}`);else{const i=new Float32Array(this.buffer,_,16);m instanceof Me?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3],i[4]=m.data[4],i[5]=m.data[5],i[6]=m.data[6],i[7]=m.data[7],i[8]=m.data[8],i[9]=m.data[9],i[10]=m.data[10],i[11]=m.data[11],i[12]=m.data[12],i[13]=m.data[13],i[14]=m.data[14],i[15]=m.data[15]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7],i[8]=m[8],i[9]=m[9],i[10]=m[10],i[11]=m[11],i[12]=m[12],i[13]=m[13],i[14]=m[14],i[15]=m[15])}else{const i=new Float32Array(this.buffer,_,12);m instanceof Me?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3],i[4]=m.data[4],i[5]=m.data[5],i[6]=m.data[6],i[7]=m.data[7],i[8]=m.data[8],i[9]=m.data[9],i[10]=m.data[10],i[11]=m.data[11]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7],i[8]=m[8],i[9]=m[9],i[10]=m[10],i[11]=m[11])}else{const i=new Float32Array(this.buffer,_,8);m instanceof Me?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3],i[4]=m.data[4],i[5]=m.data[5],i[6]=m.data[6],i[7]=m.data[7]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7])}else{const i=new Float32Array(this.buffer,_,12);m instanceof Me?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3],i[4]=m.data[4],i[5]=m.data[5],i[6]=m.data[6],i[7]=m.data[7],i[8]=m.data[8],i[9]=m.data[9],i[10]=m.data[10],i[11]=m.data[11]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7],i[8]=m[8],i[9]=m[9],i[10]=m[10],i[11]=m[11])}else{const i=new Float32Array(this.buffer,_,9);m instanceof Me?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3],i[4]=m.data[4],i[5]=m.data[5],i[6]=m.data[6],i[7]=m.data[7],i[8]=m.data[8]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7],i[8]=m[8])}else{const i=new Float32Array(this.buffer,_,6);m instanceof Me?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3],i[4]=m.data[4],i[5]=m.data[5]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5])}else{const i=new Float32Array(this.buffer,_,8);m instanceof Me?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3],i[4]=m.data[4],i[5]=m.data[5],i[6]=m.data[6],i[7]=m.data[7]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7])}else{const i=new Float32Array(this.buffer,_,6);m instanceof Me?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3],i[4]=m.data[4],i[5]=m.data[5]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5])}else{const i=new Float32Array(this.buffer,_,4);m instanceof Me?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3])}else{const i=new Uint32Array(this.buffer,_,4);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3])}else{const i=new Uint32Array(this.buffer,_,3);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2]):(i[0]=m[0],i[1]=m[1],i[2]=m[2])}else{const i=new Uint32Array(this.buffer,_,2);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1]):(i[0]=m[0],i[1]=m[1])}else{const i=new Uint32Array(this.buffer,_,4);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3])}else{const i=new Uint32Array(this.buffer,_,3);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2]):(i[0]=m[0],i[1]=m[1],i[2]=m[2])}else{const i=new Uint32Array(this.buffer,_,2);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1]):(i[0]=m[0],i[1]=m[1])}else{const i=new Int32Array(this.buffer,_,4);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3])}else{const i=new Int32Array(this.buffer,_,3);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2]):(i[0]=m[0],i[1]=m[1],i[2]=m[2])}else{const i=new Int32Array(this.buffer,_,2);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1]):(i[0]=m[0],i[1]=m[1])}else{const i=new Float32Array(this.buffer,_,4);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2],i[3]=m.data[3]):(i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3])}else{const i=new Float32Array(this.buffer,_,3);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1],i[2]=m.data[2]):(i[0]=m[0],i[1]=m[1],i[2]=m[2])}else{const i=new Float32Array(this.buffer,_,2);m instanceof Fe?(i[0]=m.data[0],i[1]=m.data[1]):(i[0]=m[0],i[1]=m[1])}else m instanceof Oe&&(new Int32Array(this.buffer,_,1)[0]=m.value);else m instanceof Oe&&(new Uint32Array(this.buffer,_,1)[0]=m.value);else m instanceof Oe&&(new Int32Array(this.buffer,_,1)[0]=m.value);else m instanceof Oe&&(new Float32Array(this.buffer,_,1)[0]=m.value)}getSubData(i,m,g){var _,b,y;if(null===m)return this;let T=this.offset,w=this.typeInfo;for(;m;){if(m instanceof be){const _=m.index,b=_ instanceof he?i.evalExpression(_,g):_;let y=0;if(b instanceof Oe?y=b.value:"number"==typeof b?y=b:console.error("GetDataValue:Invalid index type",_),w instanceof s)T+=y*w.stride,w=w.format;else{const m=w.getTypeName();"mat4x4"===m||"mat4x4f"===m||"mat4x4h"===m?(T+=16*y,w=i.getTypeInfo("vec4f")):console.error(`getDataValue:Type ${w.getTypeName()} is not an array`)}}else{if(!(m instanceof fe))return console.error("GetDataValue:Unknown postfix type",m),null;{const g=m.value;if(w instanceof n){let i=!1;for(const m of w.members)if(m.name===g){T+=m.offset,w=m.type,i=!0;break}if(!i)return console.error(`GetDataValue:Member ${g} not found`),null}else if(w instanceof e){const m=w.getTypeName();if("vec2f"===m||"vec3f"===m||"vec4f"===m||"vec2i"===m||"vec3i"===m||"vec4i"===m||"vec2u"===m||"vec3u"===m||"vec4u"===m||"vec2b"===m||"vec3b"===m||"vec4b"===m||"vec2h"===m||"vec3h"===m||"vec4h"===m||"vec2"===m||"vec3"===m||"vec4"===m){if(g.length>0&&g.length<5){let _="f";const b=[];for(let y=0;y<g.length;++y){const w=g[y].toLowerCase();let P=0;if("x"===w||"r"===w)P=0;else if("y"===w||"g"===w)P=1;else if("z"===w||"b"===w)P=2;else{if("w"!==w&&"a"!==w)return console.error(`Unknown member ${g}`),null;P=3}if(1===g.length){if(m.endsWith("f"))return this.buffer.byteLength<T+4*P+4?(console.log("Insufficient buffer data"),null):new Oe(new Float32Array(this.buffer,T+4*P,1),i.getTypeInfo("f32"),this);if(m.endsWith("h"))return new Oe(new Float32Array(this.buffer,T+4*P,1),i.getTypeInfo("f16"),this);if(m.endsWith("i"))return new Oe(new Int32Array(this.buffer,T+4*P,1),i.getTypeInfo("i32"),this);if(m.endsWith("b"))return new Oe(new Int32Array(this.buffer,T+4*P,1),i.getTypeInfo("bool"),this);if(m.endsWith("u"))return new Oe(new Uint32Array(this.buffer,T+4*P,1),i.getTypeInfo("i32"),this)}if("vec2f"===m)b.push(new Float32Array(this.buffer,T,2)[P]);else if("vec3f"===m){if(T+12>=this.buffer.byteLength)return console.log("Insufficient buffer data"),null;const i=new Float32Array(this.buffer,T,3);b.push(i[P])}else if("vec4f"===m)b.push(new Float32Array(this.buffer,T,4)[P]);else if("vec2i"===m)_="i",b.push(new Int32Array(this.buffer,T,2)[P]);else if("vec3i"===m)_="i",b.push(new Int32Array(this.buffer,T,3)[P]);else if("vec4i"===m)_="i",b.push(new Int32Array(this.buffer,T,4)[P]);else if("vec2u"===m){_="u";const i=new Uint32Array(this.buffer,T,2);b.push(i[P])}else"vec3u"===m?(_="u",b.push(new Uint32Array(this.buffer,T,3)[P])):"vec4u"===m&&(_="u",b.push(new Uint32Array(this.buffer,T,4)[P]))}return 2===b.length?w=i.getTypeInfo(`vec2${_}`):3===b.length?w=i.getTypeInfo(`vec3${_}`):4===b.length?w=i.getTypeInfo(`vec4${_}`):console.error(`GetDataValue:Invalid vector length ${b.length}`),new Fe(b,w,null)}return console.error(`GetDataValue:Unknown member ${g}`),null}return console.error(`GetDataValue:Type ${m} is not a struct`),null}}}m=m.postfix}const P=w.getTypeName();return"f32"===P?new Oe(new Float32Array(this.buffer,T,1),w,this):"i32"===P?new Oe(new Int32Array(this.buffer,T,1),w,this):"u32"===P?new Oe(new Uint32Array(this.buffer,T,1),w,this):"vec2f"===P?new Fe(new Float32Array(this.buffer,T,2),w,this):"vec3f"===P?new Fe(new Float32Array(this.buffer,T,3),w,this):"vec4f"===P?new Fe(new Float32Array(this.buffer,T,4),w,this):"vec2i"===P?new Fe(new Int32Array(this.buffer,T,2),w,this):"vec3i"===P?new Fe(new Int32Array(this.buffer,T,3),w,this):"vec4i"===P?new Fe(new Int32Array(this.buffer,T,4),w,this):"vec2u"===P?new Fe(new Uint32Array(this.buffer,T,2),w,this):"vec3u"===P?new Fe(new Uint32Array(this.buffer,T,3),w,this):"vec4u"===P?new Fe(new Uint32Array(this.buffer,T,4),w,this):w instanceof a&&"atomic"===w.name?"u32"===(null===(_=w.format)||void 0===_?void 0:_.name)?new Oe(new Uint32Array(this.buffer,T,1)[0],w.format,this):"i32"===(null===(b=w.format)||void 0===b?void 0:b.name)?new Oe(new Int32Array(this.buffer,T,1)[0],w.format,this):(console.error(`GetDataValue:Invalid atomic format ${null===(y=w.format)||void 0===y?void 0:y.name}`),null):new Ue(this.buffer,w,T,this)}toString(){let i="";if(this.typeInfo instanceof s)if("f32"===this.typeInfo.format.name){const m=new Float32Array(this.buffer,this.offset);i=`[${m[0]}`;for(let g=1;g<m.length;++g)i+=`,${m[g]}`}else if("i32"===this.typeInfo.format.name){const m=new Int32Array(this.buffer,this.offset);i=`[${m[0]}`;for(let g=1;g<m.length;++g)i+=`,${m[g]}`}else if("u32"===this.typeInfo.format.name){const m=new Uint32Array(this.buffer,this.offset);i=`[${m[0]}`;for(let g=1;g<m.length;++g)i+=`,${m[g]}`}else if("vec2f"===this.typeInfo.format.name){const m=new Float32Array(this.buffer,this.offset);i=`[${m[0]},${m[1]}]`;for(let g=1;g<m.length/2;++g)i+=`,[${m[2*g]},${m[2*g+1]}]`}else if("vec3f"===this.typeInfo.format.name){const m=new Float32Array(this.buffer,this.offset);i=`[${m[0]},${m[1]},${m[2]}]`;for(let g=4;g<m.length;g+=4)i+=`,[${m[g]},${m[g+1]},${m[g+2]}]`}else if("vec4f"===this.typeInfo.format.name){const m=new Float32Array(this.buffer,this.offset);i=`[${m[0]},${m[1]},${m[2]},${m[3]}]`;for(let g=4;g<m.length;g+=4)i+=`,[${m[g]},${m[g+1]},${m[g+2]},${m[g+3]}]`}else i="[...]";else this.typeInfo instanceof n?i+="{...}":i="[...]";return i}}class Pe extends De{constructor(i,m,g,_){super(m,null),this.data=i,this.descriptor=g,this.view=_}clone(){return new Pe(this.data,this.typeInfo,this.descriptor,this.view)}get width(){var i,m;const g=this.descriptor.size;return g instanceof Array&&g.length>0?null!==(i=g[0])&&void 0!==i?i:0:g instanceof Object&&null!==(m=g.width)&&void 0!==m?m:0}get height(){var i,m;const g=this.descriptor.size;return g instanceof Array&&g.length>1?null!==(i=g[1])&&void 0!==i?i:0:g instanceof Object&&null!==(m=g.height)&&void 0!==m?m:0}get depthOrArrayLayers(){var i,m;const g=this.descriptor.size;return g instanceof Array&&g.length>2?null!==(i=g[2])&&void 0!==i?i:0:g instanceof Object&&null!==(m=g.depthOrArrayLayers)&&void 0!==m?m:0}get format(){var i;return this.descriptor&&null!==(i=this.descriptor.format)&&void 0!==i?i:"rgba8unorm"}get sampleCount(){var i;return this.descriptor&&null!==(i=this.descriptor.sampleCount)&&void 0!==i?i:1}get mipLevelCount(){var i;return this.descriptor&&null!==(i=this.descriptor.mipLevelCount)&&void 0!==i?i:1}get dimension(){var i;return this.descriptor&&null!==(i=this.descriptor.dimension)&&void 0!==i?i:"2d"}getMipLevelSize(i){if(i>=this.mipLevelCount)return[0,0,0];const m=[this.width,this.height,this.depthOrArrayLayers];for(let g=0;g<m.length;++g)m[g]=Math.max(1,m[g]>>i);return m}get texelByteSize(){const i=this.format,m=Wt[i];return m?m.isDepthStencil?4:m.bytesPerBlock:0}get bytesPerRow(){return this.width*this.texelByteSize}get isDepthStencil(){const i=this.format,m=Wt[i];return!!m&&m.isDepthStencil}getGpuSize(){const i=this.format,m=Wt[i],g=this.width;if(!i||g<=0||!m)return-1;const _=this.height,b=this.depthOrArrayLayers,y=this.dimension;return g/m.blockWidth*("1d"===y?1:_/m.blockHeight)*m.bytesPerBlock*b}getPixel(i,m,g=0,_=0){const b=this.texelByteSize,y=this.bytesPerRow,T=this.height,w=this.data[_];return function(i,m,g,_,b,y,T,w,P){const H=_*(T>>=b)*(y>>=b)+g*T+m*w;switch(P){case"r8unorm":return[k(i,H,"8unorm",1)[0]];case"r8snorm":return[k(i,H,"8snorm",1)[0]];case"r8uint":return[k(i,H,"8uint",1)[0]];case"r8sint":return[k(i,H,"8sint",1)[0]];case"rg8unorm":{const m=k(i,H,"8unorm",2);return[m[0],m[1]]}case"rg8snorm":{const m=k(i,H,"8snorm",2);return[m[0],m[1]]}case"rg8uint":{const m=k(i,H,"8uint",2);return[m[0],m[1]]}case"rg8sint":{const m=k(i,H,"8sint",2);return[m[0],m[1]]}case"rgba8unorm-srgb":case"rgba8unorm":{const m=k(i,H,"8unorm",4);return[m[0],m[1],m[2],m[3]]}case"rgba8snorm":{const m=k(i,H,"8snorm",4);return[m[0],m[1],m[2],m[3]]}case"rgba8uint":{const m=k(i,H,"8uint",4);return[m[0],m[1],m[2],m[3]]}case"rgba8sint":{const m=k(i,H,"8sint",4);return[m[0],m[1],m[2],m[3]]}case"bgra8unorm-srgb":case"bgra8unorm":{const m=k(i,H,"8unorm",4);return[m[2],m[1],m[0],m[3]]}case"r16uint":return[k(i,H,"16uint",1)[0]];case"r16sint":return[k(i,H,"16sint",1)[0]];case"r16float":return[k(i,H,"16float",1)[0]];case"rg16uint":{const m=k(i,H,"16uint",2);return[m[0],m[1]]}case"rg16sint":{const m=k(i,H,"16sint",2);return[m[0],m[1]]}case"rg16float":{const m=k(i,H,"16float",2);return[m[0],m[1]]}case"rgba16uint":{const m=k(i,H,"16uint",4);return[m[0],m[1],m[2],m[3]]}case"rgba16sint":{const m=k(i,H,"16sint",4);return[m[0],m[1],m[2],m[3]]}case"rgba16float":{const m=k(i,H,"16float",4);return[m[0],m[1],m[2],m[3]]}case"r32uint":return[k(i,H,"32uint",1)[0]];case"r32sint":return[k(i,H,"32sint",1)[0]];case"depth16unorm":case"depth24plus":case"depth24plus-stencil8":case"depth32float":case"depth32float-stencil8":case"r32float":return[k(i,H,"32float",1)[0]];case"rg32uint":{const m=k(i,H,"32uint",2);return[m[0],m[1]]}case"rg32sint":{const m=k(i,H,"32sint",2);return[m[0],m[1]]}case"rg32float":{const m=k(i,H,"32float",2);return[m[0],m[1]]}case"rgba32uint":{const m=k(i,H,"32uint",4);return[m[0],m[1],m[2],m[3]]}case"rgba32sint":{const m=k(i,H,"32sint",4);return[m[0],m[1],m[2],m[3]]}case"rgba32float":{const m=k(i,H,"32float",4);return[m[0],m[1],m[2],m[3]]}case"rg11b10ufloat":{const m=new Uint32Array(i.buffer,H,1)[0],g=(4192256&m)>>11,_=(4290772992&m)>>22;return[v(2047&m),v(g),function(i){const m=112+(i>>5&31)<<23|(31&i)<<18;return $t[0]=m,Kt[0]}(_),1]}}return null}(new Uint8Array(w),i,m,g,_,T,y,b,this.format)}setPixel(i,m,g,_,b){const y=this.texelByteSize,T=this.bytesPerRow,w=this.height,P=this.data[_];!function(i,m,g,_,b,y,T,w,P,H){const $=_*(T>>=b)*(y>>=b)+g*T+m*w;switch(P){case"r8unorm":return void I(i,$,"8unorm",1,H);case"r8snorm":return void I(i,$,"8snorm",1,H);case"r8uint":return void I(i,$,"8uint",1,H);case"r8sint":return void I(i,$,"8sint",1,H);case"rg8unorm":return void I(i,$,"8unorm",2,H);case"rg8snorm":return void I(i,$,"8snorm",2,H);case"rg8uint":return void I(i,$,"8uint",2,H);case"rg8sint":return void I(i,$,"8sint",2,H);case"rgba8unorm-srgb":case"rgba8unorm":case"bgra8unorm-srgb":case"bgra8unorm":return void I(i,$,"8unorm",4,H);case"rgba8snorm":return void I(i,$,"8snorm",4,H);case"rgba8uint":return void I(i,$,"8uint",4,H);case"rgba8sint":return void I(i,$,"8sint",4,H);case"r16uint":return void I(i,$,"16uint",1,H);case"r16sint":return void I(i,$,"16sint",1,H);case"r16float":return void I(i,$,"16float",1,H);case"rg16uint":return void I(i,$,"16uint",2,H);case"rg16sint":return void I(i,$,"16sint",2,H);case"rg16float":return void I(i,$,"16float",2,H);case"rgba16uint":return void I(i,$,"16uint",4,H);case"rgba16sint":return void I(i,$,"16sint",4,H);case"rgba16float":return void I(i,$,"16float",4,H);case"r32uint":return void I(i,$,"32uint",1,H);case"r32sint":return void I(i,$,"32sint",1,H);case"depth16unorm":case"depth24plus":case"depth24plus-stencil8":case"depth32float":case"depth32float-stencil8":case"r32float":return void I(i,$,"32float",1,H);case"rg32uint":return void I(i,$,"32uint",2,H);case"rg32sint":return void I(i,$,"32sint",2,H);case"rg32float":return void I(i,$,"32float",2,H);case"rgba32uint":return void I(i,$,"32uint",4,H);case"rgba32sint":return void I(i,$,"32sint",4,H);case"rgba32float":return void I(i,$,"32float",4,H);case"rg11b10ufloat":console.error("TODO:rg11b10ufloat not supported for writing")}}(new Uint8Array(P),i,m,g,_,w,T,y,this.format,b)}}(i=>{i[i.token=0]="token",i[i.keyword=1]="keyword",i[i.reserved=2]="reserved"})(Zt||(Zt={}));class We{constructor(i,m,g){this.name=i,this.type=m,this.rule=g}toString(){return this.name}}class qe{}Yt=qe,qe.none=new We("",Zt.reserved,""),qe.eof=new We("EOF",Zt.token,""),qe.reserved={asm:new We("asm",Zt.reserved,"asm"),bf16:new We("bf16",Zt.reserved,"bf16"),do:new We("do",Zt.reserved,"do"),enum:new We("enum",Zt.reserved,"enum"),f16:new We("f16",Zt.reserved,"f16"),f64:new We("f64",Zt.reserved,"f64"),handle:new We("handle",Zt.reserved,"handle"),i8:new We("i8",Zt.reserved,"i8"),i16:new We("i16",Zt.reserved,"i16"),i64:new We("i64",Zt.reserved,"i64"),mat:new We("mat",Zt.reserved,"mat"),premerge:new We("premerge",Zt.reserved,"premerge"),regardless:new We("regardless",Zt.reserved,"regardless"),typedef:new We("typedef",Zt.reserved,"typedef"),u8:new We("u8",Zt.reserved,"u8"),u16:new We("u16",Zt.reserved,"u16"),u64:new We("u64",Zt.reserved,"u64"),unless:new We("unless",Zt.reserved,"unless"),using:new We("using",Zt.reserved,"using"),vec:new We("vec",Zt.reserved,"vec"),void:new We("void",Zt.reserved,"void")},qe.keywords={array:new We("array",Zt.keyword,"array"),atomic:new We("atomic",Zt.keyword,"atomic"),bool:new We("bool",Zt.keyword,"bool"),f32:new We("f32",Zt.keyword,"f32"),i32:new We("i32",Zt.keyword,"i32"),mat2x2:new We("mat2x2",Zt.keyword,"mat2x2"),mat2x3:new We("mat2x3",Zt.keyword,"mat2x3"),mat2x4:new We("mat2x4",Zt.keyword,"mat2x4"),mat3x2:new We("mat3x2",Zt.keyword,"mat3x2"),mat3x3:new We("mat3x3",Zt.keyword,"mat3x3"),mat3x4:new We("mat3x4",Zt.keyword,"mat3x4"),mat4x2:new We("mat4x2",Zt.keyword,"mat4x2"),mat4x3:new We("mat4x3",Zt.keyword,"mat4x3"),mat4x4:new We("mat4x4",Zt.keyword,"mat4x4"),ptr:new We("ptr",Zt.keyword,"ptr"),sampler:new We("sampler",Zt.keyword,"sampler"),sampler_comparison:new We("sampler_comparison",Zt.keyword,"sampler_comparison"),struct:new We("struct",Zt.keyword,"struct"),texture_1d:new We("texture_1d",Zt.keyword,"texture_1d"),texture_2d:new We("texture_2d",Zt.keyword,"texture_2d"),texture_2d_array:new We("texture_2d_array",Zt.keyword,"texture_2d_array"),texture_3d:new We("texture_3d",Zt.keyword,"texture_3d"),texture_cube:new We("texture_cube",Zt.keyword,"texture_cube"),texture_cube_array:new We("texture_cube_array",Zt.keyword,"texture_cube_array"),texture_multisampled_2d:new We("texture_multisampled_2d",Zt.keyword,"texture_multisampled_2d"),texture_storage_1d:new We("texture_storage_1d",Zt.keyword,"texture_storage_1d"),texture_storage_2d:new We("texture_storage_2d",Zt.keyword,"texture_storage_2d"),texture_storage_2d_array:new We("texture_storage_2d_array",Zt.keyword,"texture_storage_2d_array"),texture_storage_3d:new We("texture_storage_3d",Zt.keyword,"texture_storage_3d"),texture_depth_2d:new We("texture_depth_2d",Zt.keyword,"texture_depth_2d"),texture_depth_2d_array:new We("texture_depth_2d_array",Zt.keyword,"texture_depth_2d_array"),texture_depth_cube:new We("texture_depth_cube",Zt.keyword,"texture_depth_cube"),texture_depth_cube_array:new We("texture_depth_cube_array",Zt.keyword,"texture_depth_cube_array"),texture_depth_multisampled_2d:new We("texture_depth_multisampled_2d",Zt.keyword,"texture_depth_multisampled_2d"),texture_external:new We("texture_external",Zt.keyword,"texture_external"),u32:new We("u32",Zt.keyword,"u32"),vec2:new We("vec2",Zt.keyword,"vec2"),vec3:new We("vec3",Zt.keyword,"vec3"),vec4:new We("vec4",Zt.keyword,"vec4"),bitcast:new We("bitcast",Zt.keyword,"bitcast"),block:new We("block",Zt.keyword,"block"),break:new We("break",Zt.keyword,"break"),case:new We("case",Zt.keyword,"case"),continue:new We("continue",Zt.keyword,"continue"),continuing:new We("continuing",Zt.keyword,"continuing"),default:new We("default",Zt.keyword,"default"),diagnostic:new We("diagnostic",Zt.keyword,"diagnostic"),discard:new We("discard",Zt.keyword,"discard"),else:new We("else",Zt.keyword,"else"),enable:new We("enable",Zt.keyword,"enable"),fallthrough:new We("fallthrough",Zt.keyword,"fallthrough"),false:new We("false",Zt.keyword,"false"),fn:new We("fn",Zt.keyword,"fn"),for:new We("for",Zt.keyword,"for"),function:new We("function",Zt.keyword,"function"),if:new We("if",Zt.keyword,"if"),let:new We("let",Zt.keyword,"let"),const:new We("const",Zt.keyword,"const"),loop:new We("loop",Zt.keyword,"loop"),while:new We("while",Zt.keyword,"while"),private:new We("private",Zt.keyword,"private"),read:new We("read",Zt.keyword,"read"),read_write:new We("read_write",Zt.keyword,"read_write"),return:new We("return",Zt.keyword,"return"),requires:new We("requires",Zt.keyword,"requires"),storage:new We("storage",Zt.keyword,"storage"),switch:new We("switch",Zt.keyword,"switch"),true:new We("true",Zt.keyword,"true"),alias:new We("alias",Zt.keyword,"alias"),type:new We("type",Zt.keyword,"type"),uniform:new We("uniform",Zt.keyword,"uniform"),var:new We("var",Zt.keyword,"var"),override:new We("override",Zt.keyword,"override"),workgroup:new We("workgroup",Zt.keyword,"workgroup"),write:new We("write",Zt.keyword,"write"),r8unorm:new We("r8unorm",Zt.keyword,"r8unorm"),r8snorm:new We("r8snorm",Zt.keyword,"r8snorm"),r8uint:new We("r8uint",Zt.keyword,"r8uint"),r8sint:new We("r8sint",Zt.keyword,"r8sint"),r16uint:new We("r16uint",Zt.keyword,"r16uint"),r16sint:new We("r16sint",Zt.keyword,"r16sint"),r16float:new We("r16float",Zt.keyword,"r16float"),rg8unorm:new We("rg8unorm",Zt.keyword,"rg8unorm"),rg8snorm:new We("rg8snorm",Zt.keyword,"rg8snorm"),rg8uint:new We("rg8uint",Zt.keyword,"rg8uint"),rg8sint:new We("rg8sint",Zt.keyword,"rg8sint"),r32uint:new We("r32uint",Zt.keyword,"r32uint"),r32sint:new We("r32sint",Zt.keyword,"r32sint"),r32float:new We("r32float",Zt.keyword,"r32float"),rg16uint:new We("rg16uint",Zt.keyword,"rg16uint"),rg16sint:new We("rg16sint",Zt.keyword,"rg16sint"),rg16float:new We("rg16float",Zt.keyword,"rg16float"),rgba8unorm:new We("rgba8unorm",Zt.keyword,"rgba8unorm"),rgba8unorm_srgb:new We("rgba8unorm_srgb",Zt.keyword,"rgba8unorm_srgb"),rgba8snorm:new We("rgba8snorm",Zt.keyword,"rgba8snorm"),rgba8uint:new We("rgba8uint",Zt.keyword,"rgba8uint"),rgba8sint:new We("rgba8sint",Zt.keyword,"rgba8sint"),bgra8unorm:new We("bgra8unorm",Zt.keyword,"bgra8unorm"),bgra8unorm_srgb:new We("bgra8unorm_srgb",Zt.keyword,"bgra8unorm_srgb"),rgb10a2unorm:new We("rgb10a2unorm",Zt.keyword,"rgb10a2unorm"),rg11b10float:new We("rg11b10float",Zt.keyword,"rg11b10float"),rg32uint:new We("rg32uint",Zt.keyword,"rg32uint"),rg32sint:new We("rg32sint",Zt.keyword,"rg32sint"),rg32float:new We("rg32float",Zt.keyword,"rg32float"),rgba16uint:new We("rgba16uint",Zt.keyword,"rgba16uint"),rgba16sint:new We("rgba16sint",Zt.keyword,"rgba16sint"),rgba16float:new We("rgba16float",Zt.keyword,"rgba16float"),rgba32uint:new We("rgba32uint",Zt.keyword,"rgba32uint"),rgba32sint:new We("rgba32sint",Zt.keyword,"rgba32sint"),rgba32float:new We("rgba32float",Zt.keyword,"rgba32float"),static_assert:new We("static_assert",Zt.keyword,"static_assert")},qe.tokens={decimal_float_literal:new We("decimal_float_literal",Zt.token,/((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/),hex_float_literal:new We("hex_float_literal",Zt.token,/-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+[fh]?))/),int_literal:new We("int_literal",Zt.token,/-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),uint_literal:new We("uint_literal",Zt.token,/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),name:new We("name",Zt.token,/([_\p{XID_Start}][\p{XID_Continue}]+)|([\p{XID_Start}])/u),ident:new We("ident",Zt.token,/[_a-zA-Z][0-9a-zA-Z_]*/),and:new We("and",Zt.token,"&"),and_and:new We("and_and",Zt.token,"&&"),arrow:new We("arrow ",Zt.token,"->"),attr:new We("attr",Zt.token,"@"),forward_slash:new We("forward_slash",Zt.token,"/"),bang:new We("bang",Zt.token,"!"),bracket_left:new We("bracket_left",Zt.token,"["),bracket_right:new We("bracket_right",Zt.token,"]"),brace_left:new We("brace_left",Zt.token,"{"),brace_right:new We("brace_right",Zt.token,"}"),colon:new We("colon",Zt.token,":"),comma:new We("comma",Zt.token,","),equal:new We("equal",Zt.token,"="),equal_equal:new We("equal_equal",Zt.token,"=="),not_equal:new We("not_equal",Zt.token,"!="),greater_than:new We("greater_than",Zt.token,">"),greater_than_equal:new We("greater_than_equal",Zt.token,">="),shift_right:new We("shift_right",Zt.token,">>"),less_than:new We("less_than",Zt.token,"<"),less_than_equal:new We("less_than_equal",Zt.token,"<="),shift_left:new We("shift_left",Zt.token,"<<"),modulo:new We("modulo",Zt.token,"%"),minus:new We("minus",Zt.token,"-"),minus_minus:new We("minus_minus",Zt.token,"--"),period:new We("period",Zt.token,"."),plus:new We("plus",Zt.token,"+"),plus_plus:new We("plus_plus",Zt.token,"++"),or:new We("or",Zt.token,"|"),or_or:new We("or_or",Zt.token,"||"),paren_left:new We("paren_left",Zt.token,"("),paren_right:new We("paren_right",Zt.token,")"),semicolon:new We("semicolon",Zt.token,";"),star:new We("star",Zt.token,"*"),tilde:new We("tilde",Zt.token,"~"),underscore:new We("underscore",Zt.token,"_"),xor:new We("xor",Zt.token,"^"),plus_equal:new We("plus_equal",Zt.token,"+="),minus_equal:new We("minus_equal",Zt.token,"-="),times_equal:new We("times_equal",Zt.token,"*="),division_equal:new We("division_equal",Zt.token,"/="),modulo_equal:new We("modulo_equal",Zt.token,"%="),and_equal:new We("and_equal",Zt.token,"&="),or_equal:new We("or_equal",Zt.token,"|="),xor_equal:new We("xor_equal",Zt.token,"^="),shift_right_equal:new We("shift_right_equal",Zt.token,">>="),shift_left_equal:new We("shift_left_equal",Zt.token,"<<=")},qe.simpleTokens={"@":Yt.tokens.attr,"{":Yt.tokens.brace_left,"}":Yt.tokens.brace_right,":":Yt.tokens.colon,",":Yt.tokens.comma,"(":Yt.tokens.paren_left,")":Yt.tokens.paren_right,";":Yt.tokens.semicolon},qe.literalTokens={"&":Yt.tokens.and,"&&":Yt.tokens.and_and,"->":Yt.tokens.arrow,"/":Yt.tokens.forward_slash,"!":Yt.tokens.bang,"[":Yt.tokens.bracket_left,"]":Yt.tokens.bracket_right,"=":Yt.tokens.equal,"==":Yt.tokens.equal_equal,"!=":Yt.tokens.not_equal,">":Yt.tokens.greater_than,">=":Yt.tokens.greater_than_equal,">>":Yt.tokens.shift_right,"<":Yt.tokens.less_than,"<=":Yt.tokens.less_than_equal,"<<":Yt.tokens.shift_left,"%":Yt.tokens.modulo,"-":Yt.tokens.minus,"--":Yt.tokens.minus_minus,".":Yt.tokens.period,"+":Yt.tokens.plus,"++":Yt.tokens.plus_plus,"|":Yt.tokens.or,"||":Yt.tokens.or_or,"*":Yt.tokens.star,"~":Yt.tokens.tilde,_:Yt.tokens.underscore,"^":Yt.tokens.xor,"+=":Yt.tokens.plus_equal,"-=":Yt.tokens.minus_equal,"*=":Yt.tokens.times_equal,"/=":Yt.tokens.division_equal,"%=":Yt.tokens.modulo_equal,"&=":Yt.tokens.and_equal,"|=":Yt.tokens.or_equal,"^=":Yt.tokens.xor_equal,">>=":Yt.tokens.shift_right_equal,"<<=":Yt.tokens.shift_left_equal},qe.regexTokens={decimal_float_literal:Yt.tokens.decimal_float_literal,hex_float_literal:Yt.tokens.hex_float_literal,int_literal:Yt.tokens.int_literal,uint_literal:Yt.tokens.uint_literal,ident:Yt.tokens.ident},qe.storage_class=[Yt.keywords.function,Yt.keywords.private,Yt.keywords.workgroup,Yt.keywords.uniform,Yt.keywords.storage],qe.access_mode=[Yt.keywords.read,Yt.keywords.write,Yt.keywords.read_write],qe.sampler_type=[Yt.keywords.sampler,Yt.keywords.sampler_comparison],qe.sampled_texture_type=[Yt.keywords.texture_1d,Yt.keywords.texture_2d,Yt.keywords.texture_2d_array,Yt.keywords.texture_3d,Yt.keywords.texture_cube,Yt.keywords.texture_cube_array],qe.multisampled_texture_type=[Yt.keywords.texture_multisampled_2d],qe.storage_texture_type=[Yt.keywords.texture_storage_1d,Yt.keywords.texture_storage_2d,Yt.keywords.texture_storage_2d_array,Yt.keywords.texture_storage_3d],qe.depth_texture_type=[Yt.keywords.texture_depth_2d,Yt.keywords.texture_depth_2d_array,Yt.keywords.texture_depth_cube,Yt.keywords.texture_depth_cube_array,Yt.keywords.texture_depth_multisampled_2d],qe.texture_external_type=[Yt.keywords.texture_external],qe.any_texture_type=[...Yt.sampled_texture_type,...Yt.multisampled_texture_type,...Yt.storage_texture_type,...Yt.depth_texture_type,...Yt.texture_external_type],qe.texel_format=[Yt.keywords.r8unorm,Yt.keywords.r8snorm,Yt.keywords.r8uint,Yt.keywords.r8sint,Yt.keywords.r16uint,Yt.keywords.r16sint,Yt.keywords.r16float,Yt.keywords.rg8unorm,Yt.keywords.rg8snorm,Yt.keywords.rg8uint,Yt.keywords.rg8sint,Yt.keywords.r32uint,Yt.keywords.r32sint,Yt.keywords.r32float,Yt.keywords.rg16uint,Yt.keywords.rg16sint,Yt.keywords.rg16float,Yt.keywords.rgba8unorm,Yt.keywords.rgba8unorm_srgb,Yt.keywords.rgba8snorm,Yt.keywords.rgba8uint,Yt.keywords.rgba8sint,Yt.keywords.bgra8unorm,Yt.keywords.bgra8unorm_srgb,Yt.keywords.rgb10a2unorm,Yt.keywords.rg11b10float,Yt.keywords.rg32uint,Yt.keywords.rg32sint,Yt.keywords.rg32float,Yt.keywords.rgba16uint,Yt.keywords.rgba16sint,Yt.keywords.rgba16float,Yt.keywords.rgba32uint,Yt.keywords.rgba32sint,Yt.keywords.rgba32float],qe.const_literal=[Yt.tokens.int_literal,Yt.tokens.uint_literal,Yt.tokens.decimal_float_literal,Yt.tokens.hex_float_literal,Yt.keywords.true,Yt.keywords.false],qe.literal_or_ident=[Yt.tokens.ident,Yt.tokens.int_literal,Yt.tokens.uint_literal,Yt.tokens.decimal_float_literal,Yt.tokens.hex_float_literal,Yt.tokens.name],qe.element_count_expression=[Yt.tokens.int_literal,Yt.tokens.uint_literal,Yt.tokens.ident],qe.template_types=[Yt.keywords.vec2,Yt.keywords.vec3,Yt.keywords.vec4,Yt.keywords.mat2x2,Yt.keywords.mat2x3,Yt.keywords.mat2x4,Yt.keywords.mat3x2,Yt.keywords.mat3x3,Yt.keywords.mat3x4,Yt.keywords.mat4x2,Yt.keywords.mat4x3,Yt.keywords.mat4x4,Yt.keywords.atomic,Yt.keywords.bitcast,...Yt.any_texture_type],qe.attribute_name=[Yt.tokens.ident,Yt.keywords.block,Yt.keywords.diagnostic],qe.assignment_operators=[Yt.tokens.equal,Yt.tokens.plus_equal,Yt.tokens.minus_equal,Yt.tokens.times_equal,Yt.tokens.division_equal,Yt.tokens.modulo_equal,Yt.tokens.and_equal,Yt.tokens.or_equal,Yt.tokens.xor_equal,Yt.tokens.shift_right_equal,Yt.tokens.shift_left_equal],qe.increment_operators=[Yt.tokens.plus_plus,Yt.tokens.minus_minus];class He{constructor(i,m,g,_,b){this.type=i,this.lexeme=m,this.line=g,this.start=_,this.end=b}toString(){return this.lexeme}isTemplateType(){return-1!=qe.template_types.indexOf(this.type)}isArrayType(){return this.type==qe.keywords.array}isArrayOrTemplateType(){return this.isArrayType()||this.isTemplateType()}}class ze{constructor(i){this._tokens=[],this._start=0,this._current=0,this._line=1,this._source=null!=i?i:""}scanTokens(){for(;!this._isAtEnd();)if(this._start=this._current,!this.scanToken())throw`Invalid syntax at line ${this._line}`;return this._tokens.push(new He(qe.eof,"",this._line,this._current,this._current)),this._tokens}scanToken(){let i=this._advance();if("\n"==i)return this._line++,!0;if(this._isWhitespace(i))return!0;if("/"==i){if("/"==this._peekAhead()){for(;"\n"!=i;){if(this._isAtEnd())return!0;i=this._advance()}return this._line++,!0}if("*"==this._peekAhead()){this._advance();let m=1;for(;m>0;){if(this._isAtEnd())return!0;if(i=this._advance(),"\n"==i)this._line++;else if("*"==i){if("/"==this._peekAhead()&&(this._advance(),m--,0==m))return!0}else"/"==i&&"*"==this._peekAhead()&&(this._advance(),m++)}return!0}}const m=qe.simpleTokens[i];if(m)return this._addToken(m),!0;let g=qe.none;const _=this._isAlpha(i),b="_"===i;if(this._isAlphaNumeric(i)){let m=this._peekAhead();for(;this._isAlphaNumeric(m);)i+=this._advance(),m=this._peekAhead()}if(_){const m=qe.keywords[i];if(m)return this._addToken(m),!0}if(_||b)return this._addToken(qe.tokens.ident),!0;for(;;){let m=this._findType(i);const _=this._peekAhead();if("-"==i&&this._tokens.length>0){if("="==_)return this._current++,i+=_,this._addToken(qe.tokens.minus_equal),!0;if("-"==_)return this._current++,i+=_,this._addToken(qe.tokens.minus_minus),!0;const g=this._tokens.length-1;if((-1!=qe.literal_or_ident.indexOf(this._tokens[g].type)||this._tokens[g].type==qe.tokens.paren_right)&&">"!=_)return this._addToken(m),!0}if(">"==i&&(">"==_||"="==_)){let i=!1,g=this._tokens.length-1;for(let m=0;m<5&&g>=0&&-1===qe.assignment_operators.indexOf(this._tokens[g].type);++m,--g)if(this._tokens[g].type===qe.tokens.less_than){g>0&&this._tokens[g-1].isArrayOrTemplateType()&&(i=!0);break}if(i)return this._addToken(m),!0}if(m===qe.none){let _=i,b=0;const y=2;for(let i=0;i<y;++i)if(_+=this._peekAhead(i),m=this._findType(_),m!==qe.none){b=i;break}if(m===qe.none)return g!==qe.none&&(this._current--,this._addToken(g),!0);i=_,this._current+=b+1}if(g=m,this._isAtEnd())break;i+=this._advance()}return g!==qe.none&&(this._addToken(g),!0)}_findType(i){for(const m in qe.regexTokens){const g=qe.regexTokens[m];if(this._match(i,g.rule))return g}return qe.literalTokens[i]||qe.none}_match(i,m){const g=m.exec(i);return g&&0==g.index&&g[0]==i}_isAtEnd(){return this._current>=this._source.length}_isAlpha(i){return!this._isNumeric(i)&&!this._isWhitespace(i)&&"_"!==i&&"."!==i&&"("!==i&&")"!==i&&"["!==i&&"]"!==i&&"{"!==i&&"}"!==i&&","!==i&&";"!==i&&":"!==i&&"="!==i&&"!"!==i&&"<"!==i&&">"!==i&&"+"!==i&&"-"!==i&&"*"!==i&&"/"!==i&&"%"!==i&&"&"!==i&&"|"!==i&&"^"!==i&&"~"!==i&&"@"!==i&&"#"!==i&&"?"!==i&&"'"!==i&&"`"!==i&&'"'!==i&&"\\"!==i&&"\n"!==i&&"\r"!==i&&"\t"!==i&&"\0"!==i}_isNumeric(i){return i>="0"&&i<="9"}_isAlphaNumeric(i){return this._isAlpha(i)||this._isNumeric(i)||"_"===i}_isWhitespace(i){return" "==i||"\t"==i||"\r"==i}_advance(i=0){let m=this._source[this._current];return i=i||0,i++,this._current+=i,m}_peekAhead(i=0){return i=i||0,this._current+i>=this._source.length?"\0":this._source[this._current+i]}_addToken(i){const m=this._source.substring(this._start,this._current);this._tokens.push(new He(i,m,this._line,this._start,this._current))}}function Re(i){return Array.isArray(i)||(null==i?void 0:i.buffer)instanceof ArrayBuffer}const Jt=new Float32Array(1),Qt=new Uint32Array(Jt.buffer),en=new Uint32Array(Jt.buffer),tn=new Int32Array(1),nn=new Float32Array(tn.buffer),rn=new Uint32Array(tn.buffer),an=new Uint32Array(1),sn=new Float32Array(an.buffer),on=new Int32Array(an.buffer);function tt(i,m,g){if(m===g)return i;if("f32"===m){if("i32"===g||"x32"===g)return Jt[0]=i,Qt[0];if("u32"===g)return Jt[0]=i,en[0]}else if("i32"===m||"x32"===m){if("f32"===g)return tn[0]=i,nn[0];if("u32"===g)return tn[0]=i,rn[0]}else if("u32"===m){if("f32"===g)return an[0]=i,sn[0];if("i32"===g||"x32"===g)return an[0]=i,on[0]}return console.error(`Unsupported cast from ${m} to ${g}`),i}class nt{constructor(i){this.resources=null,this.inUse=!1,this.info=null,this.node=i}}class st{constructor(i,m){this.align=i,this.size=m}}class rt{constructor(){this.uniforms=[],this.storage=[],this.textures=[],this.samplers=[],this.aliases=[],this.overrides=[],this.structs=[],this.entry=new d,this.functions=[],this._types=new Map,this._functions=new Map}_isStorageTexture(i){return"texture_storage_1d"==i.name||"texture_storage_2d"==i.name||"texture_storage_2d_array"==i.name||"texture_storage_3d"==i.name}updateAST(i){for(const m of i)m instanceof C&&this._functions.set(m.name,new nt(m));for(const m of i)if(m instanceof ie){const i=this.getTypeInfo(m,null);i instanceof n&&this.structs.push(i)}for(const m of i)if(m instanceof ee)this.aliases.push(this._getAliasInfo(m));else if(m instanceof F){const i=m,g=this._getAttributeNum(i.attributes,"id",0),_=null!=i.type?this.getTypeInfo(i.type,i.attributes):null;this.overrides.push(new h(i.name,_,i.attributes,g))}else if(this._isUniformVar(m)){const i=m,g=this._getAttributeNum(i.attributes,"group",0),_=this._getAttributeNum(i.attributes,"binding",0),b=this.getTypeInfo(i.type,i.attributes),y=new o(i.name,b,g,_,i.attributes,Nt.Uniform,i.access);y.access||(y.access="read"),this.uniforms.push(y)}else if(this._isStorageVar(m)){const i=m,g=this._getAttributeNum(i.attributes,"group",0),_=this._getAttributeNum(i.attributes,"binding",0),b=this.getTypeInfo(i.type,i.attributes),y=this._isStorageTexture(b),T=new o(i.name,b,g,_,i.attributes,y?Nt.StorageTexture:Nt.Storage,i.access);T.access||(T.access="read"),this.storage.push(T)}else if(this._isTextureVar(m)){const i=m,g=this._getAttributeNum(i.attributes,"group",0),_=this._getAttributeNum(i.attributes,"binding",0),b=this.getTypeInfo(i.type,i.attributes),y=this._isStorageTexture(b),T=new o(i.name,b,g,_,i.attributes,y?Nt.StorageTexture:Nt.Texture,i.access);T.access||(T.access="read"),y?this.storage.push(T):this.textures.push(T)}else if(this._isSamplerVar(m)){const i=m,g=this._getAttributeNum(i.attributes,"group",0),_=this._getAttributeNum(i.attributes,"binding",0),b=this.getTypeInfo(i.type,i.attributes),y=new o(i.name,b,g,_,i.attributes,Nt.Sampler,i.access);this.samplers.push(y)}for(const m of i)if(m instanceof C){const i=this._getAttribute(m,"vertex"),g=this._getAttribute(m,"fragment"),_=this._getAttribute(m,"compute"),b=i||g||_,y=new p(m.name,null==b?void 0:b.name,m.attributes);y.attributes=m.attributes,y.startLine=m.startLine,y.endLine=m.endLine,this.functions.push(y),this._functions.get(m.name).info=y,b&&(this._functions.get(m.name).inUse=!0,y.inUse=!0,y.resources=this._findResources(m,!!b),y.inputs=this._getInputs(m.args),y.outputs=this._getOutputs(m.returnType),this.entry[b.name].push(y)),y.arguments=m.args.map(i=>new f(i.name,this.getTypeInfo(i.type,i.attributes),i.attributes)),y.returnType=m.returnType?this.getTypeInfo(m.returnType,m.attributes):null}for(const i of this._functions.values())i.info&&(i.info.inUse=i.inUse,this._addCalls(i.node,i.info.calls));for(const i of this._functions.values())i.node.search(m=>{var g,_,b;if(m instanceof Ce){if(m.value)if(Re(m.value))for(const _ of m.value)for(const m of this.overrides)_===m.name&&(null===(g=i.info)||void 0===g||g.overrides.push(m));else for(const g of this.overrides)m.value===g.name&&(null===(_=i.info)||void 0===_||_.overrides.push(g))}else if(m instanceof me)for(const g of this.overrides)m.name===g.name&&(null===(b=i.info)||void 0===b||b.overrides.push(g))});for(const i of this.uniforms)this._markStructsInUse(i.type);for(const i of this.storage)this._markStructsInUse(i.type)}getStructInfo(i){for(const m of this.structs)if(m.name==i)return m;return null}getOverrideInfo(i){for(const m of this.overrides)if(m.name==i)return m;return null}_markStructsInUse(i){if(i)if(i.isStruct){if(i.inUse=!0,i.members)for(const m of i.members)this._markStructsInUse(m.type)}else if(i.isArray)this._markStructsInUse(i.format);else if(i.isTemplate)i.format&&this._markStructsInUse(i.format);else{const m=this._getAlias(i.name);m&&this._markStructsInUse(m)}}_addCalls(i,m){var g;for(const _ of i.calls){const i=null===(g=this._functions.get(_.name))||void 0===g?void 0:g.info;i&&m.add(i)}}findResource(i,m,g){if(g){for(const _ of this.entry.compute)if(_.name===g)for(const g of _.resources)if(g.group==i&&g.binding==m)return g;for(const _ of this.entry.vertex)if(_.name===g)for(const g of _.resources)if(g.group==i&&g.binding==m)return g;for(const _ of this.entry.fragment)if(_.name===g)for(const g of _.resources)if(g.group==i&&g.binding==m)return g}for(const g of this.uniforms)if(g.group==i&&g.binding==m)return g;for(const g of this.storage)if(g.group==i&&g.binding==m)return g;for(const g of this.textures)if(g.group==i&&g.binding==m)return g;for(const g of this.samplers)if(g.group==i&&g.binding==m)return g;return null}_findResource(i){for(const m of this.uniforms)if(m.name==i)return m;for(const m of this.storage)if(m.name==i)return m;for(const m of this.textures)if(m.name==i)return m;for(const m of this.samplers)if(m.name==i)return m;return null}_markStructsFromAST(i){const m=this.getTypeInfo(i,null);this._markStructsInUse(m)}_findResources(i,m){const g=[],_=this,b=[];return i.search(y=>{if(y instanceof A)b.push({});else if(y instanceof E)b.pop();else if(y instanceof B){const i=y;m&&null!==i.type&&this._markStructsFromAST(i.type),b.length>0&&(b[b.length-1][i.name]=i)}else if(y instanceof pe){const i=y;m&&null!==i.type&&this._markStructsFromAST(i.type)}else if(y instanceof M){const i=y;m&&null!==i.type&&this._markStructsFromAST(i.type),b.length>0&&(b[b.length-1][i.name]=i)}else if(y instanceof me){const i=y;if(b.length>0&&b[b.length-1][i.name])return;const m=_._findResource(i.name);m&&g.push(m)}else if(y instanceof de){const b=y,T=_._functions.get(b.name);T&&(m&&(T.inUse=!0),i.calls.add(T.node),null===T.resources&&(T.resources=_._findResources(T.node,m)),g.push(...T.resources))}else if(y instanceof G){const b=y,T=_._functions.get(b.name);T&&(m&&(T.inUse=!0),i.calls.add(T.node),null===T.resources&&(T.resources=_._findResources(T.node,m)),g.push(...T.resources))}}),[...new Map(g.map(i=>[i.name,i])).values()]}getBindGroups(){const i=[];function t(m,g){m>=i.length&&(i.length=m+1),void 0===i[m]&&(i[m]=[]),g>=i[m].length&&(i[m].length=g+1)}for(const m of this.uniforms)t(m.group,m.binding),i[m.group][m.binding]=m;for(const m of this.storage)t(m.group,m.binding),i[m.group][m.binding]=m;for(const m of this.textures)t(m.group,m.binding),i[m.group][m.binding]=m;for(const m of this.samplers)t(m.group,m.binding),i[m.group][m.binding]=m;return i}_getOutputs(i,m=void 0){if(void 0===m&&(m=[]),i instanceof ie)this._getStructOutputs(i,m);else{const g=this._getOutputInfo(i);null!==g&&m.push(g)}return m}_getStructOutputs(i,m){for(const g of i.members)if(g.type instanceof ie)this._getStructOutputs(g.type,m);else{const i=this._getAttribute(g,"location")||this._getAttribute(g,"builtin");if(null!==i){const _=this.getTypeInfo(g.type,g.type.attributes),b=this._parseInt(i.value),y=new u(g.name,_,i.name,b);m.push(y)}}}_getOutputInfo(i){const m=this._getAttribute(i,"location")||this._getAttribute(i,"builtin");if(null!==m){const g=this.getTypeInfo(i,i.attributes),_=this._parseInt(m.value);return new u("",g,m.name,_)}return null}_getInputs(i,m=void 0){void 0===m&&(m=[]);for(const g of i)if(g.type instanceof ie)this._getStructInputs(g.type,m);else{const i=this._getInputInfo(g);null!==i&&m.push(i)}return m}_getStructInputs(i,m){for(const g of i.members)if(g.type instanceof ie)this._getStructInputs(g.type,m);else{const i=this._getInputInfo(g);null!==i&&m.push(i)}}_getInputInfo(i){const m=this._getAttribute(i,"location")||this._getAttribute(i,"builtin");if(null!==m){const g=this._getAttribute(i,"interpolation"),_=this.getTypeInfo(i.type,i.attributes),b=this._parseInt(m.value),y=new c(i.name,_,m.name,b);return null!==g&&(y.interpolation=this._parseString(g.value)),y}return null}_parseString(i){return i instanceof Array&&(i=i[0]),i}_parseInt(i){i instanceof Array&&(i=i[0]);const m=parseInt(i);return isNaN(m)?i:m}_getAlias(i){for(const m of this.aliases)if(m.name==i)return m.type;return null}_getAliasInfo(i){return new l(i.name,this.getTypeInfo(i.type,null))}getTypeInfoByName(i){for(const m of this.structs)if(m.name==i)return m;for(const m of this.aliases)if(m.name==i)return m.type;return null}getTypeInfo(i,m=null){if(this._types.has(i))return this._types.get(i);if(i instanceof le){const g=i.type?this.getTypeInfo(i.type,i.attributes):null,_=new r(i.name,g,m);return this._types.set(i,_),this._updateTypeInfo(_),_}if(i instanceof ce){const g=i,_=g.format?this.getTypeInfo(g.format,g.attributes):null,b=new s(g.name,m);return b.format=_,b.count=g.count,this._types.set(i,b),this._updateTypeInfo(b),b}if(i instanceof ie){const g=i,_=new n(g.name,m);_.startLine=g.startLine,_.endLine=g.endLine;for(const i of g.members){const m=this.getTypeInfo(i.type,i.attributes);_.members.push(new t(i.name,m,i.attributes))}return this._types.set(i,_),this._updateTypeInfo(_),_}if(i instanceof ue){const g=i,_=g.format instanceof re,b=g.format?_?this.getTypeInfo(g.format,null):new e(g.format,null):null,y=new a(g.name,b,m,g.access);return this._types.set(i,y),this._updateTypeInfo(y),y}if(i instanceof oe){const g=i,_=g.format?this.getTypeInfo(g.format,null):null,b=new a(g.name,_,m,g.access);return this._types.set(i,b),this._updateTypeInfo(b),b}const g=new e(i.name,m);return this._types.set(i,g),this._updateTypeInfo(g),g}_updateTypeInfo(i){var m,g,_;const b=this._getTypeSize(i);if(i.size=null!==(m=null==b?void 0:b.size)&&void 0!==m?m:0,i instanceof s&&i.format){const m=this._getTypeSize(i.format);i.stride=Math.max(null!==(g=null==m?void 0:m.size)&&void 0!==g?g:0,null!==(_=null==m?void 0:m.align)&&void 0!==_?_:0),this._updateTypeInfo(i.format)}i instanceof r&&this._updateTypeInfo(i.format),i instanceof n&&this._updateStructInfo(i)}_updateStructInfo(i){var m;let g=0,_=0,b=0,y=0;for(let T=0,w=i.members.length;T<w;++T){const w=i.members[T],P=this._getTypeSize(w);if(!P)continue;null!==(m=this._getAlias(w.type.name))&&void 0!==m||w.type;const H=P.align,$=P.size;g=this._roundUp(H,g+_),_=$,b=g,y=Math.max(y,H),w.offset=g,w.size=$,this._updateTypeInfo(w.type)}i.size=this._roundUp(y,b+_),i.align=y}_getTypeSize(i){var m,g;if(null==i)return null;const _=this._getAttributeNum(i.attributes,"size",0),b=this._getAttributeNum(i.attributes,"align",0);if(i instanceof t&&(i=i.type),i instanceof e){const m=this._getAlias(i.name);null!==m&&(i=m)}{const g=rt._typeInfo[i.name];if(void 0!==g){const y="f16"===(null===(m=i.format)||void 0===m?void 0:m.name)?2:1;return new st(Math.max(b,g.align/y),Math.max(_,g.size/y))}}{const m=rt._typeInfo[i.name.substring(0,i.name.length-1)];if(m){const g="h"===i.name[i.name.length-1]?2:1;return new st(Math.max(b,m.align/g),Math.max(_,m.size/g))}}if(i instanceof s){let m=i,y=8,T=8;const w=this._getTypeSize(m.format);return null!==w&&(T=w.size,y=w.align),T=m.count*this._getAttributeNum(null!==(g=null==i?void 0:i.attributes)&&void 0!==g?g:null,"stride",this._roundUp(y,T)),_&&(T=_),new st(Math.max(b,y),Math.max(_,T))}if(i instanceof n){let m=0,g=0,y=0,T=0,w=0;for(const g of i.members){const i=this._getTypeSize(g.type);null!==i&&(m=Math.max(i.align,m),y=this._roundUp(i.align,y+T),T=i.size,w=y)}return g=this._roundUp(m,w+T),new st(Math.max(b,m),Math.max(_,g))}return null}_isUniformVar(i){return i instanceof B&&"uniform"==i.storage}_isStorageVar(i){return i instanceof B&&"storage"==i.storage}_isTextureVar(i){return i instanceof B&&null!==i.type&&-1!=rt._textureTypes.indexOf(i.type.name)}_isSamplerVar(i){return i instanceof B&&null!==i.type&&-1!=rt._samplerTypes.indexOf(i.type.name)}_getAttribute(i,m){const g=i;if(!g||!g.attributes)return null;const _=g.attributes;for(let i of _)if(i.name==m)return i;return null}_getAttributeNum(i,m,g){if(null===i)return g;for(let _ of i)if(_.name==m){let i=null!==_&&null!==_.value?_.value:g;return i instanceof Array&&(i=i[0]),"number"==typeof i?i:"string"==typeof i?parseInt(i):g}return g}_roundUp(i,m){return Math.ceil(m/i)*i}}rt._typeInfo={f16:{align:2,size:2},i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},atomic:{align:4,size:4},vec2:{align:8,size:8},vec3:{align:16,size:12},vec4:{align:16,size:16},mat2x2:{align:8,size:16},mat3x2:{align:8,size:24},mat4x2:{align:8,size:32},mat2x3:{align:16,size:32},mat3x3:{align:16,size:48},mat4x3:{align:16,size:64},mat2x4:{align:16,size:32},mat3x4:{align:16,size:48},mat4x4:{align:16,size:64}},rt._textureTypes=qe.any_texture_type.map(i=>i.name),rt._samplerTypes=qe.sampler_type.map(i=>i.name);let un=0;class it{constructor(i,m,g){this.id=un++,this.name=i,this.value=m,this.node=g}clone(){return new it(this.name,this.value,this.node)}}class ot{constructor(i){this.id=un++,this.name=i.name,this.node=i}clone(){return new ot(this.node)}}class lt{constructor(i){this.parent=null,this.variables=new Map,this.functions=new Map,this.currentFunctionName="",this.id=un++,i&&(this.parent=i,this.currentFunctionName=i.currentFunctionName)}getVariable(i){var m;return this.variables.has(i)?null!==(m=this.variables.get(i))&&void 0!==m?m:null:this.parent?this.parent.getVariable(i):null}getFunction(i){var m;return this.functions.has(i)?null!==(m=this.functions.get(i))&&void 0!==m?m:null:this.parent?this.parent.getFunction(i):null}createVariable(i,m,g){this.variables.set(i,new it(i,m,null!=g?g:null))}setVariable(i,m,g){const _=this.getVariable(i);null!==_?_.value=m:this.createVariable(i,m,g)}getVariableValue(i){var m;const g=this.getVariable(i);return null!==(m=null==g?void 0:g.value)&&void 0!==m?m:null}clone(){return new lt(this)}}class ct{evalExpression(i,m){return null}getTypeInfo(i){return null}getVariableName(i,m){return""}}class ut{constructor(i){this.exec=i}getTypeInfo(i){return this.exec.getTypeInfo(i)}All(i,m){const g=this.exec.evalExpression(i.args[0],m);let _=!0;if(g instanceof Fe)return g.data.forEach(i=>{i||(_=!1)}),new Oe(_?1:0,this.getTypeInfo("bool"));throw new Error(`All() expects a vector argument. Line ${i.line}`)}Any(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe){const i=g.data.some(i=>i);return new Oe(i?1:0,this.getTypeInfo("bool"))}throw new Error(`Any() expects a vector argument. Line ${i.line}`)}Select(i,m){const g=this.exec.evalExpression(i.args[2],m);if(!(g instanceof Oe))throw new Error(`Select() expects a bool condition. Line ${i.line}`);return g.value?this.exec.evalExpression(i.args[1],m):this.exec.evalExpression(i.args[0],m)}ArrayLength(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const _=this.exec.evalExpression(g,m);if(_ instanceof Ue&&0===_.typeInfo.size){const i=_.typeInfo,m=_.buffer.byteLength/i.stride;return new Oe(m,this.getTypeInfo("u32"))}return new Oe(_.typeInfo.size,this.getTypeInfo("u32"))}Abs(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.abs(i)),g.typeInfo);const _=g;return new Oe(Math.abs(_.value),_.typeInfo)}Acos(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.acos(i)),g.typeInfo);const _=g;return new Oe(Math.acos(_.value),g.typeInfo)}Acosh(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.acosh(i)),g.typeInfo);const _=g;return new Oe(Math.acosh(_.value),g.typeInfo)}Asin(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.asin(i)),g.typeInfo);const _=g;return new Oe(Math.asin(_.value),g.typeInfo)}Asinh(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.asinh(i)),g.typeInfo);const _=g;return new Oe(Math.asinh(_.value),g.typeInfo)}Atan(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.atan(i)),g.typeInfo);const _=g;return new Oe(Math.atan(_.value),g.typeInfo)}Atanh(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.atanh(i)),g.typeInfo);const _=g;return new Oe(Math.atanh(_.value),g.typeInfo)}Atan2(i,m){const g=this.exec.evalExpression(i.args[0],m),_=this.exec.evalExpression(i.args[1],m);if(g instanceof Fe&&_ instanceof Fe)return new Fe(g.data.map((i,m)=>Math.atan2(i,_.data[m])),g.typeInfo);const b=g,y=_;return new Oe(Math.atan2(b.value,y.value),g.typeInfo)}Ceil(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.ceil(i)),g.typeInfo);const _=g;return new Oe(Math.ceil(_.value),g.typeInfo)}_clamp(i,m,g){return Math.min(Math.max(i,m),g)}Clamp(i,m){const g=this.exec.evalExpression(i.args[0],m),_=this.exec.evalExpression(i.args[1],m),b=this.exec.evalExpression(i.args[2],m);if(g instanceof Fe&&_ instanceof Fe&&b instanceof Fe)return new Fe(g.data.map((i,m)=>this._clamp(i,_.data[m],b.data[m])),g.typeInfo);const y=g,T=_,w=b;return new Oe(this._clamp(y.value,T.value,w.value),g.typeInfo)}Cos(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.cos(i)),g.typeInfo);const _=g;return new Oe(Math.cos(_.value),g.typeInfo)}Cosh(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.cosh(i)),g.typeInfo);const _=g;return new Oe(Math.cos(_.value),g.typeInfo)}CountLeadingZeros(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.clz32(i)),g.typeInfo);const _=g;return new Oe(Math.clz32(_.value),g.typeInfo)}_countOneBits(i){let m=0;for(;0!==i;)1&i&&m++,i>>=1;return m}CountOneBits(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>this._countOneBits(i)),g.typeInfo);const _=g;return new Oe(this._countOneBits(_.value),g.typeInfo)}_countTrailingZeros(i){if(0===i)return 32;let m=0;for(;!(1&i);)i>>=1,m++;return m}CountTrailingZeros(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>this._countTrailingZeros(i)),g.typeInfo);const _=g;return new Oe(this._countTrailingZeros(_.value),g.typeInfo)}Cross(i,m){const g=this.exec.evalExpression(i.args[0],m),_=this.exec.evalExpression(i.args[1],m);if(g instanceof Fe&&_ instanceof Fe){if(3!==g.data.length||3!==_.data.length)return console.error(`Cross() expects 3D vectors. Line ${i.line}`),null;const m=g.data,b=_.data;return new Fe([m[1]*b[2]-b[1]*m[2],m[2]*b[0]-b[2]*m[0],m[0]*b[1]-b[0]*m[1]],g.typeInfo)}return console.error(`Cross() expects vector arguments. Line ${i.line}`),null}Degrees(i,m){const g=this.exec.evalExpression(i.args[0],m),_=180/Math.PI;return g instanceof Fe?new Fe(g.data.map(i=>i*_),g.typeInfo):new Oe(g.value*_,this.getTypeInfo("f32"))}Determinant(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Me){const i=g.data,m=g.typeInfo.getTypeName(),_=m.endsWith("h")?this.getTypeInfo("f16"):this.getTypeInfo("f32");if("mat2x2"===m||"mat2x2f"===m||"mat2x2h"===m)return new Oe(i[0]*i[3]-i[1]*i[2],_);if("mat2x3"===m||"mat2x3f"===m||"mat2x3h"===m)return new Oe(i[0]*(i[4]*i[8]-i[5]*i[7])-i[1]*(i[3]*i[8]-i[5]*i[6])+i[2]*(i[3]*i[7]-i[4]*i[6]),_);if("mat2x4"===m||"mat2x4f"===m||"mat2x4h"===m)console.error(`TODO:Determinant for ${m}`);else if("mat3x2"===m||"mat3x2f"===m||"mat3x2h"===m)console.error(`TODO:Determinant for ${m}`);else{if("mat3x3"===m||"mat3x3f"===m||"mat3x3h"===m)return new Oe(i[0]*(i[4]*i[8]-i[5]*i[7])-i[1]*(i[3]*i[8]-i[5]*i[6])+i[2]*(i[3]*i[7]-i[4]*i[6]),_);"mat3x4"===m||"mat3x4f"===m||"mat3x4h"===m||"mat4x2"===m||"mat4x2f"===m||"mat4x2h"===m||"mat4x3"===m||"mat4x3f"===m||"mat4x3h"===m?console.error(`TODO:Determinant for ${m}`):"mat4x4"!==m&&"mat4x4f"!==m&&"mat4x4h"!==m||console.error(`TODO:Determinant for ${m}`)}}return console.error(`Determinant expects a matrix argument. Line ${i.line}`),null}Distance(i,m){const g=this.exec.evalExpression(i.args[0],m),_=this.exec.evalExpression(i.args[1],m);if(g instanceof Fe&&_ instanceof Fe){let i=0;for(let m=0;m<g.data.length;++m)i+=(g.data[m]-_.data[m])*(g.data[m]-_.data[m]);return new Oe(Math.sqrt(i),this.getTypeInfo("f32"))}const b=g,y=_;return new Oe(Math.abs(b.value-y.value),g.typeInfo)}_dot(i,m){let g=0;for(let _=0;_<i.length;++_)g+=m[_]*i[_];return g}Dot(i,m){const g=this.exec.evalExpression(i.args[0],m),_=this.exec.evalExpression(i.args[1],m);return g instanceof Fe&&_ instanceof Fe?new Oe(this._dot(g.data,_.data),this.getTypeInfo("f32")):(console.error(`Dot() expects vector arguments. Line ${i.line}`),null)}Dot4U8Packed(i,m){return console.error(`TODO:dot4U8Packed. Line ${i.line}`),null}Dot4I8Packed(i,m){return console.error(`TODO:dot4I8Packed. Line ${i.line}`),null}Exp(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.exp(i)),g.typeInfo);const _=g;return new Oe(Math.exp(_.value),g.typeInfo)}Exp2(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.pow(2,i)),g.typeInfo);const _=g;return new Oe(Math.pow(2,_.value),g.typeInfo)}ExtractBits(i,m){const g=this.exec.evalExpression(i.args[0],m),_=this.exec.evalExpression(i.args[1],m),b=this.exec.evalExpression(i.args[2],m);if("u32"!==_.typeInfo.name&&"x32"!==_.typeInfo.name)return console.error(`ExtractBits() expects an i32 offset argument. Line ${i.line}`),null;if("u32"!==b.typeInfo.name&&"x32"!==b.typeInfo.name)return console.error(`ExtractBits() expects an i32 count argument. Line ${i.line}`),null;const y=_.value,T=b.value;if(g instanceof Fe)return new Fe(g.data.map(i=>i>>y&(1<<T)-1),g.typeInfo);if("i32"!==g.typeInfo.name&&"x32"!==g.typeInfo.name)return console.error(`ExtractBits() expects an i32 argument. Line ${i.line}`),null;const w=g.value;return new Oe(w>>y&(1<<T)-1,this.getTypeInfo("i32"))}FaceForward(i,m){const g=this.exec.evalExpression(i.args[0],m),_=this.exec.evalExpression(i.args[1],m),b=this.exec.evalExpression(i.args[2],m);if(g instanceof Fe&&_ instanceof Fe&&b instanceof Fe){const i=this._dot(_.data,b.data);return new Fe(i<0?Array.from(g.data):g.data.map(i=>-i),g.typeInfo)}return console.error(`FaceForward() expects vector arguments. Line ${i.line}`),null}_firstLeadingBit(i){return 0===i?-1:31-Math.clz32(i)}FirstLeadingBit(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>this._firstLeadingBit(i)),g.typeInfo);const _=g;return new Oe(this._firstLeadingBit(_.value),g.typeInfo)}_firstTrailingBit(i){return 0===i?-1:Math.log2(i&-i)}FirstTrailingBit(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>this._firstTrailingBit(i)),g.typeInfo);const _=g;return new Oe(this._firstTrailingBit(_.value),g.typeInfo)}Floor(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.floor(i)),g.typeInfo);const _=g;return new Oe(Math.floor(_.value),g.typeInfo)}Fma(i,m){const g=this.exec.evalExpression(i.args[0],m),_=this.exec.evalExpression(i.args[1],m),b=this.exec.evalExpression(i.args[2],m);if(g instanceof Fe&&_ instanceof Fe&&b instanceof Fe)return g.data.length!==_.data.length||g.data.length!==b.data.length?(console.error(`Fma() expects vectors of the same length. Line ${i.line}`),null):new Fe(g.data.map((i,m)=>i*_.data[m]+b.data[m]),g.typeInfo);const y=g,T=_,w=b;return new Oe(y.value*T.value+w.value,y.typeInfo)}Fract(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>i-Math.floor(i)),g.typeInfo);const _=g;return new Oe(_.value-Math.floor(_.value),g.typeInfo)}Frexp(i,m){return console.error(`TODO:frexp. Line ${i.line}`),null}InsertBits(i,m){const g=this.exec.evalExpression(i.args[0],m),_=this.exec.evalExpression(i.args[1],m),b=this.exec.evalExpression(i.args[2],m),y=this.exec.evalExpression(i.args[3],m);if("u32"!==b.typeInfo.name&&"x32"!==b.typeInfo.name)return console.error(`InsertBits() expects an i32 offset argument. Line ${i.line}`),null;const T=b.value,w=(1<<y.value)-1<<T,P=~w;if(g instanceof Fe&&_ instanceof Fe)return new Fe(g.data.map((i,m)=>i&P|_.data[m]<<T&w),g.typeInfo);const H=g.value,$=_.value;return new Oe(H&P|$<<T&w,g.typeInfo)}InverseSqrt(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>1/Math.sqrt(i)),g.typeInfo);const _=g;return new Oe(1/Math.sqrt(_.value),g.typeInfo)}Ldexp(i,m){return console.error(`TODO:ldexp. Line ${i.line}`),null}Length(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe){let i=0;return g.data.forEach(m=>{i+=m*m}),new Oe(Math.sqrt(i),this.getTypeInfo("f32"))}const _=g;return new Oe(Math.abs(_.value),g.typeInfo)}Log(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.log(i)),g.typeInfo);const _=g;return new Oe(Math.log(_.value),g.typeInfo)}Log2(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.log2(i)),g.typeInfo);const _=g;return new Oe(Math.log2(_.value),g.typeInfo)}Max(i,m){const g=this.exec.evalExpression(i.args[0],m),_=this.exec.evalExpression(i.args[1],m);if(g instanceof Fe&&_ instanceof Fe)return new Fe(g.data.map((i,m)=>Math.max(i,_.data[m])),g.typeInfo);const b=g,y=_;return new Oe(Math.max(b.value,y.value),g.typeInfo)}Min(i,m){const g=this.exec.evalExpression(i.args[0],m),_=this.exec.evalExpression(i.args[1],m);if(g instanceof Fe&&_ instanceof Fe)return new Fe(g.data.map((i,m)=>Math.min(i,_.data[m])),g.typeInfo);const b=g,y=_;return new Oe(Math.min(b.value,y.value),g.typeInfo)}Mix(i,m){const g=this.exec.evalExpression(i.args[0],m),_=this.exec.evalExpression(i.args[1],m),b=this.exec.evalExpression(i.args[2],m);if(g instanceof Fe&&_ instanceof Fe&&b instanceof Fe)return new Fe(g.data.map((i,m)=>g.data[m]*(1-b.data[m])+_.data[m]*b.data[m]),g.typeInfo);const y=_,T=b;return new Oe(g.value*(1-T.value)+y.value*T.value,g.typeInfo)}Modf(i,m){const g=this.exec.evalExpression(i.args[0],m),_=this.exec.evalExpression(i.args[1],m);if(g instanceof Fe&&_ instanceof Fe)return new Fe(g.data.map((i,m)=>i%_.data[m]),g.typeInfo);const b=_;return new Oe(g.value%b.value,g.typeInfo)}Normalize(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe){const _=this.Length(i,m).value;return new Fe(g.data.map(i=>i/_),g.typeInfo)}return console.error(`Normalize() expects a vector argument. Line ${i.line}`),null}Pow(i,m){const g=this.exec.evalExpression(i.args[0],m),_=this.exec.evalExpression(i.args[1],m);if(g instanceof Fe&&_ instanceof Fe)return new Fe(g.data.map((i,m)=>Math.pow(i,_.data[m])),g.typeInfo);const b=g,y=_;return new Oe(Math.pow(b.value,y.value),g.typeInfo)}QuantizeToF16(i,m){const g=this.exec.evalExpression(i.args[0],m);return g instanceof Fe?new Fe(g.data.map(i=>i),g.typeInfo):new Oe(g.value,g.typeInfo)}Radians(i,m){const g=this.exec.evalExpression(i.args[0],m);return g instanceof Fe?new Fe(g.data.map(i=>i*Math.PI/180),g.typeInfo):new Oe(g.value*Math.PI/180,this.getTypeInfo("f32"))}Reflect(i,m){let g=this.exec.evalExpression(i.args[0],m),_=this.exec.evalExpression(i.args[1],m);if(g instanceof Fe&&_ instanceof Fe){const i=this._dot(g.data,_.data);return new Fe(g.data.map((m,g)=>m-2*i*_.data[g]),g.typeInfo)}return console.error(`Reflect() expects vector arguments. Line ${i.line}`),null}Refract(i,m){let g=this.exec.evalExpression(i.args[0],m),_=this.exec.evalExpression(i.args[1],m),b=this.exec.evalExpression(i.args[2],m);if(g instanceof Fe&&_ instanceof Fe&&b instanceof Oe){const i=this._dot(_.data,g.data);return new Fe(g.data.map((m,g)=>{const y=1-b.value*b.value*(1-i*i);if(y<0)return 0;const T=Math.sqrt(y);return b.value*m-(b.value*i+T)*_.data[g]}),g.typeInfo)}return console.error(`Refract() expects vector arguments and a scalar argument. Line ${i.line}`),null}ReverseBits(i,m){return console.error(`TODO:reverseBits. Line ${i.line}`),null}Round(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.round(i)),g.typeInfo);const _=g;return new Oe(Math.round(_.value),g.typeInfo)}Saturate(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.min(Math.max(i,0),1)),g.typeInfo);const _=g;return new Oe(Math.min(Math.max(_.value,0),1),g.typeInfo)}Sign(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.sign(i)),g.typeInfo);const _=g;return new Oe(Math.sign(_.value),g.typeInfo)}Sin(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.sin(i)),g.typeInfo);const _=g;return new Oe(Math.sin(_.value),g.typeInfo)}Sinh(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.sinh(i)),g.typeInfo);const _=g;return new Oe(Math.sinh(_.value),g.typeInfo)}_smoothstep(i,m,g){const _=Math.min(Math.max((g-i)/(m-i),0),1);return _*_*(3-2*_)}SmoothStep(i,m){const g=this.exec.evalExpression(i.args[0],m),_=this.exec.evalExpression(i.args[1],m),b=this.exec.evalExpression(i.args[2],m);if(b instanceof Fe&&g instanceof Fe&&_ instanceof Fe)return new Fe(b.data.map((i,m)=>this._smoothstep(g.data[m],_.data[m],i)),b.typeInfo);const y=g,T=_,w=b;return new Oe(this._smoothstep(y.value,T.value,w.value),b.typeInfo)}Sqrt(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.sqrt(i)),g.typeInfo);const _=g;return new Oe(Math.sqrt(_.value),g.typeInfo)}Step(i,m){const g=this.exec.evalExpression(i.args[0],m),_=this.exec.evalExpression(i.args[1],m);if(_ instanceof Fe&&g instanceof Fe)return new Fe(_.data.map((i,m)=>i<g.data[m]?0:1),_.typeInfo);const b=g;return new Oe(_.value<b.value?0:1,b.typeInfo)}Tan(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.tan(i)),g.typeInfo);const _=g;return new Oe(Math.tan(_.value),g.typeInfo)}Tanh(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.tanh(i)),g.typeInfo);const _=g;return new Oe(Math.tanh(_.value),g.typeInfo)}_getTransposeType(i){const m=i.getTypeName();return"mat2x2f"===m||"mat2x2h"===m?i:"mat2x3f"===m?this.getTypeInfo("mat3x2f"):"mat2x3h"===m?this.getTypeInfo("mat3x2h"):"mat2x4f"===m?this.getTypeInfo("mat4x2f"):"mat2x4h"===m?this.getTypeInfo("mat4x2h"):"mat3x2f"===m?this.getTypeInfo("mat2x3f"):"mat3x2h"===m?this.getTypeInfo("mat2x3h"):"mat3x3f"===m||"mat3x3h"===m?i:"mat3x4f"===m?this.getTypeInfo("mat4x3f"):"mat3x4h"===m?this.getTypeInfo("mat4x3h"):"mat4x2f"===m?this.getTypeInfo("mat2x4f"):"mat4x2h"===m?this.getTypeInfo("mat2x4h"):"mat4x3f"===m?this.getTypeInfo("mat3x4f"):"mat4x3h"===m?this.getTypeInfo("mat3x4h"):("mat4x4f"===m||"mat4x4h"===m||console.error(`Invalid matrix type ${m}`),i)}Transpose(i,m){const g=this.exec.evalExpression(i.args[0],m);if(!(g instanceof Me))return console.error(`Transpose() expects a matrix argument. Line ${i.line}`),null;const _=this._getTransposeType(g.typeInfo);if("mat2x2"===g.typeInfo.name||"mat2x2f"===g.typeInfo.name||"mat2x2h"===g.typeInfo.name){const i=g.data;return new Me([i[0],i[2],i[1],i[3]],_)}if("mat2x3"===g.typeInfo.name||"mat2x3f"===g.typeInfo.name||"mat2x3h"===g.typeInfo.name){const i=g.data;return new Me([i[0],i[3],i[6],i[1],i[4],i[7]],_)}if("mat2x4"===g.typeInfo.name||"mat2x4f"===g.typeInfo.name||"mat2x4h"===g.typeInfo.name){const i=g.data;return new Me([i[0],i[4],i[8],i[12],i[1],i[5],i[9],i[13]],_)}if("mat3x2"===g.typeInfo.name||"mat3x2f"===g.typeInfo.name||"mat3x2h"===g.typeInfo.name){const i=g.data;return new Me([i[0],i[3],i[1],i[4],i[2],i[5]],_)}if("mat3x3"===g.typeInfo.name||"mat3x3f"===g.typeInfo.name||"mat3x3h"===g.typeInfo.name){const i=g.data;return new Me([i[0],i[3],i[6],i[1],i[4],i[7],i[2],i[5],i[8]],_)}if("mat3x4"===g.typeInfo.name||"mat3x4f"===g.typeInfo.name||"mat3x4h"===g.typeInfo.name){const i=g.data;return new Me([i[0],i[4],i[8],i[12],i[1],i[5],i[9],i[13],i[2],i[6],i[10],i[14]],_)}if("mat4x2"===g.typeInfo.name||"mat4x2f"===g.typeInfo.name||"mat4x2h"===g.typeInfo.name){const i=g.data;return new Me([i[0],i[4],i[1],i[5],i[2],i[6]],_)}if("mat4x3"===g.typeInfo.name||"mat4x3f"===g.typeInfo.name||"mat4x3h"===g.typeInfo.name){const i=g.data;return new Me([i[0],i[4],i[8],i[1],i[5],i[9],i[2],i[6],i[10]],_)}if("mat4x4"===g.typeInfo.name||"mat4x4f"===g.typeInfo.name||"mat4x4h"===g.typeInfo.name){const i=g.data;return new Me([i[0],i[4],i[8],i[12],i[1],i[5],i[9],i[13],i[2],i[6],i[10],i[14],i[3],i[7],i[11],i[15]],_)}return console.error(`Invalid matrix type ${g.typeInfo.name}`),null}Trunc(i,m){const g=this.exec.evalExpression(i.args[0],m);if(g instanceof Fe)return new Fe(g.data.map(i=>Math.trunc(i)),g.typeInfo);const _=g;return new Oe(Math.trunc(_.value),g.typeInfo)}Dpdx(i,m){return console.error(`TODO:dpdx. Line ${i.line}`),null}DpdxCoarse(i,m){return console.error(`TODO:dpdxCoarse. Line ${i.line}`),null}DpdxFine(i,m){return console.error("TODO:dpdxFine"),null}Dpdy(i,m){return console.error("TODO:dpdy"),null}DpdyCoarse(i,m){return console.error("TODO:dpdyCoarse"),null}DpdyFine(i,m){return console.error("TODO:dpdyFine"),null}Fwidth(i,m){return console.error("TODO:fwidth"),null}FwidthCoarse(i,m){return console.error("TODO:fwidthCoarse"),null}FwidthFine(i,m){return console.error("TODO:fwidthFine"),null}TextureDimensions(i,m){const g=i.args[0],_=i.args.length>1?this.exec.evalExpression(i.args[1],m).value:0;if(g instanceof me){const b=g.name,y=m.getVariableValue(b);if(y instanceof Pe){if(_<0||_>=y.mipLevelCount)return console.error(`Invalid mip level for textureDimensions. Line ${i.line}`),null;const m=y.getMipLevelSize(_),g=y.dimension;return"1d"===g?new Oe(m[0],this.getTypeInfo("u32")):"3d"===g?new Fe(m,this.getTypeInfo("vec3u")):"2d"===g?new Fe(m.slice(0,2),this.getTypeInfo("vec2u")):(console.error(`Invalid texture dimension ${g} not found. Line ${i.line}`),null)}return console.error(`Texture ${b} not found. Line ${i.line}`),null}return console.error(`Invalid texture argument for textureDimensions. Line ${i.line}`),null}TextureGather(i,m){return console.error("TODO:textureGather"),null}TextureGatherCompare(i,m){return console.error("TODO:textureGatherCompare"),null}TextureLoad(i,m){const g=i.args[0],_=this.exec.evalExpression(i.args[1],m),b=i.args.length>2?this.exec.evalExpression(i.args[2],m).value:0;if(!(_ instanceof Fe)||2!==_.data.length)return console.error(`Invalid UV argument for textureLoad. Line ${i.line}`),null;if(g instanceof me){const y=g.name,T=m.getVariableValue(y);if(T instanceof Pe){const m=Math.floor(_.data[0]),g=Math.floor(_.data[1]);if(m<0||m>=T.width||g<0||g>=T.height)return console.error(`Texture ${y} out of bounds. Line ${i.line}`),null;const w=T.getPixel(m,g,0,b);return null===w?(console.error(`Invalid texture format for textureLoad. Line ${i.line}`),null):new Fe(w,this.getTypeInfo("vec4f"))}return console.error(`Texture ${y} not found. Line ${i.line}`),null}return console.error(`Invalid texture argument for textureLoad. Line ${i.line}`),null}TextureNumLayers(i,m){const g=i.args[0];if(g instanceof me){const _=g.name,b=m.getVariableValue(_);return b instanceof Pe?new Oe(b.depthOrArrayLayers,this.getTypeInfo("u32")):(console.error(`Texture ${_} not found. Line ${i.line}`),null)}return console.error(`Invalid texture argument for textureNumLayers. Line ${i.line}`),null}TextureNumLevels(i,m){const g=i.args[0];if(g instanceof me){const _=g.name,b=m.getVariableValue(_);return b instanceof Pe?new Oe(b.mipLevelCount,this.getTypeInfo("u32")):(console.error(`Texture ${_} not found. Line ${i.line}`),null)}return console.error(`Invalid texture argument for textureNumLevels. Line ${i.line}`),null}TextureNumSamples(i,m){const g=i.args[0];if(g instanceof me){const _=g.name,b=m.getVariableValue(_);return b instanceof Pe?new Oe(b.sampleCount,this.getTypeInfo("u32")):(console.error(`Texture ${_} not found. Line ${i.line}`),null)}return console.error(`Invalid texture argument for textureNumSamples. Line ${i.line}`),null}TextureSample(i,m){return console.error("TODO:textureSample"),null}TextureSampleBias(i,m){return console.error("TODO:textureSampleBias"),null}TextureSampleCompare(i,m){return console.error("TODO:textureSampleCompare"),null}TextureSampleCompareLevel(i,m){return console.error("TODO:textureSampleCompareLevel"),null}TextureSampleGrad(i,m){return console.error("TODO:textureSampleGrad"),null}TextureSampleLevel(i,m){return console.error("TODO:textureSampleLevel"),null}TextureSampleBaseClampToEdge(i,m){return console.error("TODO:textureSampleBaseClampToEdge"),null}TextureStore(i,m){const g=i.args[0],_=this.exec.evalExpression(i.args[1],m),b=4===i.args.length?this.exec.evalExpression(i.args[2],m).value:0,y=4===i.args.length?this.exec.evalExpression(i.args[3],m).data:this.exec.evalExpression(i.args[2],m).data;if(4!==y.length)return console.error(`Invalid value argument for textureStore. Line ${i.line}`),null;if(!(_ instanceof Fe)||2!==_.data.length)return console.error(`Invalid UV argument for textureStore. Line ${i.line}`),null;if(g instanceof me){const T=g.name,w=m.getVariableValue(T);if(w instanceof Pe){const m=w.getMipLevelSize(0),g=Math.floor(_.data[0]),P=Math.floor(_.data[1]);return g<0||g>=m[0]||P<0||P>=m[1]?(console.error(`Texture ${T} out of bounds. Line ${i.line}`),null):(w.setPixel(g,P,0,b,Array.from(y)),null)}return console.error(`Texture ${T} not found. Line ${i.line}`),null}return console.error(`Invalid texture argument for textureStore. Line ${i.line}`),null}AtomicLoad(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const _=this.exec.getVariableName(g,m);return m.getVariable(_).value.getSubData(this.exec,g.postfix,m)}AtomicStore(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const _=this.exec.getVariableName(g,m),b=m.getVariable(_);let y=i.args[1];const T=this.exec.evalExpression(y,m),w=b.value.getSubData(this.exec,g.postfix,m);return w instanceof Oe&&T instanceof Oe&&(w.value=T.value),b.value instanceof Ue&&b.value.setDataValue(this.exec,w,g.postfix,m),null}AtomicAdd(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const _=this.exec.getVariableName(g,m),b=m.getVariable(_);let y=i.args[1];const T=this.exec.evalExpression(y,m),w=b.value.getSubData(this.exec,g.postfix,m),P=new Oe(w.value,w.typeInfo);return w instanceof Oe&&T instanceof Oe&&(w.value+=T.value),b.value instanceof Ue&&b.value.setDataValue(this.exec,w,g.postfix,m),P}AtomicSub(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const _=this.exec.getVariableName(g,m),b=m.getVariable(_);let y=i.args[1];const T=this.exec.evalExpression(y,m),w=b.value.getSubData(this.exec,g.postfix,m),P=new Oe(w.value,w.typeInfo);return w instanceof Oe&&T instanceof Oe&&(w.value-=T.value),b.value instanceof Ue&&b.value.setDataValue(this.exec,w,g.postfix,m),P}AtomicMax(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const _=this.exec.getVariableName(g,m),b=m.getVariable(_);let y=i.args[1];const T=this.exec.evalExpression(y,m),w=b.value.getSubData(this.exec,g.postfix,m),P=new Oe(w.value,w.typeInfo);return w instanceof Oe&&T instanceof Oe&&(w.value=Math.max(w.value,T.value)),b.value instanceof Ue&&b.value.setDataValue(this.exec,w,g.postfix,m),P}AtomicMin(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const _=this.exec.getVariableName(g,m),b=m.getVariable(_);let y=i.args[1];const T=this.exec.evalExpression(y,m),w=b.value.getSubData(this.exec,g.postfix,m),P=new Oe(w.value,w.typeInfo);return w instanceof Oe&&T instanceof Oe&&(w.value=Math.min(w.value,T.value)),b.value instanceof Ue&&b.value.setDataValue(this.exec,w,g.postfix,m),P}AtomicAnd(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const _=this.exec.getVariableName(g,m),b=m.getVariable(_);let y=i.args[1];const T=this.exec.evalExpression(y,m),w=b.value.getSubData(this.exec,g.postfix,m),P=new Oe(w.value,w.typeInfo);return w instanceof Oe&&T instanceof Oe&&(w.value=w.value&T.value),b.value instanceof Ue&&b.value.setDataValue(this.exec,w,g.postfix,m),P}AtomicOr(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const _=this.exec.getVariableName(g,m),b=m.getVariable(_);let y=i.args[1];const T=this.exec.evalExpression(y,m),w=b.value.getSubData(this.exec,g.postfix,m),P=new Oe(w.value,w.typeInfo);return w instanceof Oe&&T instanceof Oe&&(w.value=w.value|T.value),b.value instanceof Ue&&b.value.setDataValue(this.exec,w,g.postfix,m),P}AtomicXor(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const _=this.exec.getVariableName(g,m),b=m.getVariable(_);let y=i.args[1];const T=this.exec.evalExpression(y,m),w=b.value.getSubData(this.exec,g.postfix,m),P=new Oe(w.value,w.typeInfo);return w instanceof Oe&&T instanceof Oe&&(w.value=w.value^T.value),b.value instanceof Ue&&b.value.setDataValue(this.exec,w,g.postfix,m),P}AtomicExchange(i,m){let g=i.args[0];g instanceof we&&(g=g.right);const _=this.exec.getVariableName(g,m),b=m.getVariable(_);let y=i.args[1];const T=this.exec.evalExpression(y,m),w=b.value.getSubData(this.exec,g.postfix,m),P=new Oe(w.value,w.typeInfo);return w instanceof Oe&&T instanceof Oe&&(w.value=T.value),b.value instanceof Ue&&b.value.setDataValue(this.exec,w,g.postfix,m),P}AtomicCompareExchangeWeak(i,m){return console.error("TODO:atomicCompareExchangeWeak"),null}Pack4x8snorm(i,m){return console.error("TODO:pack4x8snorm"),null}Pack4x8unorm(i,m){return console.error("TODO:pack4x8unorm"),null}Pack4xI8(i,m){return console.error("TODO:pack4xI8"),null}Pack4xU8(i,m){return console.error("TODO:pack4xU8"),null}Pack4x8Clamp(i,m){return console.error("TODO:pack4x8Clamp"),null}Pack4xU8Clamp(i,m){return console.error("TODO:pack4xU8Clamp"),null}Pack2x16snorm(i,m){return console.error("TODO:pack2x16snorm"),null}Pack2x16unorm(i,m){return console.error("TODO:pack2x16unorm"),null}Pack2x16float(i,m){return console.error("TODO:pack2x16float"),null}Unpack4x8snorm(i,m){return console.error("TODO:unpack4x8snorm"),null}Unpack4x8unorm(i,m){return console.error("TODO:unpack4x8unorm"),null}Unpack4xI8(i,m){return console.error("TODO:unpack4xI8"),null}Unpack4xU8(i,m){return console.error("TODO:unpack4xU8"),null}Unpack2x16snorm(i,m){return console.error("TODO:unpack2x16snorm"),null}Unpack2x16unorm(i,m){return console.error("TODO:unpack2x16unorm"),null}Unpack2x16float(i,m){return console.error("TODO:unpack2x16float"),null}StorageBarrier(i,m){return null}TextureBarrier(i,m){return null}WorkgroupBarrier(i,m){return null}WorkgroupUniformLoad(i,m){return null}SubgroupAdd(i,m){return console.error("TODO:subgroupAdd"),null}SubgroupExclusiveAdd(i,m){return console.error("TODO:subgroupExclusiveAdd"),null}SubgroupInclusiveAdd(i,m){return console.error("TODO:subgroupInclusiveAdd"),null}SubgroupAll(i,m){return console.error("TODO:subgroupAll"),null}SubgroupAnd(i,m){return console.error("TODO:subgroupAnd"),null}SubgroupAny(i,m){return console.error("TODO:subgroupAny"),null}SubgroupBallot(i,m){return console.error("TODO:subgroupBallot"),null}SubgroupBroadcast(i,m){return console.error("TODO:subgroupBroadcast"),null}SubgroupBroadcastFirst(i,m){return console.error("TODO:subgroupBroadcastFirst"),null}SubgroupElect(i,m){return console.error("TODO:subgroupElect"),null}SubgroupMax(i,m){return console.error("TODO:subgroupMax"),null}SubgroupMin(i,m){return console.error("TODO:subgroupMin"),null}SubgroupMul(i,m){return console.error("TODO:subgroupMul"),null}SubgroupExclusiveMul(i,m){return console.error("TODO:subgroupExclusiveMul"),null}SubgroupInclusiveMul(i,m){return console.error("TODO:subgroupInclusiveMul"),null}SubgroupOr(i,m){return console.error("TODO:subgroupOr"),null}SubgroupShuffle(i,m){return console.error("TODO:subgroupShuffle"),null}SubgroupShuffleDown(i,m){return console.error("TODO:subgroupShuffleDown"),null}SubgroupShuffleUp(i,m){return console.error("TODO:subgroupShuffleUp"),null}SubgroupShuffleXor(i,m){return console.error("TODO:subgroupShuffleXor"),null}SubgroupXor(i,m){return console.error("TODO:subgroupXor"),null}QuadBroadcast(i,m){return console.error("TODO:quadBroadcast"),null}QuadSwapDiagonal(i,m){return console.error("TODO:quadSwapDiagonal"),null}QuadSwapX(i,m){return console.error("TODO:quadSwapX"),null}QuadSwapY(i,m){return console.error("TODO:quadSwapY"),null}}const ln={vec2:2,vec2f:2,vec2i:2,vec2u:2,vec2b:2,vec2h:2,vec3:3,vec3f:3,vec3i:3,vec3u:3,vec3b:3,vec3h:3,vec4:4,vec4f:4,vec4i:4,vec4u:4,vec4b:4,vec4h:4},cn={mat2x2:[2,2,4],mat2x2f:[2,2,4],mat2x2h:[2,2,4],mat2x3:[2,3,6],mat2x3f:[2,3,6],mat2x3h:[2,3,6],mat2x4:[2,4,8],mat2x4f:[2,4,8],mat2x4h:[2,4,8],mat3x2:[3,2,6],mat3x2f:[3,2,6],mat3x2h:[3,2,6],mat3x3:[3,3,9],mat3x3f:[3,3,9],mat3x3h:[3,3,9],mat3x4:[3,4,12],mat3x4f:[3,4,12],mat3x4h:[3,4,12],mat4x2:[4,2,8],mat4x2f:[4,2,8],mat4x2h:[4,2,8],mat4x3:[4,3,12],mat4x3f:[4,3,12],mat4x3h:[4,3,12],mat4x4:[4,4,16],mat4x4f:[4,4,16],mat4x4h:[4,4,16]};class pt extends ct{constructor(i,m){var g;super(),this.ast=null!=i?i:[],this.reflection=new rt,this.reflection.updateAST(this.ast),this.context=null!==(g=null==m?void 0:m.clone())&&void 0!==g?g:new lt,this.builtins=new ut(this),this.typeInfo={bool:this.getTypeInfo(re.bool),i32:this.getTypeInfo(re.i32),u32:this.getTypeInfo(re.u32),f32:this.getTypeInfo(re.f32),f16:this.getTypeInfo(re.f16),vec2f:this.getTypeInfo(oe.vec2f),vec2u:this.getTypeInfo(oe.vec2u),vec2i:this.getTypeInfo(oe.vec2i),vec2h:this.getTypeInfo(oe.vec2h),vec3f:this.getTypeInfo(oe.vec3f),vec3u:this.getTypeInfo(oe.vec3u),vec3i:this.getTypeInfo(oe.vec3i),vec3h:this.getTypeInfo(oe.vec3h),vec4f:this.getTypeInfo(oe.vec4f),vec4u:this.getTypeInfo(oe.vec4u),vec4i:this.getTypeInfo(oe.vec4i),vec4h:this.getTypeInfo(oe.vec4h),mat2x2f:this.getTypeInfo(oe.mat2x2f),mat2x3f:this.getTypeInfo(oe.mat2x3f),mat2x4f:this.getTypeInfo(oe.mat2x4f),mat3x2f:this.getTypeInfo(oe.mat3x2f),mat3x3f:this.getTypeInfo(oe.mat3x3f),mat3x4f:this.getTypeInfo(oe.mat3x4f),mat4x2f:this.getTypeInfo(oe.mat4x2f),mat4x3f:this.getTypeInfo(oe.mat4x3f),mat4x4f:this.getTypeInfo(oe.mat4x4f)}}getVariableValue(i){var m,g;const _=null!==(g=null===(m=this.context.getVariable(i))||void 0===m?void 0:m.value)&&void 0!==g?g:null;if(null===_)return null;if(_ instanceof Oe)return _.value;if(_ instanceof Fe)return Array.from(_.data);if(_ instanceof Me)return Array.from(_.data);if(_ instanceof Ue&&_.typeInfo instanceof s){if("u32"===_.typeInfo.format.name)return Array.from(new Uint32Array(_.buffer,_.offset,_.typeInfo.count));if("i32"===_.typeInfo.format.name)return Array.from(new Int32Array(_.buffer,_.offset,_.typeInfo.count));if("f32"===_.typeInfo.format.name)return Array.from(new Float32Array(_.buffer,_.offset,_.typeInfo.count))}return console.error(`Unsupported return variable type ${_.typeInfo.name}`),null}execute(i){(i=null!=i?i:{}).constants&&this._setOverrides(i.constants,this.context),this._execStatements(this.ast,this.context)}dispatchWorkgroups(i,m,g,_){const b=this.context.clone();(_=null!=_?_:{}).constants&&this._setOverrides(_.constants,b),this._execStatements(this.ast,b);const y=b.getFunction(i);if(!y)return void console.error(`Function ${i} not found`);if("number"==typeof m)m=[m,1,1];else{if(0===m.length)return void console.error("Invalid dispatch count");1===m.length?m=[m[0],1,1]:2===m.length?m=[m[0],m[1],1]:m.length>3&&(m=[m[0],m[1],m[2]])}const T=m[0],w=m[1],P=m[2],H=this.getTypeInfo("vec3u");b.setVariable("@num_workgroups",new Fe(m,H));for(const i in g)for(const m in g[i]){const _=g[i][m];b.variables.forEach(g=>{var b;const y=g.node;if(null==y?void 0:y.attributes){let T=null,w=null;for(const i of y.attributes)"binding"===i.name?T=i.value:"group"===i.name&&(w=i.value);if(m==T&&i==w)if(void 0!==_.texture&&void 0!==_.descriptor){const i=new Pe(_.texture,this.getTypeInfo(y.type),_.descriptor,null!==(b=_.texture.view)&&void 0!==b?b:null);g.value=i}else void 0!==_.uniform?g.value=new Ue(_.uniform,this.getTypeInfo(y.type)):g.value=new Ue(_,this.getTypeInfo(y.type))}})}for(let i=0;i<P;++i)for(let m=0;m<w;++m)for(let g=0;g<T;++g)b.setVariable("@workgroup_id",new Fe([g,m,i],this.getTypeInfo("vec3u"))),this._dispatchWorkgroup(y,[g,m,i],b)}execStatement(i,m){if(i instanceof Q)return this.evalExpression(i.value,m);if(i instanceof ne){if(i.condition){const g=this.evalExpression(i.condition,m);if(!(g instanceof Oe))throw new Error("Invalid break-if condition");if(!g.value)return null}return pt._breakObj}if(i instanceof se)return pt._continueObj;if(i instanceof M)this._let(i,m);else if(i instanceof B)this._var(i,m);else if(i instanceof U)this._const(i,m);else if(i instanceof C)this._function(i,m);else{if(i instanceof Z)return this._if(i,m);if(i instanceof j)return this._switch(i,m);if(i instanceof O)return this._for(i,m);if(i instanceof N)return this._while(i,m);if(i instanceof X)return this._loop(i,m);if(i instanceof V){const g=m.clone();return g.currentFunctionName=m.currentFunctionName,this._execStatements(i.body,g)}if(i instanceof R)this._assign(i,m);else if(i instanceof z)this._increment(i,m);else{if(i instanceof ie)return null;if(i instanceof F){const g=i.name;null===m.getVariable(g)&&m.setVariable(g,new Oe(0,this.getTypeInfo("u32")))}else if(i instanceof G)this._call(i,m);else{if(i instanceof J)return null;if(i instanceof ee)return null;console.error("Invalid statement type.",i,`Line ${i.line}`)}}}return null}evalExpression(i,m){return i instanceof ke?this._evalBinaryOp(i,m):i instanceof ge?this._evalLiteral(i,m):i instanceof me?this._evalVariable(i,m):i instanceof de?this._evalCall(i,m):i instanceof pe?this._evalCreate(i,m):i instanceof _e?this._evalConst(i,m):i instanceof xe?this._evalBitcast(i,m):i instanceof we?this._evalUnaryOp(i,m):(console.error("Invalid expression type",i,`Line ${i.line}`),null)}getTypeInfo(i){var m;if(i instanceof re){const m=this.reflection.getTypeInfo(i);if(null!==m)return m}let g=null!==(m=this.typeInfo[i])&&void 0!==m?m:null;return null!==g||(g=this.reflection.getTypeInfoByName(i)),g}_setOverrides(i,m){for(const g in i){const _=i[g],b=this.reflection.getOverrideInfo(g);null!==b?(null===b.type&&(b.type=this.getTypeInfo("u32")),"u32"===b.type.name||"i32"===b.type.name||"f32"===b.type.name||"f16"===b.type.name?m.setVariable(g,new Oe(_,b.type)):"bool"===b.type.name?m.setVariable(g,new Oe(_?1:0,b.type)):"vec2"===b.type.name||"vec3"===b.type.name||"vec4"===b.type.name||"vec2f"===b.type.name||"vec3f"===b.type.name||"vec4f"===b.type.name||"vec2i"===b.type.name||"vec3i"===b.type.name||"vec4i"===b.type.name||"vec2u"===b.type.name||"vec3u"===b.type.name||"vec4u"===b.type.name||"vec2h"===b.type.name||"vec3h"===b.type.name||"vec4h"===b.type.name?m.setVariable(g,new Fe(_,b.type)):console.error(`Invalid constant type for ${g}`)):console.error(`Override ${g} does not exist in the shader.`)}}_dispatchWorkgroup(i,m,g){const _=[1,1,1];for(const m of i.node.attributes)if("workgroup_size"===m.name){if(m.value.length>0){const i=g.getVariableValue(m.value[0]);_[0]=i instanceof Oe?i.value:parseInt(m.value[0])}if(m.value.length>1){const i=g.getVariableValue(m.value[1]);_[1]=i instanceof Oe?i.value:parseInt(m.value[1])}if(m.value.length>2){const i=g.getVariableValue(m.value[2]);_[2]=i instanceof Oe?i.value:parseInt(m.value[2])}}const b=this.getTypeInfo("vec3u"),y=this.getTypeInfo("u32");g.setVariable("@workgroup_size",new Fe(_,b));const T=_[0],w=_[1],P=_[2];for(let H=0,$=0;H<P;++H)for(let P=0;P<w;++P)for(let w=0;w<T;++w,++$){const T=[w,P,H],W=[w+m[0]*_[0],P+m[1]*_[1],H+m[2]*_[2]];g.setVariable("@local_invocation_id",new Fe(T,b)),g.setVariable("@global_invocation_id",new Fe(W,b)),g.setVariable("@local_invocation_index",new Oe($,y)),this._dispatchExec(i,g)}}_dispatchExec(i,m){for(const g of i.node.args)for(const i of g.attributes)if("builtin"===i.name){const _=`@${i.value}`,b=m.getVariable(_);void 0!==b&&m.variables.set(g.name,b)}this._execStatements(i.node.body,m)}getVariableName(i,m){for(;i instanceof we;)i=i.right;return i instanceof me?i.name:(console.error("Unknown variable type",i,"Line",i.line),null)}_execStatements(i,m){for(const g of i){if(g instanceof Array){const i=m.clone(),_=this._execStatements(g,i);if(_)return _;continue}const i=this.execStatement(g,m);if(i)return i}return null}_call(i,m){const g=m.clone();g.currentFunctionName=i.name;const _=m.getFunction(i.name);if(_){for(let m=0;m<_.node.args.length;++m){const b=_.node.args[m],y=this.evalExpression(i.args[m],g);g.setVariable(b.name,y,b)}this._execStatements(_.node.body,g)}else i.isBuiltin?this._callBuiltinFunction(i,g):this.getTypeInfo(i.name)&&this._evalCreate(i,m)}_increment(i,m){const g=this.getVariableName(i.variable,m),_=m.getVariable(g);_?"++"===i.operator?_.value instanceof Oe?_.value.value++:console.error(`Variable ${g} is not a scalar. Line ${i.line}`):"--"===i.operator?_.value instanceof Oe?_.value.value--:console.error(`Variable ${g} is not a scalar. Line ${i.line}`):console.error(`Unknown increment operator ${i.operator}. Line ${i.line}`):console.error(`Variable ${g} not found. Line ${i.line}`)}_getVariableData(i,m){if(i instanceof me){const g=this.getVariableName(i,m),_=m.getVariable(g);return null===_?(console.error(`Variable ${g} not found. Line ${i.line}`),null):_.value.getSubData(this,i.postfix,m)}if(i instanceof we){if("*"===i.operator){const g=this._getVariableData(i.right,m);return g instanceof Ve?g.reference.getSubData(this,i.postfix,m):(console.error(`Variable ${i.right} is not a pointer. Line ${i.line}`),null)}if("&"===i.operator){const g=this._getVariableData(i.right,m);return new Ve(g)}}return null}_assign(i,m){let g=null,_="<var>",b=null;if(i.variable instanceof we){const g=this._getVariableData(i.variable,m),_=this.evalExpression(i.value,m),b=i.operator;if("="===b){if(g instanceof Oe||g instanceof Fe||g instanceof Me){if(_ instanceof Oe||_ instanceof Fe||_ instanceof Me&&g.data.length===_.data.length)return void g.data.set(_.data);console.error(`Invalid assignment. Line ${i.line}`)}else if(g instanceof Ue&&_ instanceof Ue&&g.buffer.byteLength-g.offset>=_.buffer.byteLength-_.offset)return void(g.buffer.byteLength%4==0?new Uint32Array(g.buffer,g.offset,g.typeInfo.size/4).set(new Uint32Array(_.buffer,_.offset,_.typeInfo.size/4)):new Uint8Array(g.buffer,g.offset,g.typeInfo.size).set(new Uint8Array(_.buffer,_.offset,_.typeInfo.size)));return console.error(`Invalid assignment. Line ${i.line}`),null}if("+="===b)return g instanceof Oe||g instanceof Fe||g instanceof Me?_ instanceof Oe||_ instanceof Fe||_ instanceof Me?void g.data.set(_.data.map((i,m)=>g.data[m]+i)):void console.error(`Invalid assignment . Line ${i.line}`):void console.error(`Invalid assignment. Line ${i.line}`);if("-="===b)return(g instanceof Oe||g instanceof Fe||g instanceof Me)&&(_ instanceof Oe||_ instanceof Fe||_ instanceof Me)?void g.data.set(_.data.map((i,m)=>g.data[m]-i)):void console.error(`Invalid assignment. Line ${i.line}`)}if(i.variable instanceof we){if("*"===i.variable.operator){_=this.getVariableName(i.variable.right,m);const b=m.getVariable(_);if(!(b&&b.value instanceof Ve))return void console.error(`Variable ${_} is not a pointer. Line ${i.line}`);g=b.value.reference;let y=i.variable.postfix;if(!y){let m=i.variable.right;for(;m instanceof we;){if(m.postfix){y=m.postfix;break}m=m.right}}y&&(g=g.getSubData(this,y,m))}}else{b=i.variable.postfix,_=this.getVariableName(i.variable,m);const y=m.getVariable(_);if(null===y)return void console.error(`Variable ${_} not found. Line ${i.line}`);g=y.value}if(g instanceof Ve&&(g=g.reference),null===g)return void console.error(`Variable ${_} not found. Line ${i.line}`);const y=this.evalExpression(i.value,m),T=i.operator;if("="===T)if(g instanceof Ue)g.setDataValue(this,y,b,m);else if(b){if(!(g instanceof Fe||g instanceof Me))return void console.error(`Variable ${_} is not a vector or matrix. Line ${i.line}`);if(b instanceof be){const T=this.evalExpression(b.index,m).value;if(g instanceof Fe){if(!(y instanceof Oe))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);g.data[T]=y.value}else{if(!(g instanceof Me))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);{const T=this.evalExpression(b.index,m).value;if(T<0)return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);if(!(y instanceof Fe))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);{const m=g.typeInfo.getTypeName();if("mat2x2"===m||"mat2x2f"===m||"mat2x2h"===m){if(!(T<2&&2===y.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);g.data[2*T]=y.data[0],g.data[2*T+1]=y.data[1]}else if("mat2x3"===m||"mat2x3f"===m||"mat2x3h"===m){if(!(T<2&&3===y.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);g.data[3*T]=y.data[0],g.data[3*T+1]=y.data[1],g.data[3*T+2]=y.data[2]}else if("mat2x4"===m||"mat2x4f"===m||"mat2x4h"===m){if(!(T<2&&4===y.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);g.data[4*T]=y.data[0],g.data[4*T+1]=y.data[1],g.data[4*T+2]=y.data[2],g.data[4*T+3]=y.data[3]}else if("mat3x2"===m||"mat3x2f"===m||"mat3x2h"===m){if(!(T<3&&2===y.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);g.data[2*T]=y.data[0],g.data[2*T+1]=y.data[1]}else if("mat3x3"===m||"mat3x3f"===m||"mat3x3h"===m){if(!(T<3&&3===y.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);g.data[3*T]=y.data[0],g.data[3*T+1]=y.data[1],g.data[3*T+2]=y.data[2]}else if("mat3x4"===m||"mat3x4f"===m||"mat3x4h"===m){if(!(T<3&&4===y.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);g.data[4*T]=y.data[0],g.data[4*T+1]=y.data[1],g.data[4*T+2]=y.data[2],g.data[4*T+3]=y.data[3]}else if("mat4x2"===m||"mat4x2f"===m||"mat4x2h"===m){if(!(T<4&&2===y.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);g.data[2*T]=y.data[0],g.data[2*T+1]=y.data[1]}else if("mat4x3"===m||"mat4x3f"===m||"mat4x3h"===m){if(!(T<4&&3===y.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);g.data[3*T]=y.data[0],g.data[3*T+1]=y.data[1],g.data[3*T+2]=y.data[2]}else{if("mat4x4"!==m&&"mat4x4f"!==m&&"mat4x4h"!==m)return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);if(!(T<4&&4===y.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);g.data[4*T]=y.data[0],g.data[4*T+1]=y.data[1],g.data[4*T+2]=y.data[2],g.data[4*T+3]=y.data[3]}}}}}else if(b instanceof fe){const m=b.value;if(!(g instanceof Fe))return void console.error(`Invalid assignment to ${m}. Variable ${_} is not a vector. Line ${i.line}`);if(y instanceof Oe){if(m.length>1)return void console.error(`Invalid assignment to ${m} for variable ${_}. Line ${i.line}`);if("x"===m)g.data[0]=y.value;else if("y"===m){if(g.data.length<2)return void console.error(`Invalid assignment to ${m} for variable ${_}. Line ${i.line}`);g.data[1]=y.value}else if("z"===m){if(g.data.length<3)return void console.error(`Invalid assignment to ${m} for variable ${_}. Line ${i.line}`);g.data[2]=y.value}else if("w"===m){if(g.data.length<4)return void console.error(`Invalid assignment to ${m} for variable ${_}. Line ${i.line}`);g.data[3]=y.value}}else{if(!(y instanceof Fe))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);if(m.length!==y.data.length)return void console.error(`Invalid assignment to ${m} for variable ${_}. Line ${i.line}`);for(let b=0;b<m.length;++b){const T=m[b];if("x"===T||"r"===T)g.data[0]=y.data[b];else if("y"===T||"g"===T){if(y.data.length<2)return void console.error(`Invalid assignment to ${T} for variable ${_}. Line ${i.line}`);g.data[1]=y.data[b]}else if("z"===T||"b"===T){if(y.data.length<3)return void console.error(`Invalid assignment to ${T} for variable ${_}. Line ${i.line}`);g.data[2]=y.data[b]}else{if("w"!==T&&"a"!==T)return void console.error(`Invalid assignment to ${T} for variable ${_}. Line ${i.line}`);if(y.data.length<4)return void console.error(`Invalid assignment to ${T} for variable ${_}. Line ${i.line}`);g.data[3]=y.data[b]}}}}}else g instanceof Oe&&y instanceof Oe?g.value=y.value:g instanceof Fe&&y instanceof Fe||g instanceof Me&&y instanceof Me?g.data.set(y.data):console.error(`Invalid assignment to ${_}. Line ${i.line}`);else{const _=g.getSubData(this,b,m);if(_ instanceof Fe&&y instanceof Oe){const m=_.data,g=y.value;if("+="===T)for(let i=0;i<m.length;++i)m[i]+=g;else if("-="===T)for(let i=0;i<m.length;++i)m[i]-=g;else if("*="===T)for(let i=0;i<m.length;++i)m[i]*=g;else if("/="===T)for(let i=0;i<m.length;++i)m[i]/=g;else if("%="===T)for(let i=0;i<m.length;++i)m[i]%=g;else if("&="===T)for(let i=0;i<m.length;++i)m[i]&=g;else if("|="===T)for(let i=0;i<m.length;++i)m[i]|=g;else if("^="===T)for(let i=0;i<m.length;++i)m[i]^=g;else if("<<="===T)for(let i=0;i<m.length;++i)m[i]<<=g;else if(">>="===T)for(let i=0;i<m.length;++i)m[i]>>=g;else console.error(`Invalid operator ${T}. Line ${i.line}`)}else if(_ instanceof Fe&&y instanceof Fe){const m=_.data,g=y.data;if(m.length!==g.length)return void console.error(`Vector length mismatch. Line ${i.line}`);if("+="===T)for(let i=0;i<m.length;++i)m[i]+=g[i];else if("-="===T)for(let i=0;i<m.length;++i)m[i]-=g[i];else if("*="===T)for(let i=0;i<m.length;++i)m[i]*=g[i];else if("/="===T)for(let i=0;i<m.length;++i)m[i]/=g[i];else if("%="===T)for(let i=0;i<m.length;++i)m[i]%=g[i];else if("&="===T)for(let i=0;i<m.length;++i)m[i]&=g[i];else if("|="===T)for(let i=0;i<m.length;++i)m[i]|=g[i];else if("^="===T)for(let i=0;i<m.length;++i)m[i]^=g[i];else if("<<="===T)for(let i=0;i<m.length;++i)m[i]<<=g[i];else if(">>="===T)for(let i=0;i<m.length;++i)m[i]>>=g[i];else console.error(`Invalid operator ${T}. Line ${i.line}`)}else{if(!(_ instanceof Oe&&y instanceof Oe))return void console.error(`Invalid type for ${i.operator} operator. Line ${i.line}`);"+="===T?_.value+=y.value:"-="===T?_.value-=y.value:"*="===T?_.value*=y.value:"/="===T?_.value/=y.value:"%="===T?_.value%=y.value:"&="===T?_.value&=y.value:"|="===T?_.value|=y.value:"^="===T?_.value^=y.value:"<<="===T?_.value<<=y.value:">>="===T?_.value>>=y.value:console.error(`Invalid operator ${T}. Line ${i.line}`)}g instanceof Ue&&g.setDataValue(this,_,b,m)}}_function(i,m){const g=new ot(i);m.functions.set(i.name,g)}_const(i,m){let g=null;null!==i.value&&(g=this.evalExpression(i.value,m)),m.createVariable(i.name,g,i)}_let(i,m){let g=null;if(null!==i.value){if(g=this.evalExpression(i.value,m),null===g)return void console.error(`Invalid value for variable ${i.name}. Line ${i.line}`);i.value instanceof we||(g=g.clone())}else{const _=i.type.name;if("f32"===_||"i32"===_||"u32"===_||"bool"===_||"f16"===_||"vec2"===_||"vec3"===_||"vec4"===_||"vec2f"===_||"vec3f"===_||"vec4f"===_||"vec2i"===_||"vec3i"===_||"vec4i"===_||"vec2u"===_||"vec3u"===_||"vec4u"===_||"vec2h"===_||"vec3h"===_||"vec4h"===_||"vec2b"===_||"vec3b"===_||"vec4b"===_||"mat2x2"===_||"mat2x3"===_||"mat2x4"===_||"mat3x2"===_||"mat3x3"===_||"mat3x4"===_||"mat4x2"===_||"mat4x3"===_||"mat4x4"===_||"mat2x2f"===_||"mat2x3f"===_||"mat2x4f"===_||"mat3x2f"===_||"mat3x3f"===_||"mat3x4f"===_||"mat4x2f"===_||"mat4x3f"===_||"mat4x4f"===_||"mat2x2h"===_||"mat2x3h"===_||"mat2x4h"===_||"mat3x2h"===_||"mat3x3h"===_||"mat3x4h"===_||"mat4x2h"===_||"mat4x3h"===_||"mat4x4h"===_||"array"===_){const _=new pe(i.type,[]);g=this._evalCreate(_,m)}}m.createVariable(i.name,g,i)}_var(i,m){let g=null;if(null!==i.value){if(g=this.evalExpression(i.value,m),null===g)return void console.error(`Invalid value for variable ${i.name}. Line ${i.line}`);i.value instanceof we||(g=g.clone())}else{if(null===i.type)return void console.error(`Variable ${i.name} has no type. Line ${i.line}`);const _=i.type.name;if("f32"===_||"i32"===_||"u32"===_||"bool"===_||"f16"===_||"vec2"===_||"vec3"===_||"vec4"===_||"vec2f"===_||"vec3f"===_||"vec4f"===_||"vec2i"===_||"vec3i"===_||"vec4i"===_||"vec2u"===_||"vec3u"===_||"vec4u"===_||"vec2h"===_||"vec3h"===_||"vec4h"===_||"vec2b"===_||"vec3b"===_||"vec4b"===_||"mat2x2"===_||"mat2x3"===_||"mat2x4"===_||"mat3x2"===_||"mat3x3"===_||"mat3x4"===_||"mat4x2"===_||"mat4x3"===_||"mat4x4"===_||"mat2x2f"===_||"mat2x3f"===_||"mat2x4f"===_||"mat3x2f"===_||"mat3x3f"===_||"mat3x4f"===_||"mat4x2f"===_||"mat4x3f"===_||"mat4x4f"===_||"mat2x2h"===_||"mat2x3h"===_||"mat2x4h"===_||"mat3x2h"===_||"mat3x3h"===_||"mat3x4h"===_||"mat4x2h"===_||"mat4x3h"===_||"mat4x4h"===_||i.type instanceof ce||i.type instanceof ie||i.type instanceof oe){const _=new pe(i.type,[]);g=this._evalCreate(_,m)}}m.createVariable(i.name,g,i)}_switch(i,m){m=m.clone();const g=this.evalExpression(i.condition,m);if(!(g instanceof Oe))return console.error(`Invalid if condition. Line ${i.line}`),null;let _=null;for(const b of i.cases)if(b instanceof Se)for(const y of b.selectors){if(y instanceof Te){_=b;continue}const T=this.evalExpression(y,m);if(!(T instanceof Oe))return console.error(`Invalid case selector. Line ${i.line}`),null;if(T.value===g.value)return this._execStatements(b.body,m)}else b instanceof Ae&&(_=b);return _?this._execStatements(_.body,m):null}_if(i,m){m=m.clone();const g=this.evalExpression(i.condition,m);if(!(g instanceof Oe))return console.error(`Invalid if condition. Line ${i.line}`),null;if(g.value)return this._execStatements(i.body,m);for(const g of i.elseif){const _=this.evalExpression(g.condition,m);if(!(_ instanceof Oe))return console.error(`Invalid if condition. Line ${i.line}`),null;if(_.value)return this._execStatements(g.body,m)}return i.else?this._execStatements(i.else,m):null}_getScalarValue(i){return i instanceof Oe?i.value:(console.error("Expected scalar value.",i),0)}_for(i,m){for(m=m.clone(),this.execStatement(i.init,m);this._getScalarValue(this.evalExpression(i.condition,m));){const g=this._execStatements(i.body,m);if(g===pt._breakObj)break;if(null!==g&&g!==pt._continueObj)return g;this.execStatement(i.increment,m)}return null}_loop(i,m){for(m=m.clone();;){const g=this._execStatements(i.body,m);if(g===pt._breakObj)break;if(g===pt._continueObj){if(i.continuing&&this._execStatements(i.continuing.body,m)===pt._breakObj)break}else if(null!==g)return g}return null}_while(i,m){for(m=m.clone();this._getScalarValue(this.evalExpression(i.condition,m));){const g=this._execStatements(i.body,m);if(g===pt._breakObj)break;if(g!==pt._continueObj&&null!==g)return g}return null}_evalBitcast(i,m){const g=this.evalExpression(i.value,m),_=i.type;if(g instanceof Oe){const i=tt(g.value,g.typeInfo.name,_.name);return new Oe(i,this.getTypeInfo(_))}if(g instanceof Fe){const m=g.typeInfo.getTypeName();let b="";if(m.endsWith("f"))b="f32";else if(m.endsWith("i"))b="i32";else if(m.endsWith("u"))b="u32";else if(m.endsWith("b"))b="bool";else{if(!m.endsWith("h"))return console.error(`Unknown vector type ${m}. Line ${i.line}`),null;b="f16"}const y=_.getTypeName();let T="";if(y.endsWith("f"))T="f32";else if(y.endsWith("i"))T="i32";else if(y.endsWith("u"))T="u32";else if(y.endsWith("b"))T="bool";else{if(!y.endsWith("h"))return console.error(`Unknown vector type ${T}. Line ${i.line}`),null;T="f16"}const w=function(i,m,g){if(m===g)return i;const _=new Array(i.length);for(let b=0;b<i.length;b++)_[b]=tt(i[b],m,g);return _}(Array.from(g.data),b,T);return new Fe(w,this.getTypeInfo(_))}return console.error(`TODO:bitcast for ${g.typeInfo.name}. Line ${i.line}`),null}_evalConst(i,m){return m.getVariableValue(i.name).clone().getSubData(this,i.postfix,m)}_evalCreate(i,m){var g;if(i instanceof pe){if(null===i.type)return Ne.void;switch(i.type.getTypeName()){case"bool":case"i32":case"u32":case"f32":case"f16":return this._callConstructorValue(i,m);case"vec2":case"vec3":case"vec4":case"vec2f":case"vec3f":case"vec4f":case"vec2h":case"vec3h":case"vec4h":case"vec2i":case"vec3i":case"vec4i":case"vec2u":case"vec3u":case"vec4u":case"vec2b":case"vec3b":case"vec4b":return this._callConstructorVec(i,m);case"mat2x2":case"mat2x2f":case"mat2x2h":case"mat2x3":case"mat2x3f":case"mat2x3h":case"mat2x4":case"mat2x4f":case"mat2x4h":case"mat3x2":case"mat3x2f":case"mat3x2h":case"mat3x3":case"mat3x3f":case"mat3x3h":case"mat3x4":case"mat3x4f":case"mat3x4h":case"mat4x2":case"mat4x2f":case"mat4x2h":case"mat4x3":case"mat4x3f":case"mat4x3h":case"mat4x4":case"mat4x4f":case"mat4x4h":return this._callConstructorMatrix(i,m)}}const _=i instanceof pe?i.type.name:i.name,b=i instanceof pe?this.getTypeInfo(i.type):this.getTypeInfo(i.name);if(null===b)return console.error(`Unknown type ${_}. Line ${i.line}`),null;if(0===b.size)return null;const y=new Ue(new ArrayBuffer(b.size),b,0);if(b instanceof n){if(i.args)for(let g=0;g<i.args.length;++g){const _=b.members[g],T=i.args[g],w=this.evalExpression(T,m);y.setData(this,w,_.type,_.offset,m)}}else if(b instanceof s){let _=0;if(i.args)for(let T=0;T<i.args.length;++T){const w=i.args[T],P=this.evalExpression(w,m);null===b.format&&("x32"===(null===(g=P.typeInfo)||void 0===g?void 0:g.name)?b.format=this.getTypeInfo("i32"):b.format=P.typeInfo),y.setData(this,P,b.format,_,m),_+=b.stride}}else console.error(`Unknown type "${_}". Line ${i.line}`);return i instanceof pe?y.getSubData(this,i.postfix,m):y}_evalLiteral(i,m){const g=this.getTypeInfo(i.type),_=g.name;return"x32"===_||"u32"===_||"f32"===_||"f16"===_||"i32"===_||"bool"===_?new Oe(i.scalarValue,g):"vec2"===_||"vec3"===_||"vec4"===_||"vec2f"===_||"vec3f"===_||"vec4f"===_||"vec2h"===_||"vec3h"===_||"vec4h"===_||"vec2i"===_||"vec3i"===_||"vec4i"===_||"vec2u"===_||"vec3u"===_||"vec4u"===_?this._callConstructorVec(i,m):"mat2x2"===_||"mat2x3"===_||"mat2x4"===_||"mat3x2"===_||"mat3x3"===_||"mat3x4"===_||"mat4x2"===_||"mat4x3"===_||"mat4x4"===_||"mat2x2f"===_||"mat2x3f"===_||"mat2x4f"===_||"mat3x2f"===_||"mat3x3f"===_||"mat3x4f"===_||"mat4x2f"===_||"mat4x3f"===_||"mat4x4f"===_||"mat2x2h"===_||"mat2x3h"===_||"mat2x4h"===_||"mat3x2h"===_||"mat3x3h"===_||"mat3x4h"===_||"mat4x2h"===_||"mat4x3h"===_||"mat4x4h"===_?this._callConstructorMatrix(i,m):i.value}_evalVariable(i,m){const g=m.getVariableValue(i.name);return null===g?g:g.getSubData(this,i.postfix,m)}_maxFormatTypeInfo(i){let m=i[0];if("f32"===m.name)return m;for(let g=1;g<i.length;++g){const _=pt._priority.get(m.name);pt._priority.get(i[g].name)<_&&(m=i[g])}return"x32"===m.name?this.getTypeInfo("i32"):m}_evalUnaryOp(i,m){const g=this.evalExpression(i.right,m);if("&"===i.operator)return new Ve(g);if("*"===i.operator)return g instanceof Ve?g.reference.getSubData(this,i.postfix,m):(console.error(`Invalid dereference. Line ${i.line}`),null);const _=g instanceof Oe?g.value:g instanceof Fe?Array.from(g.data):null;switch(i.operator){case"+":{if(Re(_)){const i=_.map((i,m)=>+i);return new Fe(i,g.typeInfo)}const i=_,m=this._maxFormatTypeInfo([g.typeInfo,g.typeInfo]);return new Oe(+i,m)}case"-":{if(Re(_)){const i=_.map((i,m)=>-i);return new Fe(i,g.typeInfo)}const i=_,m=this._maxFormatTypeInfo([g.typeInfo,g.typeInfo]);return new Oe(-i,m)}case"!":{if(Re(_)){const i=_.map((i,m)=>i?0:1);return new Fe(i,g.typeInfo)}const i=_,m=this._maxFormatTypeInfo([g.typeInfo,g.typeInfo]);return new Oe(i?0:1,m)}case"~":{if(Re(_)){const i=_.map((i,m)=>~i);return new Fe(i,g.typeInfo)}const i=_,m=this._maxFormatTypeInfo([g.typeInfo,g.typeInfo]);return new Oe(~i,m)}}return console.error(`Invalid unary operator ${i.operator}. Line ${i.line}`),null}_evalBinaryOp(i,m){const g=this.evalExpression(i.left,m),_=this.evalExpression(i.right,m),b=g instanceof Oe?g.value:g instanceof Fe||g instanceof Me?Array.from(g.data):null,y=_ instanceof Oe?_.value:_ instanceof Fe||_ instanceof Me?Array.from(_.data):null;switch(i.operator){case"+":{if(Re(b)&&Re(y)){const m=b,_=y;if(m.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const T=m.map((i,m)=>i+_[m]);return new Fe(T,g.typeInfo)}if(Re(b)){const i=y,m=b.map((m,g)=>m+i);return new Fe(m,g.typeInfo)}if(Re(y)){const i=b,m=y.map((m,g)=>i+m);return new Fe(m,_.typeInfo)}const m=b,T=y,w=this._maxFormatTypeInfo([g.typeInfo,_.typeInfo]);return new Oe(m+T,w)}case"-":{if(Re(b)&&Re(y)){const m=b,_=y;if(m.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const T=m.map((i,m)=>i-_[m]);return new Fe(T,g.typeInfo)}if(Re(b)){const i=y,m=b.map((m,g)=>m-i);return new Fe(m,g.typeInfo)}if(Re(y)){const i=b,m=y.map((m,g)=>i-m);return new Fe(m,_.typeInfo)}const m=b,T=y,w=this._maxFormatTypeInfo([g.typeInfo,_.typeInfo]);return new Oe(m-T,w)}case"*":{if(Re(b)&&Re(y)){const m=b,T=y;if(g instanceof Me&&_ instanceof Me){const b=function(i,m,g,_){if(void 0===cn[m.name]||void 0===cn[_.name])return null;const b=cn[m.name][0],y=cn[m.name][1],T=cn[_.name][0];if(b!==cn[_.name][1])return null;const w=new Array(T*y);for(let m=0;m<y;m++)for(let _=0;_<T;_++){let P=0;for(let T=0;T<b;T++)P+=i[T*y+m]*g[_*b+T];w[m*T+_]=P}return w}(m,g.typeInfo,T,_.typeInfo);if(null===b)return console.error(`Matrix multiplication failed. Line ${i.line}.`),null;const y=cn[_.typeInfo.name][0],w=cn[g.typeInfo.name][1],P=this.getTypeInfo(`mat${y}x${w}f`);return new Me(b,P)}if(g instanceof Me&&_ instanceof Fe){const b=function(i,m,g,_){if(void 0===cn[m.name]||void 0===ln[_.name])return null;const b=cn[m.name][0],y=cn[m.name][1];if(b!==g.length)return null;const T=new Array(y);for(let m=0;m<y;m++){let _=0;for(let T=0;T<b;T++)_+=i[T*y+m]*g[T];T[m]=_}return T}(m,g.typeInfo,T,_.typeInfo);return null===b?(console.error(`Matrix vector multiplication failed. Line ${i.line}.`),null):new Fe(b,_.typeInfo)}if(g instanceof Fe&&_ instanceof Me){const b=function(i,m,g,_){if(void 0===ln[m.name]||void 0===cn[_.name])return null;const b=cn[_.name][0],y=cn[_.name][1];if(y!==i.length)return null;const T=[];for(let m=0;m<b;m++){let _=0;for(let T=0;T<y;T++)_+=i[T]*g[T*b+m];T[m]=_}return T}(m,g.typeInfo,T,_.typeInfo);return null===b?(console.error(`Matrix vector multiplication failed. Line ${i.line}.`),null):new Fe(b,g.typeInfo)}{if(m.length!==T.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const _=m.map((i,m)=>i*T[m]);return new Fe(_,g.typeInfo)}}if(Re(b)){const i=y,m=b.map((m,g)=>m*i);return g instanceof Me?new Me(m,g.typeInfo):new Fe(m,g.typeInfo)}if(Re(y)){const i=b,m=y.map((m,g)=>i*m);return _ instanceof Me?new Me(m,_.typeInfo):new Fe(m,_.typeInfo)}const m=b,T=y,w=this._maxFormatTypeInfo([g.typeInfo,_.typeInfo]);return new Oe(m*T,w)}case"%":{if(Re(b)&&Re(y)){const m=b,_=y;if(m.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const T=m.map((i,m)=>i%_[m]);return new Fe(T,g.typeInfo)}if(Re(b)){const i=y,m=b.map((m,g)=>m%i);return new Fe(m,g.typeInfo)}if(Re(y)){const i=b,m=y.map((m,g)=>i%m);return new Fe(m,_.typeInfo)}const m=b,T=y,w=this._maxFormatTypeInfo([g.typeInfo,_.typeInfo]);return new Oe(m%T,w)}case"/":{if(Re(b)&&Re(y)){const m=b,_=y;if(m.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const T=m.map((i,m)=>i/_[m]);return new Fe(T,g.typeInfo)}if(Re(b)){const i=y,m=b.map((m,g)=>m/i);return new Fe(m,g.typeInfo)}if(Re(y)){const i=b,m=y.map((m,g)=>i/m);return new Fe(m,_.typeInfo)}const m=b,T=y,w=this._maxFormatTypeInfo([g.typeInfo,_.typeInfo]);return new Oe(m/T,w)}case"&":{if(Re(b)&&Re(y)){const m=b,_=y;if(m.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const T=m.map((i,m)=>i&_[m]);return new Fe(T,g.typeInfo)}if(Re(b)){const i=y,m=b.map((m,g)=>m&i);return new Fe(m,g.typeInfo)}if(Re(y)){const i=b,m=y.map((m,g)=>i&m);return new Fe(m,_.typeInfo)}const m=b,T=y,w=this._maxFormatTypeInfo([g.typeInfo,_.typeInfo]);return new Oe(m&T,w)}case"|":{if(Re(b)&&Re(y)){const m=b,_=y;if(m.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const T=m.map((i,m)=>i|_[m]);return new Fe(T,g.typeInfo)}if(Re(b)){const i=y,m=b.map((m,g)=>m|i);return new Fe(m,g.typeInfo)}if(Re(y)){const i=b,m=y.map((m,g)=>i|m);return new Fe(m,_.typeInfo)}const m=b,T=y,w=this._maxFormatTypeInfo([g.typeInfo,_.typeInfo]);return new Oe(m|T,w)}case"^":{if(Re(b)&&Re(y)){const m=b,_=y;if(m.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const T=m.map((i,m)=>i^_[m]);return new Fe(T,g.typeInfo)}if(Re(b)){const i=y,m=b.map((m,g)=>m^i);return new Fe(m,g.typeInfo)}if(Re(y)){const i=b,m=y.map((m,g)=>i^m);return new Fe(m,_.typeInfo)}const m=b,T=y,w=this._maxFormatTypeInfo([g.typeInfo,_.typeInfo]);return new Oe(m^T,w)}case"<<":{if(Re(b)&&Re(y)){const m=b,_=y;if(m.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const T=m.map((i,m)=>i<<_[m]);return new Fe(T,g.typeInfo)}if(Re(b)){const i=y,m=b.map((m,g)=>m<<i);return new Fe(m,g.typeInfo)}if(Re(y)){const i=b,m=y.map((m,g)=>i<<m);return new Fe(m,_.typeInfo)}const m=b,T=y,w=this._maxFormatTypeInfo([g.typeInfo,_.typeInfo]);return new Oe(m<<T,w)}case">>":{if(Re(b)&&Re(y)){const m=b,_=y;if(m.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const T=m.map((i,m)=>i>>_[m]);return new Fe(T,g.typeInfo)}if(Re(b)){const i=y,m=b.map((m,g)=>m>>i);return new Fe(m,g.typeInfo)}if(Re(y)){const i=b,m=y.map((m,g)=>i>>m);return new Fe(m,_.typeInfo)}const m=b,T=y,w=this._maxFormatTypeInfo([g.typeInfo,_.typeInfo]);return new Oe(m>>T,w)}case">":if(Re(b)&&Re(y)){const m=b,_=y;if(m.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const T=m.map((i,m)=>i>_[m]?1:0);return new Fe(T,g.typeInfo)}if(Re(b)){const i=y,m=b.map((m,g)=>m>i?1:0);return new Fe(m,g.typeInfo)}if(Re(y)){const i=b,m=y.map((m,g)=>i>m?1:0);return new Fe(m,_.typeInfo)}return new Oe(b>y?1:0,this.getTypeInfo("bool"));case"<":if(Re(b)&&Re(y)){const m=b,_=y;if(m.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const T=m.map((i,m)=>i<_[m]?1:0);return new Fe(T,g.typeInfo)}if(Re(b)){const i=y,m=b.map((m,g)=>m<i?1:0);return new Fe(m,g.typeInfo)}if(Re(y)){const i=b,m=y.map((m,g)=>i<m?1:0);return new Fe(m,_.typeInfo)}return new Oe(b<y?1:0,this.getTypeInfo("bool"));case"==":if(Re(b)&&Re(y)){const m=b,_=y;if(m.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const T=m.map((i,m)=>i===_[m]?1:0);return new Fe(T,g.typeInfo)}if(Re(b)){const i=y,m=b.map((m,g)=>m==i?1:0);return new Fe(m,g.typeInfo)}if(Re(y)){const i=b,m=y.map((m,g)=>i==m?1:0);return new Fe(m,_.typeInfo)}return new Oe(b===y?1:0,this.getTypeInfo("bool"));case"!=":if(Re(b)&&Re(y)){const m=b,_=y;if(m.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const T=m.map((i,m)=>i!==_[m]?1:0);return new Fe(T,g.typeInfo)}if(Re(b)){const i=y,m=b.map((m,g)=>m!==i?1:0);return new Fe(m,g.typeInfo)}if(Re(y)){const i=b,m=y.map((m,g)=>i!==m?1:0);return new Fe(m,_.typeInfo)}return new Oe(b!==y?1:0,this.getTypeInfo("bool"));case">=":if(Re(b)&&Re(y)){const m=b,_=y;if(m.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const T=m.map((i,m)=>i>=_[m]?1:0);return new Fe(T,g.typeInfo)}if(Re(b)){const i=y,m=b.map((m,g)=>m>=i?1:0);return new Fe(m,g.typeInfo)}if(Re(y)){const i=b,m=y.map((m,g)=>i>=m?1:0);return new Fe(m,_.typeInfo)}return new Oe(b>=y?1:0,this.getTypeInfo("bool"));case"<=":if(Re(b)&&Re(y)){const m=b,_=y;if(m.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const T=m.map((i,m)=>i<=_[m]?1:0);return new Fe(T,g.typeInfo)}if(Re(b)){const i=y,m=b.map((m,g)=>m<=i?1:0);return new Fe(m,g.typeInfo)}if(Re(y)){const i=b,m=y.map((m,g)=>i<=m?1:0);return new Fe(m,_.typeInfo)}return new Oe(b<=y?1:0,this.getTypeInfo("bool"));case"&&":if(Re(b)&&Re(y)){const m=b,_=y;if(m.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const T=m.map((i,m)=>i&&_[m]?1:0);return new Fe(T,g.typeInfo)}if(Re(b)){const i=y,m=b.map((m,g)=>m&&i?1:0);return new Fe(m,g.typeInfo)}if(Re(y)){const i=b,m=y.map((m,g)=>i&&m?1:0);return new Fe(m,_.typeInfo)}return new Oe(b&&y?1:0,this.getTypeInfo("bool"));case"||":if(Re(b)&&Re(y)){const m=b,_=y;if(m.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const T=m.map((i,m)=>i||_[m]?1:0);return new Fe(T,g.typeInfo)}if(Re(b)){const i=y,m=b.map((m,g)=>m||i?1:0);return new Fe(m,g.typeInfo)}if(Re(y)){const i=b,m=y.map((m,g)=>i||m?1:0);return new Fe(m,_.typeInfo)}return new Oe(b||y?1:0,this.getTypeInfo("bool"))}return console.error(`Unknown operator ${i.operator}. Line ${i.line}`),null}_evalCall(i,m){if(null!==i.cachedReturnValue)return i.cachedReturnValue;const g=m.clone();g.currentFunctionName=i.name;const _=m.getFunction(i.name);if(!_)return i.isBuiltin?this._callBuiltinFunction(i,g):this.getTypeInfo(i.name)?this._evalCreate(i,m):(console.error(`Unknown function "${i.name}". Line ${i.line}`),null);for(let m=0;m<_.node.args.length;++m){const b=_.node.args[m],y=this.evalExpression(i.args[m],g);g.createVariable(b.name,y,b)}return this._execStatements(_.node.body,g)}_callBuiltinFunction(i,m){switch(i.name){case"all":return this.builtins.All(i,m);case"any":return this.builtins.Any(i,m);case"select":return this.builtins.Select(i,m);case"arrayLength":return this.builtins.ArrayLength(i,m);case"abs":return this.builtins.Abs(i,m);case"acos":return this.builtins.Acos(i,m);case"acosh":return this.builtins.Acosh(i,m);case"asin":return this.builtins.Asin(i,m);case"asinh":return this.builtins.Asinh(i,m);case"atan":return this.builtins.Atan(i,m);case"atanh":return this.builtins.Atanh(i,m);case"atan2":return this.builtins.Atan2(i,m);case"ceil":return this.builtins.Ceil(i,m);case"clamp":return this.builtins.Clamp(i,m);case"cos":return this.builtins.Cos(i,m);case"cosh":return this.builtins.Cosh(i,m);case"countLeadingZeros":return this.builtins.CountLeadingZeros(i,m);case"countOneBits":return this.builtins.CountOneBits(i,m);case"countTrailingZeros":return this.builtins.CountTrailingZeros(i,m);case"cross":return this.builtins.Cross(i,m);case"degrees":return this.builtins.Degrees(i,m);case"determinant":return this.builtins.Determinant(i,m);case"distance":return this.builtins.Distance(i,m);case"dot":return this.builtins.Dot(i,m);case"dot4U8Packed":return this.builtins.Dot4U8Packed(i,m);case"dot4I8Packed":return this.builtins.Dot4I8Packed(i,m);case"exp":return this.builtins.Exp(i,m);case"exp2":return this.builtins.Exp2(i,m);case"extractBits":return this.builtins.ExtractBits(i,m);case"faceForward":return this.builtins.FaceForward(i,m);case"firstLeadingBit":return this.builtins.FirstLeadingBit(i,m);case"firstTrailingBit":return this.builtins.FirstTrailingBit(i,m);case"floor":return this.builtins.Floor(i,m);case"fma":return this.builtins.Fma(i,m);case"fract":return this.builtins.Fract(i,m);case"frexp":return this.builtins.Frexp(i,m);case"insertBits":return this.builtins.InsertBits(i,m);case"inverseSqrt":return this.builtins.InverseSqrt(i,m);case"ldexp":return this.builtins.Ldexp(i,m);case"length":return this.builtins.Length(i,m);case"log":return this.builtins.Log(i,m);case"log2":return this.builtins.Log2(i,m);case"max":return this.builtins.Max(i,m);case"min":return this.builtins.Min(i,m);case"mix":return this.builtins.Mix(i,m);case"modf":return this.builtins.Modf(i,m);case"normalize":return this.builtins.Normalize(i,m);case"pow":return this.builtins.Pow(i,m);case"quantizeToF16":return this.builtins.QuantizeToF16(i,m);case"radians":return this.builtins.Radians(i,m);case"reflect":return this.builtins.Reflect(i,m);case"refract":return this.builtins.Refract(i,m);case"reverseBits":return this.builtins.ReverseBits(i,m);case"round":return this.builtins.Round(i,m);case"saturate":return this.builtins.Saturate(i,m);case"sign":return this.builtins.Sign(i,m);case"sin":return this.builtins.Sin(i,m);case"sinh":return this.builtins.Sinh(i,m);case"smoothStep":return this.builtins.SmoothStep(i,m);case"sqrt":return this.builtins.Sqrt(i,m);case"step":return this.builtins.Step(i,m);case"tan":return this.builtins.Tan(i,m);case"tanh":return this.builtins.Tanh(i,m);case"transpose":return this.builtins.Transpose(i,m);case"trunc":return this.builtins.Trunc(i,m);case"dpdx":return this.builtins.Dpdx(i,m);case"dpdxCoarse":return this.builtins.DpdxCoarse(i,m);case"dpdxFine":return this.builtins.DpdxFine(i,m);case"dpdy":return this.builtins.Dpdy(i,m);case"dpdyCoarse":return this.builtins.DpdyCoarse(i,m);case"dpdyFine":return this.builtins.DpdyFine(i,m);case"fwidth":return this.builtins.Fwidth(i,m);case"fwidthCoarse":return this.builtins.FwidthCoarse(i,m);case"fwidthFine":return this.builtins.FwidthFine(i,m);case"textureDimensions":return this.builtins.TextureDimensions(i,m);case"textureGather":return this.builtins.TextureGather(i,m);case"textureGatherCompare":return this.builtins.TextureGatherCompare(i,m);case"textureLoad":return this.builtins.TextureLoad(i,m);case"textureNumLayers":return this.builtins.TextureNumLayers(i,m);case"textureNumLevels":return this.builtins.TextureNumLevels(i,m);case"textureNumSamples":return this.builtins.TextureNumSamples(i,m);case"textureSample":return this.builtins.TextureSample(i,m);case"textureSampleBias":return this.builtins.TextureSampleBias(i,m);case"textureSampleCompare":return this.builtins.TextureSampleCompare(i,m);case"textureSampleCompareLevel":return this.builtins.TextureSampleCompareLevel(i,m);case"textureSampleGrad":return this.builtins.TextureSampleGrad(i,m);case"textureSampleLevel":return this.builtins.TextureSampleLevel(i,m);case"textureSampleBaseClampToEdge":return this.builtins.TextureSampleBaseClampToEdge(i,m);case"textureStore":return this.builtins.TextureStore(i,m);case"atomicLoad":return this.builtins.AtomicLoad(i,m);case"atomicStore":return this.builtins.AtomicStore(i,m);case"atomicAdd":return this.builtins.AtomicAdd(i,m);case"atomicSub":return this.builtins.AtomicSub(i,m);case"atomicMax":return this.builtins.AtomicMax(i,m);case"atomicMin":return this.builtins.AtomicMin(i,m);case"atomicAnd":return this.builtins.AtomicAnd(i,m);case"atomicOr":return this.builtins.AtomicOr(i,m);case"atomicXor":return this.builtins.AtomicXor(i,m);case"atomicExchange":return this.builtins.AtomicExchange(i,m);case"atomicCompareExchangeWeak":return this.builtins.AtomicCompareExchangeWeak(i,m);case"pack4x8snorm":return this.builtins.Pack4x8snorm(i,m);case"pack4x8unorm":return this.builtins.Pack4x8unorm(i,m);case"pack4xI8":return this.builtins.Pack4xI8(i,m);case"pack4xU8":return this.builtins.Pack4xU8(i,m);case"pack4x8Clamp":return this.builtins.Pack4x8Clamp(i,m);case"pack4xU8Clamp":return this.builtins.Pack4xU8Clamp(i,m);case"pack2x16snorm":return this.builtins.Pack2x16snorm(i,m);case"pack2x16unorm":return this.builtins.Pack2x16unorm(i,m);case"pack2x16float":return this.builtins.Pack2x16float(i,m);case"unpack4x8snorm":return this.builtins.Unpack4x8snorm(i,m);case"unpack4x8unorm":return this.builtins.Unpack4x8unorm(i,m);case"unpack4xI8":return this.builtins.Unpack4xI8(i,m);case"unpack4xU8":return this.builtins.Unpack4xU8(i,m);case"unpack2x16snorm":return this.builtins.Unpack2x16snorm(i,m);case"unpack2x16unorm":return this.builtins.Unpack2x16unorm(i,m);case"unpack2x16float":return this.builtins.Unpack2x16float(i,m);case"storageBarrier":return this.builtins.StorageBarrier(i,m);case"textureBarrier":return this.builtins.TextureBarrier(i,m);case"workgroupBarrier":return this.builtins.WorkgroupBarrier(i,m);case"workgroupUniformLoad":return this.builtins.WorkgroupUniformLoad(i,m);case"subgroupAdd":return this.builtins.SubgroupAdd(i,m);case"subgroupExclusiveAdd":return this.builtins.SubgroupExclusiveAdd(i,m);case"subgroupInclusiveAdd":return this.builtins.SubgroupInclusiveAdd(i,m);case"subgroupAll":return this.builtins.SubgroupAll(i,m);case"subgroupAnd":return this.builtins.SubgroupAnd(i,m);case"subgroupAny":return this.builtins.SubgroupAny(i,m);case"subgroupBallot":return this.builtins.SubgroupBallot(i,m);case"subgroupBroadcast":return this.builtins.SubgroupBroadcast(i,m);case"subgroupBroadcastFirst":return this.builtins.SubgroupBroadcastFirst(i,m);case"subgroupElect":return this.builtins.SubgroupElect(i,m);case"subgroupMax":return this.builtins.SubgroupMax(i,m);case"subgroupMin":return this.builtins.SubgroupMin(i,m);case"subgroupMul":return this.builtins.SubgroupMul(i,m);case"subgroupExclusiveMul":return this.builtins.SubgroupExclusiveMul(i,m);case"subgroupInclusiveMul":return this.builtins.SubgroupInclusiveMul(i,m);case"subgroupOr":return this.builtins.SubgroupOr(i,m);case"subgroupShuffle":return this.builtins.SubgroupShuffle(i,m);case"subgroupShuffleDown":return this.builtins.SubgroupShuffleDown(i,m);case"subgroupShuffleUp":return this.builtins.SubgroupShuffleUp(i,m);case"subgroupShuffleXor":return this.builtins.SubgroupShuffleXor(i,m);case"subgroupXor":return this.builtins.SubgroupXor(i,m);case"quadBroadcast":return this.builtins.QuadBroadcast(i,m);case"quadSwapDiagonal":return this.builtins.QuadSwapDiagonal(i,m);case"quadSwapX":return this.builtins.QuadSwapX(i,m);case"quadSwapY":return this.builtins.QuadSwapY(i,m)}const g=m.getFunction(i.name);if(g){const _=m.clone();for(let m=0;m<g.node.args.length;++m){const b=g.node.args[m],y=this.evalExpression(i.args[m],_);_.setVariable(b.name,y,b)}return this._execStatements(g.node.body,_)}return null}_callConstructorValue(i,m){if(!i.args||0===i.args.length)return new Oe(0,this.getTypeInfo(i.type));const g=this.evalExpression(i.args[0],m);return g.typeInfo=this.getTypeInfo(i.type),g.getSubData(this,i.postfix,m).clone()}_callConstructorVec(i,m){const g=this.getTypeInfo(i.type),_=i.type.getTypeName(),b=ln[_];if(void 0===b)return console.error(`Invalid vec constructor ${_}. Line ${i.line}`),null;const y=[];if(i instanceof ge)if(i.isVector){const m=i.vectorValue;for(const i of m)y.push(i)}else y.push(i.scalarValue);else if(i.args)for(const g of i.args){const i=this.evalExpression(g,m);if(i instanceof Fe){const m=i.data;for(let i=0;i<m.length;++i){let g=m[i];y.push(g)}}else if(i instanceof Oe){let m=i.value;y.push(m)}}if(i.type instanceof oe&&null===i.type.format&&(i.type.format=oe.f32),0===y.length){const _=new Array(b).fill(0);return new Fe(_,g).getSubData(this,i.postfix,m)}if(1===y.length)for(;y.length<b;)y.push(y[0]);return y.length<b?(console.error(`Invalid vec constructor. Line ${i.line}`),null):new Fe(y.length>b?y.slice(0,b):y,g).getSubData(this,i.postfix,m)}_callConstructorMatrix(i,m){const g=this.getTypeInfo(i.type),_=i.type.getTypeName(),b=cn[_];if(void 0===b)return console.error(`Invalid matrix constructor ${_}. Line ${i.line}`),null;const y=[];if(i instanceof ge)if(i.isVector){const m=i.vectorValue;for(const i of m)y.push(i)}else y.push(i.scalarValue);else if(i.args)for(const g of i.args){const i=this.evalExpression(g,m);i instanceof Fe?y.push(...i.data):i instanceof Oe?y.push(i.value):i instanceof Me&&y.push(...i.data)}if(g instanceof a&&null===g.format&&(g.format=this.getTypeInfo("f32")),0===y.length){const _=new Array(b[2]).fill(0);return new Me(_,g).getSubData(this,i.postfix,m)}return y.length!==b[2]?(console.error(`Invalid matrix constructor. Line ${i.line}`),null):new Me(y,g).getSubData(this,i.postfix,m)}}pt._breakObj=new De(new e("BREAK",null),null),pt._continueObj=new De(new e("CONTINUE",null),null),pt._priority=new Map([["f32",0],["f16",1],["u32",2],["i32",3],["x32",3]]);class dt{constructor(){this.constants=new Map,this.aliases=new Map,this.structs=new Map}}class mt{constructor(){this._tokens=[],this._current=0,this._currentLine=1,this._deferArrayCountEval=[],this._currentLoop=[],this._context=new dt,this._exec=new pt,this._forwardTypeCount=0}parse(i){this._initialize(i),this._deferArrayCountEval.length=0;const m=[];for(;!this._isAtEnd();){const i=this._global_decl_or_directive();if(!i)break;m.push(i)}if(this._deferArrayCountEval.length>0){for(const m of this._deferArrayCountEval){const g=m.arrayType,_=m.countNode;if(_ instanceof me){const m=_.name,b=this._context.constants.get(m);if(b)try{const i=b.constEvaluate(this._exec);g.count=i}catch(i){}}}this._deferArrayCountEval.length=0}if(this._forwardTypeCount>0)for(const i of m)i.search(i=>{i instanceof Le||i instanceof le?i.type=this._forwardType(i.type):i instanceof ce?i.format=this._forwardType(i.format):i instanceof B||i instanceof M||i instanceof U?i.type=this._forwardType(i.type):i instanceof C?i.returnType=this._forwardType(i.returnType):i instanceof Ee&&(i.type=this._forwardType(i.type))});return m}_forwardType(i){if(i instanceof ae){const m=this._getType(i.name);if(m)return m}else i instanceof le?i.type=this._forwardType(i.type):i instanceof ce&&(i.format=this._forwardType(i.format));return i}_initialize(i){if(i)if("string"==typeof i){const m=new ze(i);this._tokens=m.scanTokens()}else this._tokens=i;else this._tokens=[];this._current=0}_updateNode(i,m){return i.line=null!=m?m:this._currentLine,i}_error(i,m){return{token:i,message:m,toString:()=>`${m}`}}_isAtEnd(){return this._current>=this._tokens.length||this._peek().type==qe.eof}_match(i){if(i instanceof We)return!!this._check(i)&&(this._advance(),!0);for(let m=0,g=i.length;m<g;++m){const g=i[m];if(this._check(g))return this._advance(),!0}return!1}_consume(i,m){if(this._check(i))return this._advance();throw this._error(this._peek(),`${m}. Line:${this._currentLine}`)}_check(i){if(this._isAtEnd())return!1;const m=this._peek();if(i instanceof Array){const g=m.type;let _=!1;for(const m of i){if(g===m)return!0;m===qe.tokens.name&&(_=!0)}if(_){const i=qe.tokens.name.rule.exec(m.lexeme);if(i&&0==i.index&&i[0]==m.lexeme)return!0}return!1}if(m.type===i)return!0;if(i===qe.tokens.name){const i=qe.tokens.name.rule.exec(m.lexeme);return i&&0==i.index&&i[0]==m.lexeme}return!1}_advance(){var i,m;return this._currentLine=null!==(m=null===(i=this._peek())||void 0===i?void 0:i.line)&&void 0!==m?m:-1,this._isAtEnd()||this._current++,this._previous()}_peek(){return this._tokens[this._current]}_previous(){return this._tokens[this._current-1]}_global_decl_or_directive(){for(;this._match(qe.tokens.semicolon)&&!this._isAtEnd(););if(this._match(qe.keywords.alias)){const i=this._type_alias();return this._consume(qe.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([i]),i}if(this._match(qe.keywords.diagnostic)){const i=this._diagnostic();return this._consume(qe.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([i]),i}if(this._match(qe.keywords.requires)){const i=this._requires_directive();return this._consume(qe.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([i]),i}if(this._match(qe.keywords.enable)){const i=this._enable_directive();return this._consume(qe.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([i]),i}const i=this._attribute();if(this._check(qe.keywords.var)){const m=this._global_variable_decl();return null!=m&&(m.attributes=i),this._consume(qe.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([m]),m}if(this._check(qe.keywords.override)){const m=this._override_variable_decl();return null!=m&&(m.attributes=i),this._consume(qe.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([m]),m}if(this._check(qe.keywords.let)){const m=this._global_let_decl();return null!=m&&(m.attributes=i),this._consume(qe.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([m]),m}if(this._check(qe.keywords.const)){const m=this._global_const_decl();return null!=m&&(m.attributes=i),this._consume(qe.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([m]),m}if(this._check(qe.keywords.struct)){const m=this._struct_decl();return null!=m&&(m.attributes=i),this._exec.reflection.updateAST([m]),m}if(this._check(qe.keywords.fn)){const m=this._function_decl();return null!=m&&(m.attributes=i),this._exec.reflection.updateAST([m]),m}return null}_function_decl(){if(!this._match(qe.keywords.fn))return null;const i=this._currentLine,m=this._consume(qe.tokens.ident,"Expected function name.").toString();this._consume(qe.tokens.paren_left,"Expected '(' for function arguments.");const g=[];if(!this._check(qe.tokens.paren_right))do{if(this._check(qe.tokens.paren_right))break;const i=this._attribute(),m=this._consume(qe.tokens.name,"Expected argument name.").toString();this._consume(qe.tokens.colon,"Expected ':' for argument type.");const _=this._attribute(),b=this._type_decl();null!=b&&(b.attributes=_,g.push(this._updateNode(new Ee(m,b,i))))}while(this._match(qe.tokens.comma));this._consume(qe.tokens.paren_right,"Expected ')' after function arguments.");let _=null;if(this._match(qe.tokens.arrow)){const i=this._attribute();_=this._type_decl(),null!=_&&(_.attributes=i)}const b=this._compound_statement(),y=this._currentLine;return this._updateNode(new C(m,g,_,b,i,y),i)}_compound_statement(){const i=[];for(this._consume(qe.tokens.brace_left,"Expected '{' for block.");!this._check(qe.tokens.brace_right);){const m=this._statement();null!==m&&i.push(m)}return this._consume(qe.tokens.brace_right,"Expected '}' for block."),i}_statement(){for(;this._match(qe.tokens.semicolon)&&!this._isAtEnd(););if(this._check(qe.tokens.attr)&&this._attribute(),this._check(qe.keywords.if))return this._if_statement();if(this._check(qe.keywords.switch))return this._switch_statement();if(this._check(qe.keywords.loop))return this._loop_statement();if(this._check(qe.keywords.for))return this._for_statement();if(this._check(qe.keywords.while))return this._while_statement();if(this._check(qe.keywords.continuing))return this._continuing_statement();if(this._check(qe.keywords.static_assert))return this._static_assert_statement();if(this._check(qe.tokens.brace_left))return this._compound_statement();let i=null;if(this._check(qe.keywords.return))i=this._return_statement();else if(this._check([qe.keywords.var,qe.keywords.let,qe.keywords.const]))i=this._variable_statement();else if(this._match(qe.keywords.discard))i=this._updateNode(new te);else if(this._match(qe.keywords.break)){const m=this._updateNode(new ne);if(this._currentLoop.length>0){const i=this._currentLoop[this._currentLoop.length-1];m.loopId=i.id}i=m,this._check(qe.keywords.if)&&(this._advance(),m.condition=this._optional_paren_expression())}else if(this._match(qe.keywords.continue)){const m=this._updateNode(new se);if(!(this._currentLoop.length>0))throw this._error(this._peek(),`Continue statement must be inside a loop. Line:${m.line}`);{const i=this._currentLoop[this._currentLoop.length-1];m.loopId=i.id}i=m}else i=this._increment_decrement_statement()||this._func_call_statement()||this._assignment_statement();return null!=i&&this._consume(qe.tokens.semicolon,"Expected ';' after statement."),i}_static_assert_statement(){if(!this._match(qe.keywords.static_assert))return null;const i=this._currentLine,m=this._optional_paren_expression();return this._updateNode(new D(m),i)}_while_statement(){if(!this._match(qe.keywords.while))return null;const i=this._updateNode(new N(null,null));return this._currentLoop.push(i),i.condition=this._optional_paren_expression(),this._check(qe.tokens.attr)&&this._attribute(),i.body=this._compound_statement(),this._currentLoop.pop(),i}_continuing_statement(){const i=this._currentLoop.length>0?this._currentLoop[this._currentLoop.length-1].id:-1;if(!this._match(qe.keywords.continuing))return null;const m=this._currentLine,g=this._compound_statement();return this._updateNode(new V(g,i),m)}_for_statement(){if(!this._match(qe.keywords.for))return null;this._consume(qe.tokens.paren_left,"Expected '('.");const i=this._updateNode(new O(null,null,null,null));return this._currentLoop.push(i),i.init=this._check(qe.tokens.semicolon)?null:this._for_init(),this._consume(qe.tokens.semicolon,"Expected ';'."),i.condition=this._check(qe.tokens.semicolon)?null:this._short_circuit_or_expression(),this._consume(qe.tokens.semicolon,"Expected ';'."),i.increment=this._check(qe.tokens.paren_right)?null:this._for_increment(),this._consume(qe.tokens.paren_right,"Expected ')'."),this._check(qe.tokens.attr)&&this._attribute(),i.body=this._compound_statement(),this._currentLoop.pop(),i}_for_init(){return this._variable_statement()||this._func_call_statement()||this._assignment_statement()}_for_increment(){return this._func_call_statement()||this._increment_decrement_statement()||this._assignment_statement()}_variable_statement(){if(this._check(qe.keywords.var)){const i=this._variable_decl();if(null===i)throw this._error(this._peek(),"Variable declaration expected.");let m=null;return this._match(qe.tokens.equal)&&(m=this._short_circuit_or_expression()),this._updateNode(new B(i.name,i.type,i.storage,i.access,m),i.line)}if(this._match(qe.keywords.let)){const i=this._currentLine,m=this._consume(qe.tokens.name,"Expected name for let.").toString();let g=null;if(this._match(qe.tokens.colon)){const i=this._attribute();g=this._type_decl(),null!=g&&(g.attributes=i)}this._consume(qe.tokens.equal,"Expected '=' for let.");const _=this._short_circuit_or_expression();return this._updateNode(new M(m,g,null,null,_),i)}if(this._match(qe.keywords.const)){const i=this._currentLine,m=this._consume(qe.tokens.name,"Expected name for const.").toString();let g=null;if(this._match(qe.tokens.colon)){const i=this._attribute();g=this._type_decl(),null!=g&&(g.attributes=i)}this._consume(qe.tokens.equal,"Expected '=' for const.");const _=this._short_circuit_or_expression();return null===g&&_ instanceof ge&&(g=_.type),this._updateNode(new U(m,g,null,null,_),i)}return null}_increment_decrement_statement(){const i=this._current,m=this._unary_expression();if(null==m)return null;if(!this._check(qe.increment_operators))return this._current=i,null;const g=this._consume(qe.increment_operators,"Expected increment operator");return this._updateNode(new z(g.type===qe.tokens.plus_plus?Xt.increment:Xt.decrement,m))}_assignment_statement(){let i=null;const m=this._currentLine;if(this._check(qe.tokens.brace_right))return null;let g=this._match(qe.tokens.underscore);if(g||(i=this._unary_expression()),!g&&null==i)return null;const _=this._consume(qe.assignment_operators,"Expected assignment operator."),b=this._short_circuit_or_expression();return this._updateNode(new R(qt.parse(_.lexeme),i,b),m)}_func_call_statement(){if(!this._check(qe.tokens.ident))return null;const i=this._currentLine,m=this._current,g=this._consume(qe.tokens.ident,"Expected function name."),_=this._argument_expression_list();return null===_?(this._current=m,null):this._updateNode(new G(g.lexeme,_),i)}_loop_statement(){if(!this._match(qe.keywords.loop))return null;this._check(qe.tokens.attr)&&this._attribute(),this._consume(qe.tokens.brace_left,"Expected '{' for loop.");const i=this._updateNode(new X([],null));this._currentLoop.push(i);let m=this._statement();for(;null!==m;){if(Array.isArray(m))for(let g of m)i.body.push(g);else i.body.push(m);if(m instanceof V){i.continuing=m;break}m=this._statement()}return this._currentLoop.pop(),this._consume(qe.tokens.brace_right,"Expected '}' for loop."),i}_switch_statement(){if(!this._match(qe.keywords.switch))return null;const i=this._updateNode(new j(null,[]));if(this._currentLoop.push(i),i.condition=this._optional_paren_expression(),this._check(qe.tokens.attr)&&this._attribute(),this._consume(qe.tokens.brace_left,"Expected '{' for switch."),i.cases=this._switch_body(),null==i.cases||0==i.cases.length)throw this._error(this._previous(),"Expected 'case' or 'default'.");return this._consume(qe.tokens.brace_right,"Expected '}' for switch."),this._currentLoop.pop(),i}_switch_body(){const i=[];let m=!1;for(;this._check([qe.keywords.default,qe.keywords.case]);){if(this._match(qe.keywords.case)){const g=this._case_selectors();for(const i of g)if(i instanceof Te){if(m)throw this._error(this._previous(),"Multiple default cases in switch statement.");m=!0;break}this._match(qe.tokens.colon),this._check(qe.tokens.attr)&&this._attribute(),this._consume(qe.tokens.brace_left,"Exected '{' for switch case.");const _=this._case_body();this._consume(qe.tokens.brace_right,"Exected '}' for switch case."),i.push(this._updateNode(new Se(g,_)))}if(this._match(qe.keywords.default)){if(m)throw this._error(this._previous(),"Multiple default cases in switch statement.");this._match(qe.tokens.colon),this._check(qe.tokens.attr)&&this._attribute(),this._consume(qe.tokens.brace_left,"Exected '{' for switch default.");const g=this._case_body();this._consume(qe.tokens.brace_right,"Exected '}' for switch default."),i.push(this._updateNode(new Ae(g)))}}return i}_case_selectors(){const i=[];for(this._match(qe.keywords.default)?i.push(this._updateNode(new Te)):i.push(this._shift_expression());this._match(qe.tokens.comma);)this._match(qe.keywords.default)?i.push(this._updateNode(new Te)):i.push(this._shift_expression());return i}_case_body(){if(this._match(qe.keywords.fallthrough))return this._consume(qe.tokens.semicolon,"Expected ';'"),[];let i=this._statement();if(null==i)return[];i instanceof Array||(i=[i]);const m=this._case_body();return 0==m.length?i:[...i,m[0]]}_if_statement(){if(!this._match(qe.keywords.if))return null;const i=this._currentLine,m=this._optional_paren_expression();this._check(qe.tokens.attr)&&this._attribute();const g=this._compound_statement();let _=[];this._match_elseif()&&(this._check(qe.tokens.attr)&&this._attribute(),_=this._elseif_statement(_));let b=null;return this._match(qe.keywords.else)&&(this._check(qe.tokens.attr)&&this._attribute(),b=this._compound_statement()),this._updateNode(new Z(m,g,_,b),i)}_match_elseif(){return this._tokens[this._current].type===qe.keywords.else&&this._tokens[this._current+1].type===qe.keywords.if&&(this._advance(),this._advance(),!0)}_elseif_statement(i=[]){const m=this._optional_paren_expression(),g=this._compound_statement();return i.push(this._updateNode(new $e(m,g))),this._match_elseif()&&(this._check(qe.tokens.attr)&&this._attribute(),this._elseif_statement(i)),i}_return_statement(){if(!this._match(qe.keywords.return))return null;const i=this._short_circuit_or_expression();return this._updateNode(new Q(i))}_short_circuit_or_expression(){let i=this._short_circuit_and_expr();for(;this._match(qe.tokens.or_or);)i=this._updateNode(new ke(this._previous().toString(),i,this._short_circuit_and_expr()));return i}_short_circuit_and_expr(){let i=this._inclusive_or_expression();for(;this._match(qe.tokens.and_and);)i=this._updateNode(new ke(this._previous().toString(),i,this._inclusive_or_expression()));return i}_inclusive_or_expression(){let i=this._exclusive_or_expression();for(;this._match(qe.tokens.or);)i=this._updateNode(new ke(this._previous().toString(),i,this._exclusive_or_expression()));return i}_exclusive_or_expression(){let i=this._and_expression();for(;this._match(qe.tokens.xor);)i=this._updateNode(new ke(this._previous().toString(),i,this._and_expression()));return i}_and_expression(){let i=this._equality_expression();for(;this._match(qe.tokens.and);)i=this._updateNode(new ke(this._previous().toString(),i,this._equality_expression()));return i}_equality_expression(){const i=this._relational_expression();return this._match([qe.tokens.equal_equal,qe.tokens.not_equal])?this._updateNode(new ke(this._previous().toString(),i,this._relational_expression())):i}_relational_expression(){let i=this._shift_expression();for(;this._match([qe.tokens.less_than,qe.tokens.greater_than,qe.tokens.less_than_equal,qe.tokens.greater_than_equal]);)i=this._updateNode(new ke(this._previous().toString(),i,this._shift_expression()));return i}_shift_expression(){let i=this._additive_expression();for(;this._match([qe.tokens.shift_left,qe.tokens.shift_right]);)i=this._updateNode(new ke(this._previous().toString(),i,this._additive_expression()));return i}_additive_expression(){let i=this._multiplicative_expression();for(;this._match([qe.tokens.plus,qe.tokens.minus]);)i=this._updateNode(new ke(this._previous().toString(),i,this._multiplicative_expression()));return i}_multiplicative_expression(){let i=this._unary_expression();for(;this._match([qe.tokens.star,qe.tokens.forward_slash,qe.tokens.modulo]);)i=this._updateNode(new ke(this._previous().toString(),i,this._unary_expression()));return i}_unary_expression(){return this._match([qe.tokens.minus,qe.tokens.bang,qe.tokens.tilde,qe.tokens.star,qe.tokens.and])?this._updateNode(new we(this._previous().toString(),this._unary_expression())):this._singular_expression()}_singular_expression(){const i=this._primary_expression(),m=this._postfix_expression();return m&&(i.postfix=m),i}_postfix_expression(){if(this._match(qe.tokens.bracket_left)){const i=this._short_circuit_or_expression();this._consume(qe.tokens.bracket_right,"Expected ']'.");const m=this._updateNode(new be(i)),g=this._postfix_expression();return g&&(m.postfix=g),m}if(this._match(qe.tokens.period)){const i=this._consume(qe.tokens.name,"Expected member name."),m=this._postfix_expression(),g=this._updateNode(new fe(i.lexeme));return m&&(g.postfix=m),g}return null}_getStruct(i){return this._context.aliases.has(i)?this._context.aliases.get(i).type:this._context.structs.has(i)?this._context.structs.get(i):null}_getType(i){const m=this._getStruct(i);if(null!==m)return m;switch(i){case"void":return re.void;case"bool":return re.bool;case"i32":return re.i32;case"u32":return re.u32;case"f32":return re.f32;case"f16":return re.f16;case"vec2f":return oe.vec2f;case"vec3f":return oe.vec3f;case"vec4f":return oe.vec4f;case"vec2i":return oe.vec2i;case"vec3i":return oe.vec3i;case"vec4i":return oe.vec4i;case"vec2u":return oe.vec2u;case"vec3u":return oe.vec3u;case"vec4u":return oe.vec4u;case"vec2h":return oe.vec2h;case"vec3h":return oe.vec3h;case"vec4h":return oe.vec4h;case"mat2x2f":return oe.mat2x2f;case"mat2x3f":return oe.mat2x3f;case"mat2x4f":return oe.mat2x4f;case"mat3x2f":return oe.mat3x2f;case"mat3x3f":return oe.mat3x3f;case"mat3x4f":return oe.mat3x4f;case"mat4x2f":return oe.mat4x2f;case"mat4x3f":return oe.mat4x3f;case"mat4x4f":return oe.mat4x4f;case"mat2x2h":return oe.mat2x2h;case"mat2x3h":return oe.mat2x3h;case"mat2x4h":return oe.mat2x4h;case"mat3x2h":return oe.mat3x2h;case"mat3x3h":return oe.mat3x3h;case"mat3x4h":return oe.mat3x4h;case"mat4x2h":return oe.mat4x2h;case"mat4x3h":return oe.mat4x3h;case"mat4x4h":return oe.mat4x4h;case"mat2x2i":return oe.mat2x2i;case"mat2x3i":return oe.mat2x3i;case"mat2x4i":return oe.mat2x4i;case"mat3x2i":return oe.mat3x2i;case"mat3x3i":return oe.mat3x3i;case"mat3x4i":return oe.mat3x4i;case"mat4x2i":return oe.mat4x2i;case"mat4x3i":return oe.mat4x3i;case"mat4x4i":return oe.mat4x4i;case"mat2x2u":return oe.mat2x2u;case"mat2x3u":return oe.mat2x3u;case"mat2x4u":return oe.mat2x4u;case"mat3x2u":return oe.mat3x2u;case"mat3x3u":return oe.mat3x3u;case"mat3x4u":return oe.mat3x4u;case"mat4x2u":return oe.mat4x2u;case"mat4x3u":return oe.mat4x3u;case"mat4x4u":return oe.mat4x4u}return null}_validateTypeRange(i,m){if("i32"===m.name){if(i<-2147483648||i>2147483647)throw this._error(this._previous(),`Value out of range for i32:${i}. Line:${this._currentLine}.`)}else if("u32"===m.name&&(i<0||i>4294967295))throw this._error(this._previous(),`Value out of range for u32:${i}. Line:${this._currentLine}.`)}_primary_expression(){if(this._match(qe.tokens.ident)){const i=this._previous().toString();if(this._check(qe.tokens.paren_left)){const m=this._argument_expression_list(),g=this._getType(i);return null!==g?this._updateNode(new pe(g,m)):this._updateNode(new de(i,m))}if(this._context.constants.has(i)){const m=this._context.constants.get(i);return this._updateNode(new _e(i,m.value))}return this._updateNode(new me(i))}if(this._match(qe.tokens.int_literal)){const i=this._previous().toString();let m=i.endsWith("i")||i.endsWith("i")?re.i32:i.endsWith("u")||i.endsWith("U")?re.u32:re.x32;const g=parseInt(i);return this._validateTypeRange(g,m),this._updateNode(new ge(new Oe(g,this._exec.getTypeInfo(m)),m))}if(this._match(qe.tokens.uint_literal)){const i=parseInt(this._previous().toString());return this._validateTypeRange(i,re.u32),this._updateNode(new ge(new Oe(i,this._exec.getTypeInfo(re.u32)),re.u32))}if(this._match([qe.tokens.decimal_float_literal,qe.tokens.hex_float_literal])){let i=this._previous().toString(),m=i.endsWith("h");m&&(i=i.substring(0,i.length-1));const g=parseFloat(i);this._validateTypeRange(g,m?re.f16:re.f32);const _=m?re.f16:re.f32;return this._updateNode(new ge(new Oe(g,this._exec.getTypeInfo(_)),_))}if(this._match([qe.keywords.true,qe.keywords.false])){let i=this._previous().toString()===qe.keywords.true.rule;return this._updateNode(new ge(new Oe(i?1:0,this._exec.getTypeInfo(re.bool)),re.bool))}if(this._check(qe.tokens.paren_left))return this._paren_expression();if(this._match(qe.keywords.bitcast)){this._consume(qe.tokens.less_than,"Expected '<'.");const i=this._type_decl();this._consume(qe.tokens.greater_than,"Expected '>'.");const m=this._paren_expression();return this._updateNode(new xe(i,m))}const i=this._type_decl(),m=this._argument_expression_list();return this._updateNode(new pe(i,m))}_argument_expression_list(){if(!this._match(qe.tokens.paren_left))return null;const i=[];do{if(this._check(qe.tokens.paren_right))break;const m=this._short_circuit_or_expression();i.push(m)}while(this._match(qe.tokens.comma));return this._consume(qe.tokens.paren_right,"Expected ')' for agument list"),i}_optional_paren_expression(){this._match(qe.tokens.paren_left);const i=this._short_circuit_or_expression();return this._match(qe.tokens.paren_right),i}_paren_expression(){this._consume(qe.tokens.paren_left,"Expected '('.");const i=this._short_circuit_or_expression();return this._consume(qe.tokens.paren_right,"Expected ')'."),i}_struct_decl(){if(!this._match(qe.keywords.struct))return null;const i=this._currentLine,m=this._consume(qe.tokens.ident,"Expected name for struct.").toString();this._consume(qe.tokens.brace_left,"Expected '{' for struct body.");const g=[];for(;!this._check(qe.tokens.brace_right);){const i=this._attribute(),m=this._consume(qe.tokens.name,"Expected variable name.").toString();this._consume(qe.tokens.colon,"Expected ':' for struct member type.");const _=this._attribute(),b=this._type_decl();null!=b&&(b.attributes=_),this._check(qe.tokens.brace_right)?this._match(qe.tokens.comma):this._consume(qe.tokens.comma,"Expected ',' for struct member."),g.push(this._updateNode(new Le(m,b,i)))}this._consume(qe.tokens.brace_right,"Expected '}' after struct body.");const _=this._currentLine,b=this._updateNode(new ie(m,g,i,_),i);return this._context.structs.set(m,b),b}_global_variable_decl(){const i=this._variable_decl();if(!i)return null;if(this._match(qe.tokens.equal)){const m=this._const_expression();i.value=m}if(null!==i.type&&i.value instanceof ge){if("x32"!==i.value.type.name&&i.type.getTypeName()!==i.value.type.getTypeName())throw this._error(this._peek(),`Invalid cast from ${i.value.type.name} to ${i.type.name}. Line:${this._currentLine}`);i.value.isScalar&&this._validateTypeRange(i.value.scalarValue,i.type),i.value.type=i.type}else null===i.type&&i.value instanceof ge&&(i.type="x32"===i.value.type.name?re.i32:i.value.type,i.value.isScalar&&this._validateTypeRange(i.value.scalarValue,i.type));return i}_override_variable_decl(){const i=this._override_decl();return i&&this._match(qe.tokens.equal)&&(i.value=this._const_expression()),i}_global_const_decl(){var i;if(!this._match(qe.keywords.const))return null;const m=this._consume(qe.tokens.name,"Expected variable name"),g=this._currentLine;let _=null;if(this._match(qe.tokens.colon)){const i=this._attribute();_=this._type_decl(),null!=_&&(_.attributes=i)}let b=null;this._consume(qe.tokens.equal,"const declarations require an assignment");const y=this._short_circuit_or_expression();try{let i=[re.f32],g=y.constEvaluate(this._exec,i);g instanceof Oe&&this._validateTypeRange(g.value,i[0]),i[0]instanceof oe&&null===i[0].format&&g.typeInfo instanceof a&&null!==g.typeInfo.format&&("f16"===g.typeInfo.format.name?i[0].format=re.f16:"f32"===g.typeInfo.format.name?i[0].format=re.f32:"i32"===g.typeInfo.format.name?i[0].format=re.i32:"u32"===g.typeInfo.format.name?i[0].format=re.u32:"bool"===g.typeInfo.format.name?i[0].format=re.bool:console.error(`TODO:impelement template format type ${g.typeInfo.format.name}`)),b=this._updateNode(new ge(g,i[0])),this._exec.context.setVariable(m.toString(),g)}catch(i){b=y}if(null!==_&&b instanceof ge){if("x32"!==b.type.name&&_.getTypeName()!==b.type.getTypeName())throw this._error(this._peek(),`Invalid cast from ${b.type.name} to ${_.name}. Line:${this._currentLine}`);b.type=_,b.isScalar&&this._validateTypeRange(b.scalarValue,b.type)}else null===_&&b instanceof ge&&(_=null!==(i=null==b?void 0:b.type)&&void 0!==i?i:re.f32,_===re.x32&&(_=re.i32));const T=this._updateNode(new U(m.toString(),_,"","",b),g);return this._context.constants.set(T.name,T),T}_global_let_decl(){if(!this._match(qe.keywords.let))return null;const i=this._currentLine,m=this._consume(qe.tokens.name,"Expected variable name");let g=null;if(this._match(qe.tokens.colon)){const i=this._attribute();g=this._type_decl(),null!=g&&(g.attributes=i)}let _=null;if(this._match(qe.tokens.equal)&&(_=this._const_expression()),null!==g&&_ instanceof ge){if("x32"!==_.type.name&&g.getTypeName()!==_.type.getTypeName())throw this._error(this._peek(),`Invalid cast from ${_.type.name} to ${g.name}. Line:${this._currentLine}`);_.type=g}else null===g&&_ instanceof ge&&(g="x32"===_.type.name?re.i32:_.type);return _ instanceof ge&&_.isScalar&&this._validateTypeRange(_.scalarValue,g),this._updateNode(new M(m.toString(),g,"","",_),i)}_const_expression(){return this._short_circuit_or_expression()}_variable_decl(){if(!this._match(qe.keywords.var))return null;const i=this._currentLine;let m="",g="";this._match(qe.tokens.less_than)&&(m=this._consume(qe.storage_class,"Expected storage_class.").toString(),this._match(qe.tokens.comma)&&(g=this._consume(qe.access_mode,"Expected access_mode.").toString()),this._consume(qe.tokens.greater_than,"Expected '>'."));const _=this._consume(qe.tokens.name,"Expected variable name");let b=null;if(this._match(qe.tokens.colon)){const i=this._attribute();b=this._type_decl(),null!=b&&(b.attributes=i)}return this._updateNode(new B(_.toString(),b,m,g,null),i)}_override_decl(){if(!this._match(qe.keywords.override))return null;const i=this._consume(qe.tokens.name,"Expected variable name");let m=null;if(this._match(qe.tokens.colon)){const i=this._attribute();m=this._type_decl(),null!=m&&(m.attributes=i)}return this._updateNode(new F(i.toString(),m,null))}_diagnostic(){this._consume(qe.tokens.paren_left,"Expected '('");const i=this._consume(qe.tokens.ident,"Expected severity control name.");this._consume(qe.tokens.comma,"Expected ','");let m=this._consume(qe.tokens.ident,"Expected diagnostic rule name.").toString();return this._match(qe.tokens.period)&&(m+=`.${this._consume(qe.tokens.ident,"Expected diagnostic message.").toString()}`),this._consume(qe.tokens.paren_right,"Expected ')'"),this._updateNode(new J(i.toString(),m))}_enable_directive(){const i=this._consume(qe.tokens.ident,"identity expected.");return this._updateNode(new Y(i.toString()))}_requires_directive(){const i=[this._consume(qe.tokens.ident,"identity expected.").toString()];for(;this._match(qe.tokens.comma);){const m=this._consume(qe.tokens.ident,"identity expected.");i.push(m.toString())}return this._updateNode(new K(i))}_type_alias(){const i=this._consume(qe.tokens.ident,"identity expected.");this._consume(qe.tokens.equal,"Expected '=' for type alias.");let m=this._type_decl();if(null===m)throw this._error(this._peek(),"Expected Type for Alias.");this._context.aliases.has(m.name)&&(m=this._context.aliases.get(m.name).type);const g=this._updateNode(new ee(i.toString(),m));return this._context.aliases.set(g.name,g),g}_type_decl(){if(this._check([qe.tokens.ident,...qe.texel_format,qe.keywords.bool,qe.keywords.f32,qe.keywords.i32,qe.keywords.u32])){const i=this._advance().toString();if(this._context.structs.has(i))return this._context.structs.get(i);if(this._context.aliases.has(i))return this._context.aliases.get(i).type;if(!this._getType(i)){const m=this._updateNode(new ae(i));return this._forwardTypeCount++,m}return this._updateNode(new re(i))}let i=this._texture_sampler_types();if(i)return i;if(this._check(qe.template_types)){let i=this._advance().toString(),m=null,g=null;return this._match(qe.tokens.less_than)&&(m=this._type_decl(),g=null,this._match(qe.tokens.comma)&&(g=this._consume(qe.access_mode,"Expected access_mode for pointer").toString()),this._consume(qe.tokens.greater_than,"Expected '>' for type.")),this._updateNode(new oe(i,m,g))}if(this._match(qe.keywords.ptr)){let i=this._previous().toString();this._consume(qe.tokens.less_than,"Expected '<' for pointer.");const m=this._consume(qe.storage_class,"Expected storage_class for pointer");this._consume(qe.tokens.comma,"Expected ',' for pointer.");const g=this._type_decl();let _=null;return this._match(qe.tokens.comma)&&(_=this._consume(qe.access_mode,"Expected access_mode for pointer").toString()),this._consume(qe.tokens.greater_than,"Expected '>' for pointer."),this._updateNode(new le(i,m.toString(),g,_))}const m=this._attribute();if(this._match(qe.keywords.array)){let g=null,_=-1;const b=this._previous();let y=null;if(this._match(qe.tokens.less_than)){g=this._type_decl(),this._context.aliases.has(g.name)&&(g=this._context.aliases.get(g.name).type);let m="";if(this._match(qe.tokens.comma)){y=this._shift_expression();try{m=y.constEvaluate(this._exec).toString(),y=null}catch(i){m="1"}}this._consume(qe.tokens.greater_than,"Expected '>' for array."),_=m?parseInt(m):0}const T=this._updateNode(new ce(b.toString(),m,g,_));return y&&this._deferArrayCountEval.push({arrayType:T,countNode:y}),T}return null}_texture_sampler_types(){if(this._match(qe.sampler_type))return this._updateNode(new ue(this._previous().toString(),null,null));if(this._match(qe.depth_texture_type))return this._updateNode(new ue(this._previous().toString(),null,null));if(this._match(qe.sampled_texture_type)||this._match(qe.multisampled_texture_type)){const i=this._previous();this._consume(qe.tokens.less_than,"Expected '<' for sampler type.");const m=this._type_decl();return this._consume(qe.tokens.greater_than,"Expected '>' for sampler type."),this._updateNode(new ue(i.toString(),m,null))}if(this._match(qe.storage_texture_type)){const i=this._previous();this._consume(qe.tokens.less_than,"Expected '<' for sampler type.");const m=this._consume(qe.texel_format,"Invalid texel format.").toString();this._consume(qe.tokens.comma,"Expected ',' after texel format.");const g=this._consume(qe.access_mode,"Expected access mode for storage texture type.").toString();return this._consume(qe.tokens.greater_than,"Expected '>' for sampler type."),this._updateNode(new ue(i.toString(),m,g))}return null}_attribute(){let i=[];for(;this._match(qe.tokens.attr);){const m=this._consume(qe.attribute_name,"Expected attribute name"),g=this._updateNode(new Ce(m.toString(),null));if(this._match(qe.tokens.paren_left)){if(g.value=this._consume(qe.literal_or_ident,"Expected attribute value").toString(),this._check(qe.tokens.comma)){this._advance();do{const i=this._consume(qe.literal_or_ident,"Expected attribute value").toString();g.value instanceof Array||(g.value=[g.value]),g.value.push(i)}while(this._match(qe.tokens.comma))}this._consume(qe.tokens.paren_right,"Expected ')'")}i.push(g)}return 0==i.length?null:i}}class _t extends rt{constructor(i){super(),i&&this.update(i)}update(i){const m=(new mt).parse(i);this.updateAST(m)}}function ensureVertexIndexBuiltin(i){if(/@builtin\s*\(\s*vertex_index\s*\)/.test(i))return i;return i.replace(/(@vertex\s+fn\s+)([a-zA-Z_][a-zA-Z0-9_]*)\s*\(([^)]*)(\))/,(i,m,g,_,b)=>{const y=_.trim(),T="@builtin(vertex_index) redgpu_auto_builtin_vertex_index:u32";return`${m}${g}(${0===y.length?T:`${y},${T}`}${b}`})}class WGSLUniformTypes{static get i32(){return{numElements:1,align:4,size:4,type:"i32",wgslType:"i32",View:Int32Array}}static get u32(){return{numElements:1,align:4,size:4,type:"u32",wgslType:"u32",View:Uint32Array}}static get f32(){return{numElements:1,align:4,size:4,type:"f32",wgslType:"f32",View:Float32Array}}static get f16(){return{numElements:1,align:2,size:2,type:"f16",wgslType:"f16",View:Uint16Array}}static get vec2f32(){return{numElements:2,align:8,size:8,type:"f32",wgslType:"vec2<f32>",View:Float32Array}}static get vec2i32(){return{numElements:2,align:8,size:8,type:"i32",wgslType:"vec2<i32>",View:Int32Array}}static get vec2u32(){return{numElements:2,align:8,size:8,type:"u32",wgslType:"vec2<u32>",View:Uint32Array}}static get vec2u16(){return{numElements:2,align:4,size:4,type:"u16",wgslType:"vec2<u16>",View:Uint16Array}}static get vec3i32(){return{numElements:3,align:16,size:12,type:"i32",wgslType:"vec3<i32>",View:Int32Array}}static get vec3u32(){return{numElements:3,align:16,size:12,type:"u32",wgslType:"vec3<u32>",View:Uint32Array}}static get vec3f32(){return{numElements:3,align:16,size:12,type:"f32",wgslType:"vec3<f32>",View:Float32Array}}static get vec3u16(){return{numElements:3,align:8,size:6,type:"u16",wgslType:"vec3<u16>",View:Uint16Array}}static get vec4i32(){return{numElements:4,align:16,size:16,type:"i32",wgslType:"vec4<i32>",View:Int32Array}}static get vec4u32(){return{numElements:4,align:16,size:16,type:"u32",wgslType:"vec4<u32>",View:Uint32Array}}static get vec4f32(){return{numElements:4,align:16,size:16,type:"f32",wgslType:"vec4<f32>",View:Float32Array}}static get vec4u16(){return{numElements:4,align:8,size:8,type:"u16",wgslType:"vec4<u16>",View:Uint16Array}}static get mat2x2f32(){return{numElements:4,align:8,size:16,type:"f32",wgslType:"mat2x2<f32>",View:Float32Array}}static get mat2x2u16(){return{numElements:4,align:4,size:8,type:"u16",wgslType:"mat2x2<u16>",View:Uint16Array}}static get mat3x2f32(){return{numElements:6,align:8,size:24,type:"f32",wgslType:"mat3x2<f32>",View:Float32Array}}static get mat3x2u16(){return{numElements:6,align:4,size:12,type:"u16",wgslType:"mat3x2<u16>",View:Uint16Array}}static get mat3x3f32(){return{numElements:16,align:16,size:64,type:"f32",wgslType:"mat3x3<f32>",View:Float32Array}}static get mat4x2f32(){return{numElements:8,align:8,size:32,type:"f32",wgslType:"mat4x2<f32>",View:Float32Array}}static get mat4x2u16(){return{numElements:8,align:4,size:16,type:"u16",wgslType:"mat4x2<u16>",View:Uint16Array}}static get mat2x3f32(){return{numElements:8,align:16,size:32,type:"f32",wgslType:"mat2x3<f32>",View:Float32Array}}static get mat2x3u16(){return{numElements:8,align:8,size:16,type:"u16",wgslType:"mat2x3<u16>",View:Uint16Array}}static get mat4x4f32(){return{numElements:16,align:16,size:64,type:"f32",wgslType:"mat4x4<f32>",View:Float32Array}}static get mat4x4u16(){return{numElements:16,align:8,size:32,type:"u16",wgslType:"mat4x4<u16>",View:Uint16Array}}}Object.freeze(WGSLUniformTypes);const processMembers=(i,m=0,g=0)=>{let _=0,b=g;const y=i?.reduce((i,g,y)=>{const{type:T,offset:w,size:P,stride:H,count:$,isArray:W}=g,{format:q}=T,ye="array"===T.name?`${q.name}${q.format?`${q.format.name}`:""}`:`${T.name}${q?`${q.name}`:""}`;if(_=m,b=w+P,i[g.name]=((i,m,g)=>{const _=WGSLUniformTypes[g];return{uniformOffset:i.offset+m,uniformOffsetForData:i.offset,stride:i.stride,isArray:i.isArray,typeInfo:_,View:_?.View}})(g,m,ye),W&&q.members){const m=processMembers(q.members).members;i[g.name].memberList=Array.from({length:$},(i,g)=>{const _={};for(const i in m){const b=_[i]={...m[i]};b.uniformOffset=b.uniformOffset+w+H*g}return _})}else T.members&&(i[g.name]=processMembers(T.members,w+m,b));return i},{});return{members:y,startOffset:_,endOffset:b}},hn=new Map,parseWGSL=i=>{i=ensureVertexIndexBuiltin(i);const{defaultSource:m,shaderSourceVariant:g,conditionalBlocks:_,cacheKey:b}=preprocessWGSL(i),y=hn.get(b);let T;if(y)T=y;else{const i=new _t(m);T={uniforms:{...(P=i.uniforms,P.reduce((i,m)=>(i[m.name]={name:m.name,...processMembers(m.members),arrayBufferByteLength:m.size,stride:m.stride},m.attributes?.forEach(g=>i[m.name][g.name]=+g.value),i),{}))},storage:{...(w=i.storage,w.reduce((i,m)=>(i[m.name]={name:m.name,...processMembers(m.members),arrayBufferByteLength:m.size,stride:m.stride,acccess:m.access,type:m.type},m.attributes?.forEach(g=>i[m.name][g.name]=+g.value),i),{}))},samplers:i.samplers,textures:i.textures,vertexEntries:i.entry.vertex.map(i=>i.name),fragmentEntries:i.entry.fragment.map(i=>i.name),computeEntries:i.entry.compute.map(i=>i.name)},hn.set(b,T)}var w,P;return{...T,defaultSource:m,shaderSourceVariant:g,conditionalBlocks:_}};class PassClusterLightBound{#Rt;#Pt;#Bt;#It;#Et;#l;constructor(i,m){validateRedGPUContext(i),this.#l=i,this.#Rt=m,this.#Dt()}get clusterBoundBuffer(){return this.#Pt}render(){const i=this.#Rt.systemUniform_Vertex_UniformBindGroup;if(i){const{gpuDevice:m}=this.#l,g=m.createCommandEncoder(),_=g.beginComputePass({label:"Bound cluster"}),b=Pt.getDispatchSize();_.setPipeline(this.#Et),_.setBindGroup(0,i),_.setBindGroup(1,this.#It),_.dispatchWorkgroups(b[0],b[1],b[2]),_.end(),m.queue.submit([g.finish()])}}#Dt(){const{gpuDevice:i,resourceManager:m}=this.#l,g=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\n@group(1) @binding(0) var<storage,read_write> clusterLight_Clusters:ClusterLight_Clusters;\nfn lineIntersectionToZPlane(a:vec3<f32>,b:vec3<f32>,zDistance:f32) -> vec3<f32> { let normal=vec3<f32>(0.0,0.0,0.5); let ab=b - a; let t=(zDistance - dot(normal,a))/dot(normal,ab); return a + t * ab;\n}\nfn clipToView(clip:vec4<f32>) -> vec4<f32> { let view=systemUniforms.inverseProjectionMatrix * clip; return view/vec4<f32>(view.w,view.w,view.w,view.w);\n}\nfn screen2View(screen:vec4<f32>) -> vec4<f32> { let texCoord=screen.xy/systemUniforms.resolution.xy; let clip=vec4<f32>(vec2<f32>(texCoord.x,1.0 - texCoord.y) * 2.0 - vec2<f32>(1.0,1.0),screen.z,screen.w ); return clipToView(clip);\n}\nconst eyePos=vec3<f32>(0.0);\n@compute @workgroup_size(REDGPU_DEFINE_WORKGROUP_SIZE_X,REDGPU_DEFINE_WORKGROUP_SIZE_Y,REDGPU_DEFINE_WORKGROUP_SIZE_Z)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>) { let tileIndex=global_id.x + global_id.y * clusterLight_tileCount.x + global_id.z * clusterLight_tileCount.x * clusterLight_tileCount.y; let tileSize=vec2<f32>( systemUniforms.resolution.x/f32(clusterLight_tileCount.x), systemUniforms.resolution.y/f32(clusterLight_tileCount.y) ); let global_id_x_pos_one=vec2<f32>(f32(global_id.x + 1u),f32(global_id.y + 1u)) * tileSize; let global_id_x_y=vec2<f32>(f32(global_id.x),f32(global_id.y)) * tileSize; let maxPoint_sS=vec4<f32>(global_id_x_pos_one,0.0,1.0); let minPoint_sS=vec4<f32>(global_id_x_y,0.0,1.0); let maxPoint_vS=screen2View(maxPoint_sS).xyz; let minPoint_vS=screen2View(minPoint_sS).xyz; let nearFarX=systemUniforms.camera.nearClipping; let nearFarY=systemUniforms.camera.farClipping; let tileZ=f32(global_id.z)/f32(clusterLight_tileCount.z); let tileZ_plus_one=f32(global_id.z + 1u)/f32(clusterLight_tileCount.z); let tileNear=-nearFarX * pow(nearFarY/nearFarX,tileZ); let tileFar=-nearFarX * pow(nearFarY/nearFarX,tileZ_plus_one); let minPointNear=lineIntersectionToZPlane(eyePos,minPoint_vS,tileNear); let minPointFar=lineIntersectionToZPlane(eyePos,minPoint_vS,tileFar); let maxPointNear=lineIntersectionToZPlane(eyePos,maxPoint_vS,tileNear); let maxPointFar=lineIntersectionToZPlane(eyePos,maxPoint_vS,tileFar); let minAABB=min(min(minPointNear,minPointFar),min(maxPointNear,maxPointFar)); let maxAABB=max(max(minPointNear,minPointFar),max(maxPointNear,maxPointFar)); clusterLight_Clusters.cubeList[tileIndex].minAABB=vec4<f32>(minAABB,0.0); clusterLight_Clusters.cubeList[tileIndex].maxAABB=vec4<f32>(maxAABB,0.0);\n}\n").defaultSource;this.#Pt=m.createGPUBuffer("PASS_CLUSTER_BOUND_BUFFER",{size:32*Pt.getTotalTileSize(),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.#Bt=i.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),this.#It=i.createBindGroup({label:"CLUSTER_BOUND_BIND_GROUP",layout:this.#Bt,entries:[{binding:0,resource:{buffer:this.#Pt}}]}),this.#Et=i.createComputePipeline({label:"CLUSTER_BOUND_PIPELINE",layout:i.createPipelineLayout({bindGroupLayouts:[m.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),this.#Bt]}),compute:{module:m.createGPUShaderModule("CLUSTER_BOUND_SHADER",{code:g}),entryPoint:"main"}})}}const fn=new Uint32Array([0,0,0,0]);class PassClustersLight{#Rt;#Lt;#Ut;#At;#l;constructor(i,m){validateRedGPUContext(i),this.#l=i,this.#Rt=m,this.#Dt()}get clusterLightsBuffer(){return this.#At}render(){const{gpuDevice:i}=this.#l,m=this.#Rt.systemUniform_Vertex_UniformBindGroup;if(m){const g=i.createCommandEncoder(),_=g.beginComputePass({label:"ClusterLight cluster"}),b=Pt.getDispatchSize();this.#l.gpuDevice.queue.writeBuffer(this.clusterLightsBuffer,0,fn),_.setPipeline(this.#Ut),_.setBindGroup(0,m),_.setBindGroup(1,this.#Lt),_.dispatchWorkgroups(b[0],b[1],b[2]),_.end(),i.queue.submit([g.finish()])}}#Dt(){const{gpuDevice:i,resourceManager:m}=this.#l,g=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\n@group(1) @binding(0) var<storage> clusterLight_Clusters:ClusterLight_Clusters;\nfn pointLight_testSphereAABB(light:u32,tile:u32) -> bool { let targetLight=clusterLightList.lights[light]; let targetTile=clusterLight_Clusters.cubeList[tile]; let radius:f32=targetLight.radius; let position:vec3<f32>=targetLight.position; let center:vec3<f32>=(systemUniforms.camera.cameraMatrix * vec4<f32>(position,1.0)).xyz; let squaredDistance:f32=pointLight_sqDistPointAABB(center,tile,targetTile.minAABB.xyz,targetTile.maxAABB.xyz); return squaredDistance <=(radius * radius);\n}\nfn pointLight_sqDistPointAABB(targetPoint:vec3<f32>,tile:u32,minAABB:vec3<f32>,maxAABB:vec3<f32>) -> f32 { var sqDist=0.0; for(var i=0u;i < 3u;i=i + 1u) { let v=targetPoint[i]; let _minAABB=minAABB[i]; let _maxAABB=maxAABB[i]; if(v < _minAABB){ sqDist +=(_minAABB - v) * (_minAABB - v); } if(v > _maxAABB){ sqDist +=(v - _maxAABB) * (v - _maxAABB); } } return sqDist;\n}\nfn spotLight_testSphereAABB(light:u32,tile:u32) -> bool { let targetLight=clusterLightList.lights[light]; let targetTile=clusterLight_Clusters.cubeList[tile]; let radius:f32=targetLight.radius; let position:vec3<f32>=targetLight.position; let center:vec3<f32>=(systemUniforms.camera.cameraMatrix * vec4<f32>(position,1.0)).xyz; let squaredDistance:f32=pointLight_sqDistPointAABB(center,tile,targetTile.minAABB.xyz,targetTile.maxAABB.xyz); return squaredDistance <=(radius * radius);\n}\n@compute @workgroup_size(REDGPU_DEFINE_WORKGROUP_SIZE_X,REDGPU_DEFINE_WORKGROUP_SIZE_Y,REDGPU_DEFINE_WORKGROUP_SIZE_Z)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>) { let tileIndex=global_id.x + global_id.y * clusterLight_tileCount.x + global_id.z * clusterLight_tileCount.x * clusterLight_tileCount.y; var clusterLightCount=0u; var clusterLightIndices:array<u32,REDGPU_DEFINE_MAX_LIGHTS_PER_CLUSTERu>; for (var i=0u;i < u32(clusterLightList.count[0]);i=i + 1u) { let lightInCluster=pointLight_testSphereAABB(i,tileIndex); if (lightInCluster) { clusterLightIndices[clusterLightCount]=i; clusterLightCount=clusterLightCount + 1u; } if (clusterLightCount==REDGPU_DEFINE_MAX_LIGHTS_PER_CLUSTERu) { break; } } let spotLightStartIndex=u32(clusterLightList.count[0]); for (var i=0u;i < u32(clusterLightList.count[1]);i=i + 1u) { let actualLightIndex=spotLightStartIndex + i; let sphereTest=spotLight_testSphereAABB(actualLightIndex,tileIndex); if (sphereTest) { clusterLightIndices[clusterLightCount]=actualLightIndex; clusterLightCount=clusterLightCount + 1u; } if (clusterLightCount==REDGPU_DEFINE_MAX_LIGHTS_PER_CLUSTERu) { break; } } var offset=atomicAdd(&clusterLightGroup.offset,clusterLightCount); for(var i=0u;i < clusterLightCount;i=i + 1u) { clusterLightGroup.indices[offset + i]=clusterLightIndices[i]; } clusterLightGroup.lights[tileIndex].offset=offset; clusterLightGroup.lights[tileIndex].count=clusterLightCount;\n}\n").defaultSource;this.#At=m.createGPUBuffer("PASS_CLUSTER_LIGHTS_BUFFER",{size:Pt.getClusterLightsBufferSize(),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});const _=i.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]});this.#Lt=i.createBindGroup({label:"CLUSTER_LIGHT_BIND_GROUP",layout:_,entries:[{binding:0,resource:{buffer:this.#Rt.passLightClustersBound.clusterBoundBuffer}}]}),this.#Ut=i.createComputePipeline({label:"CLUSTER_LIGHT_PIPELINE",layout:i.createPipelineLayout({label:"CLUSTER_LIGHT_PIPELINE_LAYOUT",bindGroupLayouts:[m.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),_]}),compute:{module:m.createGPUShaderModule("CLUSTER_LIGHTS_SHADER",{code:g}),entryPoint:"main"}})}}class ResourceStateUniformBuffer{static dirtyList=[];buffer;uuid;#Ot=0;constructor(i){this.buffer=i,this.uuid=i.uuid}get useNum(){return this.#Ot}set useNum(i){this.#Ot=i,ResourceStateUniformBuffer.dirtyList.push(this)}}const dn=Symbol("gpuBuffer"),mn=Symbol("gpuBufferData"),pn=Symbol("gpuBufferDataViewF32"),gn=Symbol("gpuBufferDataViewU32"),xn=Symbol("gpuBufferCacheKey");class ABaseBuffer extends ManagementResourceBase{[dn];[xn];#kt;constructor(i,m,g){super(i,m),this.#kt=g}get cacheKey(){return this[xn]||this.uuid}get gpuBuffer(){return this[dn]}get usage(){return this.#kt}get size(){return this[mn]?.byteLength||0}get videoMemorySize(){return this.size}destroy(){const i=this[dn];i&&(this[dn]=null,this.__fireListenerList(!0),this.redGPUContext.resourceManager.unregisterManagementResource(this),i&&i.destroy())}}class AUniformBaseBuffer extends ABaseBuffer{[mn];#Gt;#Ft;constructor(i,m,g,_,b=""){super(i,m,g),this.#Ft=_.byteLength,this.#Gt={size:this.#Ft,usage:this.usage,label:b};try{this[dn]=i.gpuDevice.createBuffer(this.#Gt)}catch(i){console.error("GPU 버퍼 생성에 실패했습니다:",i)}i.gpuDevice.queue.writeBuffer(this[dn],0,_),this[mn]=_,this[pn]=new Float32Array(_),this[gn]=new Uint32Array(_)}get data(){return this[mn]}get dataViewF32(){return this[pn]}get dataViewU32(){return this[gn]}get size(){return this.#Ft}get uniformBufferDescriptor(){return this.#Gt}writeOnlyBuffer(i,m){this.redGPUContext.gpuDevice.queue.writeBuffer(this.gpuBuffer,i.uniformOffset,new i.View("number"==typeof m?[m]:m))}}class UniformBuffer extends AUniformBaseBuffer{constructor(i,m,g="",_=""){super(i,"managedUniformBufferState",GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,m,g);const{table:b}=this.targetResourceManagedState,y=b.get(_);if(y)return y.buffer;_&&(this.name=_,this[xn]=_),this.redGPUContext.resourceManager.registerManagementResource(this,new ResourceStateUniformBuffer(this))}}Object.freeze(UniformBuffer);var _n="struct Camera { cameraMatrix:mat4x4<f32>, inverseCameraMatrix:mat4x4<f32>, cameraPosition:vec3<f32>, nearClipping:f32, farClipping:f32, fieldOfView:f32\n};\nstruct SystemUniform { projectionMatrix:mat4x4<f32>, inverseProjectionMatrix:mat4x4<f32>, projectionCameraMatrix:mat4x4<f32>, inverseProjectionCameraMatrix:mat4x4<f32>, camera:Camera,\n};\n@group(1) @binding(1) var<uniform> systemUniforms:SystemUniform;\n";const defineProperty=(i,m,g,_,...b)=>{Object.defineProperty(i.prototype,m,g(m,_,...b))},defineProperties=i=>(m,g)=>{g.forEach(g=>{if(Array.isArray(g)){const[_,b,...y]=g;defineProperty(m,_,i,b,...y)}else defineProperty(m,g,i)})},createDefineByPreset=i=>{const m={};return Object.keys(i).forEach(g=>{const[_,b]=i[g];Object.assign(m,(i=>m=>m.reduce((m,g)=>({...m,[g]:i}),{}))(_)(Object.values(b)))}),{defineByPreset:(i,g)=>((i,m,g)=>{m.forEach(m=>{if(Array.isArray(m)){const[_,b,...y]=m,T=g[_];T||consoleAndThrowError(_,"is a key not defined in Define Preset."),defineProperty(i,_,T,b,...y)}else{const _=g[m];_||consoleAndThrowError(m,"is a key not defined in Define Preset."),defineProperty(i,m,_)}})})(i,g,m)}},vn={enumerable:!0,configurable:!1};function createSetter$5(i,m,g){return function(_){this[m]=_;const{gpuRenderInfo:b}=this;if(g){const{fragmentUniformInfo:m,fragmentUniformBuffer:g}=b;g.writeOnlyBuffer(m.members[i],_?1:0),this.dirtyPipeline=!0}else if(b){const{vertexUniformInfo:m,vertexUniformBuffer:g}=b;m.members[i]&&(g.writeOnlyBuffer(m.members[i],_?1:0),this.dirtyPipeline=!0)}}}function defineBoolean(i,m=!1,g=!0){const _=Symbol(i);return{get:function(){return void 0===this[_]&&(this[_]=m),this[_]},set:createSetter$5(i,_,g),...vn}}function defineColorRGB(i,m="#fff",g=!0){const _=Symbol(i);return{get:function(){if(void 0===this[_]){let b=255,y=255,T=255;if(isHexColor(m)){const i=convertHexToRgb(m);b=i.r,y=i.g,T=i.b}this[_]=new ColorRGB(b,y,T,()=>{const{gpuRenderInfo:m}=this;if(m)if(g){const{fragmentUniformInfo:g,fragmentUniformBuffer:b}=m;b.writeOnlyBuffer(g.members[i],this[_].rgbNormalLinear)}else{const{vertexUniformInfo:g,vertexUniformBuffer:b}=m;b.writeOnlyBuffer(g.members[i],this[_].rgbNormalLinear)}})}return this[_]},...vn}}function defineColorRGBA(i,m="#fff",g=!0){const _=Symbol(i);return{get:function(){if(void 0===this[_]){let b=255,y=255,T=255,w=1;if(isHexColor(m)){const i=convertHexToRgb(m);b=i.r,y=i.g,T=i.b}this[_]=new ColorRGBA(b,y,T,w,()=>{const{gpuRenderInfo:m}=this;if(m)if(g){const{fragmentUniformInfo:g,fragmentUniformBuffer:b}=m;b.writeOnlyBuffer(g.members[i],this[_].rgbaNormalLinear)}else{const{vertexUniformInfo:g,vertexUniformBuffer:b}=m;b.writeOnlyBuffer(g.members[i],this[_].rgbaNormalLinear)}})}return this[_]},...vn}}function createSetter$4(i,m,g){const _=`use${i.charAt(0).toUpperCase()}${i.substring(1)}`;return function(i){const b=this[m];this[m]=i,this.updateTexture(b,i);const{gpuRenderInfo:y}=this;if(g){const{fragmentUniformInfo:m,fragmentUniformBuffer:g}=y;_ in this?this[_]=!!i:m.members[_]&&g.writeOnlyBuffer(m.members[_],i?1:0)}else if(y){const{vertexUniformInfo:m,vertexUniformBuffer:g}=y;m.members[_]&&g.writeOnlyBuffer(g.members[_],i?1:0)}}}function defineCubeTexture(i,m=!0){const g=Symbol(i);return{get:function(){return this[g]},set:createSetter$4(i,g,m),...vn}}function createSetter$3(i,m,g,_=0,b){return function(y){void 0!==_&&y<_&&(console.warn(`Value for ${i} is below the minimum (${_}). Received:${y}. Adjusted to ${_}.`),y=_),void 0!==b&&y>b&&(console.warn(`Value for ${i} exceeds the maximum (${b}). Received:${y}. Adjusted to ${b}.`),y=b),validatePositiveNumberRange(y),this[m]=y;const{gpuRenderInfo:T}=this;if(g){const{fragmentUniformInfo:g,fragmentUniformBuffer:_}=T;_.writeOnlyBuffer(g.members[i],this[m])}else if(T){const{vertexUniformInfo:g,vertexUniformBuffer:_}=T;_.writeOnlyBuffer(g.members[i],this[m])}}}function definePositiveNumberRange(i,m=1,g=!0,_=0,b){const y=Symbol(i);return{get:function(){return void 0===this[y]&&(this[y]=m),this[y]},set:createSetter$3(i,y,g,_,b),...vn}}function defineSampler(i){const m=Symbol(i);return{get:function(){return this[m]},set:function(i){const g=this[m];this[m]=i,this.updateSampler(g,i)},...vn}}function createSetter$2(i,m,g){const _=`use${i.charAt(0).toUpperCase()}${i.substring(1)}`;return function(i){const b=this[m];this[m]=i,this.updateTexture(b,i);const{gpuRenderInfo:y}=this;if(g){const{fragmentUniformInfo:m,fragmentUniformBuffer:g}=y;_ in this?this[_]=!!i:m.members[_]&&g.writeOnlyBuffer(m.members[_],i?1:0)}else if(y){const{vertexUniformInfo:m,vertexUniformBuffer:g}=y;m.members[_]&&g.writeOnlyBuffer(g.members[_],i?1:0)}}}function defineTexture$1(i,m=!0){const g=Symbol(i);return{get:function(){return this[g]},set:createSetter$2(i,g,m),...vn}}function createSetter$1(i,m,g,_=0,b){return function(y){validateUintRange(y),void 0!==_&&y<_&&(console.warn(`Value for ${i} is below the minimum (${_}). Received:${y}. Adjusted to ${_}.`),y=_),void 0!==b&&y>b&&(console.warn(`Value for ${i} exceeds the maximum (${b}). Received:${y}. Adjusted to ${b}.`),y=b),this[m]=y;const{gpuRenderInfo:T}=this;if(g){const{fragmentUniformInfo:g,fragmentUniformBuffer:_}=T;_.writeOnlyBuffer(g.members[i],this[m])}else if(T){const{vertexUniformInfo:g,vertexUniformBuffer:_}=T;_.writeOnlyBuffer(g.members[i],this[m])}}}function defineUintRange(i,m=0,g=!0,_=0,b){const y=Symbol(i);return{get:function(){return void 0===this[y]&&(this[y]=m),this[y]},set:createSetter$1(i,y,g,_,b),...vn}}function createSetter(i,m,g){return function(_){this[m]=_;const{gpuRenderInfo:b}=this;if(g){const{fragmentUniformInfo:m,fragmentUniformBuffer:g}=b;g.writeOnlyBuffer(m.members[i],_)}else if(b){const{vertexUniformInfo:m,vertexUniformBuffer:g}=b;g.writeOnlyBuffer(m.members[i],_)}}}function defineVector(i,m,g=!0){const _=Symbol(i);return{get:function(){return void 0===this[_]&&(this[_]=m),this[_]},set:createSetter(i,_,g),...vn}}function defineProperty_vec4$1(i,m=[0,0,0,0]){return defineVector(i,m)}function defineProperty_vec3$1(i,m=[0,0,0]){return defineVector(i,m)}function defineProperty_vec2$1(i,m=[0,0]){return defineVector(i,m)}function defineProperty_PositiveNumberRange$1(i,m=1,g,_){return definePositiveNumberRange(i,m,!0,g,_)}Object.freeze(vn),Object.freeze(defineBoolean),Object.freeze(defineColorRGB),Object.freeze(defineColorRGBA),Object.freeze(defineCubeTexture),Object.freeze(definePositiveNumberRange),Object.freeze(defineSampler),Object.freeze(defineTexture$1),Object.freeze(defineUintRange),Object.freeze(defineVector);const bn={},yn={AO_STRENGTH:"aoStrength",SPECULAR_STRENGTH:"specularStrength",EMISSIVE_STRENGTH:"emissiveStrength",OPACITY:"opacity",SHININESS:"shininess",NORMAL_SCALE:"normalScale"},Sn={},Tn={ALPHA_TEXTURE_SAMPLER:"alphaTextureSampler",AO_TEXTURE_SAMPLER:"aoTextureSampler",DIFFUSE_TEXTURE_SAMPLER:"diffuseTextureSampler",EMISSIVE_TEXTURE_SAMPLER:"emissiveTextureSampler",ENVIRONMENT_TEXTURE_SAMPLER:"environmentTextureSampler",NORMAL_TEXTURE_SAMPLER:"normalTextureSampler",SPECULAR_TEXTURE_SAMPLER:"specularTextureSampler"},Mn={ENVIRONMENT_TEXTURE:"environmentTexture"},wn={},Cn={},Rn={},Pn={ALPHA_TEXTURE:"alphaTexture",AO_TEXTURE:"aoTexture",DIFFUSE_TEXTURE:"diffuseTexture",EMISSIVE_TEXTURE:"emissiveTexture",NORMAL_TEXTURE:"normalTexture",SPECULAR_TEXTURE:"specularTexture"},Bn={COLOR:"color",EMISSIVE_COLOR:"emissiveColor",SPECULAR_COLOR:"specularColor"},In={...createDefineByPreset({defineBoolean:[defineBoolean,bn],definePositiveNumber:[defineProperty_PositiveNumberRange$1,yn],defineUint:[defineUintRange,Sn],defineVec2:[defineProperty_vec2$1,wn],defineVec3:[defineProperty_vec3$1,Cn],defineVec4:[defineProperty_vec4$1,Rn],defineColorRGB:[defineColorRGB,Bn],defineSampler:[defineSampler,Tn],defineTexture:[defineTexture$1,Pn],defineCubeTexture:[defineCubeTexture,Mn]}),defineBoolean:defineProperties(defineBoolean),definePositiveNumber:defineProperties(defineProperty_PositiveNumberRange$1),defineUint:defineProperties(defineUintRange),defineVec2:defineProperties(defineProperty_vec2$1),defineVec3:defineProperties(defineProperty_vec3$1),defineVec4:defineProperties(defineProperty_vec4$1),defineColorRGB:defineProperties(defineColorRGB),defineColorRGBA:defineProperties(defineColorRGBA),defineSampler:defineProperties(defineSampler),defineTexture:defineProperties(defineTexture$1),defineCubeTexture:defineProperties(defineCubeTexture),PRESET_BOOLEAN:bn,PRESET_POSITIVE_NUMBER:yn,PRESET_UINT:Sn,PRESET_SAMPLER:Tn,PRESET_TEXTURE:Pn,PRESET_CUBE_TEXTURE:Mn,PRESET_VEC2:wn,PRESET_VEC3:Cn,PRESET_VEC4:Rn,PRESET_COLOR_RGB:Bn};Object.freeze(In);const En={ZERO:"zero",ONE:"one",SRC:"src",ONE_MINUS_SRC:"one-minus-src",SRC_ALPHA:"src-alpha",ONE_MINUS_SRC_ALPHA:"one-minus-src-alpha",DST:"dst",ONE_MINUS_DST:"one-minus-dst",DST_ALPHA:"dst-alpha",ONE_MINUS_DST_ALPHA:"one-minus-dst-alpha",SRC_ALPHA_SATURATED:"src-alpha-saturated",CONSTANT:"constant",ONE_MINUS_CONSTANT:"one-minus-constant",SRC1:"src1",ONE_MINUS_SRC1:"one-minus-src1",SRC1_ALPHA:"src1-alpha",ONE_MINUS_SRC1_ALPHA:"one-minus-src1-alpha"};Object.freeze(En);const Dn={ADD:"add",SUBTRACT:"subtract",REVERSE_SUBTRACT:"reverse-subtract",MIN:"min",MAX:"max"};Object.freeze(Dn);const Ln=Object.values(En),Un=Object.values(Dn);class BlendState{state;#Nt;#Vt;#zt;#Ht;constructor(i,m,g,_){this.#Ht=i,this.srcFactor=m,this.dstFactor=g,this.operation=_}get operation(){return this.#zt}set operation(i){Un.includes(i)||consoleAndThrowError(`Invalid GPUBlendOperation:${i}. Valid operations are ${Un.join(",")}`),this.#zt=i,this.#$t()}get srcFactor(){return this.#Nt}set srcFactor(i){Ln.includes(i)||consoleAndThrowError(`Invalid GPUBlendFactor:${i}. Valid srcFactor factors are ${Ln.join(",")}`),this.#Nt=i,this.#$t()}get dstFactor(){return this.#Vt}set dstFactor(i){Ln.includes(i)||consoleAndThrowError(`Invalid GPUBlendFactor:${i}. Valid dstFactor factors are ${Ln.join(",")}`),this.#Vt=i,this.#$t()}#$t(){const i=this.#zt?{operation:this.#zt}:{},m=this.#Nt?{srcFactor:this.#Nt}:{},g=this.#Vt?{dstFactor:this.#Vt}:{};this.state={...i,...m,...g},this.#Ht.dirtyPipeline=!0}}const An=new Map,On=new WeakMap;let kn,Gn,Fn;class PackedTexture{#u=createUUID();#l;#pe;#U;#c;#Kt;#oe=new Map;constructor(i){this.#l=i,this.#c=i.gpuDevice,this.#Wt(),this.#pe=this.#jt()}get uuid(){return this.#u}get gpuTexture(){return this.#U}static getCacheMap(){return An}async packing(i,m,g,_,b){const y={r:"r",g:"g",b:"b",a:"a",...b},T=`${i.r?.label||""}_${i.g?.label||""}_${i.b?.label||""}_${i.a?.label||""}`,w=`${JSON.stringify(y)}_${T}`;if(!(i.r||i.g||i.b||i.a))return;this.#Xt(w);An.get(w)||await this.#qt(i,m,g,_,y,w)}destroy(){const i=On.get(this);if(i){const m=An.get(i);m&&(m.useNum--,0===m.useNum&&(m.gpuTexture?.destroy(),An.delete(i))),On.delete(this)}}#Wt(){Fn=this.#l.resourceManager.createGPUBuffer("PACK_TEXTURE_MAPPING_BUFFER",{size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),Gn||(Gn=this.#l.resourceManager.createBindGroupLayout("PACK_TEXTURE_BIND_GROUP_LAYOUT",{entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:3,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:4,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:5,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]})),kn||(kn=this.#Yt())}#Zt(i){const m=`${i.r?.label||"empty"}_${i.g?.label||"empty"}_${i.b?.label||"empty"}_${i.a?.label||"empty"}`,{resourceManager:g}=this.#l;if(!this.#oe.has(m)){const _=[{binding:0,resource:g.getGPUResourceBitmapTextureView(i.r)},{binding:1,resource:g.getGPUResourceBitmapTextureView(i.g)},{binding:2,resource:g.getGPUResourceBitmapTextureView(i.b)},{binding:3,resource:g.getGPUResourceBitmapTextureView(i.a)},{binding:4,resource:this.#pe},{binding:5,resource:{buffer:Fn}}],b=this.#c.createBindGroup({label:`PACK_TEXTURE_BIND_GROUP_${m}`,layout:Gn,entries:_});this.#oe.set(m,b)}this.#Kt=this.#oe.get(m)}#Xt(i){const m=On.get(this);if(m&&m!==i){const i=An.get(m);i&&(i.useNum--,0===i.useNum&&(i.gpuTexture?.destroy(),An.delete(m)))}const g=An.get(i);g&&(this.#U=g.gpuTexture,g.useNum++),On.set(this,i)}async#qt(i,m,g,_,b,y){const T={size:[m,g,1],format:"rgba8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC,label:_||`PACK_TEXTURE_${createUUID()}`,mipLevelCount:getMipLevelCount(m,g)};this.#U&&(this.#U=null);const w=this.#l.resourceManager.createManagedTexture(T),P=new Uint32Array([["r","g","b","a"].indexOf(b.r),["r","g","b","a"].indexOf(b.g),["r","g","b","a"].indexOf(b.b),["r","g","b","a"].indexOf(b.a)]);this.#c.queue.writeBuffer(Fn,0,P),this.#Zt(i),this.#Jt(w),this.#U=T.mipLevelCount>1?this.#l.resourceManager.mipmapGenerator.generateMipmap(w,T):w,An.set(y,{gpuTexture:this.#U,useNum:1,mappingKey:y,uuid:this.#u}),this.#Kt=null}#Jt(i){const{resourceManager:m}=this.#l,g=this.#c.createCommandEncoder({label:"PackedTexture_CommandEncoder"}),_=g.beginRenderPass({colorAttachments:[{view:m.getGPUResourceBitmapTextureView(i,{baseMipLevel:0,mipLevelCount:1,dimension:"2d",label:`${i.label}_RENDER_TARGET`}),loadOp:"clear",storeOp:"store",clearValue:[0,0,0,0]}]});_.setPipeline(kn),_.setBindGroup(0,this.#Kt),_.draw(6,1,0,0),_.end(),this.#c.queue.submit([g.finish()])}#Yt(){const i="struct VertexOut { @builtin(position) position:vec4<f32>, @location(0) uv:vec2<f32>,\n};\n@vertex\nfn vertexMain(@builtin(vertex_index) VertexIndex:u32) -> VertexOut { var pos=array<vec2<f32>,6>( vec2(-1.0,-1.0), vec2( 1.0,-1.0), vec2(-1.0,1.0), vec2(-1.0,1.0), vec2( 1.0,-1.0), vec2( 1.0,1.0) ); var uv=array<vec2<f32>,6>( vec2(0.0,1.0), vec2(1.0,1.0), vec2(0.0,0.0), vec2(0.0,0.0), vec2(1.0,1.0), vec2(1.0,0.0) ); var output:VertexOut; output.position=vec4(pos[VertexIndex],0.0,1.0); output.uv=uv[VertexIndex]; return output;\n}\nstruct ComponentMapping { r_component:u32, g_component:u32, b_component:u32, a_component:u32,\n};\n@group(0) @binding(0) var textureR:texture_2d<f32>;\n@group(0) @binding(1) var textureG:texture_2d<f32>;\n@group(0) @binding(2) var textureB:texture_2d<f32>;\n@group(0) @binding(3) var textureA:texture_2d<f32>;\n@group(0) @binding(4) var sampler0:sampler;\n@group(0) @binding(5) var<uniform> mapping:ComponentMapping;\nfn getComponent(color:vec4<f32>,componentIndex:u32) -> f32 { switch componentIndex { case 0u:{ return color.r;} case 1u:{ return color.g;} case 2u:{ return color.b;} case 3u:{ return color.a;} default:{ return 0.0;} }\n}\n@fragment\nfn fragmentMain(input:VertexOut) -> @location(0) vec4<f32> { let colorR=textureSample(textureR,sampler0,input.uv); let colorG=textureSample(textureG,sampler0,input.uv); let colorB=textureSample(textureB,sampler0,input.uv); let colorA=textureSample(textureA,sampler0,input.uv); let r=getComponent(colorR,mapping.r_component); let g=getComponent(colorG,mapping.g_component); let b=getComponent(colorB,mapping.b_component); let a=getComponent(colorA,mapping.a_component); return vec4(r,g,b,a);\n}\n",{resourceManager:m}=this.#l,g=this.#c.createPipelineLayout({label:"PACK_TEXTURE_PIPELINE_LAYOUT",bindGroupLayouts:[Gn]});return this.#c.createRenderPipeline({label:"PACK_TEXTURE_PIPELINE",layout:g,vertex:{module:m.createGPUShaderModule("PACK_TEXTURE_SHADER_MODULE",{code:i}),entryPoint:"vertexMain"},fragment:{module:m.createGPUShaderModule("PACK_TEXTURE_SHADER_MODULE",{code:i}),entryPoint:"fragmentMain",targets:[{format:"rgba8unorm"}]},primitive:{topology:"triangle-list"}})}#jt(){return new Sampler(this.#l).gpuSampler}}const Nn={NORMAL:0,MULTIPLY:1,LIGHTEN:2,SCREEN:3,LINEAR_DODGE:4,SUBTRACT:5,DARKEN:6,OVERLAY:7,COLOR_DODGE:8,COLOR_BURN:9,HARD_LIGHT:10,SOFT_LIGHT:11,DIFFERENCE:12,EXCLUSION:13,DIVIDE:14,VIVID_LIGHT:15,LINEAR_BURN:16,PIN_LIGHT:17,SATURATION:18,HUE:19,LUMINOSITY:20,COLOR:21,NEGATION:22};class FragmentGPURenderInfo{fragmentShaderModule;fragmentShaderSourceVariant;fragmentShaderVariantConditionalBlocks;fragmentUniformInfo;fragmentBindGroupLayout;fragmentUniformBuffer;fragmentUniformBindGroup;fragmentState;constructor(i,m,g,_,b,y,T,w){this.fragmentShaderModule=i,this.fragmentShaderSourceVariant=m,this.fragmentShaderVariantConditionalBlocks=g,this.fragmentUniformInfo=_,this.fragmentBindGroupLayout=b,this.fragmentUniformBuffer=y,this.fragmentUniformBindGroup=T,this.fragmentState=w}}Object.freeze(FragmentGPURenderInfo);const getBindGroupLayoutDescriptorFromShaderInfo=(i,m,g,_=!0)=>{const{textures:b,samplers:y,uniforms:T,storage:w}=i,P=[];for(const i in w){const _=w[i],{binding:b,name:y,group:T,type:H}=_;if(_.access){const i={write:"write-only-storage",read:"read-only-storage",read_write:"read-write-storage"}[_.access];m===T&&P.push({binding:b,visibility:g,buffer:{type:i}})}else if(m===T){const{access:i,format:m}=H,_={write:"write-only",read:"read-only",read_write:"read-write"}[i],y=m.name;P.push({binding:b,visibility:g,storageTexture:{access:_,format:y}})}}for(const i in b){const y=b[i],{binding:T,name:w,group:H,type:$}=y,{name:W}=$;m===H&&P.push({binding:T,visibility:g,texture:"texture_depth_2d"===W||"texture_depth_multisampled_2d"===W?{viewDimension:"2d",sampleType:"depth",multisampled:_}:"texture_cube"===W?{viewDimension:"cube"}:"texture_2d_array"===W?{viewDimension:"2d-array",sampleType:"float",multisampled:!1}:{}})}for(const i in y){const _=y[i],{binding:b,name:T,group:w}=_;m===w&&P.push({binding:b,visibility:g,sampler:{type:"filtering"}})}for(const i in T){const _=T[i],{binding:b,name:y,group:w}=_;m===w&&P.push({binding:b,visibility:g,buffer:{type:"uniform"}})}return{entries:P}},getFragmentBindGroupLayoutDescriptorFromShaderInfo=(i,m)=>getBindGroupLayoutDescriptorFromShaderInfo(i,m,GPUShaderStage.FRAGMENT),getVertexBindGroupLayoutDescriptorFromShaderInfo=(i,m)=>getBindGroupLayoutDescriptorFromShaderInfo(i,m,GPUShaderStage.VERTEX),getComputeBindGroupLayoutDescriptorFromShaderInfo=(i,m,g)=>getBindGroupLayoutDescriptorFromShaderInfo(i,m,GPUShaderStage.COMPUTE,g);class ABaseMaterial extends ResourceBase{use2PathRender;gpuRenderInfo;dirtyPipeline=!1;transparent=!1;#Qt;#en;#tn=GPUColorWrite.ALL;#nn;#rn;#in;#Fe;#an;#sn;#on;#un;#ln;#cn;#hn;#fn;#dn;#_e;#mn=Nn.MULTIPLY;constructor(i,m,g,_){super(i),this.#dn=m,this.#an=`FRAGMENT_MODULE_${this.#dn}`,this.#sn=`FRAGMENT_BIND_GROUP_DESCRIPTOR_${m}`,this.#on=`FRAGMENT_BIND_GROUP_LAYOUT_${m}`,this.#un=g,this.#ln=g?.storage,this.#cn=g?.uniforms.uniforms,this.#hn=g?.textures,this.#fn=g?.samplers,this.#_e=i.resourceManager.getGPUBindGroupLayout(this.#on)||i.resourceManager.createBindGroupLayout(this.#on,getFragmentBindGroupLayoutDescriptorFromShaderInfo(g,_)),this.#Qt=new BlendState(this,En.SRC_ALPHA,En.ONE_MINUS_SRC_ALPHA,Dn.ADD),this.#en=new BlendState(this,En.SRC_ALPHA,En.ONE_MINUS_SRC_ALPHA,Dn.ADD),this.#nn=i.resourceManager,this.#rn=this.#nn.basicSampler.gpuSampler,this.#in=this.#nn.emptyBitmapTextureView,this.#Fe=this.#nn.emptyCubeTextureView}get tintBlendMode(){const i=Object.entries(Nn).find(([,i])=>i===this.#mn);if(!i)throw new Error(`Invalid tint mode value:${this.#mn}`);return i[0]}set tintBlendMode(i){const{fragmentUniformInfo:m,fragmentUniformBuffer:g}=this.gpuRenderInfo;let _;if("string"==typeof i){if(!(i in Nn))throw new Error(`Invalid tint mode key:${i}`);_=Nn[i]}else{if("number"!=typeof i||!Object.values(Nn).includes(i))throw new Error(`Invalid tint mode:${i}`);_=i}g.writeOnlyBuffer(m.members.tintBlendMode,_),this.#mn=_}get MODULE_NAME(){return this.#dn}get FRAGMENT_SHADER_MODULE_NAME(){return this.#an}get FRAGMENT_BIND_GROUP_DESCRIPTOR_NAME(){return this.#sn}get STORAGE_STRUCT(){return this.#ln}get UNIFORM_STRUCT(){return this.#cn}get blendColorState(){return this.#Qt}get blendAlphaState(){return this.#en}get writeMaskState(){return this.#tn}set writeMaskState(i){this.#tn=i}initGPURenderInfos(){const{redGPUContext:i}=this,{resourceManager:m}=i,g=m.createGPUShaderModule(this.#an,{code:this.#un.defaultSource}),_=new ArrayBuffer(Math.max(this.#cn.arrayBufferByteLength,16)),b=new UniformBuffer(i,_,`UniformBuffer_${this.#dn}_${this.uuid}`);this.gpuRenderInfo=new FragmentGPURenderInfo(g,this.#un.shaderSourceVariant,this.#un.conditionalBlocks,this.#cn,this.#_e,b,null,null),this._updateBaseProperty(),this._updateFragmentState()}_updateFragmentState(){const{gpuDevice:i,resourceManager:m}=this.redGPUContext;this.#pn();const g=[];for(const i in this.#hn){const _=this.#hn[i],{binding:b,name:y,group:T,type:w}=_,{name:P}=w;let H;H="texture_cube"===P?m.getGPUResourceCubeTextureView(this[y]):this[y]instanceof PackedTexture?m.getGPUResourceBitmapTextureView(this[y]):m.getGPUResourceBitmapTextureView(this[y])||this.#in,2===T&&g.push({binding:b,resource:H})}for(const i in this.#fn){const m=this.#fn[i],{binding:_,name:b,group:y}=m;2===y&&g.push({binding:_,resource:this.getGPUResourceSampler(this[b])})}this.#cn&&g.push({binding:this.#cn.binding,resource:{buffer:this.gpuRenderInfo.fragmentUniformBuffer.gpuBuffer,offset:0,size:this.gpuRenderInfo.fragmentUniformBuffer.size}});const _={layout:this.gpuRenderInfo.fragmentBindGroupLayout,label:this.#sn,entries:g},b=i.createBindGroup(_);this.gpuRenderInfo.fragmentState=this.getFragmentRenderState(),this.gpuRenderInfo.fragmentUniformBindGroup=b}getFragmentRenderState(i="main"){return{module:this.gpuRenderInfo.fragmentShaderModule,entryPoint:i,targets:[{format:"rgba16float",blend:{color:this.blendColorState.state,alpha:this.blendAlphaState.state},writeMask:this.writeMaskState},{format:navigator.gpu.getPreferredCanvasFormat(),blend:void 0,writeMask:this.writeMaskState},{format:"rgba16float",blend:void 0,writeMask:this.writeMaskState}]}}_updateBaseProperty(){const{fragmentUniformInfo:i,fragmentUniformBuffer:m}=this.gpuRenderInfo,{members:g}=i;for(const _ in g){const g=this[_];g instanceof ColorRGBA?m.writeOnlyBuffer(i.members[_],g.rgbaNormalLinear):g instanceof ColorRGB?m.writeOnlyBuffer(i.members[_],g.rgbNormalLinear):Vn.test(_)||(this[_]=g)}}getGPUResourceSampler(i){return i?.gpuSampler||this.#rn}#pn(){const{gpuDevice:i,resourceManager:m}=this.redGPUContext,g=this.#gn(),_=`${this.#an}_${g}`;let b=m.getGPUShaderModule(_);if(!b){const i=this.gpuRenderInfo.fragmentShaderSourceVariant.getVariant(g);i?b=m.createGPUShaderModule(_,{code:i}):(console.warn("⚠️ 바리안트 소스를 찾을 수 없음:",g),b=this.gpuRenderInfo.fragmentShaderModule)}this.gpuRenderInfo.fragmentShaderModule=b}#gn(){const{fragmentShaderVariantConditionalBlocks:i}=this.gpuRenderInfo,m=new Set;for(const g of i)this[g]&&m.add(g);const g=m.size>0?Array.from(m).sort().join("+"):"none";return m.size,g}}const Vn=/^use\w+Texture$/;In.defineByPreset(ABaseMaterial,[In.PRESET_POSITIVE_NUMBER.OPACITY]),In.defineBoolean(ABaseMaterial,[["useTint",!1]]),In.defineColorRGBA(ABaseMaterial,["tint","#ff0000"]),Object.freeze(ABaseMaterial);class ABitmapBaseMaterial extends ABaseMaterial{__packingList;constructor(i,m,g,_){super(i,m,g,_)}updateTexture(i,m){i&&i.__removeDirtyPipelineListener(this.#xn),m&&m.__addDirtyPipelineListener(this.#xn),this.#xn()}updateSampler(i,m){i&&i.__removeDirtyPipelineListener(this.#xn),m&&m.__addDirtyPipelineListener(this.#xn),this.#xn()}#xn=()=>{this.dirtyPipeline=!0;{let i=(this.__packingList||[]).length;for(;i--;)this.__packingList[i]()}this.gpuRenderInfo?.fragmentShaderModule?this._updateFragmentState():this.initGPURenderInfos()}}Object.freeze(ABitmapBaseMaterial);var zn=Object.freeze({__proto__:null,ABaseMaterial:ABaseMaterial,ABitmapBaseMaterial:ABitmapBaseMaterial,FragmentGPURenderInfo:FragmentGPURenderInfo,getComputeBindGroupLayoutDescriptorFromShaderInfo:getComputeBindGroupLayoutDescriptorFromShaderInfo,getFragmentBindGroupLayoutDescriptorFromShaderInfo:getFragmentBindGroupLayoutDescriptorFromShaderInfo,getVertexBindGroupLayoutDescriptorFromShaderInfo:getVertexBindGroupLayoutDescriptorFromShaderInfo});class ASinglePassPostEffect{#_n;#vn;#bn;#yn;#Sn;#Tn;#Mn;#wn;#Cn;#Rn;#Pn;#Bn;#In;#En;#Dn;#h;#Ln;#Un;#An;#On;#kn;#Gn=16;#Fn=16;#Nn=1;#Vn=!1;#zn=!1;#l;#Hn;#$n=[];#F=0;#Kn;#Wn;constructor(i){this.#l=i,this.#Hn=i.antialiasingManager}get useGBufferNormalTexture(){return this.#zn}set useGBufferNormalTexture(i){this.#zn=i}get videoMemorySize(){return this.#F}get useDepthTexture(){return this.#Vn}set useDepthTexture(i){this.#Vn=i}get redGPUContext(){return this.#l}get storageInfo(){return this.#Dn}get shaderInfo(){return this.#Hn.useMSAA?this.#Ln:this.#Un}get uniformBuffer(){return this.#Bn}get uniformsInfo(){return this.#In}get systemUuniformsInfo(){return this.#En}get WORK_SIZE_X(){return this.#Gn}set WORK_SIZE_X(i){this.#Gn=i}get WORK_SIZE_Y(){return this.#Fn}set WORK_SIZE_Y(i){this.#Fn=i}get WORK_SIZE_Z(){return this.#Nn}set WORK_SIZE_Z(i){this.#Nn=i}get outputTextureView(){return this.#kn}clear(){this.#On&&(this.#On.destroy(),this.#On=null,this.#kn=null)}init(i,m,g,_){this.#h=m;const{resourceManager:b}=i;this.#_n=b.createGPUShaderModule(`${m}_MSAA`,{code:g.msaa}),this.#vn=b.createGPUShaderModule(`${m}_NonMSAA`,{code:g.nonMsaa}),this.#Ln=parseWGSL(g.msaa),this.#Un=parseWGSL(g.nonMsaa);const y=this.#Ln.storage,T=this.#Ln.uniforms;if(this.#Dn=y,this.#In=T.uniforms,this.#En=T.systemUniforms,this.#In){const m=new ArrayBuffer(this.#In.arrayBufferByteLength);this.#Bn=new UniformBuffer(i,m,`${this.constructor.name}_UniformBuffer`)}}execute(i,m,g,_){const b=m.createCommandEncoder({label:"ASinglePassPostEffect_Execute_CommandEncoder"}),y=b.beginComputePass();y.setPipeline(this.#Pn),y.setBindGroup(0,i.renderViewStateData.swapBufferIndex?this.#Tn:this.#Sn),y.setBindGroup(1,this.#Mn),y.dispatchWorkgroups(Math.ceil(g/this.WORK_SIZE_X),Math.ceil(_/this.WORK_SIZE_Y)),y.end(),m.queue.submit([b.finish()])}render(i,m,g,..._){const{gpuDevice:b,antialiasingManager:y}=this.#l,{useMSAA:T,msaaID:w}=y,P=this.#jn(i),H=this.#Kn!==T||this.#Wn!==w,$=this.#Xn(_),W=this.outputTextureView,{redGPUContext:q}=i;return(P||H||$)&&this.#qn(i,_,W,T,q,b),this.update(performance.now()),this.execute(i,b,m,g),this.#Kn=T,this.#Wn=w,{texture:this.#On,textureView:W}}update(i){}updateUniform(i,m){this.uniformBuffer.writeOnlyBuffer(this.uniformsInfo.members[i],m)}#qn(i,m,g,_,b,y){const T=this.storageInfo,w=this.uniformsInfo,P=this.systemUuniformsInfo;this.#wn=[],this.#Cn=[],this.#Rn=[];for(const i in T){const g=T[i],{binding:_,name:b}=g;"outputTexture"!==b&&(this.#wn.push({binding:_,resource:m[_].textureView}),this.#Cn.push({binding:_,resource:m[_].textureView}))}this.#Rn.push({binding:0,resource:g}),this.shaderInfo.textures.forEach(m=>{const{name:g,binding:_}=m;"depthTexture"===g&&(this.#wn.push({binding:_,resource:i.viewRenderTextureManager.depthTextureView}),this.#Cn.push({binding:_,resource:i.viewRenderTextureManager.prevDepthTextureView})),"gBufferNormalTexture"===g&&(this.#wn.push({binding:_,resource:i.redGPUContext.antialiasingManager.useMSAA?i.viewRenderTextureManager.gBufferNormalResolveTextureView:i.viewRenderTextureManager.gBufferNormalTextureView}),this.#Cn.push({binding:_,resource:i.redGPUContext.antialiasingManager.useMSAA?i.viewRenderTextureManager.gBufferNormalResolveTextureView:i.viewRenderTextureManager.gBufferNormalTextureView}))}),P&&this.#Rn.push({binding:P.binding,resource:{buffer:i.postEffectManager.postEffectSystemUniformBuffer.gpuBuffer,offset:0,size:i.postEffectManager.postEffectSystemUniformBuffer.size}}),this.#Bn&&w&&this.#Rn.push({binding:w.binding,resource:{buffer:this.#Bn.gpuBuffer,offset:0,size:this.#Bn.size}});const H=_?this.#Ln:this.#Un,$=_?this.#_n:this.#vn;this.#bn=b.resourceManager.getGPUBindGroupLayout(`${this.#h}_BIND_GROUP_LAYOUT_0_USE_MSAA_${_}`)||b.resourceManager.createBindGroupLayout(`${this.#h}_BIND_GROUP_LAYOUT_0_USE_MSAA_${_}`,getComputeBindGroupLayoutDescriptorFromShaderInfo(H,0,_)),this.#yn=b.resourceManager.getGPUBindGroupLayout(`${this.#h}_BIND_GROUP_LAYOUT_1_USE_MSAA_${_}`)||b.resourceManager.createBindGroupLayout(`${this.#h}_BIND_GROUP_LAYOUT_1_USE_MSAA_${_}`,getComputeBindGroupLayoutDescriptorFromShaderInfo(H,1,_)),this.#Sn=y.createBindGroup({label:`${this.#h}_BIND_GROUP_0_USE_MSAA_${_}_SWAP0`,layout:this.#bn,entries:this.#wn}),this.#Tn=y.createBindGroup({label:`${this.#h}_BIND_GROUP_0_USE_MSAA_${_}_SWAP0`,layout:this.#bn,entries:this.#Cn}),this.#Mn=y.createBindGroup({label:`${this.#h}_BIND_GROUP_1_USE_MSAA_${_}`,layout:this.#yn,entries:this.#Rn}),this.#Pn=y.createComputePipeline({label:`${this.#h}_COMPUTE_PIPELINE_USE_MSAA_${_}`,layout:y.createPipelineLayout({bindGroupLayouts:[this.#bn,this.#yn]}),compute:{module:$,entryPoint:"main"}}),this.#Yn(m)}#Zn(){this.#F=0,this.#On&&(this.#F=calculateTextureByteSize(this.#On))}#Xn(i){if(!this.#$n||this.#$n.length!==i.length)return!0;for(let m=0;m<i.length;m++)if(this.#$n[m].textureView!==i[m].textureView)return!0;return!1}#Yn(i){this.#$n=[...i]}#jn(i){const{redGPUContext:m,viewRenderTextureManager:g,name:_}=i,{gBufferColorTexture:b}=g,{resourceManager:y}=m,{width:T,height:w}=b,P=T!==this.#An?.width||w!==this.#An?.height||!this.#On;return P&&(this.clear(),this.#On=y.createManagedTexture({size:{width:T,height:w},format:"rgba16float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC,label:`${_}_${this.#h}_${T}x${w}}`}),this.#kn=y.getGPUResourceBitmapTextureView(this.#On)),this.#An={width:T,height:w},this.#Zn(),P}}Object.freeze(ASinglePassPostEffect);class AMultiPassPostEffect extends ASinglePassPostEffect{#Jn=[];#F=0;constructor(i,m){super(i),this.#Jn.push(...m)}get videoMemorySize(){return this.#Zn(),this.#F}get passList(){return this.#Jn}clear(){this.#Jn.forEach(i=>i.clear())}render(i,m,g,_){let b;return this.#Jn.forEach((y,T)=>{T&&(_=b),b=y.render(i,m,g,_)}),b}#Zn(){this.#F=0,this.#Jn.forEach(i=>{this.#F+=i.videoMemorySize})}}Object.freeze(AMultiPassPostEffect);const validateNumberRange=(i,m=-Number.MAX_VALUE,g=Number.MAX_VALUE)=>("number"!=typeof i&&consoleAndThrowError("Only numbers allowed."),"number"!=typeof m&&consoleAndThrowError("Only numbers allowed."),"number"!=typeof g&&consoleAndThrowError("Only numbers allowed."),(i<m||i>g)&&consoleAndThrowError(`Only numbers within the range of [${m},${g}] are allowed. input:${i}`),!0),createCode=(i,m,g="",_=!1)=>{const{WORK_SIZE_X:b,WORK_SIZE_Y:y,WORK_SIZE_Z:T}=i,w=_?"texture_depth_multisampled_2d":"texture_depth_2d";return`\n ${g} @group(0) @binding(0) var sourceTexture:texture_storage_2d<rgba16float,read>; ${i.useDepthTexture?`@group(0) @binding(1) var depthTexture:${w}`:""}; ${i.useGBufferNormalTexture?`@group(0) @binding(${i.useDepthTexture?2:1}) var gBufferNormalTexture:texture_2d<f32>`:""}; @group(1) @binding(0) var outputTexture:texture_storage_2d<rgba16float,write>; ${_n} ${g?"@group(1) @binding(2) var<uniform> uniforms:Uniforms;":""} @compute @workgroup_size(${b},${y},${T}) fn main (  @builtin(global_invocation_id) global_id:vec3<u32>, ){ ${m} } `},createBasicPostEffectCode=(i,m,g="")=>({msaa:createCode(i,m,g,!0),nonMsaa:createCode(i,m,g,!1)});Object.freeze(createBasicPostEffectCode);class BlurX extends ASinglePassPostEffect{#Ft=32;constructor(i){super(i),this.init(i,"POST_EFFECT_BLUR_X",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy);\nlet dimensions=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet size_value:f32=uniforms.size;\nvar sum:vec4<f32>=vec4<f32>(0.0,0.0,0.0,0.0);\nvar offset=random(global_id,0.0);\nvar total=0.0;\nlet loopSize=10.0;\nfor (var t=-loopSize;t <=loopSize;t=t + 1.0) { var percent=(t + offset - 0.5)/loopSize; var weight=1.0 - abs(percent); var ix=clamp((f32(global_id.x) + f32(size_value * percent)),0.0,dimW - 1.0); let delta=vec2<i32>(i32(ix),i32(global_id.y)); sum +=textureLoad(sourceTexture,delta).xyzw * weight; total +=weight;\n}\nsum/=total;\ntextureStore(outputTexture,vec2<i32>(global_id.xy),sum);\n","struct Uniforms { size:f32,\n};\nfn random(id:vec3<u32>,delta:f32) -> f32 { let seed:u32=((id.x << 16) | (id.y & 0xFFFF)) ^ (id.z * 0x63641362); let t:vec3<f32>=vec3<f32>(f32(seed & 0xFF),f32((seed >> 8) & 0xFF),f32(seed >> 16)); return delta + fract(sin(dot(t,vec3<f32>(12.9898,78.233,12.9898))) * 43758.5453);\n}\n")),this.size=this.#Ft}get size(){return this.#Ft}set size(i){validateNumberRange(i,0),this.#Ft=i,this.updateUniform("size",i)}}Object.freeze(BlurX);class BlurY extends ASinglePassPostEffect{#Ft=32;constructor(i){super(i),this.init(i,"POST_EFFECT_BLUR_Y",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy);\nlet dimensions=textureDimensions(sourceTexture);\nlet dimH=f32(dimensions.y);\nlet size_value:f32=uniforms.size;\nvar sum:vec4<f32>=vec4<f32>(0.0,0.0,0.0,0.0);\nvar offset=random(global_id,0.0);\nvar total=0.0;\nlet loopSize=10.0;\nfor (var t=-loopSize;t <=loopSize;t=t + 1.0) { var percent=(t + offset - 0.5)/loopSize; var weight=1.0 - abs(percent); var iy=clamp((f32(global_id.y) + f32(size_value * percent)),0.0,dimH - 1.0); let delta=vec2<i32>(i32(global_id.x),i32(iy)); sum +=textureLoad(sourceTexture,delta).xyzw * weight; total +=weight;\n}\nsum/=total;\ntextureStore(outputTexture,vec2<i32>(global_id.xy),sum);\n","struct Uniforms { size:f32,\n};\nfn random(id:vec3<u32>,delta:f32) -> f32 { let seed:u32=((id.x << 16) | (id.y & 0xFFFF)) ^ (id.z * 0x63641362); let t:vec3<f32>=vec3<f32>(f32(seed & 0xFF),f32((seed >> 8) & 0xFF),f32(seed >> 16)); return delta + fract(sin(dot(t,vec3<f32>(12.9898,78.233,12.9898))) * 43758.5453);\n}\n")),this.size=this.#Ft}get size(){return this.#Ft}set size(i){validateNumberRange(i,0),this.#Ft=i,this.updateUniform("size",i)}}Object.freeze(BlurY);class GaussianBlur extends AMultiPassPostEffect{#Ft=32;constructor(i){super(i,[new BlurX(i),new BlurY(i)])}get size(){return this.#Ft}set size(i){this.#Ft=i,this.passList.forEach(m=>m.size=i)}}Object.freeze(GaussianBlur);class SSAO_AO extends ASinglePassPostEffect{#Qn=.253;#er=1;#tr=.02;#nr=.02;#rr=30;#ir=20;#ar=1.5;#sr=!0;constructor(i){super(i),this.useDepthTexture=!0,this.useGBufferNormalTexture=!0,this.init(i,"POST_EFFECT_SSAO",createBasicPostEffectCode(this,"{ let screenCoord=vec2<i32>(global_id.xy); let texSize=vec2<i32>(textureDimensions(sourceTexture)); if (screenCoord.x >=texSize.x || screenCoord.y >=texSize.y) { return;} let originalColor=textureLoad(sourceTexture,screenCoord); let depth=textureLoad(depthTexture,screenCoord,0); var failColor=vec4<f32>(select(originalColor.rgb,vec3<f32>(1.0),uniforms.useBlur > 0.0),originalColor.a); if (depth < 0.001) { textureStore(outputTexture,screenCoord,failColor); return; } let normalData=textureLoad(gBufferNormalTexture,screenCoord,0); if (length(normalData.rgb)<0.001) { textureStore(outputTexture,screenCoord,failColor); return; } let viewPos=reconstructViewPosition(screenCoord,depth); let viewNormal=reconstructViewNormal(textureLoad(gBufferNormalTexture,screenCoord,0)); let distToCamera=-viewPos.z; let depthScale=distToCamera * 0.1; let adaptiveRadius=uniforms.radius * (1.0 + depthScale); let noiseVec=getNoiseVec(vec2<f32>(screenCoord)); let tangent=normalize(noiseVec - viewNormal * dot(noiseVec,viewNormal)); let bitangent=cross(viewNormal,tangent); let tbn=mat3x3<f32>(tangent,bitangent,viewNormal); let samples=array<vec3<f32>,8>( vec3<f32>(0.04,0.03,0.08),vec3<f32>(-0.04,0.04,0.08), vec3<f32>(0.10,-0.08,0.18),vec3<f32>(-0.09,-0.10,0.18), vec3<f32>(0.18,0.15,0.30),vec3<f32>(-0.17,0.18,0.30), vec3<f32>(0.28,-0.25,0.45),vec3<f32>(-0.27,-0.28,0.45) ); var totalOcclusion=0.0; for (var i=0u;i < 8u;i++) { let sampleOffset=tbn * samples[i]; let sampleDir=normalize(sampleOffset); let sampleViewPos=viewPos + sampleOffset * adaptiveRadius; let clipPos=systemUniforms.projectionMatrix * vec4<f32>(sampleViewPos,1.0); let sampleUV=(clipPos.xy/clipPos.w) * vec2<f32>(0.5,-0.5) + 0.5; if (sampleUV.x < 0.0 || sampleUV.x > 1.0 || sampleUV.y < 0.0 || sampleUV.y > 1.0) { continue; } let sampleCoord=vec2<i32>(sampleUV * vec2<f32>(texSize)); let realDepth=textureLoad(depthTexture,sampleCoord,0); if (realDepth < 0.001) { continue;} let realViewPos=reconstructViewPosition(sampleCoord,realDepth); let adaptiveBias=uniforms.bias * (1.0 + distToCamera * uniforms.biasDistanceScale); let deltaZ=realViewPos.z - sampleViewPos.z; if (deltaZ > adaptiveBias && deltaZ < adaptiveRadius * 1.5) { let sampleDist=length(viewPos - realViewPos); if (sampleDist < adaptiveRadius * 1.5) { let angleWeight=pow(max(0.0,dot(viewNormal,sampleDir)),2.0); let distFalloff=1.0 - smoothstep(0.0,adaptiveRadius * 1.5,sampleDist); totalOcclusion +=angleWeight * distFalloff; } } } let ao=(totalOcclusion/8.0) * uniforms.intensity; let distanceFade=smoothstep( uniforms.fadeDistanceStart + uniforms.fadeDistanceRange, uniforms.fadeDistanceStart, distToCamera ); var finalAO=saturate(1.0 - (ao * distanceFade)); finalAO=pow(finalAO,uniforms.contrast); let finalColor=vec4<f32>( select(originalColor.rgb * vec3<f32>(finalAO),vec3<f32>(finalAO),uniforms.useBlur > 0.0), originalColor.a ); textureStore(outputTexture,screenCoord,finalColor);\n}\n","struct Uniforms { radius:f32, intensity:f32, bias:f32, biasDistanceScale:f32, fadeDistanceStart:f32, fadeDistanceRange:f32, contrast:f32, useBlur:f32,\n}\nfn getTextureSize() -> vec2<f32> { return vec2<f32>(textureDimensions(sourceTexture));\n}\nfn reconstructViewPosition(screenCoord:vec2<i32>,depth:f32) -> vec3<f32> { let texSize=getTextureSize(); let uv=(vec2<f32>(screenCoord) + 0.5)/texSize; let ndc=vec3<f32>(uv.x * 2.0 - 1.0,(1.0 - uv.y) * 2.0 - 1.0,depth); let clipPos=vec4<f32>(ndc,1.0); let viewPos4=systemUniforms.inverseProjectionMatrix * clipPos; return viewPos4.xyz/viewPos4.w;\n}\nfn reconstructViewNormal(gBufferNormalData:vec4<f32>) -> vec3<f32> { let worldNormal=normalize(gBufferNormalData.rgb * 2.0 - 1.0); let viewNormal=(systemUniforms.camera.cameraMatrix * vec4<f32>(worldNormal,0.0)).xyz; return normalize(viewNormal);\n}\nfn getNoiseVec(p:vec2<f32>) -> vec3<f32> { let noise=fract(52.9829189 * fract(dot(p,vec2<f32>(0.06711056,0.00583715)))); let angle=noise * 6.28318530718; return vec3<f32>(cos(angle),sin(angle),0.0);\n}\n")),this.radius=this.#Qn,this.intensity=this.#er,this.bias=this.#tr,this.biasDistanceScale=this.#nr,this.fadeDistanceStart=this.#rr,this.fadeDistanceRange=this.#ir,this.contrast=this.#ar,this.useBlur=!0}get useBlur(){return this.#sr}set useBlur(i){this.#sr=i,this.updateUniform("useBlur",i?1:0)}get radius(){return this.#Qn}set radius(i){validatePositiveNumberRange(i,.01,5),this.#Qn=i,this.updateUniform("radius",i)}get intensity(){return this.#er}set intensity(i){validateNumberRange(i,0,10),this.#er=i,this.updateUniform("intensity",i)}get bias(){return this.#tr}set bias(i){validateNumberRange(i,0,.1),this.#tr=i,this.updateUniform("bias",i)}get biasDistanceScale(){return this.#nr}set biasDistanceScale(i){validateNumberRange(i,0,.5),this.#nr=i,this.updateUniform("biasDistanceScale",i)}get fadeDistanceStart(){return this.#rr}set fadeDistanceStart(i){validatePositiveNumberRange(i,1,200),this.#rr=i,this.updateUniform("fadeDistanceStart",i)}get fadeDistanceRange(){return this.#ir}set fadeDistanceRange(i){validatePositiveNumberRange(i,1,100),this.#ir=i,this.updateUniform("fadeDistanceRange",i)}get contrast(){return this.#ar}set contrast(i){validateNumberRange(i,.5,4),this.#ar=i,this.updateUniform("contrast",i)}}Object.freeze(SSAO_AO);class SSAOBlend extends ASinglePassPostEffect{constructor(i){super(i);const{WORK_SIZE_X:m,WORK_SIZE_Y:g,WORK_SIZE_Z:_}=this,b=`\n @group(0) @binding(0) var sourceTexture0:texture_storage_2d<rgba16float,read>; @group(0) @binding(1) var sourceTexture1:texture_storage_2d<rgba16float,read>; @group(1) @binding(0) var outputTexture:texture_storage_2d<rgba16float,write>;\n @compute @workgroup_size(${m},${g},${_}) fn main ( @builtin(global_invocation_id) global_id:vec3<u32>, ){ let index=vec2<u32>(global_id.xy ); let dimensions:vec2<u32>=textureDimensions(sourceTexture0); let dimW=f32(dimensions.x); let dimH=f32(dimensions.y); let uv=\tvec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH); var diffuse:vec4<f32>=textureLoad( sourceTexture0, index, ); var blur:vec4<f32>=textureLoad( sourceTexture1, index, );  let finalColor=vec4<f32>((diffuse.rgb * blur.rgb ) ,diffuse.a); textureStore(outputTexture,index,finalColor ); }; `;this.init(i,"POST_EFFECT_OLD_BLOOM",{msaa:b,nonMsaa:b})}render(i,m,g,_,b){return super.render(i,m,g,_,b)}}Object.freeze(SSAOBlend);class SSAO extends AMultiPassPostEffect{#or;#ur;#lr;constructor(i){super(i,[new SSAO_AO(i),new GaussianBlur(i),new SSAOBlend(i)]),this.#or=this.passList[0],this.#ur=this.passList[1],this.#ur.size=3,this.#lr=this.passList[2]}get useBlur(){return this.#or.useBlur}set useBlur(i){this.#or.useBlur=i}get radius(){return this.#or.radius}set radius(i){this.#or.radius=i}get intensity(){return this.#or.intensity}set intensity(i){this.#or.intensity=i}get bias(){return this.#or.bias}set bias(i){this.#or.bias=i}get biasDistanceScale(){return this.#or.biasDistanceScale}set biasDistanceScale(i){this.#or.biasDistanceScale=i}get fadeDistanceStart(){return this.#or.fadeDistanceStart}set fadeDistanceStart(i){this.#or.fadeDistanceStart=i}get fadeDistanceRange(){return this.#or.fadeDistanceRange}set fadeDistanceRange(i){this.#or.fadeDistanceRange=i}get contrast(){return this.#or.contrast}set contrast(i){this.#or.contrast=i}render(i,m,g,_){const b=this.#or.render(i,m,g,_);if(this.useBlur){const y=this.#ur.render(i,m,g,b);return this.#lr.render(i,m,g,_,y)}return b}}Object.freeze(SSAO);class SSR extends ASinglePassPostEffect{#cr=64;#hr=15;#fr=.02;#dr=1;#mr=12;#pr=.15;constructor(i){super(i),this.WORK_SIZE_X=8,this.WORK_SIZE_Y=8,this.WORK_SIZE_Z=1,this.useDepthTexture=!0,this.useGBufferNormalTexture=!0,this.init(i,"POST_EFFECT_SSR",createBasicPostEffectCode(this,"let screenCoord=vec2<i32>(global_id.xy);\nlet texDims=textureDimensions(sourceTexture);\nlet texSize=vec2<i32>(texDims);\nif (screenCoord.x >=texSize.x || screenCoord.y >=texSize.y) { return;\n}\nlet originalColor=textureLoad(sourceTexture,screenCoord);\nlet depth=textureLoad(depthTexture,screenCoord,0);\nif (depth >=0.999) { textureStore(outputTexture,screenCoord,originalColor); return;\n}\nlet gBufferNormalData=textureLoad(gBufferNormalTexture,screenCoord,0);\nlet precomputedReflectionStrength=gBufferNormalData.a;\nif (precomputedReflectionStrength < 0.05) { textureStore(outputTexture,screenCoord,originalColor); return;\n}\nlet worldPos=reconstructWorldPosition(screenCoord,depth);\nlet worldNormal=reconstructWorldNormal(gBufferNormalData);\nif (length(worldNormal) < 0.01) { textureStore(outputTexture,screenCoord,originalColor); return;\n}\nlet normal=normalize(worldNormal);\nlet cameraWorldPos=systemUniforms.camera.inverseCameraMatrix[3].xyz;\nlet reflectionDir=calculateWorldReflectionRay(worldPos,normal,cameraWorldPos);\nlet reflection=performWorldRayMarching(worldPos,reflectionDir);\nif (reflection.a > 0.001) { let finalReflectionStrength=reflection.a * uniforms.reflectionIntensity * precomputedReflectionStrength; let reflectionColor=reflection.rgb * finalReflectionStrength; let diffuseColor=originalColor.rgb * (1.0 - finalReflectionStrength); let finalColor=diffuseColor + reflectionColor; textureStore(outputTexture,screenCoord,vec4<f32>(finalColor,originalColor.a));\n} else { textureStore(outputTexture,screenCoord,originalColor);\n}\n","struct Uniforms { maxSteps:u32, maxDistance:f32, stepSize:f32, reflectionIntensity:f32, fadeDistance:f32, edgeFade:f32, _padding:f32, _padding2:f32, } fn getTextureDimensions() -> vec2<u32> { return textureDimensions(depthTexture); } fn reconstructWorldPosition(screenCoord:vec2<i32>,depth:f32) -> vec3<f32> { let texDims=getTextureDimensions(); let invTexDims=1.0/vec2<f32>(texDims); let uv=(vec2<f32>(screenCoord) + 0.5) * invTexDims; let ndc=vec3<f32>( uv.x * 2.0 - 1.0, -(uv.y * 2.0 - 1.0), depth * 2.0 - 1.0 ); let clipPos=vec4<f32>(ndc,1.0); let viewPos4=systemUniforms.inverseProjectionMatrix * clipPos; if (abs(viewPos4.w) < 1e-6) { return vec3<f32>(0.0); } let viewPos=viewPos4.xyz/viewPos4.w; let worldPos4=systemUniforms.camera.inverseCameraMatrix * vec4<f32>(viewPos,1.0); return worldPos4.xyz; } fn reconstructWorldNormal(gBufferNormalData:vec4<f32>) -> vec3<f32> { return normalize(gBufferNormalData.rgb * 2.0 - 1.0); } fn worldToScreen(worldPos:vec3<f32>) -> vec2<f32> { let clipPos4=systemUniforms.projectionCameraMatrix * vec4<f32>(worldPos,1.0); if (abs(clipPos4.w) < 1e-6) { return vec2<f32>(-1.0); } let ndc=clipPos4.xyz/clipPos4.w; return vec2<f32>(ndc.x * 0.5 + 0.5,-ndc.y * 0.5 + 0.5); } fn calculateEdgeFade(screenUV:vec2<f32>) -> f32 { let edge=min(screenUV,1.0 - screenUV); let edgeDist=min(edge.x,edge.y); return smoothstep(0.0,uniforms.edgeFade,edgeDist); } fn calculateWorldReflectionRay(worldPos:vec3<f32>,worldNormal:vec3<f32>,cameraWorldPos:vec3<f32>) -> vec3<f32> { let viewDir=normalize(cameraWorldPos - worldPos); return reflect(-viewDir,worldNormal); }\nfn performWorldRayMarching(startWorldPos:vec3<f32>,rayDir:vec3<f32>) -> vec4<f32> { let cameraWorldPos=systemUniforms.camera.inverseCameraMatrix[3].xyz; let cameraDistance=length(startWorldPos - cameraWorldPos); let distanceScale=1.0 + cameraDistance * 0.1; let adaptiveStepSize=uniforms.stepSize * min(distanceScale,4.0); let stepScale=1.0 + cameraDistance * 0.067; let adaptiveMaxSteps=u32(f32(uniforms.maxSteps) * min(stepScale,2.0)); let maxDistanceSq=uniforms.maxDistance * uniforms.maxDistance; let texDims=getTextureDimensions(); let texSizeF=vec2<f32>(texDims); let maxRefinementLevels=4u; let invMaxSteps=1.0/f32(adaptiveMaxSteps); var currentWorldPos=startWorldPos + rayDir * 0.01; var currentStepSize=adaptiveStepSize; var refinementLevel=0u; for (var i=0u;i < adaptiveMaxSteps;i++) { currentWorldPos +=rayDir * currentStepSize; let travelVec=currentWorldPos - startWorldPos; let travelDistanceSq=dot(travelVec,travelVec); if (travelDistanceSq > maxDistanceSq) { break; } let currentScreenUV=worldToScreen(currentWorldPos); if (any(currentScreenUV < vec2<f32>(0.0)) || any(currentScreenUV > vec2<f32>(1.0))) { break; } let screenCoord=vec2<i32>(currentScreenUV * texSizeF); let sampledDepth=textureLoad(depthTexture,screenCoord,0); if (sampledDepth >=0.999) { continue; } let sampledWorldPos=reconstructWorldPosition(screenCoord,sampledDepth); let rayDistanceFromCamera=length(currentWorldPos - cameraWorldPos); let surfaceDistanceFromCamera=length(sampledWorldPos - cameraWorldPos); let distanceDiff=rayDistanceFromCamera - surfaceDistanceFromCamera; let intersectionThreshold=currentStepSize * (4.0 + cameraDistance * 0.033); if (distanceDiff > 0.0 && distanceDiff < intersectionThreshold) { if (refinementLevel < maxRefinementLevels) { currentWorldPos -=rayDir * currentStepSize; currentStepSize *=0.6; refinementLevel++; continue; } let reflectionColor=textureLoad(sourceTexture,screenCoord); let travelDistance=sqrt(travelDistanceSq); let distanceFade=1.0 - smoothstep(0.0,uniforms.fadeDistance,travelDistance); let edgeFade=calculateEdgeFade(currentScreenUV); let stepFade=1.0 - f32(i) * invMaxSteps; let distanceCompensation=min(1.5,1.0 + cameraDistance * 0.04); let totalFade=distanceFade * edgeFade * stepFade * distanceCompensation; return vec4<f32>(reflectionColor.rgb,totalFade); } } return vec4<f32>(0.0);\n}\n")),this.maxSteps=this.#cr,this.maxDistance=this.#hr,this.stepSize=this.#fr,this.reflectionIntensity=this.#dr,this.fadeDistance=this.#mr,this.edgeFade=this.#pr}get maxSteps(){return this.#cr}set maxSteps(i){validateNumberRange(i,1,512),this.#cr=i,this.updateUniform("maxSteps",i)}get maxDistance(){return this.#hr}set maxDistance(i){validatePositiveNumberRange(i,1,200),this.#hr=i,this.updateUniform("maxDistance",i)}get stepSize(){return this.#fr}set stepSize(i){validatePositiveNumberRange(i,.001,5),this.#fr=i,this.updateUniform("stepSize",i)}get reflectionIntensity(){return this.#dr}set reflectionIntensity(i){validateNumberRange(i,0,5),this.#dr=i,this.updateUniform("reflectionIntensity",i)}get fadeDistance(){return this.#mr}set fadeDistance(i){validatePositiveNumberRange(i,1,100),this.#mr=i,this.updateUniform("fadeDistance",i)}get edgeFade(){return this.#pr}set edgeFade(i){validateNumberRange(i,0,.5),this.#pr=i,this.updateUniform("edgeFade",i)}}Object.freeze(SSR);class TAASharpen extends ASinglePassPostEffect{#gr=.5;constructor(i){super(i),this.init(i,"POST_EFFECT_TAA_SHARPEN",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy);\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nif (any(index >=dimensions)) { return;\n}\nlet centerRGBA=textureLoad(sourceTexture,index);\nlet leftRGBA=textureLoad(sourceTexture,index - vec2<u32>(select(0u,1u,index.x > 0u),0u));\nlet rightRGBA=textureLoad(sourceTexture,min(index + vec2<u32>(1u,0u),dimensions - 1u));\nlet upRGBA=textureLoad(sourceTexture,index - vec2<u32>(0u,select(0u,1u,index.y > 0u)));\nlet downRGBA=textureLoad(sourceTexture,min(index + vec2<u32>(0u,1u),dimensions - 1u));\nlet lumaWeight=vec3<f32>(0.299,0.587,0.114);\nlet lCenter=dot(centerRGBA.rgb,lumaWeight);\nlet lLeft=dot(leftRGBA.rgb,lumaWeight);\nlet lRight=dot(rightRGBA.rgb,lumaWeight);\nlet lUp=dot(upRGBA.rgb,lumaWeight);\nlet lDown=dot(downRGBA.rgb,lumaWeight);\nlet minL=min(lCenter,min(min(lLeft,lRight),min(lUp,lDown)));\nlet maxL=max(lCenter,max(max(lLeft,lRight),max(lUp,lDown)));\nlet contrast=maxL - minL;\nvar finalRGBA:vec4<f32>;\nlet k=uniforms.sharpness * 0.2;\nif (contrast > 0.001) { let edgeRGB=4.0 * centerRGBA.rgb - (leftRGBA.rgb + rightRGBA.rgb + upRGBA.rgb + downRGBA.rgb); let sharpRGB=centerRGBA.rgb + edgeRGB * k; let edgeAlpha=4.0 * centerRGBA.a - (leftRGBA.a + rightRGBA.a + upRGBA.a + downRGBA.a); let sharpAlpha=centerRGBA.a + edgeAlpha * k; finalRGBA=vec4<f32>(sharpRGB,sharpAlpha);\n} else { finalRGBA=centerRGBA;\n}\ntextureStore(outputTexture,index,saturate(finalRGBA));","struct Uniforms { sharpness:f32\n};")),this.sharpness=.5}get sharpness(){return this.#gr}set sharpness(i){validateNumberRange(i,0,1),this.#gr=i,this.updateUniform("sharpness",i)}}Object.freeze(TAASharpen);class PostEffectManager{#Rt;#xr=[];#_r;#vr;#br;#ie=16;#ae=4;#yr=1;#Sr;#Tr;#Mr;#wr;#Cr;#Rr;#Pr;#F=0;#Br;#Ir;#Er;#Dr;#Lr;#Ur=!1;#Ar;#Or=!1;constructor(i){this.#Rt=i,this.#ft()}get useSSAO(){return this.#Ur}set useSSAO(i){this.#Ur=i,this.#kr()}get ssao(){return this.#Lr||(this.#Lr=new SSAO(this.#Rt.redGPUContext)),this.#Lr}get useSSR(){return this.#Or}set useSSR(i){this.#Or=i,this.#Gr()}get ssr(){return this.#Ar||(this.#Ar=new SSR(this.#Rt.redGPUContext)),this.#Ar}get postEffectSystemUniformBuffer(){return this.#Rr}get view(){return this.#Rt}get effectList(){return this.#xr}get videoMemorySize(){return this.#Zn(),this.#F}addEffect(i){this.#xr.push(i)}getEffectAt(i){return this.#xr[i]}removeAllEffect(){this.#xr.forEach(i=>{i.clear()}),this.#xr.length=0}render(){const{viewRenderTextureManager:i,redGPUContext:m,taa:g,fxaa:_,toneMappingManager:b}=this.#Rt,{antialiasingManager:y}=m,{useMSAA:T,useFXAA:w,useTAA:P}=y,{gBufferColorTextureView:H,gBufferColorResolveTextureView:$,gBufferColorTexture:W}=i,{width:q,height:ye}=W,Ge=T?$:H;this.#Fr(),this.#vr=this.#Nr(this.#Rt,Ge);let Ke={texture:this.#_r,textureView:this.#vr};return Ke=b.render(q,ye,Ke),this.#xr.forEach(i=>{Ke=i.render(this.#Rt,q,ye,Ke)}),w&&(Ke=_.render(this.#Rt,q,ye,Ke)),this.#Ur&&(Ke=this.ssao.render(this.#Rt,q,ye,Ke)),this.#Or&&(Ke=this.ssr.render(this.#Rt,q,ye,Ke)),P&&("View3D"===this.#Rt.constructor.name?(Ke=g.render(this.#Rt,q,ye,Ke),this.#Dr||(this.#Dr=new TAASharpen(m)),Ke=this.#Dr.render(this.#Rt,q,ye,Ke)):Ke=_.render(this.#Rt,q,ye,Ke)),Ke}clear(){this.#xr.forEach(i=>{i.clear()})}#kr(){!this.#Lr&&this.#Ur&&(this.#Lr=new SSAO(this.#Rt.redGPUContext))}#Gr(){!this.#Ar&&this.#Or&&(this.#Ar=new SSR(this.#Rt.redGPUContext))}#Vr(i){i.forEach(({key:i,value:m,dataView:g,targetMembers:_})=>{const b=_[i];g.set("number"==typeof m?[m]:m,b.uniformOffset/b.View.BYTES_PER_ELEMENT)})}#Fr(){const{inverseProjectionMatrix:i,projectionMatrix:m,rawCamera:g,redGPUContext:_,scene:b}=this.#Rt,{gpuDevice:y}=_,{modelMatrix:T,position:w}=g,P=this.#Pr,H=this.#Rr.gpuBuffer,$=g instanceof Camera2D,W=multiply(Hn,m,T);{const{members:_}=P,b=_.camera.members;this.#Vr([{key:"projectionMatrix",value:m,dataView:this.#Ir,targetMembers:_},{key:"inverseProjectionMatrix",value:i,dataView:this.#Ir,targetMembers:_},{key:"projectionCameraMatrix",value:W,dataView:this.#Ir,targetMembers:_},{key:"inverseProjectionCameraMatrix",value:invert($n,W),dataView:this.#Ir,targetMembers:_},{key:"cameraMatrix",value:T,dataView:this.#Ir,targetMembers:b},{key:"inverseCameraMatrix",value:invert($n,T),dataView:this.#Ir,targetMembers:b},{key:"cameraPosition",value:w,dataView:this.#Ir,targetMembers:b},{key:"nearClipping",value:$?0:g.nearClipping,dataView:this.#Ir,targetMembers:b},{key:"farClipping",value:$?0:g.farClipping,dataView:this.#Ir,targetMembers:b},{key:"fieldOfView",value:g.fieldOfView*Math.PI/180,dataView:this.#Ir,targetMembers:b}])}y.queue.writeBuffer(H,0,this.#Br)}#ft(){const{redGPUContext:i}=this.#Rt,{gpuDevice:m,resourceManager:g}=i,_=this.#zr();this.#Sr=g.createGPUShaderModule("POST_EFFECT_TEXTURE_COPY_COMPUTE_SHADER",{code:_}),this.#Mr=this.#Hr(i),this.#wr=this.#$r(m,this.#Sr,this.#Mr);const b=parseWGSL(_n).uniforms.systemUniforms,y=new ArrayBuffer(b.arrayBufferByteLength);this.#Pr=b,this.#Rr=new UniformBuffer(i,y,`${this.#Rt.name}_POST_EFFECT_SYSTEM_UNIFORM_BUFFER`),this.#Br=new ArrayBuffer(this.#Pr.endOffset),this.#Ir=new Float32Array(this.#Br),this.#Er=new Uint32Array(this.#Br)}#Zn(){const i=this.#_r;if(!i)return 0;this.#F=calculateTextureByteSize(i),this.#xr.forEach(i=>{this.#F+=i.videoMemorySize})}#Nr(i,m){const{redGPUContext:g,viewRenderTextureManager:_}=i,{gBufferColorTexture:b}=_,{gpuDevice:y,antialiasingManager:T,resourceManager:w}=g,{useMSAA:P,changedMSAA:H}=T,{width:$,height:W}=b,q=$!==this.#Cr?.width||W!==this.#Cr?.height;return q&&(this.#_r&&(this.#_r.destroy(),this.#_r=null),this.#_r=this.#Kr(y,$,W),this.#br=w.getGPUResourceBitmapTextureView(this.#_r)),(q||H)&&(this.#Tr=this.#Wr(g,this.#Mr,m,this.#br)),this.#Cr={width:$,height:W},this.#jr(y,this.#wr,this.#Tr,$,W),this.#br}#zr(){return`\n\t @group(0) @binding(0) var sourceTextureSampler:sampler; @group(0) @binding(1) var sourceTexture:texture_2d<f32>; @group(0) @binding(2) var outputTexture:texture_storage_2d<rgba16float,write>;  @compute @workgroup_size(${this.#ie},${this.#ae},${this.#yr}) fn main ( @builtin(global_invocation_id) global_id:vec3<u32>, ){ let index=vec2<u32>(global_id.xy ); let dimensions:vec2<u32>=textureDimensions(sourceTexture); let dimW=f32(dimensions.x); let dimH=f32(dimensions.y); let uv=\tvec2<f32>((f32(index.x)+0.5)/dimW,(f32(index.y)+0.5)/dimH); var color:vec4<f32>=textureSampleLevel( sourceTexture, sourceTextureSampler, uv, 0 );  textureStore(outputTexture,index,color ); }; `}#Hr(i){return i.resourceManager.createBindGroupLayout(`${this.#Rt.name}_POST_EFFECT_TEXTURE_COPY_BIND_GROUP_LAYOUT`,{entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,sampler:{type:"filtering"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{}},{binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float"}}]})}#Kr(i,m,g){return this.#Rt.redGPUContext.resourceManager.createManagedTexture({size:{width:m,height:g},format:"rgba16float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC,label:`${this.#Rt.name}_POST_EFFECT_STORAGE_TEXTURE_${m}x${g}`})}#Wr(i,m,g,_){const b=Date.now();return i.gpuDevice.createBindGroup({label:`${this.#Rt.name}_POST_EFFECT_TEXTURE_COPY_BIND_GROUP_${b}`,layout:m,entries:[{binding:0,resource:new Sampler(i).gpuSampler},{binding:1,resource:g},{binding:2,resource:_}]})}#$r(i,m,g){return i.createComputePipeline({label:"POST_EFFECT_TEXTURE_COPY_COMPUTE_PIPELINE",layout:i.createPipelineLayout({label:"POST_EFFECT_TEXTURE_COPY_PIPELINE_LAYOUT",bindGroupLayouts:[g]}),compute:{module:m,entryPoint:"main"}})}#jr(i,m,g,_,b){const y=i.createCommandEncoder({label:"POST_EFFECT_TEXTURE_COPY_COMMAND_ENCODER"}),T=y.beginComputePass({label:"POST_EFFECT_TEXTURE_COPY_COMPUTE_PASS"});T.setPipeline(m),T.setBindGroup(0,g),T.dispatchWorkgroups(Math.ceil(_/this.#ie),Math.ceil(b/this.#ae)),T.end(),i.queue.submit([y.finish()])}}let Hn=create$2(),$n=create$2();function defineProperty_boolean(i,m=!1){return defineBoolean(i,m,!1)}function defineProperty_uintRange(i,m=0,g,_){return defineUintRange(i,m,!1,g,_)}function defineProperty_PositiveNumberRange(i,m=1,g,_){return definePositiveNumberRange(i,m,!1,g,_)}Object.freeze(PostEffectManager);const Kn={USE_BILLBOARD_PERSPECTIVE:"useBillboardPerspective",USE_BILLBOARD:"useBillboard",RECEIVE_SHADOW:"receiveShadow"},Wn={BILLBOARD_FIXED_SCALE:"billboardFixedScale"},jn={},Xn={...createDefineByPreset({defineBoolean:[defineProperty_boolean,Kn],defineUint:[defineProperty_uintRange,jn],definePositiveNumber:[defineProperty_PositiveNumberRange,Wn]}),defineBoolean:defineProperties(defineProperty_boolean),defineUint:defineProperties(defineProperty_uintRange),definePositiveNumber:defineProperties(defineProperty_PositiveNumberRange),defineVec4:defineProperties(function(i,m=[0,0,0,0]){return defineVector(i,m,!1)}),defineVec3:defineProperties(function(i,m=[0,0,0]){return defineVector(i,m,!1)}),defineVec2:defineProperties(function(i,m=[0,0]){return defineVector(i,m,!1)}),PRESET_BOOLEAN:Kn,PRESET_POSITIVE_NUMBER:Wn,PRESET_UINT:jn,PRESET_SAMPLER:{},PRESET_TEXTURE:{},PRESET_CUBE_TEXTURE:{},PRESET_VEC2:{},PRESET_VEC3:{},PRESET_VEC4:{},PRESET_COLOR_RGB:{}};Object.freeze(Xn);class GeometryGPURenderInfo{buffers;constructor(i){this.buffers=i}}Object.freeze(GeometryGPURenderInfo);class AABB{minX;maxX;minY;maxY;minZ;maxZ;centerX;centerY;centerZ;xSize;ySize;zSize;geometryRadius;constructor(i,m,g,_,b,y){this.minX=i,this.maxX=m,this.minY=g,this.maxY=_,this.minZ=b,this.maxZ=y,this.centerX=(m+i)/2,this.centerY=(_+g)/2,this.centerZ=(y+b)/2,this.xSize=m-i,this.ySize=_-g,this.zSize=y-b,this.geometryRadius=Math.sqrt((this.xSize/2)**2+(this.ySize/2)**2+(this.zSize/2)**2)}intersects(i){return i instanceof AABB||consoleAndThrowError("allow only AABB instance"),this.minX<=i.maxX&&this.maxX>=i.minX&&this.minY<=i.maxY&&this.maxY>=i.minY&&this.minZ<=i.maxZ&&this.maxZ>=i.minZ}contains(i,m,g){if(Array.isArray(i)){const[m,g,_]=i;return m>=this.minX&&m<=this.maxX&&g>=this.minY&&g<=this.maxY&&_>=this.minZ&&_<=this.maxZ}return i>=this.minX&&i<=this.maxX&&m>=this.minY&&m<=this.maxY&&g>=this.minZ&&g<=this.maxZ}clone(){return new AABB(this.minX,this.maxX,this.minY,this.maxY,this.minZ,this.maxZ)}}const calculateGeometryAABB=i=>{if(!i||!i.data||0===i.vertexCount)return new AABB(0,0,0,0,0,0);const m=i.stride,g=i.data,_=i.vertexCount;let b=1/0,y=1/0,T=1/0,w=-1/0,P=-1/0,H=-1/0,$=0;for(;$<=_-4;$+=4){let i=$*m;const _=g[i],W=g[i+1],q=g[i+2];i=($+1)*m;const ye=g[i],Ge=g[i+1],Ke=g[i+2];i=($+2)*m;const je=g[i],Xe=g[i+1],Ye=g[i+2];i=($+3)*m;const Ze=g[i],Je=g[i+1],Qe=g[i+2];_<b&&(b=_),ye<b&&(b=ye),je<b&&(b=je),Ze<b&&(b=Ze),_>w&&(w=_),ye>w&&(w=ye),je>w&&(w=je),Ze>w&&(w=Ze),W<y&&(y=W),Ge<y&&(y=Ge),Xe<y&&(y=Xe),Je<y&&(y=Je),W>P&&(P=W),Ge>P&&(P=Ge),Xe>P&&(P=Xe),Je>P&&(P=Je),q<T&&(T=q),Ke<T&&(T=Ke),Ye<T&&(T=Ye),Qe<T&&(T=Qe),q>H&&(H=q),Ke>H&&(H=Ke),Ye>H&&(H=Ye),Qe>H&&(H=Qe)}for(;$<_;$++){const i=$*m,_=g[i],W=g[i+1],q=g[i+2];_<b&&(b=_),W<y&&(y=W),q<T&&(T=q),_>w&&(w=_),W>P&&(P=W),q>H&&(H=q)}return new AABB(b,w,y,P,T,H)};class Geometry extends ResourceBase{gpuRenderInfo;#Xr;#qr;#Yr;constructor(i,m,g){super(i),this.#Zr(m),this.#Jr(g);const{interleavedStruct:_}=this.#Xr;this.gpuRenderInfo=new GeometryGPURenderInfo([{arrayStride:_.arrayStride,attributes:_.attributes}])}get vertexBuffer(){return this.#Xr}get indexBuffer(){return this.#qr}get volume(){return this.#Yr||(this.#Yr=calculateGeometryAABB(this.#Xr)),this.#Yr}#Zr(i){const m=this.#Xr;this.#Xr=i,m&&m.__removeDirtyPipelineListener(this.#Qr),i&&i.__addDirtyPipelineListener(this.#Qr),this.#Yr=null}#Jr(i){const m=this.#qr;this.#qr=i,m&&m.__removeDirtyPipelineListener(this.#ei),i&&i.__addDirtyPipelineListener(this.#ei)}#Qr(){this.__fireListenerList()}#ei(){this.__fireListenerList()}}Object.freeze(Geometry);const qn={UINT16:"uint16",UINT32:"uint32"};Object.freeze(qn);class ResourceStateIndexBuffer{static dirtyList=[];buffer;label;uuid;#Ot=0;constructor(i){this.buffer=i,this.label=i.name,this.uuid=i.uuid}get useNum(){return this.#Ot}set useNum(i){this.#Ot=i,ResourceStateIndexBuffer.dirtyList.push(this)}}class IndexBuffer extends ABaseBuffer{[mn];#ti=0;#ni=0;#V=qn.UINT32;constructor(i,m,g=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,_=""){super(i,"managedIndexBufferState",g);const{table:b}=this.targetResourceManagedState,y=b.get(_);if(y)return y.buffer;_&&(this.name=_,this[xn]=_),this.changeData(m),this.redGPUContext.resourceManager.registerManagementResource(this,new ResourceStateIndexBuffer(this))}get format(){return this.#V}get triangleCount(){return this.#ni}get indexCount(){return this.#ti}get data(){return this[mn]}changeData(i){const{gpuDevice:m}=this;if(Array.isArray(i)&&(i=new Uint32Array(i)),this[dn]){this.targetResourceManagedState.videoMemory-=this[mn].byteLength||0;let i=this[dn];requestAnimationFrame(()=>{i.destroy()}),this[dn]=null}this[mn]=i,this.#ti=i.length;const g={size:this[mn].byteLength,usage:this.usage,label:this.name};this[dn]=m.createBuffer(g),this.targetResourceManagedState.videoMemory+=this[mn].byteLength||0,this.#ni=this.#ti/3,m.queue.writeBuffer(this[dn],0,this[mn])}}Object.freeze(IndexBuffer);class ResourceStateVertexBuffer{static dirtyList=[];buffer;label;uuid;#Ot=0;constructor(i){this.buffer=i,this.label=i.name,this.uuid=i.uuid}get useNum(){return this.#Ot}set useNum(i){this.#Ot=i,ResourceStateVertexBuffer.dirtyList.push(this)}}class VertexBuffer extends ABaseBuffer{[mn];#ri=0;#ii=0;#ai;#ni=0;constructor(i,m,g,_=GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE,b=""){super(i,"managedVertexBufferState",_);const{table:y}=this.targetResourceManagedState,T=y.get(b);if(T)return T.buffer;this.#ai=g,b&&(this.name=b,this[xn]=b),this.changeData(m,this.#ai),this.redGPUContext.resourceManager.registerManagementResource(this,new ResourceStateVertexBuffer(this))}get data(){return this[mn]}get stride(){return this.#ii}get interleavedStruct(){return this.#ai}get vertexCount(){return this.#ri}get triangleCount(){return this.#ni}changeData(i,m){const{gpuDevice:g}=this;if(Array.isArray(i)&&(i=new Float32Array(i)),this[mn]=i,m&&this.#si(m),this[dn]){this.targetResourceManagedState.videoMemory-=this[mn].byteLength||0;let i=this[dn];requestAnimationFrame(()=>{i.destroy()}),this[dn]=null}const _={size:this[mn].byteLength,usage:this.usage,label:this.name};this[dn]=g.createBuffer(_),this.targetResourceManagedState.videoMemory+=this[mn].byteLength||0,this.#ni=this[mn].length/this.#ii,g.queue.writeBuffer(this[dn],0,this[mn])}updateData(i,m=0){i instanceof Array&&(i=new Float32Array(i));const{gpuDevice:g}=this;g.queue.writeBuffer(this[dn],m,i)}updateAllData(i){const{gpuDevice:m}=this;m.queue.writeBuffer(this[dn],0,this[mn])}#si(i){this.#ai=i,this.#ri=0,this.#ii=0;for(const i in this.#ai.define){const m=this.#ai.define[i].attributeStride/Float32Array.BYTES_PER_ELEMENT;this.#ri+=m,this.#ii+=m}this.#ri=this[mn].length/this.#ri}}Object.freeze(VertexBuffer);class VertexInterleavedStructElement{attributeName;attributeStride;interleaveType;constructor(i,m,g){this.attributeName=i,this.attributeStride=m,this.interleaveType=g}}class VertexInterleavedStruct{#oi;#h="";#ui=[];#li=0;constructor(i,m=""){this.#h=m,this.#ci(i),this.#hi()}get label(){return this.#h}get attributes(){return this.#ui}get arrayStride(){return this.#li}get define(){return{...this.#oi}}#ci(i){let m={};for(const g in i){const _=i[g],b=_.stride;m[g]=new VertexInterleavedStructElement(g,b,_),b%4!=0&&consoleAndThrowError(`Invalid attribute stride:${b}`)}this.#oi=m}#hi(){this.#li=0,this.#ui=[];for(const[i,{attributeStride:m,interleaveType:g}]of Object.entries(this.#oi))this.#ui.push({attributeName:i,shaderLocation:this.#ui.length,offset:this.#li,format:g.gpuVertexFormat}),this.#li+=m}}class VertexInterleaveType{static get float32(){return{numElements:1,stride:Float32Array.BYTES_PER_ELEMENT,gpuVertexFormat:"float32",offset:0}}static get float32x2(){return{numElements:2,stride:2*Float32Array.BYTES_PER_ELEMENT,gpuVertexFormat:"float32x2",offset:0}}static get float32x3(){return{numElements:3,stride:3*Float32Array.BYTES_PER_ELEMENT,gpuVertexFormat:"float32x3",offset:0}}static get float32x4(){return{numElements:4,stride:4*Float32Array.BYTES_PER_ELEMENT,gpuVertexFormat:"float32x4",offset:0}}}Object.freeze(VertexInterleaveType);class Primitive{#fi;#Xr;#qr;#Yr;constructor(i){validateRedGPUContext(i)}static get primitiveInterleaveStruct(){return new VertexInterleavedStruct({vertexPosition:VertexInterleaveType.float32x3,vertexNormal:VertexInterleaveType.float32x3,texcoord:VertexInterleaveType.float32x2},"primitiveInterleaveStruct")}get gpuRenderInfo(){return this.#fi}get vertexBuffer(){return this.#Xr}get indexBuffer(){return this.#qr}get volume(){return this.#Yr||(this.#Yr=calculateGeometryAABB(this.#Xr)),this.#Yr}_setData(i){if(this.#Xr=i.vertexBuffer,this.#qr=i.indexBuffer,this.#Xr){const{interleavedStruct:i}=this.#Xr;this.#fi=new GeometryGPURenderInfo([{arrayStride:i.arrayStride,attributes:i.attributes}])}}}Object.freeze(Primitive);const createPrimitiveGeometry=(i,m,g,_)=>new Geometry(i,new VertexBuffer(i,new Float32Array(m),Primitive.primitiveInterleaveStruct,void 0,`VertexBuffer_${_}`),new IndexBuffer(i,new Uint32Array(g),void 0,`IndexBuffer_${_}`));class Plane extends Primitive{#di=function(){const i=[],m=[];return function(g,_,b,y,T,w,P,H){const $=b/2,W=y/2,q=Math.floor(T)||1,ye=Math.floor(w)||1,Ge=q+1,Ke=ye+1,je=b/q,Xe=y/ye;i.length=0,m.length=0;for(let g=0;g<Ke;g++){const _=g*Xe-W,b=H?(1-g/ye)*P:g/ye*P;for(let y=0;y<Ge;y++){const T=y*je-$,w=y/q*P;if(i.push(T,-_,0,0,0,1,w,b),g<ye&&y<q){const i=y+Ge*g,_=y+Ge*(g+1),b=y+1+Ge*(g+1),T=y+1+Ge*g;m.push(i,_,T),m.push(_,b,T)}}}return createPrimitiveGeometry(_,i,m,g)}}();constructor(i,m=1,g=1,_=1,b=1,y=1,T=!1){super(i);const w=`PRIMITIVE_PLANE_W${m}_H${g}_WS${_}_HS${b}_UV${y}_FY${T}`,P=i.resourceManager.cachedBufferState;let H=P[w];H||(H=P[w]=this.#di(w,i,m,g,_,b,y,T)),this._setData(H)}}class PerspectiveCamera{#f;#mi=new Float32Array([0,1,0]);#Tt=create$2();#Mt=0;#Ct=0;#wt=0;#pi=0;#gi=0;#xi=0;#_i=60;#vi=.01;#bi=1e4;#h;constructor(){}get rotationX(){return this.#pi}set rotationX(i){this.#pi=i}get rotationY(){return this.#gi}set rotationY(i){this.#gi=i}get rotationZ(){return this.#xi}set rotationZ(i){this.#xi=i}get fieldOfView(){return this.#_i}set fieldOfView(i){validateNumber(i),this.#_i=i}get nearClipping(){return this.#vi}set nearClipping(i){validateNumber(i),this.#vi=i}get farClipping(){return this.#bi}set farClipping(i){validateNumber(i),this.#bi=i}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get modelMatrix(){return this.#Tt}get x(){return this.#Mt}set x(i){this.#Mt=i,this.#Tt[12]=i}get y(){return this.#wt}set y(i){this.#wt=i,this.#Tt[13]=i}get z(){return this.#Ct}set z(i){this.#Ct=i,this.#Tt[14]=i}get position(){return[this.#Mt,this.#wt,this.#Ct]}setPosition(i,m,g){Array.isArray(i)?[this.#Mt,this.#wt,this.#Ct]=i:(this.#Mt=i,this.#wt=m,this.#Ct=g),[this.#Tt[12],this.#Tt[13],this.#Tt[14]]=[this.#Mt,this.#wt,this.#Ct]}lookAt(i,m,g){const _=[this.#Mt,this.#wt,this.#Ct],b=[i,m,g],y=[this.#mi[0],this.#mi[1],this.#mi[2]],T=[b[0]-_[0],b[1]-_[1],b[2]-_[2]],w=Math.sqrt(T[0]*T[0]+T[1]*T[1]+T[2]*T[2]);T[0]/=w,T[1]/=w,T[2]/=w;const P=[T[1]*y[2]-T[2]*y[1],T[2]*y[0]-T[0]*y[2],T[0]*y[1]-T[1]*y[0]];Math.sqrt(P[0]*P[0]+P[1]*P[1]+P[2]*P[2])<1e-4&&(y[2]=T[1]>0?1:-1,y[0]=0,y[1]=0),lookAt(this.#Tt,_,b,y)}}class OrthographicCamera extends PerspectiveCamera{#f;#h;#yi=1;#Si=-1;#Ti=-1;#Mi=1;#wi=1;#Ci=.1;#Ri=10;constructor(){super(),this.nearClipping=.01,this.farClipping=1e4}get top(){return this.#yi}set top(i){validateNumber(i),this.#yi=i}get bottom(){return this.#Si}set bottom(i){validateNumber(i),this.#Si=i}get left(){return this.#Ti}set left(i){validateNumber(i),this.#Ti=i}get right(){return this.#Mi}set right(i){validateNumber(i),this.#Mi=i}get zoom(){return this.#wi}set zoom(i){validateNumberRange(i,this.#Ci,this.#Ri),this.#wi=i}get minZoom(){return this.#Ci}set minZoom(i){validateNumberRange(i,.01),this.#Ci=i}get maxZoom(){return this.#Ri}set maxZoom(i){validateNumberRange(i,.01),this.#Ri=i}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}setZoom(i){this.zoom=i}}class AController{static#Pi=null;static#Bi=null;#f;#h;#l;#Ii;#Ei;#Di=-1;#Li=new Set;#Ui=!1;#Ai=null;#Oi=!1;#ki;#Gi=0;#Fi=0;#Ni=0;#Vi=!1;constructor(i,m){this.#l=i,this.#Ei=m||{},this.#Ii=m.camera||new PerspectiveCamera;const g=this.#l.detector.isMobile;this.#ki={moveKey:g?"touchmove":"mousemove",upKey:g?"touchend":"mouseup",downKey:g?"touchstart":"mousedown"},this.#zi()}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get redGPUContext(){return this.#l}get camera(){return this.#Ii}get hoveredView(){return this.#Ai}get keyboardActiveView(){return AController.#Pi}set keyboardActiveView(i){AController.#Pi=i,AController.#Bi=null===i?null:this}get isKeyboardActiveController(){return AController.#Bi===this}get keyboardProcessedThisFrame(){return this.#Ui}set keyboardProcessedThisFrame(i){this.#Ui=i}destroy(){const{moveKey:i,upKey:m,downKey:g}=this.#ki,{htmlCanvas:_}=this.redGPUContext;_.removeEventListener(g,this.#Hi),_.removeEventListener(i,this.#$i),_.removeEventListener(i,this.#Ki),window.removeEventListener(m,this.#Wi),this.#Ei.HD_Wheel&&_.removeEventListener("wheel",this.#ji)}update(i,m,g){this.#Di!==m&&(this.#Di=m,this.#Li.clear(),this.#Ui=!1),this.#Li.has(i)||(this.#Li.add(i),this.#Ei.useKeyboard&&this.keyboardActiveView&&this.keyboardActiveView!==i||g?.())}checkKeyboardInput(i,m){if(this.keyboardProcessedThisFrame)return!1;const{keyboardKeyBuffer:g}=i.redGPUContext;let _=!1;for(const i in m)if(g[m[i]]){_=!0;break}if(!_)return this.keyboardActiveView=null,!1;if(!this.keyboardActiveView){if(this.hoveredView!==i)return!1;this.keyboardActiveView=i}return this.keyboardActiveView===i&&(this.keyboardProcessedThisFrame=!0,!0)}getCanvasEventPoint=(i,m)=>{m.htmlCanvas;const g=m.detector.isMobile,_=m.boundingClientRect,b="clientX",y="clientY";let T,w;if(g){const m=i instanceof WheelEvent?i:i.changedTouches[0];T=m[b],w=m[y]}else{const m=i;T=m[b],w=m[y]}return{x:T-_.left,y:w-_.top}};findTargetViewByInputEvent=i=>{const m=this.#l;m.detector.isMobile;const{x:g,y:_}=this.getCanvasEventPoint(i,m),b=window.devicePixelRatio*m.renderScale,y=g*b,T=_*b;let w=null;for(const i of this.redGPUContext.viewList){const m=i.pixelRectObject;m.x<y&&y<m.x+m.width&&m.y<T&&T<m.y+m.height&&(w=i)}return w};#Xi=i=>{if(i.length<2)return 0;const m=i[0].clientX-i[1].clientX,g=i[0].clientY-i[1].clientY;return Math.sqrt(m*m+g*g)};#zi(){const{redGPUContext:i}=this,{htmlCanvas:m}=i,{downKey:g,moveKey:_}=this.#ki;m.addEventListener(g,this.#Hi),m.addEventListener(_,this.#$i),this.#Ei.HD_Wheel&&m.addEventListener("wheel",this.#ji,{passive:!1}),this.#Ei.HD_TouchPinch&&m.addEventListener("touchmove",this.#qi,{passive:!1})}#$i=i=>{AController.#Pi||this.#Oi||(this.#Ai=this.findTargetViewByInputEvent(i))};#Hi=i=>{const m=this.findTargetViewByInputEvent(i);if(!m)return;AController.#Pi||this.#Oi||(this.#Ai=m);const{redGPUContext:g}=this,{moveKey:_,upKey:b}=this.#ki,{x:y,y:T}=this.getCanvasEventPoint(i,g);this.#Gi=y,this.#Fi=T,i instanceof TouchEvent&&(i.touches.length>=2?(this.#Vi=!0,this.#Ni=this.#Xi(i.touches)):(this.#Vi=!1,this.#Ni=0)),this.#Li.has(m)&&(this.#Oi=!0,AController.#Pi=m,g.htmlCanvas.addEventListener(_,this.#Ki),window.addEventListener(b,this.#Wi))};#Ki=i=>{if(i instanceof TouchEvent&&i.touches.length>=2)return void(this.#Vi=!0);this.#Vi=!1;const{x:m,y:g}=this.getCanvasEventPoint(i,this.#l),_=m-this.#Gi,b=g-this.#Fi;this.#Gi=m,this.#Fi=g,this.#Ei.HD_Move?.(_,b)};#qi=i=>{if(i.touches.length<2||!this.#Ei.HD_TouchPinch)return;if(!this.#Vi)return;i.preventDefault();const m=this.#Xi(i.touches);if(0===this.#Ni)return void(this.#Ni=m);if(this.findTargetViewByInputEvent(i).rawCamera!==this.#Ii)return;const g=m/this.#Ni;this.#Ei.HD_TouchPinch?.(g),this.#Ni=m};#Wi=()=>{const{htmlCanvas:i}=this.#l,{moveKey:m,upKey:g}=this.#ki;this.#Vi=!1,this.#Ni=0,this.#Oi=!1,i.removeEventListener(m,this.#Ki),window.removeEventListener(g,this.#Wi)};#ji=i=>{const m=this.findTargetViewByInputEvent(i);m&&m.rawCamera===this.#Ii&&(i.stopPropagation(),i.preventDefault(),this.#Ei.HD_Wheel?.(i))}}const Yn=Math.PI/180;class IsometricController extends AController{#Yi=45;#Zi=1;#Ji=1;#Qi=.1;#ea=.1;#Ci=.5;#Ri=3;#ta=15;#na=15;#ra=.1;#ia=null;#aa=0;#sa=0;#oa=.25;#ua=.2;#la={moveUp:"w",moveDown:"s",moveLeft:"a",moveRight:"d"};#ca=1;#ha=.2;constructor(i){super(i,{camera:new OrthographicCamera,HD_Wheel:i=>{this.#Ji-=i.deltaY/100*this.#ea,this.#Ji=Math.max(this.#Ci,Math.min(this.#Ri,this.#Ji))},HD_Move:(m,g)=>{if(!this.#ia)return;const _=this.#Yi*Yn,b=Math.cos(_),y=Math.sin(_),T=this.#ta/this.#Zi/i.boundingClientRect.height,w=m*T,P=g*T,H=-w*b-P*y,$=-w*-y-P*b;this.#aa+=H,this.#sa+=$},HD_TouchPinch:i=>{this.#Ji/=i,this.#Ji=Math.max(this.#Ci,Math.min(this.#Ri,this.#Ji))},useKeyboard:!0}),this.#ia=new Mesh(i)}get zoom(){return this.#Ji}set zoom(i){validateNumberRange(i),i=Math.max(this.#Ci,Math.min(this.#Ri,i)),this.#Ji=i}get zoomInterpolation(){return this.#Qi}set zoomInterpolation(i){validateNumberRange(i,.01,1),this.#Qi=i}get speedZoom(){return this.#ea}set speedZoom(i){validateNumberRange(i,.01),this.#ea=i}get minZoom(){return this.#Ci}set minZoom(i){validateNumberRange(i,.01),this.#Ci=i,this.zoom=this.#Ji}get maxZoom(){return this.#Ri}set maxZoom(i){validateNumberRange(i,.01),this.#Ri=i,this.zoom=this.#Ji}get viewHeight(){return this.#na}set viewHeight(i){validateNumberRange(i,.1),this.#na=i}get viewHeightInterpolation(){return this.#ra}set viewHeightInterpolation(i){validateNumberRange(i,.01,1),this.#ra=i}get moveSpeed(){return this.#oa}set moveSpeed(i){validateNumberRange(i,.01),this.#oa=i}get moveSpeedInterpolation(){return this.#ua}set moveSpeedInterpolation(i){validateNumberRange(i,.01,1),this.#ua=i}get mouseMoveSpeed(){return this.#ca}set mouseMoveSpeed(i){validateNumberRange(i,.01),this.#ca=i}get mouseMoveSpeedInterpolation(){return this.#ha}set mouseMoveSpeedInterpolation(i){validateNumberRange(i,.01,1),this.#ha=i}get keyNameMapper(){return{...this.#la}}get x(){return this.#ia.x}get y(){return this.#ia.y}get z(){return this.#ia.z}setMoveUpKey(i){this.#la.moveUp=i}setMoveDownKey(i){this.#la.moveDown=i}setMoveLeftKey(i){this.#la.moveLeft=i}setMoveRightKey(i){this.#la.moveRight=i}update(i,m){super.update(i,m,()=>{this.#fa(i)})}#fa(i){if(this.#da(i),this.#Zi+=(this.#Ji-this.#Zi)*this.#Qi,this.#ta+=(this.#na-this.#ta)*this.#ra,!this.#ia)return;this.#ia.x+=(this.#aa-this.#ia.x)*this.#ua,this.#ia.z+=(this.#sa-this.#ia.z)*this.#ua;const m=this.#ia.position,g=this.#Yi*Yn,{width:_,height:b}=i.pixelRectObject,y=_/b,T=this.#ta/this.#Zi,w=T*y,P=this.#ta/15,H=15*P/this.#Zi,$=12*P/this.#Zi,W=m[0]+Math.cos(g)*H,q=m[1]+$,ye=m[2]+Math.sin(g)*H;this.camera.setPosition(W,q,ye),this.camera.lookAt(m[0],m[1],m[2]);const Ge=this.camera;Ge.left=-w/2,Ge.right=w/2,Ge.top=T/2,Ge.bottom=-T/2}#da(i){if(!this.checkKeyboardInput(i,this.#la))return!1;if(!this.#ia)return!1;const{keyboardKeyBuffer:m}=i.redGPUContext,g=this.#la;let _=0,b=0,y=0,T=0;m[g.moveUp]&&(_=this.#oa),m[g.moveDown]&&(b=this.#oa),m[g.moveLeft]&&(y=this.#oa),m[g.moveRight]&&(T=this.#oa);const w=this.#Yi*Yn,P=Math.cos(w),H=Math.sin(w),$=(b-_)*P+(T-y)*P,W=(b-_)*H+(T-y)*-H;this.#aa+=$,this.#sa+=W}}class DrawBufferManager{static#ma;static#pa=5;#l;#ga=[];#xa=[];#_a;#va=0;#ba=0;#ya;#Sa=new Set;constructor(i){this.#l=i,this.#Ta()}static getInstance(i){return DrawBufferManager.#ma||(DrawBufferManager.#ma=new DrawBufferManager(i)),DrawBufferManager.#ma}allocateDrawCommand(i){this.#ba>=this.#_a&&(this.#va=this.#Ma(),this.#ba=0),this.#Sa.add(this.#va);const m={bufferIndex:this.#va,commandOffset:this.#ba*DrawBufferManager.#pa,buffer:this.#ga[this.#va],dataArray:this.#xa[this.#va]};return this.#ba++,m}setIndexedIndirectCommand(i,m,g=1,_=0,b=0,y=0){const T=i.commandOffset,w=i.dataArray;w[T]=m,w[T+1]=g,w[T+2]=_,w[T+3]=b,w[T+4]=y}setInstanceNum(i,m=0){const g=i.commandOffset;i.dataArray[g+1]=m}setIndirectCommand(i,m,g=1,_=0,b=0){const y=i.commandOffset,T=i.dataArray;T[y]=m,T[y+1]=g,T[y+2]=_,T[y+3]=b}updateSingleCommand(i){const m=this.#ga[i.bufferIndex],g=this.#xa[i.bufferIndex],_=DrawBufferManager.#pa,b=4*i.commandOffset,y=_;this.#l.gpuDevice.queue.writeBuffer(m,b,g,i.commandOffset,y)}getTotalCommandCount(){let i=0;for(const m of this.#Sa)m===this.#va?i+=this.#ba:i+=this.#_a;return i}getMemoryUsage(){const i=this.#ga.length,m=this.#Sa.size,g=i*this.#ya,_=m*this.#ya;return{totalBuffers:i,usedBuffers:m,maxCommandsPerBuffer:this.#_a,totalMemory:formatBytes(g),usedMemory:formatBytes(_),totalCommands:this.getTotalCommandCount()}}flushAllCommands(i){performance.now();for(const i of this.#Sa){const m=this.#ga[i],g=this.#xa[i],_=(i===this.#va?this.#ba:this.#_a)*DrawBufferManager.#pa*4;this.#l.gpuDevice.queue.writeBuffer(m,0,g,0,_/4)}performance.now()}#Ta(){this.#wa(),this.#Ca()}#wa(){this.#l.gpuDevice.limits,this.#ya=Math.floor(.9*Math.min(268435456,134217728)),this.#_a=Math.floor(this.#ya/(4*DrawBufferManager.#pa))}#Ca(){this.#Ma()}#Ma(){const i=this.#_a*DrawBufferManager.#pa*4,m=this.#l.gpuDevice.createBuffer({size:i,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.COPY_DST,label:`DrawBuffer_${this.#ga.length}`}),g=new Uint32Array(this.#_a*DrawBufferManager.#pa);return this.#ga.push(m),this.#xa.push(g),this.#ga.length-1}}create$1(),create$1();const calculateMeshAABB=i=>{if(!i||!i._geometry){const m=i.modelMatrix;return m[12],m[13],m[14],new AABB(0,0,0,0,0,0)}const m=i._geometry.volume,{minX:g,maxX:_,minY:b,maxY:y,minZ:T,maxZ:w}=m;let P=1/0,H=1/0,$=1/0,W=-1/0,q=-1/0,ye=-1/0;const Ge=i.modelMatrix;for(let i=0;i<8;i++){const m=1&i?_:g,Ke=2&i?y:b,je=4&i?w:T,Xe=Ge[0]*m+Ge[4]*Ke+Ge[8]*je+Ge[12],Ye=Ge[1]*m+Ge[5]*Ke+Ge[9]*je+Ge[13],Ze=Ge[2]*m+Ge[6]*Ke+Ge[10]*je+Ge[14];Xe<P&&(P=Xe),Ye<H&&(H=Ye),Ze<$&&($=Ze),Xe>W&&(W=Xe),Ye>q&&(q=Ye),Ze>ye&&(ye=Ze)}return new AABB(P,W,H,q,$,ye)},calculateMeshCombinedAABB=i=>{const m=[];return collectRecursive(i,m),0===m.length?new AABB(0,0,0,0,0,0):calculateCombinedAABBFromAABBs(m)},collectRecursive=(i,m)=>{if(i._geometry){const g=i.boundingAABB;m.push(g)}if(i.children)for(let g=0;g<i.children.length;g++){const _=i.children[g];_ instanceof Mesh&&collectRecursive(_,m)}},calculateCombinedAABBFromAABBs=i=>{if(0===i.length)return new AABB(0,0,0,0,0,0);if(1===i.length)return i[0];let m=1/0,g=1/0,_=1/0,b=-1/0,y=-1/0,T=-1/0;for(let w=0;w<i.length;w++){const P=i[w];P.minX<m&&(m=P.minX),P.minY<g&&(g=P.minY),P.minZ<_&&(_=P.minZ),P.maxX>b&&(b=P.maxX),P.maxY>y&&(y=P.maxY),P.maxZ>T&&(T=P.maxZ)}return new AABB(m,b,g,y,_,T)};class OBB{centerX;centerY;centerZ;halfExtentX;halfExtentY;halfExtentZ;orientation;center;halfExtents;geometryRadius;constructor(i,m,g){this.centerX=i[0],this.centerY=i[1],this.centerZ=i[2],this.halfExtentX=m[0],this.halfExtentY=m[1],this.halfExtentZ=m[2],this.center=[this.centerX,this.centerY,this.centerZ],this.halfExtents=[this.halfExtentX,this.halfExtentY,this.halfExtentZ],this.orientation=clone(g),this.geometryRadius=Math.sqrt(this.halfExtentX**2+this.halfExtentY**2+this.halfExtentZ**2)}intersects(i){i instanceof OBB||consoleAndThrowError("allow only OBB instance");const m=subtract(create$1(),this.center,i.center);if(length(m)>this.geometryRadius+i.geometryRadius)return!1;const g=[...this.#Ra(),...i.#Ra()];for(const _ of g){const g=this.#Pa(_),b=i.#Pa(_);if(Math.abs(dot(m,_))>g+b)return!1}return!0}contains(i,m,g){let _;_=Array.isArray(i)?fromValues(i[0],i[1],i[2]):fromValues(i,m,g);const b=subtract(create$1(),_,this.center),y=this.#Ra();for(let i=0;i<3;i++){const m=dot(b,y[i]);if(Math.abs(m)>this.halfExtents[i])return!1}return!0}clone(){return new OBB([this.centerX,this.centerY,this.centerZ],[this.halfExtentX,this.halfExtentY,this.halfExtentZ],this.orientation)}#Ra(){return[fromValues(this.orientation[0],this.orientation[1],this.orientation[2]),fromValues(this.orientation[4],this.orientation[5],this.orientation[6]),fromValues(this.orientation[8],this.orientation[9],this.orientation[10])]}#Pa(i){const m=this.#Ra();return Math.abs(dot(m[0],i))*this.halfExtentX+Math.abs(dot(m[1],i))*this.halfExtentY+Math.abs(dot(m[2],i))*this.halfExtentZ}}const calculateMeshOBB=i=>{if(!i||!i._geometry){const i=create$2();return new OBB([0,0,0],[0,0,0],i)}const m=i._geometry.volume;if(0===m.minX&&0===m.maxX&&0===m.minY&&0===m.maxY&&0===m.minZ&&0===m.maxZ){const i=create$2();return new OBB([0,0,0],[0,0,0],i)}const g=[m.centerX,m.centerY,m.centerZ],_=[(m.maxX-m.minX)/2,(m.maxY-m.minY)/2,(m.maxZ-m.minZ)/2],b=create$1();transformMat4(b,g,i.modelMatrix);const y=create$2();copy$1(y,i.modelMatrix),y[12]=0,y[13]=0,y[14]=0;const T=[create$1(),create$1(),create$1()],w=[0,0,0];for(let i=0;i<3;i++){const m=[0,0,0];m[i]=_[i],transformMat4(T[i],m,y),w[i]=length(T[i]),normalize(T[i],T[i])}const P=create$2();return P[0]=T[0][0],P[1]=T[0][1],P[2]=T[0][2],P[3]=0,P[4]=T[1][0],P[5]=T[1][1],P[6]=T[1][2],P[7]=0,P[8]=T[2][0],P[9]=T[2][1],P[10]=T[2][2],P[11]=0,P[12]=0,P[13]=0,P[14]=0,P[15]=1,new OBB([b[0],b[1],b[2]],w,P)},Zn={POINT_LIST:"point-list",LINE_LIST:"line-list",LINE_STRIP:"line-strip",TRIANGLE_LIST:"triangle-list",TRIANGLE_STRIP:"triangle-strip"};Object.freeze(Zn);const Jn=parseWGSL("#redgpu_include drawPicking;\n#redgpu_include calcTintBlendMode;\n#redgpu_include FragmentOutput;\n#redgpu_include calculateMotionVector;\nstruct Uniforms { color:vec3<f32>, opacity:f32, useTint:u32, tint:vec4<f32>, tintBlendMode:u32,\n};\nstruct InputData { @builtin(position) position:vec4<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n}\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\n@fragment\nfn main(inputData:InputData) -> FragmentOutput { var output:FragmentOutput; var finalColor=vec4<f32>( uniforms.color.r,uniforms.color.g,uniforms.color.b,uniforms.opacity * inputData.combinedOpacity); #redgpu_if useTint finalColor=calcTintBlendMode(finalColor,uniforms.tintBlendMode,uniforms.tint); #redgpu_endIf if (finalColor.a==0.0) { discard; } output.color=finalColor; output.gBufferMotionVector=vec4<f32>(calculateMotionVector(inputData.currentClipPos,inputData.prevClipPos),0.0,1.0 ); return output;\n}\n");class ColorMaterial extends ABaseMaterial{constructor(i,m="#fff"){super(i,"COLOR_MATERIAL",Jn,2),this.initGPURenderInfos(),this.color.setColorByHEX(m)}}In.defineByPreset(ColorMaterial,[In.PRESET_COLOR_RGB.COLOR]),Object.freeze(ColorMaterial);class DrawDebuggerMesh{#l;#Ba;#Xr;#Ia;#Ea;#Da="AABB";#La;#Ua;#Aa=null;#Oa=null;constructor(i,m){this.#l=i,this.#Ba=m;const g=this.#ka(i);this.#Xr=g.vertexBuffer,this.#Ia=new ColorMaterial(i),this.#Ia.color.setColorByRGB(255,0,0),this.#Ea=new Mesh(i,g,this.#Ia),this.#Ea.primitiveState.cullMode="none",this.#Ea.primitiveState.topology=Zn.LINE_LIST;const _=this.#ka(i);this.#La=new ColorMaterial(i),this.#La.color.setColorByRGB(0,255,0),this.#Ua=new Mesh(i,_,this.#La),this.#Ua.primitiveState.cullMode="none",this.#Ua.primitiveState.topology=Zn.LINE_LIST}get debugMode(){return this.#Da}set debugMode(i){this.#Da=i,"OBB"===i?this.#Ia.color.setColorByRGB(255,0,0):"AABB"===i||"COMBINED_AABB"===i?this.#Ia.color.setColorByRGB(0,255,0):"BOTH"===i&&(this.#Ia.color.setColorByRGB(255,0,0),this.#La.color.setColorByRGB(0,255,0)),this.#Aa=null,this.#Oa=null}render(i){if(!this.#Ba.enableDebugger)return;if("OBB"===this.#Da){const i=this.#Ba.boundingOBB;this.#Ga(i)&&(this.#Fa(i,this.#Xr),this.#Na(i)),this.#Ea.setPosition(0,0,0),this.#Ea.setRotation(0,0,0),this.#Ea.setScale(1,1,1)}else if("AABB"===this.#Da||"COMBINED_AABB"===this.#Da){const i="COMBINED_AABB"===this.#Da?this.#Ba.combinedBoundingAABB:this.#Ba.boundingAABB;this.#Va(i)&&(this.#za(i,this.#Xr),this.#Ha(i)),this.#Ea.setPosition(0,0,0),this.#Ea.setRotation(0,0,0),this.#Ea.setScale(1,1,1)}else if("BOTH"===this.#Da){const i=this.#Ba.boundingOBB,m=this.#Ba.boundingAABB;this.#Ga(i)&&(this.#Fa(i,this.#Xr),this.#Na(i)),this.#Ea.setPosition(0,0,0),this.#Ea.setRotation(0,0,0),this.#Ea.setScale(1,1,1),this.#Va(m)&&(this.#za(m,this.#Ua.geometry.vertexBuffer),this.#Ha(m)),this.#Ua.setPosition(0,0,0),this.#Ua.setRotation(0,0,0),this.#Ua.setScale(1,1,1)}let m=!0,g=!0;{const{frustumPlanes:_}=i,b=_[0],y=_[1],T=_[2],w=_[3],P=_[4],H=_[5];{const i=this.#Ba.boundingAABB,g=i.centerX,_=i.centerY,$=i.centerZ,W=i.geometryRadius;(b[0]*g+b[1]*_+b[2]*$+b[3]<=-W||y[0]*g+y[1]*_+y[2]*$+y[3]<=-W||T[0]*g+T[1]*_+T[2]*$+T[3]<=-W||w[0]*g+w[1]*_+w[2]*$+w[3]<=-W||P[0]*g+P[1]*_+P[2]*$+P[3]<=-W||H[0]*g+H[1]*_+H[2]*$+H[3]<=-W)&&(m=!1)}{const i=this.#Ba.boundingOBB,m=i.centerX,_=i.centerY,$=i.centerZ,W=i.geometryRadius;(b[0]*m+b[1]*_+b[2]*$+b[3]<=-W||y[0]*m+y[1]*_+y[2]*$+y[3]<=-W||T[0]*m+T[1]*_+T[2]*$+T[3]<=-W||w[0]*m+w[1]*_+w[2]*$+w[3]<=-W||P[0]*m+P[1]*_+P[2]*$+P[3]<=-W||H[0]*m+H[1]*_+H[2]*$+H[3]<=-W)&&(g=!1)}}"OBB"===this.#Da?g&&this.#Ea.render(i):"AABB"===this.#Da||"COMBINED_AABB"===this.#Da?m&&this.#Ea.render(i):"BOTH"===this.#Da&&(g&&this.#Ea.render(i),m&&this.#Ua.render(i))}#ka(i){const m=new Float32Array(192),g=new VertexInterleavedStruct({vertexPosition:VertexInterleaveType.float32x3,vertexNormal:VertexInterleaveType.float32x3,texcoord:VertexInterleaveType.float32x2},`wireframeBoxStruct_${Math.random()}`),_=new VertexBuffer(i,m,g);return new Geometry(i,_)}#Ga(i){if(!this.#Aa)return!0;const m=this.#Aa;return m.center[0]!==i.center[0]||m.center[1]!==i.center[1]||m.center[2]!==i.center[2]||m.halfExtents[0]!==i.halfExtents[0]||m.halfExtents[1]!==i.halfExtents[1]||m.halfExtents[2]!==i.halfExtents[2]||!this.#$a(m.orientation,i.orientation)}#Va(i){if(!this.#Oa)return!0;const m=this.#Oa;return m.minX!==i.minX||m.maxX!==i.maxX||m.minY!==i.minY||m.maxY!==i.maxY||m.minZ!==i.minZ||m.maxZ!==i.maxZ}#$a(i,m){if(i.length!==m.length)return!1;for(let g=0;g<i.length;g++)if(Math.abs(i[g]-m[g])>1e-4)return!1;return!0}#Na(i){this.#Aa=new OBB(i.center,i.halfExtents,i.orientation)}#Ha(i){this.#Oa=i.clone()}#Fa(i,m){const{center:g,halfExtents:_,orientation:b}=i,y=[[-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1],[-1,-1,1],[1,-1,1],[1,1,1],[-1,1,1]].map(i=>{const m=[i[0]*_[0],i[1]*_[1],i[2]*_[2]],y=[b[0]*m[0]+b[4]*m[1]+b[8]*m[2],b[1]*m[0]+b[5]*m[1]+b[9]*m[2],b[2]*m[0]+b[6]*m[1]+b[10]*m[2]];return[y[0]+g[0],y[1]+g[1],y[2]+g[2]]});this.#Zr(y,m)}#za(i,m){const{minX:g,maxX:_,minY:b,maxY:y,minZ:T,maxZ:w}=i,P=[[g,b,T],[_,b,T],[_,y,T],[g,y,T],[g,b,w],[_,b,w],[_,y,w],[g,y,w]];this.#Zr(P,m)}#Zr(i,m){const g=m.data;let _=0;[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]].forEach(([m,b])=>{g[_++]=i[m][0],g[_++]=i[m][1],g[_++]=i[m][2],g[_++]=0,g[_++]=0,g[_++]=1,g[_++]=0,g[_++]=0,g[_++]=i[b][0],g[_++]=i[b][1],g[_++]=i[b][2],g[_++]=0,g[_++]=0,g[_++]=1,g[_++]=0,g[_++]=0}),m.updateAllData(g)}}Object.freeze(DrawDebuggerMesh);const Qn={MESH:"mesh",PARTICLE:"particle",INSTANCED_MESH:"instancedMesh"};Object.freeze(Qn);const createMeshVertexUniformBuffers=(i,m=!1)=>{const{gpuRenderInfo:g,redGPUContext:_}=i,{resourceManager:b}=_,y=b.getGPUBindGroupLayout(m?ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_SKIN:ResourceManager.PRESET_VERTEX_GPUBindGroupLayout),T=new ArrayBuffer(g.vertexUniformInfo.arrayBufferByteLength),w=new UniformBuffer(_,T,i.name);g.vertexBindGroupLayout=y,g.vertexUniformBuffer=w};const er=[{textureList:["baseColorTexture"],vec4List:[["baseColorFactor",[1,1,1,1]]]},{textureList:["normalTexture"]},{textureList:["metallicRoughnessTexture"],positiveNumberList:["metallicFactor","roughnessFactor"]},{textureList:["emissiveTexture"],vec3List:["emissiveFactor"]},{textureList:["occlusionTexture"],positiveNumberList:["occlusionStrength"]},{extensionName:"KHR_materials_clearcoat",textureList:["KHR_clearcoatTexture","KHR_clearcoatNormalTexture","KHR_clearcoatRoughnessTexture"],positiveNumberList:[["KHR_clearcoatFactor",0],["KHR_clearcoatRoughnessFactor",0],"KHR_clearcoatNormalScale"]},{extensionName:"KHR_materials_sheen",textureList:["KHR_sheenColorTexture","KHR_sheenRoughnessTexture"],positiveNumberList:[["KHR_sheenRoughnessFactor",0]],vec3List:[["KHR_sheenColorFactor",[0,0,0]]]},{extensionName:"KHR_materials_specular",textureList:["KHR_specularTexture","KHR_specularColorTexture"],positiveNumberList:["KHR_specularFactor"],vec3List:[["KHR_specularColorFactor",[1,1,1]]]},{extensionName:"KHR_materials_transmission",textureList:["KHR_transmissionTexture"],positiveNumberList:[["KHR_transmissionFactor",0]]},{extensionName:"KHR_materials_volume",textureList:["KHR_thicknessTexture"],positiveNumberList:[["KHR_thicknessFactor",0],["KHR_attenuationDistance",1]],vec3List:[["KHR_attenuationColor",[1,1,1]]]},{extensionName:"KHR_materials_diffuse_transmission",textureList:["KHR_diffuseTransmissionTexture","KHR_diffuseTransmissionColorTexture"],positiveNumberList:[["KHR_diffuseTransmissionFactor",0]],vec3List:[["KHR_diffuseTransmissionColorFactor",[1,1,1]]]},{extensionName:"KHR_materials_anisotropy",textureList:["KHR_anisotropyTexture"],positiveNumberList:[["KHR_anisotropyStrength",0],["KHR_anisotropyRotation",0]]},{extensionName:"KHR_materials_iridescence",textureList:["KHR_iridescenceTexture","KHR_iridescenceThicknessTexture"],positiveNumberList:[["KHR_iridescenceFactor",0],["KHR_iridescenceIor",1.3],["KHR_iridescenceThicknessMinimum",100],["KHR_iridescenceThicknessMaximum",400]]}],tr=parseWGSL((i=>{const m=er.map(i=>{const{textureList:m,positiveNumberList:g}=i,_=m?.map(i=>` use${i.charAt(0).toUpperCase()}${i.substring(1)}:u32, ${i}_texCoord_index:u32, use_${i}_KHR_texture_transform:u32, ${i}_KHR_texture_transform_offset:vec2<f32>, ${i}_KHR_texture_transform_scale:vec2<f32>, ${i}_KHR_texture_transform_rotation:f32,`).join("");return[_].join("\n")}).join("");return i.replace(/#redgpu_include KHR_texture_transform/g,m)})("#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include calcDirectionalShadowVisibility;\n#redgpu_include calcTintBlendMode;\n#redgpu_include normalFunctions;\n#redgpu_include drawPicking;\n#redgpu_include calcPrePathBackground\n#redgpu_include FragmentOutput\n#redgpu_include calculateMotionVector;\nstruct Uniforms { useVertexColor:u32, useCutOff:u32, cutOff:f32, alphaBlend:u32, doubleSided:u32, useVertexTangent:u32, opacity:f32, useTint:u32, tint:vec4<f32>, tintBlendMode:u32, baseColorFactor:vec4<f32>, emissiveFactor:vec3<f32>, emissiveStrength:f32, occlusionStrength:f32, metallicFactor:f32, roughnessFactor:f32, normalScale:f32, useKHR_materials_unlit:u32, KHR_materials_ior:f32, useKHR_materials_transmission:u32, KHR_transmissionFactor:f32, useKHR_materials_diffuse_transmission:u32, KHR_diffuseTransmissionFactor:f32, KHR_diffuseTransmissionColorFactor:vec3<f32>, KHR_dispersion:f32, useKHR_materials_volume:u32, KHR_thicknessFactor:f32, KHR_attenuationDistance:f32, KHR_attenuationColor:vec3<f32>, useKHR_materials_specular:u32, KHR_specularFactor:f32, KHR_specularColorFactor:vec3<f32>, useKHR_materials_anisotropy:u32, KHR_anisotropyStrength:f32, KHR_anisotropyRotation:f32, useKHR_materials_iridescence:u32, KHR_iridescenceFactor:f32, KHR_iridescenceIor:f32, KHR_iridescenceThicknessMinimum:f32, KHR_iridescenceThicknessMaximum:f32, useKHR_materials_sheen:u32, KHR_sheenColorFactor:vec3<f32>, KHR_sheenRoughnessFactor:f32, useKHR_materials_clearcoat:u32, KHR_clearcoatFactor:f32, KHR_clearcoatRoughnessFactor:f32, KHR_clearcoatNormalScale:f32, #redgpu_include KHR_texture_transform\n};\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\n@group(2) @binding(1) var baseColorTextureSampler:sampler;\n@group(2) @binding(2) var baseColorTexture:texture_2d<f32>;\n@group(2) @binding(3) var emissiveTextureSampler:sampler;\n@group(2) @binding(4) var emissiveTexture:texture_2d<f32>;\n@group(2) @binding(5) var normalTextureSampler:sampler;\n@group(2) @binding(6) var normalTexture:texture_2d<f32>;\n@group(2) @binding(7) var packedORMTexture:texture_2d<f32>;\n@group(2) @binding(8) var KHR_specularTextureSampler:sampler;\n@group(2) @binding(9) var KHR_specularTexture:texture_2d<f32>;\n@group(2) @binding(10) var KHR_specularColorTextureSampler:sampler;\n@group(2) @binding(11) var KHR_specularColorTexture:texture_2d<f32>;\n@group(2) @binding(12) var KHR_clearcoatNormalTexture:texture_2d<f32>;\n@group(2) @binding(13) var packedKHR_clearcoatTexture_transmission:texture_2d<f32>;\n@group(2) @binding(14) var packedKHR_diffuse_transmission:texture_2d<f32>;\n@group(2) @binding(15) var packedKHR_sheen:texture_2d<f32>;\n@group(2) @binding(16) var KHR_anisotropyTexture:texture_2d<f32>;\n@group(2) @binding(17) var packedKHR_iridescence:texture_2d<f32>;\nstruct InputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(3) uv1:vec2<f32>, @location(4) vertexColor_0:vec4<f32>, @location(5) vertexTangent:vec4<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(10) localNodeScale_volumeScale:vec2<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(14) @interpolate(flat) receiveShadow:f32, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n}\n@fragment\nfn main(inputData:InputData) -> FragmentOutput { var output:FragmentOutput; let input_vertexNormal=(inputData.vertexNormal.xyz); let input_vertexPosition=inputData.vertexPosition.xyz; let input_vertexColor_0=inputData.vertexColor_0; let input_vertexTangent=inputData.vertexTangent; let input_ndcPosition=inputData.position.xyz/inputData.position.w; let input_uv=inputData.uv; let input_uv1=inputData.uv1; let u_ambientLight=systemUniforms.ambientLight; let u_ambientLightColor=u_ambientLight.color; let u_ambientLightIntensity=u_ambientLight.intensity; let u_directionalLightCount=systemUniforms.directionalLightCount; let u_directionalLights=systemUniforms.directionalLights; let u_shadowDepthTextureSize=systemUniforms.shadowDepthTextureSize; let u_bias=systemUniforms.bias; let u_useIblTexture=systemUniforms.useIblTexture==1u; let receiveShadowYn=inputData.receiveShadow !=.0; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_opacity=uniforms.opacity; let u_cutOff=uniforms.cutOff; let u_useVertexColor=uniforms.useVertexColor==1u; let u_useVertexTangent=uniforms.useVertexTangent==1u; let u_baseColorFactor=uniforms.baseColorFactor; let u_metallicFactor=uniforms.metallicFactor; let u_roughnessFactor=uniforms.roughnessFactor; let u_normalScale=uniforms.normalScale; let u_occlusionStrength=uniforms.occlusionStrength; let u_emissiveFactor=uniforms.emissiveFactor; let u_emissiveStrength=uniforms.emissiveStrength; let u_useKHR_materials_unlit=uniforms.useKHR_materials_unlit==1u; let u_KHR_materials_ior=uniforms.KHR_materials_ior; let u_KHR_dispersion=uniforms.KHR_dispersion; let u_KHR_transmissionFactor=uniforms.KHR_transmissionFactor; var u_useKHR_materials_volume=uniforms.useKHR_materials_volume==1u; var u_KHR_thicknessFactor=uniforms.KHR_thicknessFactor; var u_KHR_attenuationColor=uniforms.KHR_attenuationColor; var u_KHR_attenuationDistance=uniforms.KHR_attenuationDistance; let u_useKHR_materials_diffuse_transmission=uniforms.useKHR_materials_diffuse_transmission==1u; let u_KHR_diffuseTransmissionFactor=uniforms.KHR_diffuseTransmissionFactor; let u_KHR_diffuseTransmissionColorFactor=uniforms.KHR_diffuseTransmissionColorFactor; let u_KHR_specularFactor=uniforms.KHR_specularFactor; let u_KHR_specularColorFactor=uniforms.KHR_specularColorFactor; let u_KHR_anisotropyStrength=uniforms.KHR_anisotropyStrength; let u_KHR_anisotropyRotation=uniforms.KHR_anisotropyRotation; let u_useKHR_anisotropyTexture=uniforms.useKHR_anisotropyTexture==1u; let u_KHR_sheenColorFactor=uniforms.KHR_sheenColorFactor; let u_KHR_sheenRoughnessFactor=uniforms.KHR_sheenRoughnessFactor; let u_useKHR_materials_iridescence=uniforms.useKHR_materials_iridescence==1u; let u_KHR_iridescenceFactor=uniforms.KHR_iridescenceFactor; let u_KHR_iridescenceIor=uniforms.KHR_iridescenceIor; let u_KHR_iridescenceThicknessMinimum=uniforms.KHR_iridescenceThicknessMinimum; let u_KHR_iridescenceThicknessMaximum=uniforms.KHR_iridescenceThicknessMaximum; let u_KHR_clearcoatFactor=uniforms.KHR_clearcoatFactor; let u_KHR_clearcoatRoughnessFactor=uniforms.KHR_clearcoatRoughnessFactor; let u_KHR_clearcoatNormalScale=uniforms.KHR_clearcoatNormalScale; let diffuseUV=get_transformed_uv( input_uv,input_uv1, uniforms.baseColorTexture_texCoord_index, uniforms.use_baseColorTexture_KHR_texture_transform, uniforms.baseColorTexture_KHR_texture_transform_offset, uniforms.baseColorTexture_KHR_texture_transform_rotation, uniforms.baseColorTexture_KHR_texture_transform_scale ); let emissiveUV=get_transformed_uv( input_uv,input_uv1, uniforms.emissiveTexture_texCoord_index, uniforms.use_emissiveTexture_KHR_texture_transform, uniforms.emissiveTexture_KHR_texture_transform_offset, uniforms.emissiveTexture_KHR_texture_transform_rotation, uniforms.emissiveTexture_KHR_texture_transform_scale ); let occlusionUV=get_transformed_uv( input_uv,input_uv1, uniforms.occlusionTexture_texCoord_index, uniforms.use_occlusionTexture_KHR_texture_transform, uniforms.occlusionTexture_KHR_texture_transform_offset, uniforms.occlusionTexture_KHR_texture_transform_rotation, uniforms.occlusionTexture_KHR_texture_transform_scale ); let metallicRoughnessUV=get_transformed_uv( input_uv,input_uv1, uniforms.metallicRoughnessTexture_texCoord_index, uniforms.use_metallicRoughnessTexture_KHR_texture_transform, uniforms.metallicRoughnessTexture_KHR_texture_transform_offset, uniforms.metallicRoughnessTexture_KHR_texture_transform_rotation, uniforms.metallicRoughnessTexture_KHR_texture_transform_scale ); let normalUV=get_transformed_uv( input_uv,input_uv1, uniforms.normalTexture_texCoord_index, uniforms.use_normalTexture_KHR_texture_transform, uniforms.normalTexture_KHR_texture_transform_offset, uniforms.normalTexture_KHR_texture_transform_rotation, uniforms.normalTexture_KHR_texture_transform_scale ); let KHR_clearcoatUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_clearcoatTexture_texCoord_index, uniforms.use_KHR_clearcoatTexture_KHR_texture_transform, uniforms.KHR_clearcoatTexture_KHR_texture_transform_offset, uniforms.KHR_clearcoatTexture_KHR_texture_transform_rotation, uniforms.KHR_clearcoatTexture_KHR_texture_transform_scale ); let KHR_clearcoatNormalUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_clearcoatNormalTexture_texCoord_index, uniforms.use_KHR_clearcoatNormalTexture_KHR_texture_transform, uniforms.KHR_clearcoatNormalTexture_KHR_texture_transform_offset, uniforms.KHR_clearcoatNormalTexture_KHR_texture_transform_rotation, uniforms.KHR_clearcoatNormalTexture_KHR_texture_transform_scale ); let KHR_clearcoatRoughnessUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_clearcoatRoughnessTexture_texCoord_index, uniforms.use_KHR_clearcoatRoughnessTexture_KHR_texture_transform, uniforms.KHR_clearcoatRoughnessTexture_KHR_texture_transform_offset, uniforms.KHR_clearcoatRoughnessTexture_KHR_texture_transform_rotation, uniforms.KHR_clearcoatRoughnessTexture_KHR_texture_transform_scale ); let KHR_sheenColorUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_sheenColorTexture_texCoord_index, uniforms.use_KHR_sheenColorTexture_KHR_texture_transform, uniforms.KHR_sheenColorTexture_KHR_texture_transform_offset, uniforms.KHR_sheenColorTexture_KHR_texture_transform_rotation, uniforms.KHR_sheenColorTexture_KHR_texture_transform_scale ); let KHR_sheenRoughnessUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_sheenRoughnessTexture_texCoord_index, uniforms.use_KHR_sheenRoughnessTexture_KHR_texture_transform, uniforms.KHR_sheenRoughnessTexture_KHR_texture_transform_offset, uniforms.KHR_sheenRoughnessTexture_KHR_texture_transform_rotation, uniforms.KHR_sheenRoughnessTexture_KHR_texture_transform_scale ); let KHR_specularTextureUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_specularTexture_texCoord_index, uniforms.use_KHR_specularTexture_KHR_texture_transform, uniforms.KHR_specularTexture_KHR_texture_transform_offset, uniforms.KHR_specularTexture_KHR_texture_transform_rotation, uniforms.KHR_specularTexture_KHR_texture_transform_scale ); let KHR_specularColorTextureUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_specularColorTexture_texCoord_index, uniforms.use_KHR_specularColorTexture_KHR_texture_transform, uniforms.KHR_specularColorTexture_KHR_texture_transform_offset, uniforms.KHR_specularColorTexture_KHR_texture_transform_rotation, uniforms.KHR_specularColorTexture_KHR_texture_transform_scale ); let KHR_iridescenceTextureUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_iridescenceTexture_texCoord_index, uniforms.use_KHR_iridescenceTexture_KHR_texture_transform, uniforms.KHR_iridescenceTexture_KHR_texture_transform_offset, uniforms.KHR_iridescenceTexture_KHR_texture_transform_rotation, uniforms.KHR_iridescenceTexture_KHR_texture_transform_scale ); let KHR_iridescenceThicknessTextureUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_iridescenceThicknessTexture_texCoord_index, uniforms.use_KHR_iridescenceThicknessTexture_KHR_texture_transform, uniforms.KHR_iridescenceThicknessTexture_KHR_texture_transform_offset, uniforms.KHR_iridescenceThicknessTexture_KHR_texture_transform_rotation, uniforms.KHR_iridescenceThicknessTexture_KHR_texture_transform_scale ); let KHR_transmissionUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_transmissionTexture_texCoord_index, uniforms.use_KHR_transmissionTexture_KHR_texture_transform, uniforms.KHR_transmissionTexture_KHR_texture_transform_offset, uniforms.KHR_transmissionTexture_KHR_texture_transform_rotation, uniforms.KHR_transmissionTexture_KHR_texture_transform_scale ); let KHR_diffuseTransmissionUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_diffuseTransmissionTexture_texCoord_index, uniforms.use_KHR_diffuseTransmissionTexture_KHR_texture_transform, uniforms.KHR_diffuseTransmissionTexture_KHR_texture_transform_offset, uniforms.KHR_diffuseTransmissionTexture_KHR_texture_transform_rotation, uniforms.KHR_diffuseTransmissionTexture_KHR_texture_transform_scale ); let KHR_diffuseTransmissionColorUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_diffuseTransmissionColorTexture_texCoord_index, uniforms.use_KHR_diffuseTransmissionColorTexture_KHR_texture_transform, uniforms.KHR_diffuseTransmissionColorTexture_KHR_texture_transform_offset, uniforms.KHR_diffuseTransmissionColorTexture_KHR_texture_transform_rotation, uniforms.KHR_diffuseTransmissionColorTexture_KHR_texture_transform_scale ); let KHR_anisotropyUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_anisotropyTexture_texCoord_index, uniforms.use_KHR_anisotropyTexture_KHR_texture_transform, uniforms.KHR_anisotropyTexture_KHR_texture_transform_offset, uniforms.KHR_anisotropyTexture_KHR_texture_transform_rotation, uniforms.KHR_anisotropyTexture_KHR_texture_transform_scale ); var N:vec3<f32>=normalize(input_vertexNormal.xyz); var backFaceYn:bool=false; #redgpu_if doubleSided { var fdx:vec3<f32>=dpdx(input_vertexPosition); var fdy:vec3<f32>=dpdy(input_vertexPosition); var faceNormal:vec3<f32>=normalize(cross(fdy,fdx)); if (dot(N,faceNormal) < 0.0) { N=-N; backFaceYn=true; }; } #redgpu_endIf #redgpu_if normalTexture { var targetUv=select(normalUV,1.0 - normalUV,backFaceYn); let normalSamplerColor=textureSample(normalTexture,normalTextureSampler,normalUV).rgb; N=perturb_normal( N, input_vertexPosition, targetUv, vec3<f32>(normalSamplerColor.r,1.0 - normalSamplerColor.g,normalSamplerColor.b), u_normalScale ); N=select(N,select(N,-N,backFaceYn),u_useVertexTangent); } #redgpu_else { N=N * u_normalScale; } #redgpu_endIf let V:vec3<f32>=normalize(u_cameraPosition - input_vertexPosition); let NdotV=max(dot(N,V),0.04); let VdotN=max(dot(V,N),0.0); var visibility:f32=1.0; visibility=calcDirectionalShadowVisibility( directionalShadowMap, directionalShadowMapSampler, u_shadowDepthTextureSize, u_bias, inputData.shadowPos ); if(!receiveShadowYn){ visibility=1.0; } var finalColor:vec4<f32>; var ior:f32=u_KHR_materials_ior; var baseColor=u_baseColorFactor; var resultAlpha:f32=u_opacity * baseColor.a; baseColor *=select(vec4<f32>(1.0),input_vertexColor_0,u_useVertexColor); #redgpu_if baseColorTexture let diffuseSampleColor=(textureSample(baseColorTexture,baseColorTextureSampler,diffuseUV)); baseColor *=diffuseSampleColor; resultAlpha *=diffuseSampleColor.a; #redgpu_endIf let albedo:vec3<f32>=baseColor.rgb; #redgpu_if useKHR_materials_unlit if(u_useKHR_materials_unlit){ output.color=baseColor; return output; } #redgpu_endIf var occlusionParameter:f32=1; #redgpu_if useOcclusionTexture occlusionParameter=textureSample(packedORMTexture,packedTextureSampler,occlusionUV).r * u_occlusionStrength; #redgpu_endIf var metallicParameter:f32=u_metallicFactor; var roughnessParameter:f32=u_roughnessFactor; #redgpu_if useMetallicRoughnessTexture let metallicRoughnessSample=(textureSample(packedORMTexture,packedTextureSampler,metallicRoughnessUV)); metallicParameter=metallicRoughnessSample.b * metallicParameter; roughnessParameter=metallicRoughnessSample.g * roughnessParameter; #redgpu_endIf roughnessParameter=max(roughnessParameter,0.045); if (abs(ior - 1.0) < 0.0001) { roughnessParameter=0;} var clearcoatParameter=u_KHR_clearcoatFactor; var clearcoatRoughnessParameter=u_KHR_clearcoatRoughnessFactor; var clearcoatNormal:vec3<f32>=N; if(clearcoatParameter !=0.0){ #redgpu_if useKHR_clearcoatTexture let clearcoatSample=textureSample(packedKHR_clearcoatTexture_transmission,packedTextureSampler,KHR_clearcoatUV); clearcoatParameter *=clearcoatSample.r; #redgpu_endIf #redgpu_if useKHR_clearcoatRoughnessTexture let clearcoatRoughnesstSample=textureSample(packedKHR_clearcoatTexture_transmission,packedTextureSampler,KHR_clearcoatRoughnessUV); clearcoatRoughnessParameter *=clearcoatRoughnesstSample.g; #redgpu_endIf var clearcoatNormalSampler=textureSample(KHR_clearcoatNormalTexture,baseColorTextureSampler,KHR_clearcoatNormalUV); #redgpu_if useKHR_clearcoatNormalTexture { var targetUv=KHR_clearcoatNormalUV; if(backFaceYn){ targetUv=1.0 - targetUv; } clearcoatNormal=clearcoatNormalSampler.rgb; clearcoatNormal=perturb_normal( N, input_vertexPosition, targetUv, clearcoatNormal, u_normalScale ); if(u_useVertexTangent){ if(backFaceYn ){ clearcoatNormal=-clearcoatNormal;} } clearcoatNormal=normalize(clearcoatNormal); } #redgpu_endIf } var specularParameter=u_KHR_specularFactor; var specularColor=u_KHR_specularColorFactor; #redgpu_if KHR_specularColorTexture let specularColorTextureSample=textureSample( KHR_specularColorTexture, KHR_specularColorTextureSampler, KHR_specularColorTextureUV ); specularColor *=specularColorTextureSample.rgb; #redgpu_endIf #redgpu_if KHR_specularTexture let specularTextureSample=textureSample( KHR_specularTexture, KHR_specularTextureSampler, KHR_specularTextureUV ); specularParameter *=specularTextureSample.a; #redgpu_endIf var transmissionParameter:f32=u_KHR_transmissionFactor; #redgpu_if useKHR_transmissionTexture let transmissionSample:vec4<f32>=textureSample( packedKHR_clearcoatTexture_transmission, packedTextureSampler, KHR_transmissionUV ); transmissionParameter *=transmissionSample.b; #redgpu_endIf var thicknessParameter:f32=u_KHR_thicknessFactor; #redgpu_if useKHR_thicknessTexture let thicknessSample:vec4<f32>=textureSample( packedKHR_clearcoatTexture_transmission, packedTextureSampler, KHR_transmissionUV ); thicknessParameter *=thicknessSample.a; #redgpu_endIf var diffuseTransmissionColor:vec3<f32>=u_KHR_diffuseTransmissionColorFactor; var diffuseTransmissionParameter:f32=u_KHR_diffuseTransmissionFactor; #redgpu_if useKHR_diffuseTransmissionTexture let diffuseTransmissionTextureSample=textureSample( packedKHR_diffuse_transmission, packedTextureSampler, KHR_diffuseTransmissionUV ); diffuseTransmissionParameter *=diffuseTransmissionTextureSample.a; #redgpu_endIf #redgpu_if useKHR_diffuseTransmissionColorTexture let diffuseTransmissionColorTextureSample=textureSample( packedKHR_diffuse_transmission, packedTextureSampler, KHR_diffuseTransmissionColorUV ); diffuseTransmissionColor *=diffuseTransmissionColorTextureSample.rgb; #redgpu_endIf var sheenColor=u_KHR_sheenColorFactor; var sheenRoughnessParameter=u_KHR_sheenRoughnessFactor; #redgpu_if useKHR_sheenColorTexture let sheenColorSample=(textureSample(packedKHR_sheen,packedTextureSampler,KHR_sheenColorUV)); sheenColor *=sheenColorSample.rgb; #redgpu_endIf #redgpu_if useKHR_sheenRoughnessTexture let sheenRoughnessSample=(textureSample(packedKHR_sheen,packedTextureSampler,KHR_sheenRoughnessUV)); sheenRoughnessParameter *=sheenRoughnessSample.a; #redgpu_endIf var iridescenceParameter=u_KHR_iridescenceFactor; var iridescenceThickness=u_KHR_iridescenceThicknessMaximum; #redgpu_if useKHR_iridescenceTexture let iridescenceTextureSample:vec4<f32>=textureSample( packedKHR_iridescence, packedTextureSampler, KHR_iridescenceTextureUV ); iridescenceParameter *=iridescenceTextureSample.r; #redgpu_endIf #redgpu_if useKHR_iridescenceThicknessTexture let iridescenceThicknessTextureSample:vec4<f32>=textureSample( packedKHR_iridescence, packedTextureSampler, KHR_iridescenceThicknessTextureUV ); iridescenceThickness=mix(u_KHR_iridescenceThicknessMinimum,u_KHR_iridescenceThicknessMaximum,iridescenceThicknessTextureSample.g); #redgpu_endIf var anisotropy:f32=u_KHR_anisotropyStrength; var anisotropicT:vec3<f32>=vec3<f32>(1.0); var anisotropicB:vec3<f32>=vec3<f32>(1.0); #redgpu_if useKHR_materials_anisotropy { var T:vec3<f32>; var B:vec3<f32>; if (u_useVertexTangent && length(input_vertexTangent.xyz) > 0.0) { T=normalize(input_vertexTangent.xyz); B=normalize(cross(N,T) * input_vertexTangent.w); } else { T=normalize(select(vec3<f32>(1.0,0.0,0.0),vec3<f32>(0.0,1.0,0.0),abs(N.x) > 0.9)); T=normalize(T - N * dot(T,N)); B=normalize(cross(N,T)); } var anisotropicDirection:vec2<f32>=vec2<f32>(1.0,0.0); if(u_useKHR_anisotropyTexture){ let anisotropyTex=textureSample(KHR_anisotropyTexture,baseColorTextureSampler,KHR_anisotropyUV).rgb; anisotropicDirection=anisotropyTex.rg * 2.0 - vec2<f32>(1.0,1.0); anisotropy *=anisotropyTex.b; } var cosR=cos(u_KHR_anisotropyRotation); var sinR=sin(u_KHR_anisotropyRotation); let rotationMtx:mat2x2<f32>=mat2x2<f32>( cosR,sinR, -sinR,cosR ); anisotropicDirection=rotationMtx * anisotropicDirection; anisotropicT=normalize(T * anisotropicDirection.x + B * anisotropicDirection.y); anisotropicB=normalize(cross(N,anisotropicT)); } #redgpu_endIf var prePathBackground=vec3<f32>(0.0); #redgpu_if useKHR_materials_transmission prePathBackground=calcPrePathBackground( u_useKHR_materials_volume,thicknessParameter * inputData.localNodeScale_volumeScale[1],u_KHR_dispersion,u_KHR_attenuationDistance,u_KHR_attenuationColor, ior,roughnessParameter,albedo, systemUniforms.projectionCameraMatrix,input_vertexPosition,input_ndcPosition, V,N, renderPath1ResultTexture,renderPath1ResultTextureSampler ); #redgpu_endIf let F0_dielectric_base=vec3(pow((1.0 - ior)/(1.0 + ior),2.0)); var F0_dielectric=F0_dielectric_base * specularColor; var F0_metal=baseColor.rgb; #redgpu_if useKHR_materials_iridescence if (iridescenceParameter > 0.0) { F0_dielectric=iridescent_fresnel(1.0,u_KHR_iridescenceIor,F0_dielectric,iridescenceThickness,iridescenceParameter,NdotV); F0_metal=iridescent_fresnel(1.0,u_KHR_iridescenceIor,baseColor.rgb,iridescenceThickness,iridescenceParameter,NdotV); } #redgpu_endIf let F0=mix(F0_dielectric,F0_metal,metallicParameter); var totalDirectLighting=vec3<f32>(0.0); for (var i=0u;i < u_directionalLightCount;i++) { totalDirectLighting +=calcLight( u_directionalLights[i].color,u_directionalLights[i].intensity * visibility, N,V,-normalize(u_directionalLights[i].direction), VdotN, roughnessParameter,metallicParameter,albedo, F0,ior, prePathBackground, specularColor,specularParameter, u_useKHR_materials_diffuse_transmission,diffuseTransmissionParameter,diffuseTransmissionColor, transmissionParameter, sheenColor,sheenRoughnessParameter, anisotropy,anisotropicT,anisotropicB, clearcoatParameter,clearcoatRoughnessParameter,clearcoatNormal ); } { let clusterIndex=getClusterLightClusterIndex(inputData.position); let lightOffset=clusterLightGroup.lights[clusterIndex].offset; let lightCount:u32=clusterLightGroup.lights[clusterIndex].count; for (var lightIndex=0u;lightIndex < lightCount;lightIndex=lightIndex + 1u) { let i=clusterLightGroup.indices[lightOffset + lightIndex]; let targetLight=clusterLightList.lights[i]; let u_clusterLightPosition=targetLight.position; let u_clusterLightRadius=targetLight.radius; let u_isSpotLight=targetLight.isSpotLight; let lightDistance=length(u_clusterLightPosition - input_vertexPosition); if (lightDistance > u_clusterLightRadius) { continue; } let lightDir=normalize(u_clusterLightPosition - input_vertexPosition);\nlet Lvec=u_clusterLightPosition - input_vertexPosition;\nlet dist2=max(dot(Lvec,Lvec),0.0001);\nlet d=sqrt(dist2);\nlet rangePart=pow(clamp(1.0 - d/u_clusterLightRadius,0.0,1.0),2.0);\nlet invSquare=(u_clusterLightRadius * u_clusterLightRadius)/dist2;\nlet attenuation=rangePart * invSquare; var finalAttenuation=attenuation; if (u_isSpotLight > 0.0) { let u_clusterLightDirection=normalize(vec3<f32>( targetLight.directionX, targetLight.directionY, targetLight.directionZ )); let u_clusterLightInnerAngle=targetLight.innerCutoff; let u_clusterLightOuterCutoff=targetLight.outerCutoff; let lightToVertex=normalize(-lightDir); let cosTheta=dot(lightToVertex,u_clusterLightDirection); let cosOuter=cos(radians(u_clusterLightOuterCutoff)); let cosInner=cos(radians(u_clusterLightInnerAngle)); if (cosTheta < cosOuter) { continue; } let epsilon=cosInner - cosOuter; let spotIntensity=clamp((cosTheta - cosOuter)/epsilon,0.0,1.0); finalAttenuation *=spotIntensity; } totalDirectLighting +=calcLight( targetLight.color,targetLight.intensity * finalAttenuation, N,V,lightDir, VdotN, roughnessParameter,metallicParameter,albedo, F0,ior, prePathBackground, specularColor,specularParameter, u_useKHR_materials_diffuse_transmission,diffuseTransmissionParameter,diffuseTransmissionColor, transmissionParameter, sheenColor,sheenRoughnessParameter, anisotropy,anisotropicT,anisotropicB, clearcoatParameter,clearcoatRoughnessParameter,clearcoatNormal ); } } if (u_useIblTexture) { var R=(reflect(-V,N)); let NdotV=max(dot(N,V),1e-4); #redgpu_if useKHR_materials_anisotropy { var bentNormal=cross(anisotropicB,V); bentNormal=normalize(cross(bentNormal,anisotropicB)); let temp=1.0 - anisotropy * (1.0 - roughnessParameter); let tempSquared=temp * temp; var a=tempSquared * tempSquared; bentNormal=normalize(mix(bentNormal,N,a)); var reflectVec=reflect(-V,bentNormal); reflectVec=normalize(mix(reflectVec,bentNormal,roughnessParameter * roughnessParameter)); let roughnessT=roughnessParameter * (1.0 + anisotropy); let roughnessB=roughnessParameter * (1.0 - anisotropy); let TdotR=dot(anisotropicT,reflectVec); let BdotR=dot(anisotropicB,reflectVec); let TdotV=dot(anisotropicT,V); let BdotV=dot(anisotropicB,V); R=normalize(reflectVec - anisotropy * (TdotR * anisotropicT - BdotR * anisotropicB)); let VdotN=max(1e-4,dot(V,N)); let oneMinusVdotN=1.0 - VdotN; let directionFactor=oneMinusVdotN * oneMinusVdotN * oneMinusVdotN; let VdotT_abs=abs(TdotV); let VdotB_abs=abs(BdotV); let totalWeight=max(1e-4,VdotT_abs + VdotB_abs); let weightedRoughness=(roughnessT * VdotT_abs + roughnessB * VdotB_abs)/totalWeight; roughnessParameter=weightedRoughness; } #redgpu_endIf let iblMipmapCount:f32=f32(textureNumLevels(ibl_environmentTexture) - 1); var mipLevel=roughnessParameter * (1.7 - 0.7 * roughnessParameter) * iblMipmapCount; var reflectedColor=textureSampleLevel( ibl_environmentTexture,iblTextureSampler,R,mipLevel ).rgb; let fresnel=pow(1.0 - NdotV,5.0); var F_IBL_dielectric=F0_dielectric + (max(vec3<f32>(1.0 - roughnessParameter),F0_dielectric) - F0_dielectric) * fresnel; var F_IBL_metal=F0_metal + (max(vec3<f32>(1.0 - roughnessParameter),F0_metal) - F0_metal) * fresnel; var F_IBL=F0 + (max(vec3<f32>(1.0 - roughnessParameter),F0) - F0) * fresnel; let K=(roughnessParameter + 1.0) * (roughnessParameter + 1.0)/8.0; let G=NdotV/(NdotV * (1.0 - K) + K); let a2=roughnessParameter * roughnessParameter; let G_smith=NdotV/(NdotV * (1.0 - a2) + a2); let effectiveTransmission=transmissionParameter * (1.0 - metallicParameter); let iblDiffuseColor=textureSampleLevel(ibl_irradianceTexture,iblTextureSampler,N,0).rgb; var envIBL_DIFFUSE:vec3<f32>=albedo * iblDiffuseColor* (vec3<f32>(1.0) - F_IBL_dielectric); #redgpu_if useKHR_materials_diffuse_transmission { var backScatteringColor=textureSampleLevel(ibl_environmentTexture,iblTextureSampler,-N,mipLevel).rgb; let transmittedIBL=backScatteringColor * diffuseTransmissionColor * (vec3<f32>(1.0) - F_IBL_dielectric); envIBL_DIFFUSE=mix(envIBL_DIFFUSE,transmittedIBL,diffuseTransmissionParameter); } #redgpu_endIf var envIBL_SPECULAR:vec3<f32>; envIBL_SPECULAR=reflectedColor * F_IBL * specularParameter; var envIBL_SPECULAR_BTDF=vec3<f32>(0.0); #redgpu_if useKHR_materials_transmission var refractedDir:vec3<f32>; let eta=1.0/ior; if (abs(ior - 1.0) < 0.0001) { refractedDir=V;} else { refractedDir=refract(-V,-N,eta);} if(length(refractedDir) > 0.0001) { let NdotT=abs(dot(N,normalize(refractedDir))); let F_transmission=vec3<f32>(1.0) - mix(F_IBL_dielectric,F_IBL_metal,metallicParameter); var attenuatedBackground=prePathBackground; if (u_useKHR_materials_volume) { let localNodeScale=inputData.localNodeScale_volumeScale[0]; let volumeScale=inputData.localNodeScale_volumeScale[1]; let scaledThickness=thicknessParameter * localNodeScale; let safeAttenuationColor=clamp(u_KHR_attenuationColor,vec3<f32>(0.0001),vec3<f32>(1.0)); let safeAttenuationDistance=max(u_KHR_attenuationDistance,0.0001); let attenuationCoefficient=-log(safeAttenuationColor)/safeAttenuationDistance; let cosTheta=max(NdotT,0.001); let pathLength=scaledThickness/cosTheta; let transmittance=exp(-attenuationCoefficient * pathLength); attenuatedBackground *=transmittance; }else{ attenuatedBackground *=albedo; } envIBL_SPECULAR_BTDF=attenuatedBackground * F_transmission * transmissionParameter + reflectedColor * G_smith * mix(F_IBL_dielectric,F_IBL_metal,metallicParameter) * NdotT; } #redgpu_endIf let envIBL_DIELECTRIC=mix(envIBL_DIFFUSE,envIBL_SPECULAR_BTDF,transmissionParameter) + envIBL_SPECULAR; var envIBL_SHEEN=vec3<f32>(0.0); var sheen_albedo_scaling:f32=1.0; let maxSheenColor=max(sheenColor.x,max(sheenColor.y,sheenColor.z)); #redgpu_if useKHR_materials_sheen let sheenResult=calcIBLSheen( N, V, sheenColor, maxSheenColor, sheenRoughnessParameter, iblMipmapCount ); envIBL_SHEEN=sheenResult.envIBL_SHEEN; sheen_albedo_scaling=sheenResult.sheen_albedo_scaling; #redgpu_endIf let envIBL_METAL=reflectedColor * F_IBL_metal; let metallicPart=envIBL_METAL * metallicParameter; let dielectricPart=envIBL_DIELECTRIC * (1.0 - metallicParameter); var indirectLighting=(metallicPart + dielectricPart) * sheen_albedo_scaling + envIBL_SHEEN; #redgpu_if useKHR_materials_clearcoat if (clearcoatParameter > 0.0) { let clearcoatF0=0.04; let clearcoatR=reflect(-V,clearcoatNormal); let clearcoatNdotV=max(dot(clearcoatNormal,V),0.04); let clearcoatMipLevel=clearcoatRoughnessParameter * iblMipmapCount; let clearcoatPrefilteredColor=textureSampleLevel(ibl_environmentTexture,iblTextureSampler,clearcoatR,clearcoatMipLevel).rgb; let clearcoatF=clearcoatF0 + (vec3<f32>(1.0) - clearcoatF0) * pow(1.0 - clearcoatNdotV,5.0); let clearcoatAlpha=clearcoatRoughnessParameter * clearcoatRoughnessParameter; let clearcoatK=clearcoatAlpha/2.0; let clearcoatG=clearcoatNdotV/(clearcoatNdotV * (1.0 - clearcoatK) + clearcoatK); let clearcoatBRDF=clearcoatF * clearcoatG; let clearcoatSpecularIBL=clearcoatPrefilteredColor * clearcoatBRDF * clearcoatParameter; indirectLighting=clearcoatSpecularIBL + (vec3<f32>(1.0) - clearcoatF ) * indirectLighting; } #redgpu_endIf let environmentIntensity=1.0; let surfaceColor=totalDirectLighting + indirectLighting * environmentIntensity * occlusionParameter; finalColor=vec4<f32>(surfaceColor,resultAlpha); } else { let ambientContribution=albedo * u_ambientLightColor * u_ambientLightIntensity * occlusionParameter; finalColor=vec4<f32>(totalDirectLighting + ambientContribution,resultAlpha); } var emissiveSamplerColor=vec3<f32>(1.0); #redgpu_if emissiveTexture emissiveSamplerColor=textureSample(emissiveTexture,emissiveTextureSampler,emissiveUV).rgb; #redgpu_endIf finalColor +=vec4<f32>( emissiveSamplerColor.rgb * u_emissiveFactor * u_emissiveStrength,0); #redgpu_if useCutOff if (resultAlpha <=u_cutOff) { discard;} #redgpu_endIf output.color=finalColor; { let smoothness=1.0 - roughnessParameter; let smoothnessCurved=smoothness * smoothness * (3.0 - 2.0 * smoothness); let metallicWeight=metallicParameter * metallicParameter; let baseReflection=0.04 + 0.96 * metallicWeight; let baseReflectionStrength=smoothnessCurved * baseReflection; output.gBufferNormal=vec4<f32>(N * 0.5 + 0.5,baseReflectionStrength); } output.gBufferMotionVector=vec4<f32>(calculateMotionVector(inputData.currentClipPos,inputData.prevClipPos),0.0,1.0 ); return output;\n};\nstruct SheenResult { envIBL_SHEEN:vec3<f32>, sheen_albedo_scaling:f32\n}\nfn calcIBLSheen( N:vec3<f32>, V:vec3<f32>, sheenColor:vec3<f32>, maxSheenColor:f32, sheenRoughness:f32, iblMipmapCount:f32,\n) -> SheenResult { let NdotV=clamp(dot(N,V),0.0001,1.0); let R=reflect(-V,N); let mipLevel=sheenRoughness * iblMipmapCount; let sheenRadiance=textureSampleLevel( ibl_irradianceTexture,iblTextureSampler,R,mipLevel ).rgb; let sheenDFG=charlieSheenDFG(NdotV,sheenRoughness); let envIBL_SHEEN=sheenRadiance * sheenColor * sheenDFG; let E=charlieSheenE(NdotV,sheenRoughness); let sheen_albedo_scaling=1.0 - maxSheenColor * E; return SheenResult(envIBL_SHEEN,sheen_albedo_scaling);\n}\nfn charlieSheenDFG(NdotV:f32,roughness:f32) -> f32 { if (roughness < 0.01) { return 0.0; } let r=clamp(roughness,0.01,1.0); let grazingFactor=1.0 - NdotV; let roughnessExp=1.0/max(r,0.1); let distribution=pow(grazingFactor,roughnessExp); let intensity=pow(roughnessExp,0.5); return distribution * intensity * 0.5;\n}\nfn charlieSheenE(NdotV:f32,roughness:f32) -> f32 { if (roughness < 0.01) { return 0.0; } let r=clamp(roughness,0.01,1.0); let grazingFactor=1.0 - NdotV; let roughnessExp=1.0/max(r,0.1); return pow(grazingFactor,roughnessExp) * pow(r,0.5);\n}\nfn calcLight( lightColor:vec3<f32>,lightIntensity:f32, N:vec3<f32>,V:vec3<f32>,L:vec3<f32>, VdotN:f32, roughnessParameter:f32,metallicParameter:f32,albedo:vec3<f32>, F0:vec3<f32>,ior:f32, prePathBackground:vec3<f32>, specularColor:vec3<f32>,specularParameter:f32, u_useKHR_materials_diffuse_transmission:bool,diffuseTransmissionParameter:f32,diffuseTransmissionColor:vec3<f32>, transmissionParameter:f32, sheenColor:vec3<f32>,sheenRoughnessParameter:f32, anisotropy:f32,anisotropicT:vec3<f32>,anisotropicB:vec3<f32>, clearcoatParameter:f32,clearcoatRoughnessParameter:f32,clearcoatNormal:vec3<f32>\n) -> vec3<f32>{ let dLight=lightColor * lightIntensity; let NdotL=max(dot(N,L),0.04); let NdotV=max(dot(N,V),0.04); let H=normalize(L + V); let LdotH=max(dot(L,H),0.0); let NdotH=max(dot(N,H),0.0); let VdotH=max(dot(V,H),0.0); var DIFFUSE_BRDF:vec3<f32>=diffuse_brdf_disney(NdotL,NdotV,LdotH,roughnessParameter,albedo); #redgpu_if useKHR_materials_diffuse_transmission DIFFUSE_BRDF=mix(DIFFUSE_BRDF,diffuse_btdf(N,L,diffuseTransmissionColor),diffuseTransmissionParameter); #redgpu_endIf var SPECULAR_BRDF:vec3<f32>; if (anisotropy > 0.0) { #redgpu_if useKHR_materials_anisotropy var TdotL=dot(anisotropicT,L); var TdotV=dot(anisotropicT,V); var BdotL=dot(anisotropicB,L); var TdotH=dot(anisotropicT,H); var BdotH=dot(anisotropicB,H); var BdotV=dot(anisotropicB,V); SPECULAR_BRDF=BRDF_specularAnisotropicGGX( albedo, vec3<f32>(1.0), roughnessParameter * roughnessParameter, VdotH,NdotL,NdotV,NdotH,BdotV,TdotV,TdotL,BdotL,TdotH,BdotH, anisotropy ); #redgpu_endIf }else{ SPECULAR_BRDF=specular_brdf( albedo,roughnessParameter,NdotH,NdotV,NdotL,LdotH); } let METAL_BRDF=conductor_fresnel( albedo,SPECULAR_BRDF,VdotH);; var SPECULAR_BTDF=vec3<f32>(0.0); #redgpu_if useKHR_materials_transmission if(transmissionParameter > 0.0){ SPECULAR_BTDF=specular_btdf( NdotV,NdotL,NdotH,VdotH,LdotH,roughnessParameter,albedo,ior); } #redgpu_endIf let DIELECTRIC_BRDF=fresnel_mix( F0, specularParameter, mix(DIFFUSE_BRDF,SPECULAR_BTDF,transmissionParameter), SPECULAR_BRDF, VdotH ); var SHEEN_BRDF:vec3<f32>=vec3<f32>(0.0); var sheen_albedo_scaling:f32=1.0; #redgpu_if useKHR_materials_sheen let maxSheenColor=max(sheenColor.x,max(sheenColor.y,sheenColor.z)); if(sheenRoughnessParameter > 0.0 && maxSheenColor > 0.001 && dot(N,V) > 0) { let NdotV=dot(N,V); let sheenRoughnessAlpha=sheenRoughnessParameter * sheenRoughnessParameter; let invR=1/sheenRoughnessAlpha; let cos2h=NdotH * NdotH; let sin2h=1 - cos2h; let sheenDistribution=(2 + invR) * pow(sin2h,invR * 0.5)/(2 * pi); let sheen_visibility=1.0/((1.0 + lambda_sheen(NdotV,sheenRoughnessAlpha) + lambda_sheen(NdotL,sheenRoughnessAlpha)) * (4.0 * NdotV * NdotL)); let LdotN=max(dot(L,N),0.04); let E_LdotN=1.0 - pow(1.0 - LdotN,5.0); let E_VdotN=1.0 - pow(1.0 - VdotN,5.0); sheen_albedo_scaling=max(min(1.0 - maxSheenColor * E_VdotN,1.0 - maxSheenColor * E_LdotN),0.04); SHEEN_BRDF=sheenColor * sheenDistribution * sheen_visibility; } #redgpu_endIf let metallicPart=METAL_BRDF * metallicParameter * sheen_albedo_scaling; let dielectricPart=DIELECTRIC_BRDF * sheen_albedo_scaling; let sheenPart=SHEEN_BRDF; var directLighting=(metallicPart + dielectricPart + sheenPart); #redgpu_if useKHR_materials_transmission if(transmissionParameter > 0.0) { let transmissionWeight=transmissionParameter * (vec3<f32>(1.0) - F0); directLighting=mix(directLighting,prePathBackground,transmissionWeight); } #redgpu_endIf #redgpu_if useKHR_materials_clearcoat if(clearcoatParameter > 0.0){ let clearcoatNdotL=max(dot(clearcoatNormal,L),0.04); let clearcoatNdotV=max(dot(clearcoatNormal,V),0.04); let clearcoatNdotH=max(dot(clearcoatNormal,H),0.0); let CLEARCOAT_BRDF=specular_brdf( F0,clearcoatRoughnessParameter,clearcoatNdotH,clearcoatNdotV,clearcoatNdotL,LdotH); directLighting=fresnel_coat(clearcoatNdotV,ior,clearcoatParameter,directLighting,CLEARCOAT_BRDF); } #redgpu_endIf var lightDirection:f32; #redgpu_if useKHR_materials_diffuse_transmission lightDirection=mix(abs(dot(N,L)),1.0,diffuseTransmissionParameter); #redgpu_else lightDirection=NdotL; #redgpu_endIf let lightContribution=directLighting * dLight * lightDirection; return lightContribution;\n}\nconst pi:f32=3.14159265359;\nfn BRDF_specularAnisotropicGGX( f0:vec3<f32>,f90:vec3<f32>,alphaRoughness:f32,VdotH:f32,NdotL:f32,NdotV:f32,NdotH:f32,BdotV:f32,TdotV:f32,TdotL:f32,BdotL:f32,TdotH:f32,BdotH:f32,anisotropy:f32 ) -> vec3<f32> { var at=mix(alphaRoughness,1.0,anisotropy * anisotropy); var ab=alphaRoughness; var F:vec3<f32>=fresnel_schlick(VdotH,f0); var V:f32=V_GGX_anisotropic(NdotL,NdotV,BdotV,TdotV,TdotL,BdotL,at,ab); var D:f32=D_GGX_anisotropic(NdotH,TdotH,BdotH,at,ab); return F * (V * D);\n}\nfn D_GGX_anisotropic( NdotH:f32,TdotH:f32,BdotH:f32,at:f32,ab:f32 ) -> f32 { let a2:f32=at * ab; let f:vec3<f32>=vec3<f32>(ab * TdotH,at * BdotH,a2 * NdotH); let denominator:f32=dot(f,f); let w2:f32=a2/denominator; return a2 * w2 * w2/pi;\n}\nfn V_GGX_anisotropic( NdotL:f32,NdotV:f32,BdotV:f32,TdotV:f32,TdotL:f32,BdotL:f32,at:f32,ab:f32 ) -> f32 { let GGXV=NdotL * length(vec3<f32>(at * TdotV,ab * BdotV,NdotV)); let GGXL=NdotV * length(vec3<f32>(at * TdotL,ab * BdotL,NdotL)); let v=0.5/(GGXV + GGXL); return clamp(v,0.0,1.0);\n}\nfn iridescent_fresnel(outside_ior:f32,iridescence_ior:f32,base_f0:vec3<f32>, iridescence_thickness:f32,iridescence_factor:f32,cos_theta1:f32) -> vec3<f32> { if (iridescence_thickness <=0.0 || iridescence_factor <=0.0) { return base_f0; } let cos_theta1_abs=abs(cos_theta1); let safe_iridescence_ior=max(iridescence_ior,1.01); let sin_theta1=sqrt(max(0.0,1.0 - cos_theta1_abs * cos_theta1_abs)); let sin_theta2=(outside_ior/safe_iridescence_ior) * sin_theta1; if (sin_theta2 >=1.0) { return base_f0 + iridescence_factor * (vec3<f32>(1.0) - base_f0); } let cos_theta2=sqrt(max(0.0,1.0 - sin_theta2 * sin_theta2)); let wavelengths=vec3<f32>(650.0,510.0,475.0); let effective_thickness=max(iridescence_thickness,10.0); let ior_scale=max(1.0,1.5 - 0.5 * (safe_iridescence_ior/1.5)); let optical_thickness=2.0 * effective_thickness * safe_iridescence_ior * cos_theta2 * ior_scale; let phase=(2.0 * 3.14159265359 * optical_thickness)/wavelengths; let cos_phase=cos(phase); let sin_phase=sin(phase); let outside_cos1=outside_ior * cos_theta1_abs; let iridescence_cos2=safe_iridescence_ior * cos_theta2; let iridescence_cos1=safe_iridescence_ior * cos_theta1_abs; let outside_cos2=outside_ior * cos_theta2; let r12_s=(outside_cos1 - iridescence_cos2)/(outside_cos1 + iridescence_cos2); let r12_p=(iridescence_cos1 - outside_cos2)/(iridescence_cos1 + outside_cos2); let sqrt_f0=sqrt(clamp(base_f0,vec3<f32>(0.01),vec3<f32>(0.99))); let safe_n3=max((1.0 + sqrt_f0)/(1.0 - sqrt_f0),vec3<f32>(1.2)); let iridescence_cos2_vec=vec3<f32>(iridescence_cos2); let cos_theta1_abs_vec=vec3<f32>(cos_theta1_abs); let iridescence_cos1_vec=vec3<f32>(iridescence_cos1); let cos_theta2_vec=vec3<f32>(cos_theta2); let r23_s=(iridescence_cos2_vec - safe_n3 * cos_theta1_abs_vec)/ (iridescence_cos2_vec + safe_n3 * cos_theta1_abs_vec); let r23_p=(safe_n3 * cos_theta2_vec - iridescence_cos1_vec)/ (safe_n3 * cos_theta2_vec + iridescence_cos1_vec); let r12_s_vec=vec3<f32>(r12_s); let r12_p_vec=vec3<f32>(r12_p); let num_s_real=r12_s_vec + r23_s * cos_phase; let num_s_imag=r23_s * sin_phase; let den_s_real=vec3<f32>(1.0) + r12_s_vec * r23_s * cos_phase; let den_s_imag=r12_s_vec * r23_s * sin_phase; let num_p_real=r12_p_vec + r23_p * cos_phase; let num_p_imag=r23_p * sin_phase; let den_p_real=vec3<f32>(1.0) + r12_p_vec * r23_p * cos_phase; let den_p_imag=r12_p_vec * r23_p * sin_phase; let den_s_squared=den_s_real * den_s_real + den_s_imag * den_s_imag + vec3<f32>(0.001); let rs_real=(num_s_real * den_s_real + num_s_imag * den_s_imag)/den_s_squared; let rs_imag=(num_s_imag * den_s_real - num_s_real * den_s_imag)/den_s_squared; let Rs=rs_real * rs_real + rs_imag * rs_imag; let den_p_squared=den_p_real * den_p_real + den_p_imag * den_p_imag + vec3<f32>(0.001); let rp_real=(num_p_real * den_p_real + num_p_imag * den_p_imag)/den_p_squared; let rp_imag=(num_p_imag * den_p_real - num_p_real * den_p_imag)/den_p_squared; let Rp=rp_real * rp_real + rp_imag * rp_imag; let reflectance=0.5 * (Rs + Rp); let ior_influence=smoothstep(1.0,2.0,safe_iridescence_ior); let enhanced_reflectance=mix( pow(reflectance,vec3<f32>(0.8)) * 1.2, reflectance, ior_influence ); let clamped_reflectance=clamp(enhanced_reflectance,vec3<f32>(0.0),vec3<f32>(1.0)); return mix(base_f0,clamped_reflectance,iridescence_factor);\n}\nfn specular_btdf( NdotV:f32, NdotL:f32, NdotH:f32, VdotH:f32, LdotH:f32, roughness:f32, F0:vec3<f32>, ior:f32\n) -> vec3<f32> { let eta:f32=1.0/ior; let D_rough:f32=distribution_ggx(NdotH,roughness * roughness); let t:f32=clamp((ior - 1.0) * 100.0,0.0,1.0); let D:f32=mix(1.0,D_rough,t); let G:f32=min(1.0,min((2.0 * NdotH * NdotV)/VdotH,(2.0 * NdotH * NdotL)/VdotH)); let F:vec3<f32>=fresnel_schlick(VdotH,F0); let denom:f32=(eta * VdotH + LdotH) * (eta * VdotH + LdotH); let btdf:vec3<f32>= (vec3<f32>(1.0) - F) *  abs(VdotH * LdotH) *  (eta * eta) *  D *  G/ (NdotV * denom + 0.001); return btdf;\n}\nfn lambda_sheen_calc_l(x:f32,alpha_g:f32) -> f32 { let one_minus_alpha_sq=(1.0 - alpha_g) * (1.0 - alpha_g); let a=mix(21.5473,25.3245,one_minus_alpha_sq); let b=mix(3.82987,3.32435,one_minus_alpha_sq); let c=mix(0.19823,0.16801,one_minus_alpha_sq); let d=mix(-1.97760,-1.27393,one_minus_alpha_sq); let e=mix(-4.32054,-4.85967,one_minus_alpha_sq); return a/(1.0 + b * pow(x,c)) + d * x + e;\n}\nfn lambda_sheen(cos_theta:f32,alpha_g:f32) -> f32 { if (abs(cos_theta) < 0.5) { return exp(lambda_sheen_calc_l(cos_theta,alpha_g)); } else { return exp(2.0 * lambda_sheen_calc_l(0.5,alpha_g) - lambda_sheen_calc_l(1.0 - cos_theta,alpha_g)); }\n}\nfn fresnel_coat(NdotV:f32,ior:f32,weight:f32,base:vec3<f32>,layer:vec3<f32>) -> vec3<f32> { let f0:f32=pow((1.0 - ior)/(1.0 + ior),2.0); let fr:f32=f0 + (1.0 - f0) * pow(1.0 - abs(NdotV),5.0); return mix(base,layer,weight * fr);\n}\nfn conductor_fresnel(F0:vec3<f32>,bsdf:vec3<f32>,VdotH:f32) -> vec3<f32> { let fresnel=F0 + (vec3<f32>(1.0) - F0) * pow(1.0 - abs(VdotH),5.0); return bsdf * fresnel;\n}\nfn fresnel_mix( F0:vec3<f32>, weight:f32, base:vec3<f32>, layer:vec3<f32>, VdotH:f32\n) -> vec3<f32> { var f0=F0; f0=min(f0,vec3<f32>(1.0)); let fr=f0 + (1.0 - f0) * pow(1.0 - abs(VdotH),5.0); return (1 - weight * max(max(fr.x,fr.y),fr.z)) * base + weight * fr * layer;\n}\nfn fresnel_mix_ibl( F0:vec3<f32>, weight:f32, base:vec3<f32>, layer:vec3<f32>, NdotV:f32\n) -> vec3<f32> { var f0=F0; f0=min(f0,vec3<f32>(1.0)); let fr=f0 + (1.0 - f0) * pow(1.0 - max(NdotV,0.0),5.0); return base * (1.0 - fr * weight) + layer * fr * weight;\n}\nfn diffuse_brdf_disney(NdotL:f32,NdotV:f32,LdotH:f32,roughness:f32,albedo:vec3<f32>) -> vec3<f32> { if (NdotL <=0.0) { return vec3<f32>(0.0);} let energyBias=mix(0.0,0.5,roughness); let energyFactor=mix(1.0,1.0/1.51,roughness); let fd90=energyBias + 2.0 * LdotH * LdotH * roughness; let f0=1.0; let lightScatter=f0 + (fd90 - f0) * pow(1.0 - NdotL,5.0); let viewScatter=f0 + (fd90 - f0) * pow(1.0 - NdotV,5.0); return albedo * NdotL * lightScatter * viewScatter * energyFactor/pi;\n}\nfn diffuse_brdf(NdotL:f32,albedo:vec3<f32>) -> vec3<f32> { return albedo * NdotL/pi;\n}\nfn diffuse_btdf(N:vec3<f32>,L:vec3<f32>,Albedo:vec3<f32>) -> vec3<f32> { let cos_theta=max(-dot(N,L),0.0); return Albedo * cos_theta/pi;\n}\nfn specular_brdf( F0:vec3<f32>, roughness:f32, NdotH:f32, NdotV:f32, NdotL:f32, LdotH:f32\n) -> vec3<f32> { let D=distribution_ggx(NdotH,roughness); let G=geometry_smith(NdotV,NdotL,roughness); let F=fresnel_schlick(LdotH,F0); let numerator=D * G * F; let denominator=4.0 * NdotV * NdotL + 0.04; return (numerator/denominator);\n}\nfn distribution_ggx(NdotH:f32,roughness:f32) -> f32 { let alpha=roughness * roughness; let alpha2=alpha * alpha; let NdotH2=NdotH * NdotH; let nom=alpha2; let denom=(NdotH2 * (alpha2 - 1.0) + 1.0); let denom_squared=denom * denom; return nom/(denom_squared * 3.14159265359);\n}\nfn geometry_smith(NdotV:f32,NdotL:f32,roughness:f32) -> f32 { let alpha=roughness * roughness; let k=alpha/2.0; let ggx1=NdotV/(NdotV * (1.0 - k) + k); let ggx2=NdotL/(NdotL * (1.0 - k) + k); return ggx1 * ggx2;\n}\nfn fresnel_schlick(cosTheta:f32,F0:vec3<f32>) -> vec3<f32> { return F0 + (vec3<f32>(1.0) - F0) * pow(1.0 - cosTheta,5.0);\n}\nfn get_transformed_uv( input_uv:vec2<f32>, input_uv1:vec2<f32>, texCoord_index:u32, use_transform:u32, transform_offset:vec2<f32>, transform_rotation:f32, transform_scale:vec2<f32>\n) -> vec2<f32> { var result_uv=select(input_uv,input_uv1,texCoord_index==1); if (use_transform==1) { let translation=mat3x3<f32>( 1.0,0.0,0.0, 0.0,1.0,0.0, transform_offset.x,transform_offset.y,1.0 ); let cos_rot=cos(transform_rotation); let sin_rot=sin(transform_rotation); let rotation_matrix=mat3x3<f32>( cos_rot,-sin_rot,0.0, sin_rot,cos_rot,0.0, 0.0,0.0,1.0 ); let scale_matrix=mat3x3<f32>( transform_scale.x,0.0,0.0, 0.0,transform_scale.y,0.0, 0.0,0.0,1.0 ); let result_matrix=translation * rotation_matrix * scale_matrix; result_uv=(result_matrix * vec3<f32>(result_uv,1.0)).xy; } return result_uv;\n}\nfn linear_to_srgb(linearColor:vec4<f32>) -> vec4<f32> { let cutoff=vec4<f32>(0.0031308); let higher=vec4<f32>(1.055) * pow(linearColor,vec4<f32>(1.0/2.4)) - vec4<f32>(0.055); let lower=linearColor * vec4<f32>(12.92); return vec4<f32>( mix(higher.r,lower.r,step(linearColor.r,cutoff.r)), mix(higher.g,lower.g,step(linearColor.g,cutoff.g)), mix(higher.b,lower.b,step(linearColor.b,cutoff.b)), linearColor.a  );\n}\n"));class PBRMaterial extends ABitmapBaseMaterial{#Ka;#Wa;#ja;#Xa;#qa;constructor(i){super(i,"PBR_MATERIAL",tr,2),this.initGPURenderInfos(),this.#Ka=new PackedTexture(i),this.#qa=new PackedTexture(i),this.#Wa=new PackedTexture(i),this.#ja=new PackedTexture(i),this.#Xa=new PackedTexture(i),this.__packingList=[()=>{this.setupPackORMTexture(),this.setupPackedKHR_clearcoatTexture_transmission(),this.setupPackedKHR_diffuse_transmission(),this.setupPackedKHR_sheen(),this.setupPackedKHR_iridescence()}]}get packedKHR_clearcoatTexture_transmission(){return this.#qa}get packedKHR_iridescence(){return this.#Xa}get packedORMTexture(){return this.#Ka}get packedKHR_sheen(){return this.#ja}get packedKHR_diffuse_transmission(){return this.#Wa}async setupPackORMTexture(){const i=Math.max(this.occlusionTexture?.gpuTexture?.width||1,this.metallicRoughnessTexture?.gpuTexture?.width||1),m=Math.max(this.occlusionTexture?.gpuTexture?.height||1,this.metallicRoughnessTexture?.gpuTexture?.height||1);await this.#Ka.packing({r:this.occlusionTexture?.gpuTexture,g:this.metallicRoughnessTexture?.gpuTexture,b:this.metallicRoughnessTexture?.gpuTexture},i,m,"packedORMTexture")}async setupPackedKHR_clearcoatTexture_transmission(){const i=Math.max(this.KHR_clearcoatTexture?.gpuTexture?.width||1,this.KHR_clearcoatRoughnessTexture?.gpuTexture?.width||1),m=Math.max(this.KHR_clearcoatTexture?.gpuTexture?.height||1,this.KHR_clearcoatRoughnessTexture?.gpuTexture?.height||1),g=Math.max(this.KHR_transmissionTexture?.gpuTexture?.width||1,this.KHR_thicknessTexture?.gpuTexture?.width||1),_=Math.max(this.KHR_transmissionTexture?.gpuTexture?.height||1,this.KHR_thicknessTexture?.gpuTexture?.height||1),b=Math.max(i,g),y=Math.max(m,_);await this.#qa.packing({r:this.KHR_clearcoatTexture?.gpuTexture,g:this.KHR_clearcoatRoughnessTexture?.gpuTexture,b:this.KHR_transmissionTexture?.gpuTexture,a:this.KHR_thicknessTexture?.gpuTexture},b,y,"packedKHR_clearcoatTexture_transmission",{b:"r",a:"g"})}async setupPackedKHR_diffuse_transmission(){const i=Math.max(this.KHR_diffuseTransmissionColorTexture?.gpuTexture?.width||1,this.KHR_diffuseTransmissionTexture?.gpuTexture?.width||1),m=Math.max(this.KHR_diffuseTransmissionColorTexture?.gpuTexture?.height||1,this.KHR_diffuseTransmissionTexture?.gpuTexture?.height||1);await this.#Wa.packing({r:this.KHR_diffuseTransmissionColorTexture?.gpuTexture,g:this.KHR_diffuseTransmissionColorTexture?.gpuTexture,b:this.KHR_diffuseTransmissionColorTexture?.gpuTexture,a:this.KHR_diffuseTransmissionTexture?.gpuTexture},i,m,"packedKHR_diffuse_transmission")}async setupPackedKHR_sheen(){const i=Math.max(this.KHR_sheenColorTexture?.gpuTexture?.width||1,this.KHR_sheenRoughnessTexture?.gpuTexture?.width||1),m=Math.max(this.KHR_sheenColorTexture?.gpuTexture?.height||1,this.KHR_sheenRoughnessTexture?.gpuTexture?.height||1);await this.#ja.packing({r:this.KHR_sheenColorTexture?.gpuTexture,g:this.KHR_sheenColorTexture?.gpuTexture,b:this.KHR_sheenColorTexture?.gpuTexture,a:this.KHR_sheenRoughnessTexture?.gpuTexture},i,m,"packedKHR_sheen")}async setupPackedKHR_iridescence(){const i=Math.max(this.KHR_iridescenceTexture?.gpuTexture?.width||1,this.KHR_iridescenceThicknessTexture?.gpuTexture?.width||1),m=Math.max(this.KHR_iridescenceTexture?.gpuTexture?.height||1,this.KHR_iridescenceThicknessTexture?.gpuTexture?.height||1);await this.#Xa.packing({r:this.KHR_iridescenceTexture?.gpuTexture,g:this.KHR_iridescenceThicknessTexture?.gpuTexture},i,m,"packedKHR_iridescence")}}In.defineByPreset(PBRMaterial,[In.PRESET_POSITIVE_NUMBER.EMISSIVE_STRENGTH,In.PRESET_POSITIVE_NUMBER.NORMAL_SCALE]);er.forEach(i=>{const{extensionName:m,textureList:g,useSampler:_}=i,{positiveNumberList:b,vec3List:y,vec4List:T}=i;m&&In.defineBoolean(PBRMaterial,[`use${m}`]),((i,m)=>{i?.forEach(i=>{In.defineBoolean(PBRMaterial,[`use${i.charAt(0).toUpperCase()}${i.substring(1)}`]),In.definePositiveNumber(PBRMaterial,[[`${i}_KHR_texture_transform_rotation`,0]]),In.defineBoolean(PBRMaterial,[`use_${i}_KHR_texture_transform`]),In.defineVec2(PBRMaterial,[`${i}_KHR_texture_transform_offset`,[`${i}_KHR_texture_transform_scale`,[1,1]]]),In.defineUint(PBRMaterial,[`${i}_texCoord_index`]),In.defineTexture(PBRMaterial,[i]),m&&In.defineSampler(PBRMaterial,[`${i}Sampler`])})})(g,!_),b?.forEach(i=>{In.definePositiveNumber(PBRMaterial,[i])}),y?.forEach(i=>{In.defineVec3(PBRMaterial,[i])}),T?.forEach(i=>{In.defineVec4(PBRMaterial,[i])})}),In.definePositiveNumber(PBRMaterial,[["cutOff",0],["KHR_materials_ior",1.5],["KHR_dispersion",0]]),In.defineUint(PBRMaterial,["alphaBlend"]),In.defineBoolean(PBRMaterial,["doubleSided","useCutOff","useVertexColor","useVertexTangent","useKHR_materials_unlit",["useSSR",!0]]),Object.freeze(PBRMaterial);var nr="struct InputData { @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(3) uv1:vec2<f32>, @location(4) vertexColor_0:vec4<f32>, @location(5) vertexTangent:vec4<f32>,\n};",rr="struct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(3) uv1:vec2<f32>, @location(4) vertexColor_0:vec4<f32>, @location(5) vertexTangent:vec4<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(10) localNodeScale_volumeScale:vec2<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(14) @interpolate(flat) receiveShadow:f32, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};",ir="struct InputData { @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>,\n};\n",ar="struct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(14) @interpolate(flat) receiveShadow:f32, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};",sr="#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include drawDirectionalShadowDepth;\n#redgpu_include picking;\n#redgpu_include calcDisplacements;\n#redgpu_include meshVertexBasicUniform;\nconst maxDistance:f32=1000.0;\nconst maxMipLevel:f32=10.0;\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\n@group(1) @binding(1) var displacementTextureSampler:sampler;\n@group(1) @binding(2) var displacementTexture:texture_2d<f32>;\n@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; #redgpu_if disableJitter { let u_projectionMatrix=systemUniforms.noneJitterProjectionCameraMatrix; } #redgpu_else { let u_projectionMatrix=systemUniforms.projectionMatrix; } #redgpu_endIf let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_noneJitterProjectionCameraMatrix=systemUniforms.noneJitterProjectionCameraMatrix; let u_prevNoneJitterProjectionCameraMatrix=systemUniforms.prevNoneJitterProjectionCameraMatrix; let u_resolution=systemUniforms.resolution; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_matrixList=vertexUniforms.matrixList; let u_modelMatrix=u_matrixList.modelMatrix; let u_prevModelMatrix=u_matrixList.prevModelMatrix; let u_normalModelMatrix=u_matrixList.normalModelMatrix; let u_displacementScale=vertexUniforms.displacementScale; let u_useDisplacementTexture=vertexUniforms.useDisplacementTexture==1u; let u_receiveShadow=vertexUniforms.receiveShadow; let u_directionalLightCount=systemUniforms.directionalLightCount; let u_directionalLights=systemUniforms.directionalLights; let u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix; let input_position=inputData.position; let input_position_vec4=vec4<f32>(input_position,1.0); let input_vertexNormal=inputData.vertexNormal; let input_uv=inputData.uv; var position:vec4<f32>; var normalPosition:vec4<f32>; #redgpu_if useDisplacementTexture let tempPosition=u_modelMatrix * input_position_vec4; let distance=distance(tempPosition.xyz,u_cameraPosition); let mipLevel=(distance/maxDistance) * maxMipLevel; let displacedPosition=calcDisplacementPosition( input_position, input_vertexNormal, displacementTexture, displacementTextureSampler, u_displacementScale, input_uv, mipLevel ); position=u_modelMatrix * vec4<f32>(displacedPosition,1.0); let worldUV=input_uv; let displacedNormal=calcDisplacementNormal( normalize((u_normalModelMatrix * vec4<f32>(input_vertexNormal,0.0)).xyz), displacementTexture, displacementTextureSampler, u_displacementScale, worldUV, mipLevel ); normalPosition=vec4<f32>(displacedNormal,0.0); #redgpu_else position=u_modelMatrix * input_position_vec4; normalPosition=u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0); #redgpu_endIf output.position=u_projectionCameraMatrix * position; output.vertexPosition=position.xyz; output.vertexNormal=normalPosition.xyz; output.uv=input_uv; output.combinedOpacity=vertexUniforms.combinedOpacity; #redgpu_if receiveShadow { let posFromLight=u_directionalLightProjectionViewMatrix * vec4(position.xyz,1.0); output.shadowPos=vec3(posFromLight.xy * vec2(0.5,-0.5) + vec2(0.5),posFromLight.z); output.receiveShadow=vertexUniforms.receiveShadow; } #redgpu_endIf { output.currentClipPos=u_noneJitterProjectionCameraMatrix * position; output.prevClipPos=u_prevNoneJitterProjectionCameraMatrix * u_prevModelMatrix * input_position_vec4; } return output;\n}\n";const or={SHADER_INFO_PBR:parseWGSL([nr,rr,"#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include drawDirectionalShadowDepth;\n#redgpu_include picking;\n#redgpu_include meshVertexBasicUniform;\nconst maxDistance:f32=1000.0;\nconst maxMipLevel:f32=10.0;\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\n@group(1) @binding(1) var displacementTextureSampler:sampler;\n@group(1) @binding(2) var displacementTexture:texture_2d<f32>;\n@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; let input_position=inputData.position; let input_position_vec4=vec4<f32>(input_position,1.0); let input_vertexNormal=inputData.vertexNormal; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_noneJitterProjectionCameraMatrix=systemUniforms.noneJitterProjectionCameraMatrix; let u_prevNoneJitterProjectionCameraMatrix=systemUniforms.prevNoneJitterProjectionCameraMatrix; let u_resolution=systemUniforms.resolution; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_matrixList=vertexUniforms.matrixList; let u_localMatrix=u_matrixList.localMatrix; let u_modelMatrix=u_matrixList.modelMatrix; let u_normalModelMatrix=u_matrixList.normalModelMatrix; let u_prevModelMatrix=u_matrixList.prevModelMatrix; let u_receiveShadow=vertexUniforms.receiveShadow; let u_directionalLightCount=systemUniforms.directionalLightCount; let u_directionalLights=systemUniforms.directionalLights; let u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix; var position:vec4<f32>; var normalPosition:vec4<f32>; position=u_modelMatrix * input_position_vec4; normalPosition=u_normalModelMatrix * vec4<f32>(input_vertexNormal,0.0); output.position=u_projectionCameraMatrix * position; output.vertexPosition=position.xyz; output.vertexNormal=normalize(normalPosition.xyz); output.uv=inputData.uv; output.uv1=inputData.uv1; output.vertexColor_0=inputData.vertexColor_0; let transformedTangentXYZ=(u_normalModelMatrix * vec4<f32>(inputData.vertexTangent.xyz,0.0)).xyz; output.vertexTangent=vec4<f32>( normalize(transformedTangentXYZ),inputData.vertexTangent.w ); #redgpu_if receiveShadow { let posFromLight=u_directionalLightProjectionViewMatrix * vec4(position.xyz,1.0); output.shadowPos=vec3(posFromLight.xy * vec2(0.5,-0.5) + vec2(0.5),posFromLight.z); output.receiveShadow=vertexUniforms.receiveShadow; } #redgpu_endIf { output.currentClipPos=u_noneJitterProjectionCameraMatrix * position; output.prevClipPos=u_prevNoneJitterProjectionCameraMatrix * u_prevModelMatrix * input_position_vec4; } let nodeScaleX=length(u_localMatrix[0].xyz); let nodeScaleY=length(u_localMatrix[1].xyz); let nodeScaleZ=length(u_localMatrix[2].xyz); let volumeScaleX=length(u_modelMatrix[0].xyz); let volumeScaleY=length(u_modelMatrix[1].xyz); let volumeScaleZ=length(u_modelMatrix[2].xyz); output.localNodeScale_volumeScale=vec2<f32>( pow(nodeScaleX * nodeScaleY * nodeScaleZ,1.0/3.0), pow(volumeScaleX * volumeScaleY * volumeScaleZ,1.0/3.0) ); return output;\n}\n"].join("\n")),SHADER_INFO_BASIC:parseWGSL([ir,ar,sr].join("\n")),SHADER_INFO_ONLY_FRAGMENT_PBR:parseWGSL([ir,rr,sr].join("\n")),SHADER_INFO_ONLY_VERTEX_PBR:parseWGSL([nr,ar,sr].join("\n"))};Object.freeze(or);const{SHADER_INFO_PBR:ur,SHADER_INFO_BASIC:lr,SHADER_INFO_ONLY_FRAGMENT_PBR:cr,SHADER_INFO_ONLY_VERTEX_PBR:hr}=or,fr=ur.shaderSourceVariant.getVariant("none"),dr=lr.shaderSourceVariant.getVariant("none"),mr=cr.shaderSourceVariant.getVariant("none"),pr=hr.shaderSourceVariant.getVariant("none");class LODManager{#Ya=[];#Za;#Ja=!1;constructor(i,m){"InstancingMesh"===i.constructor.name&&(this.#Ja=!0),this.#Za=m}get LODList(){return[...this.#Ya]}addLOD(i,m,g){if(validatePositiveNumberRange(i,1),this.#Ya.length>=8)throw new Error("Maximum of 8 LOD levels allowed.");if(this.#Ya.some(m=>m.distance===i))throw new Error(`LOD with distance ${i} already exists.`);const _="PBR"===m.vertexBuffer.interleavedStruct.label,b=g instanceof PBRMaterial,y={distance:i,distanceSquared:i*i,geometry:m,material:g,geometryIsPBR:_,materialIsPBR:b};this.#Ya.push({...y,...this.#Ja?{}:{label:`vertex_${_?"pbr":"noPbr"}_fragment_${b?"pbr":"noPbr"}`,source:this.#Qa(m,g)}}),this.#Ya.sort((i,m)=>i.distance-m.distance),this.#Za?.()}getLOD(i){for(const m of this.#Ya)if(i<m.distance)return m;return this.#Ya.at(-1)}removeLOD(i){this.#Ya=this.#Ya.filter(m=>m.distance!==i),this.#Za?.()}clearLOD(){this.#Ya.length=0,this.#Za?.()}#Qa(i,m){const g="PBR"===i.vertexBuffer.interleavedStruct.label,_=m instanceof PBRMaterial;return g&&_?fr:!g&&_?mr:g&&!_?pr:dr}}const gr=Object.values(Ft);class DepthStencilState{#es;#V="depth32float";#ts=["r8unorm","r8snorm","r8uint","r8sint","r16uint","r16sint","r16float","rg8unorm","rg8snorm","rg8uint","rg8sint","r32uint","r32sint","r32float","rg16uint","rg16sint","rg16float","rgba8unorm","rgba8unorm-srgb","rgba8snorm","rgba8uint","rgba8sint","bgra8unorm","bgra8unorm-srgb","rgb9e5ufloat","rgb10a2uint","rgb10a2unorm","rg11b10ufloat","rg32uint","rg32sint","rg32float","rgba16uint","rgba16sint","rgba16float","rgba32uint","rgba32sint","rgba32float","stencil8","depth16unorm","depth24plus","depth24plus-stencil8","depth32float","depth32float-stencil8","bc1-rgba-unorm","bc1-rgba-unorm-srgb","bc2-rgba-unorm","bc2-rgba-unorm-srgb","bc3-rgba-unorm","bc3-rgba-unorm-srgb","bc4-r-unorm","bc4-r-snorm","bc5-rg-unorm","bc5-rg-snorm","bc6h-rgb-ufloat","bc6h-rgb-float","bc7-rgba-unorm","bc7-rgba-unorm-srgb","etc2-rgb8unorm","etc2-rgb8unorm-srgb","etc2-rgb8a1unorm","etc2-rgb8a1unorm-srgb","etc2-rgba8unorm","etc2-rgba8unorm-srgb","eac-r11unorm","eac-r11snorm","eac-rg11unorm","eac-rg11snorm","astc-4x4-unorm","astc-4x4-unorm-srgb","astc-5x4-unorm","astc-5x4-unorm-srgb","astc-5x5-unorm","astc-5x5-unorm-srgb","astc-6x5-unorm","astc-6x5-unorm-srgb","astc-6x6-unorm","astc-6x6-unorm-srgb","astc-8x5-unorm","astc-8x5-unorm-srgb","astc-8x6-unorm","astc-8x6-unorm-srgb","astc-8x8-unorm","astc-8x8-unorm-srgb","astc-10x5-unorm","astc-10x5-unorm-srgb","astc-10x6-unorm","astc-10x6-unorm-srgb","astc-10x8-unorm","astc-10x8-unorm-srgb","astc-10x10-unorm","astc-10x10-unorm-srgb","astc-12x10-unorm","astc-12x10-unorm-srgb","astc-12x12-unorm","astc-12x12-unorm-srgb"];#ns=!0;#rs=Ft.LESS_EQUAL;#is;#as;#ss;#os;#us=1;#ls=1;#cs=1;constructor(i){this.#es=i}get format(){return this.#V}set format(i){this.#ts.includes(i)?(this.#V=i,this.#es.dirtyPipeline=!0):consoleAndThrowError(`Invalid value for format. Received ${i}. Expected one of:${this.#ts.join(",")}`)}get depthWriteEnabled(){return this.#ns}set depthWriteEnabled(i){this.#ns=i,this.#es.dirtyPipeline=!0}get depthCompare(){return this.#rs}set depthCompare(i){gr.includes(i)?(this.#rs=i,this.#es.dirtyPipeline=!0):consoleAndThrowError(`Invalid value for depthCompare. Received ${i}. Expected one of:${gr.join(",")}`)}get stencilFront(){return this.#is}set stencilFront(i){this.#is=i,this.#es.dirtyPipeline=!0}get stencilBack(){return this.#as}set stencilBack(i){this.#as=i,this.#es.dirtyPipeline=!0}get stencilReadMask(){return this.#ss}set stencilReadMask(i){this.#ss=i,this.#es.dirtyPipeline=!0}get stencilWriteMask(){return this.#os}set stencilWriteMask(i){this.#os=i,this.#es.dirtyPipeline=!0}get depthBias(){return this.#us}set depthBias(i){this.#us=i,this.#es.dirtyPipeline=!0}get depthBiasSlopeScale(){return this.#ls}set depthBiasSlopeScale(i){this.#ls=i,this.#es.dirtyPipeline=!0}get depthBiasClamp(){return this.#cs}set depthBiasClamp(i){this.#cs=i,this.#es.dirtyPipeline=!0}get state(){let i=!1;if(this.#es?.primitiveState){const{topology:m}=this.#es.primitiveState;i=m===Zn.TRIANGLE_LIST||m===Zn.TRIANGLE_STRIP}return{format:this.#V,depthWriteEnabled:this.#ns,depthCompare:this.#rs,stencilFront:this.#is,stencilBack:this.#as,stencilReadMask:this.#ss,stencilWriteMask:this.#os,depthBias:i?this.#us:null,depthBiasSlopeScale:i?this.#ls:null,depthBiasClamp:i?this.#cs:null}}}const xr={NONE:"none",FRONT:"front",BACK:"back"};Object.freeze(xr);const _r={CW:"cw",CCW:"ccw"};Object.freeze(_r);const vr=Object.values(qn),br=Object.values(_r),yr=Object.values(xr),Sr=["point-list","line-list","line-strip","triangle-list","triangle-strip"];class PrimitiveState{dirtyPipeline=!1;state;#es;#hs=Zn.TRIANGLE_LIST;#fs;#ds=_r.CCW;#ms=xr.BACK;#ps=!1;constructor(i){this.#es=i,this.#$t()}get topology(){return this.#hs}set topology(i){Sr.includes(i)?(this.#hs=i,this.#$t()):consoleAndThrowError(`Invalid value for topology. Received ${i}. Expected one of:${Sr.join(",")}`)}get stripIndexFormat(){return this.#fs}set stripIndexFormat(i){vr.includes(i)?(this.#fs=i,this.#$t()):consoleAndThrowError(`Invalid value for stripIndexFormat. Received ${i}. Expected one of:${vr.join(",")}`)}get frontFace(){return this.#ds}set frontFace(i){br.includes(i)?(this.#ds=i,this.#$t()):consoleAndThrowError(`Invalid value for frontFace. Received ${i}. Expected one of:${br.join(",")}`)}get cullMode(){return this.#ms}set cullMode(i){yr.includes(i)?(this.#ms=i,this.#$t()):consoleAndThrowError(`Invalid value for cullMode. Received ${i}. Expected one of:${yr.join(",")}`)}get unclippedDepth(){return this.#ps}set unclippedDepth(i){"boolean"==typeof i?(this.#ps=i,this.#$t()):consoleAndThrowError(`Invalid type for unclippedDepth. Received ${typeof i}. Expected type:boolean.`)}#$t(){this.state={topology:this.#hs,stripIndexFormat:this.#fs,frontFace:this.#ds,cullMode:this.#ms,unclippedDepth:this.#ps},this.#es.dirtyPipeline=!0}}class Object3DContainer{modelMatrix=create$2();#gs=[];constructor(){}get children(){return this.#gs}get numChildren(){return this.#gs.length}contains(i){return this.#xs(i),this.#gs.includes(i)}addChild(i){return this.#xs(i),this.#_s(i)?(this.#gs.push(i),i.dirtyTransform=!0,i):null}addChildAt(i,m){if(validateUintRange(m),this.#gs.length<m&&(m=this.#gs.length),!(m<0||m>this.#gs.length)&&this.#_s(i))return this.#gs.splice(m,0,i),i.dirtyTransform=!0,this}getChildAt(i){if(validateUintRange(i),!(i>=this.#gs.length||i<0))return this.#gs[i]}getChildIndex(i){this.#xs(i);const m=this.#gs.indexOf(i);return-1===m?-1:m}setChildIndex(i,m){this.#xs(i),validateUintRange(m);const g=this.#gs.length,_=m>=g,b=this.#gs.indexOf(i);-1!==b?_?consoleAndThrowError(`Invalid index. Index ${m} is out of bounds. Index should be between 0 and ${g-1}.`):(this.#gs.splice(b,1),this.#gs.splice(m,0,i)):consoleAndThrowError(`The provided is not a child of the Object3DContainer.:${i}`)}swapChildren(i,m){if(this.#xs(i),this.#xs(m),i===m)return void consoleAndThrowError("Error:child1 and child2 are the same. Cannot swap a child with itself.");const g=this.#gs.indexOf(i),_=this.#gs.indexOf(m);-1!==g&&-1!==_||consoleAndThrowError(`Error:${-1===g?"child1":"child2"} is not a child of this Object3DContainer.`),this.swapChildrenAt(g,_)}swapChildrenAt(i,m){validateUintRange(i),validateUintRange(m),i===m&&consoleAndThrowError("Error:index1 and index2 are identical. Cannot swap a child with itself.");const g=this.#gs.length;(i>=g||m>=g)&&consoleAndThrowError(`Error:Both index1 and index2 should be less than the number of children. Provided index1:${i},index2:${m},number of children:${g}`);let _=this.#gs[i];this.#gs[i]=this.#gs[m],this.#gs[m]=_}removeChild(i){this.#xs(i);const m=this.#gs.indexOf(i);if(m>-1)return i.parent=null,this.#gs.splice(m,1)[0];consoleAndThrowError("Error:Child not found within parent.")}removeChildAt(i){validateUintRange(i);const m=this.#gs[i];if(m)return m.parent=null,this.#gs.splice(i,1)[0];throw new Error(`Error:No child found at provided index:${i}.`)}removeAllChildren(){let i=this.#gs.length;for(;i--;)this.#gs[i].parent=null;return this.#gs.length=0,this}#xs(i){i instanceof Object3DContainer||consoleAndThrowError("allow only Object3DContainer instance.")}#_s=i=>(this.#xs(i),i.parent?!!i.parent?.removeChild(i)&&(i.parent=this,!0):(i.parent=this,!0))}class MeshBase extends Object3DContainer{gpuRenderInfo;animationInfo={skinInfo:null,morphInfo:null,weightBuffer:null,jointBuffer:null,animationsList:null};gltfLoaderInfo;dirtyPipeline=!0;dirtyTransform=!0;dirtyOpacity=!0;modelMatrix=create$2();localMatrix=create$2();normalModelMatrix=create$2();#l;#c;#vs;#bs;#ys;#m=[];#u=createUUID();constructor(i){super(),validateRedGPUContext(i),this.#l=i,this.#c=i.gpuDevice,this.#vs=new PrimitiveState(this),this.#bs=new DepthStencilState(this)}get uuid(){return this.#u}get currentShaderModuleName(){return this.#ys}set currentShaderModuleName(i){this.#ys=i}get primitiveState(){return this.#vs}get depthStencilState(){return this.#bs}get gpuDevice(){return this.#c}get redGPUContext(){return this.#l}worldToLocal(i,m,g){return worldToLocal(this.modelMatrix,i,m,g)}localToWorld(i,m,g){return localToWorld(this.modelMatrix,i,m,g)}getScreenPoint(i){return getScreenPoint(i,this.modelMatrix)}__fireListenerList(i=!1){for(const i of this.#m)i(this);i&&(this.#m.length=0)}}const Tr="shadow",Mr="picking",createBasePipeline=(i,m,g,_)=>{const{redGPUContext:b}=i,{gpuDevice:y,resourceManager:T}=b,w=i.material.gpuRenderInfo;let P,H;switch(_){case Tr:P="drawDirectionalShadowDepth",H=`${m.label}_shadow_pipeline`;break;case Mr:P="picking",H=`${m.label}_picking_pipeline`;break;default:P="main",H=`${m.label}_pipeline`}const $={module:m,entryPoint:P,buffers:i.vertexStateBuffers},W=[T.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),g];_!==Tr&&W.push(w.fragmentBindGroupLayout);const q={bindGroupLayouts:W,label:`${H}_${w.fragmentBindGroupLayout.label}`},ye={label:H,layout:T.createGPUPipelineLayout(`${q.label}`,q),vertex:$,primitive:i.primitiveState.state};switch(_){case Tr:ye.depthStencil={depthWriteEnabled:!0,depthCompare:Ft.LESS_EQUAL,format:"depth32float"};break;case Mr:i.material&&(ye.fragment={module:i.material.gpuRenderInfo.fragmentShaderModule,entryPoint:"picking",targets:[{format:navigator.gpu.getPreferredCanvasFormat()}]},ye.depthStencil=i.depthStencilState.state);break;default:ye.fragment=w.fragmentState,ye.depthStencil=i.depthStencilState.state,ye.multisample={count:b.antialiasingManager.useMSAA?4:1}}return y.createRenderPipeline(ye)};const getBasicMeshVertexBindGroupDescriptor=(i,m=!1)=>{const{redGPUContext:g,gpuRenderInfo:_,material:b}=i,{resourceManager:y}=g,{vertexUniformBuffer:T,vertexBindGroupLayout:w}=_,{basicSampler:P,emptyBitmapTextureView:H,emptyCubeTextureView:$}=y,{gpuSampler:W}=P;return{layout:w,label:m?"VERTEX_BIND_GROUP_DESCRIPTOR_MESH_SKIN":"VERTEX_BIND_GROUP_DESCRIPTOR_MESH",entries:m?[{binding:0,resource:{buffer:T.gpuBuffer,offset:0,size:T.size}},{binding:1,resource:getGPUResourceSampler(b?.displacementTextureSampler)||W},{binding:2,resource:y.getGPUResourceBitmapTextureView(b?.displacementTexture)||H},{binding:3,resource:{buffer:i.animationInfo.skinInfo.vertexStorageBuffer,offset:0,size:i.animationInfo.skinInfo.vertexStorageBuffer.size}},{binding:4,resource:{buffer:i.animationInfo.skinInfo.prevVertexStorageBuffer,offset:0,size:i.animationInfo.skinInfo.prevVertexStorageBuffer.size}}]:[{binding:0,resource:{buffer:T.gpuBuffer,offset:0,size:T.size}},{binding:1,resource:getGPUResourceSampler(b?.displacementTextureSampler)||W},{binding:2,resource:y.getGPUResourceBitmapTextureView(b?.displacementTexture)||H}]}},getGPUResourceSampler=i=>i?.gpuSampler,{SHADER_INFO_PBR:wr,SHADER_INFO_BASIC:Cr,SHADER_INFO_ONLY_FRAGMENT_PBR:Rr,SHADER_INFO_ONLY_VERTEX_PBR:Pr}=or,Br=wr.uniforms.vertexUniforms,Ir=Cr.uniforms.vertexUniforms,createMeshVertexShaderModule=i=>{const{material:m}=i;let g,_="basic";switch(m instanceof PBRMaterial&&i.animationInfo?.skinInfo?_="skin":i.createCustomMeshVertexShaderModule&&(_="custom"),_){case"basic":{const m=(i=>{const{geometry:m,material:g}=i,_="PBR"===m.vertexBuffer.interleavedStruct.label,b=g instanceof PBRMaterial,y=_&&!b,T=!_&&b;return _&&b?{name:"VERTEX_MODULE_MESH_PBR",shaderInfo:wr,source:wr.defaultSource,uniformStruct:Br}:T?{name:"VERTEX_MODULE_MESH_ONLY_FRAGMENT_PBR",shaderInfo:Rr,source:Rr.defaultSource,uniformStruct:Ir}:y?{name:"VERTEX_MODULE_MESH_ONLY_VERTEX_PBR",shaderInfo:Pr,source:Pr.defaultSource,uniformStruct:Ir}:{name:"VERTEX_MODULE_MESH",shaderInfo:Cr,source:Cr.defaultSource,uniformStruct:Ir}})(i);g=i.createMeshVertexShaderModuleBASIC(m.name,m.shaderInfo,m.uniformStruct,m.source);break}case"skin":g=((i,m)=>{const{redGPUContext:g,currentShaderModuleName:_}=m,{resourceManager:b,gpuDevice:y}=g,{gpuRenderInfo:T}=m,w=`${m.animationInfo.skinInfo.joints.length}`,P=`${i}_${w}`,H="#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include meshVertexBasicUniform;\nconst maxDistance:f32=1000.0;\nconst maxMipLevel:f32=10.0;\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\n@group(1) @binding(1) var displacementTextureSampler:sampler;\n@group(1) @binding(2) var displacementTexture:texture_2d<f32>;\n@group(1) @binding(3) var<storage,read> vertexStorages:array<mat4x4<f32>>;\n@group(1) @binding(4) var<storage,read> prevVertexStorages:array<mat4x4<f32>>;\nstruct InputDataSkin { @builtin(vertex_index) idx:u32, @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(3) uv1:vec2<f32>, @location(4) vertexColor_0:vec4<f32>, @location(5) vertexTangent:vec4<f32>,\n};\nstruct OutputDataSkin { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(3) uv1:vec2<f32>, @location(4) vertexColor_0:vec4<f32>, @location(5) vertexTangent:vec4<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(10) localNodeScale_volumeScale:vec2<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(14) @interpolate(flat) receiveShadow:f32, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\nstruct OutputShadowData { @builtin(position) position:vec4<f32>,\n};\n@vertex\nfn main(inputData:InputDataSkin) -> OutputDataSkin { var output:OutputDataSkin; let input_position=inputData.position; let input_position_vec4=vec4<f32>(input_position,1.0); let input_vertexNormal=inputData.vertexNormal; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_noneJitterProjectionCameraMatrix=systemUniforms.noneJitterProjectionCameraMatrix; let u_prevNoneJitterProjectionCameraMatrix=systemUniforms.prevNoneJitterProjectionCameraMatrix; let u_resolution=systemUniforms.resolution; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_matrixList=vertexUniforms.matrixList; let u_localMatrix=u_matrixList.localMatrix; let u_modelMatrix=u_matrixList.modelMatrix; let u_prevModelMatrix=u_matrixList.prevModelMatrix; let u_normalModelMatrix=u_matrixList.normalModelMatrix; let u_receiveShadow=vertexUniforms.receiveShadow; let u_directionalLightCount=systemUniforms.directionalLightCount; let u_directionalLights=systemUniforms.directionalLights; let u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix; let skinMat=vertexStorages[inputData.idx]; let prevSkinMat=prevVertexStorages[inputData.idx]; let skinnedPosition=(skinMat * vec4<f32>(inputData.position,1.0)); let position=u_modelMatrix * skinnedPosition; let skinnedNormal=(skinMat * vec4<f32>(input_vertexNormal,0.0)).xyz; let transformedNormal=normalize((u_normalModelMatrix * vec4<f32>(skinnedNormal,0.0)).xyz); output.vertexNormal=transformedNormal; let skinnedTangent=(skinMat * vec4<f32>(inputData.vertexTangent.xyz,0.0)).xyz; let transformedTangentXYZ=(u_normalModelMatrix * vec4<f32>(skinnedTangent,0.0)).xyz; output.vertexTangent=vec4<f32>(normalize(transformedTangentXYZ),inputData.vertexTangent.w); output.position=u_projectionCameraMatrix * position; output.vertexPosition=position.xyz; output.uv=inputData.uv; output.uv1=inputData.uv1; output.vertexColor_0=inputData.vertexColor_0; #redgpu_if receiveShadow { let posFromLight=u_directionalLightProjectionViewMatrix * vec4(position.xyz,1.0); output.shadowPos=vec3(posFromLight.xy * vec2(0.5,-0.5) + vec2(0.5),posFromLight.z); output.receiveShadow=vertexUniforms.receiveShadow; } #redgpu_endIf { output.currentClipPos=u_noneJitterProjectionCameraMatrix * position; output.prevClipPos=u_prevNoneJitterProjectionCameraMatrix * u_prevModelMatrix * (prevSkinMat * input_position_vec4); } let nodeScaleX=length(u_localMatrix[0].xyz); let nodeScaleY=length(u_localMatrix[1].xyz); let nodeScaleZ=length(u_localMatrix[2].xyz); let volumeScaleX=length(u_modelMatrix[0].xyz); let volumeScaleY=length(u_modelMatrix[1].xyz); let volumeScaleZ=length(u_modelMatrix[2].xyz); output.localNodeScale_volumeScale=vec2<f32>( pow(nodeScaleX * nodeScaleY * nodeScaleZ,1.0/3.0), pow(volumeScaleX * volumeScaleY * volumeScaleZ,1.0/3.0) ); return output;\n}\n@vertex\nfn drawDirectionalShadowDepth(inputData:InputDataSkin) -> OutputShadowData { var output:OutputShadowData; let u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let input_position=inputData.position;\nlet skinMat=vertexStorages[inputData.idx]; let position=u_modelMatrix * skinMat * vec4<f32>(input_position,1.0); output.position=u_directionalLightProjectionViewMatrix * position; return output;\n}\n@vertex\nfn picking(inputData:InputDataSkin) -> OutputDataSkin { var output:OutputDataSkin; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix;\nlet skinMat=vertexStorages[inputData.idx]; let position=u_modelMatrix * skinMat * vec4<f32>(inputData.position,1.0); output.position=u_projectionCameraMatrix * position; output.pickingId=unpack4x8unorm(vertexUniforms.pickingId); return output;\n}\n",$={code:H};if(_===P)return b.getGPUShaderModule(P);$.code=H.replaceAll("#JOINT_NUM",w),T.vertexUniformInfo=parseWGSL($.code).uniforms.vertexUniforms,m.animationInfo.skinInfo?(createMeshVertexUniformBuffers(m,!0),m.animationInfo.skinInfo.vertexStorageInfo=parseWGSL($.code).storage.vertexStorages,m.animationInfo.skinInfo.vertexStorageBuffer=y.createBuffer({size:16*m.geometry.vertexBuffer.vertexCount*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),m.animationInfo.skinInfo.prevVertexStorageBuffer=y.createBuffer({size:16*m.geometry.vertexBuffer.vertexCount*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),T.vertexUniformBindGroup=g.gpuDevice.createBindGroup(getBasicMeshVertexBindGroupDescriptor(m,!0))):(createMeshVertexUniformBuffers(m),T.vertexUniformBindGroup=g.gpuDevice.createBindGroup(getBasicMeshVertexBindGroupDescriptor(m)));const W=b.createGPUShaderModule(P,$);return m.gpuRenderInfo.vertexShaderModule=W,m.gpuRenderInfo.vertexShaderModule})("VERTEX_MODULE_MESH_PBR_SKIN",i);break;case"custom":g=i.createCustomMeshVertexShaderModule()}return i.currentShaderModuleName=g.label,g},updateMeshDirtyPipeline=(i,m)=>{const{material:g,gpuRenderInfo:_,redGPUContext:b}=i,{resourceManager:y}=b;i.dirtyTransform=!0,g.dirtyPipeline&&g._updateFragmentState();const T=createMeshVertexShaderModule(i),w=y.getGPUBindGroupLayout(i.animationInfo.skinInfo?ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_SKIN:ResourceManager.PRESET_VERTEX_GPUBindGroupLayout);_.vertexShaderModule=T,_.pipeline=createBasePipeline(i,T,w),_.shadowPipeline=null,_.pickingPipeline=null;const{vertexUniformInfo:P}=i.gpuRenderInfo,{members:H}=P;for(const m in H)"pickingId"!==m&&(i[m]=i[m]);i.gpuRenderInfo.vertexUniformInfo.members.pickingId&&i.gpuRenderInfo.vertexUniformBuffer.writeOnlyBuffer(i.gpuRenderInfo.vertexUniformInfo.members.pickingId,i.pickingId),g.dirtyPipeline=!1,i.dirtyPipeline=!1,m&&m.numDirtyPipelines++};class VertexGPURenderInfo{vertexShaderModule;vertexShaderSourceVariant;vertexShaderVariantConditionalBlocks;vertexStructInfo;vertexUniformInfo;vertexBindGroupLayout;vertexUniformBindGroup;vertexUniformBuffer;pipeline;shadowPipeline;pickingPipeline;constructor(i,m,g,_,b,y,T,w,P,H){this.vertexShaderModule=i,this.vertexShaderSourceVariant=m,this.vertexShaderVariantConditionalBlocks=g,this.vertexUniformInfo=_,this.vertexBindGroupLayout=b,this.vertexUniformBindGroup=T,this.vertexUniformBuffer=y,this.pipeline=w,this.shadowPipeline=P,this.pickingPipeline=H}}Object.freeze(VertexGPURenderInfo);const Er="VERTEX_MODULE_MESH_PBR_SKIN",Dr=Math.PI/180,Lr=3.141592653589793,Ur=6.283185307179586,Ar=.225,Or=1.27323954,kr=.405284735,Gr=1.5707963267948966,Fr=new Float32Array(1),Nr=new Float32Array([0,1,0]);class Mesh extends MeshBase{displacementTexture;castShadow=!1;dirtyLOD=!1;passFrustumCulling=!0;createCustomMeshVertexShaderModule;#f;#h;#Ss;#Mt=0;#wt=0;#Ct=0;#Ts=new Float32Array([0,0,0]);#Ms=0;#ws=0;#Cs=0;#Rs;#Ps=1;#Bs=1;#Is=1;#Es=new Float32Array([1,1,1]);#pi=0;#gi=0;#xi=0;#Ds=new Float32Array([0,0,0]);#Ls={};#Us=0;#As=!1;#Os=1;#ks;#Gs=!1;#Fs;#Ns;#Vs;#zs;#Hs;#$s=[];#Ks=[];#Ws;#js=null;#Xs=[];#qs=null;#Ys=!0;#Zs=!0;#Js;#Qs;#eo;#to=[];#no=-1;constructor(i,m,g,_){super(i),_&&(this.name=_),this._geometry=m,this._material=g,this.#Rs=uuidToUint(this.uuid),this.#qs=DrawBufferManager.getInstance(i),this.#ro(),this.#eo=new LODManager(this,()=>{this.dirtyLOD=!0})}get LODManager(){return this.#eo}get enableDebugger(){return this.#Gs}set enableDebugger(i){this.#Gs=i,i&&!this.#ks&&(this.#ks=new DrawDebuggerMesh(this.redGPUContext,this))}get drawDebugger(){return this.#ks}_material;get material(){return this._material}set material(i){this._material=i,this.dirtyPipeline=!0,"blendMode"in this&&(this.blendMode=this.blendMode)}_geometry;get geometry(){return this._geometry}set geometry(i){this._geometry=i,this.dirtyPipeline=!0,this.dirtyTransform=!0}get opacity(){return this.#Os}set opacity(i){validatePositiveNumberRange(i,0,1),this.#Os=i,this.dirtyOpacity=!0}get ignoreFrustumCulling(){return this.#As}set ignoreFrustumCulling(i){this.#As=i}get pickingId(){return this.#Rs}get events(){return this.#Ls}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get vertexStateBuffers(){return this._geometry.gpuRenderInfo.buffers}get parent(){return this.#Ss}set parent(i){this.#Ss=i}get pivotX(){return this.#Ms}set pivotX(i){this.#Ms=i,this.dirtyTransform=!0}get pivotY(){return this.#ws}set pivotY(i){this.#ws=i,this.dirtyTransform=!0}get pivotZ(){return this.#Cs}set pivotZ(i){this.#Cs=i,this.dirtyTransform=!0}get x(){return this.#Mt}set x(i){this.#Mt=this.#Ts[0]=i,this.dirtyTransform=!0}get y(){return this.#wt}set y(i){this.#wt=this.#Ts[1]=i,this.dirtyTransform=!0}get z(){return this.#Ct}set z(i){this.#Ct=this.#Ts[2]=i,this.dirtyTransform=!0}get position(){return this.#Ts}get scaleX(){return this.#Ps}set scaleX(i){this.#Ps=this.#Es[0]=i,this.dirtyTransform=!0}get scaleY(){return this.#Bs}set scaleY(i){this.#Bs=this.#Es[1]=i,this.dirtyTransform=!0}get scaleZ(){return this.#Is}set scaleZ(i){this.#Is=this.#Es[2]=i,this.dirtyTransform=!0}get scale(){return this.#Es}get rotationX(){return this.#pi}set rotationX(i){this.#pi=this.#Ds[0]=i%360,this.dirtyTransform=!0}get rotationY(){return this.#gi}set rotationY(i){this.#gi=this.#Ds[1]=i%360,this.dirtyTransform=!0}get rotationZ(){return this.#xi}set rotationZ(i){this.#xi=this.#Ds[2]=i%360,this.dirtyTransform=!0}get rotation(){return this.#Ds}get boundingOBB(){return this.#Ns&&!this.dirtyTransform||(this.#Ns=null,this.#Fs=null,this.#Ns=calculateMeshOBB(this)),this.#Ns}get boundingAABB(){return this.#Fs&&!this.dirtyTransform||(this.#Ns=null,this.#Fs=null,this.#Fs=calculateMeshAABB(this)),this.#Fs}get combinedBoundingAABB(){return calculateMeshCombinedAABB(this)}setEnableDebuggerRecursively(i=!1){"enableDebugger"in this&&(this.enableDebugger=i),this.children&&this.children.forEach(m=>{m.setEnableDebuggerRecursively(i)})}setCastShadowRecursively(i=!1){"castShadow"in this&&(this.castShadow=i),this.children&&this.children.forEach(m=>{m.setCastShadowRecursively(i)})}setReceiveShadowRecursively(i=!1){"receiveShadow"in this&&(this.receiveShadow=i),this.children&&this.children.forEach(m=>{m.setReceiveShadowRecursively(i)})}setIgnoreFrustumCullingRecursively(i=!1){"ignoreFrustumCulling"in this&&(this.ignoreFrustumCulling=i),this.children&&this.children.forEach(m=>{m.setIgnoreFrustumCullingRecursively(i)})}getCombinedOpacity(){if(this.is2DMeshType){const i=this.parent;return this.#Os*(i?.getCombinedOpacity?i.getCombinedOpacity():1)}return 1}addListener(i,m){this.#Ls[i]=m,this.#Us=Object.keys(this.#Ls).length}lookAt(i,m,g){var _,b=[];b[0]=i,b[1]=m,b[2]=g,identity(this.localMatrix),targetTo(this.localMatrix,[this.#Mt,this.#wt,this.#Ct],b,Nr),_=mat4ToEuler(this.localMatrix,[]),this.rotationX=180*_[0]/Math.PI,this.rotationY=180*_[1]/Math.PI,this.rotationZ=180*_[2]/Math.PI}setScale(i,m,g){m=m??i,g=g??i;const _=this.#Es;this.#Ps=_[0]=i,this.#Bs=_[1]=m,this.#Is=_[2]=g,this.dirtyTransform=!0}setPosition(i,m,g){m=m??i,g=g??i;const _=this.#Ts;this.#Mt=_[0]=i,this.#wt=_[1]=m,this.#Ct=_[2]=g,this.dirtyTransform=!0}setRotation(i,m,g){m=m??i,g=g??i;const _=this.#Ds;this.#pi=_[0]=i,this.#gi=_[1]=m,this.#xi=_[2]=g,this.dirtyTransform=!0}clone(){const i=new Mesh(this.redGPUContext,this._geometry,this._material);i.setPosition(this.#Mt,this.#wt,this.#Ct),i.setRotation(this.#pi,this.#gi,this.#xi),i.setScale(this.#Ps,this.#Bs,this.#Is);let m=this.children.length;for(;m--;)i.addChild(this.children[m].clone());return i}render(i){const{redGPUContext:m}=this,{view:g,isScene2DMode:_,frustumPlanes:b,dirtyVertexUniformFromMaterial:y,useDistanceCulling:T,cullingDistanceSquared:w}=i,{antialiasingManager:P,gpuDevice:H}=m,{scene:$}=g,{shadowManager:W}=$,{directionalShadowManager:q}=W,{pickingManager:ye}=g,{castingList:Ge}=q,Ke=this._geometry,je=this._material,{uuid:Xe}=je||{};let Ye,Ze,Je=this.dirtyPipeline;const{skinInfo:Qe}=this.animationInfo;if(_&&(this.#Ct=0,this.#Cs=0,this.depthStencilState.depthWriteEnabled&&(this.depthStencilState.depthWriteEnabled=!1)),this.dirtyTransform){Ye=!0,this.#Ys=!0,this.#Zs=!0;{const{pixelRectObject:i}=g,m=this.parent,b=this.localMatrix;let y,T,w,P,H,$,W,q,ye,Ge,Ke,je,Xe,Ye,Ze,Je,Qe,et,at,ht,ft,gt,xt,vt,bt,yt,St,Tt,Mt,wt,Ct,Rt,Pt,Bt,It,Et,Dt,Lt,Ut;b[12]=this.#Mt,b[13]=this.#wt,b[14]=this.#Ct,b[15]=1,y=this.#pi*Dr,T=this.#gi*Dr,w=this.#xi*Dr,xt=1,vt=0,bt=0,St=0,Tt=1,Mt=0,Ct=0,Rt=0,Pt=1,Ut=y%Ur,Ut<-Lr?Ut+=Ur:Ut>Lr&&(Ut-=Ur),Ut=Ut<0?Or*Ut+kr*Ut*Ut:Or*Ut-kr*Ut*Ut,P=Ut<0?Ar*(Ut*-Ut-Ut)+Ut:Ar*(Ut*Ut-Ut)+Ut,Ut=(y+Gr)%Ur,Ut<-Lr?Ut+=Ur:Ut>Lr&&(Ut-=Ur),Ut=Ut<0?Or*Ut+kr*Ut*Ut:Or*Ut-kr*Ut*Ut,W=Ut<0?Ar*(Ut*-Ut-Ut)+Ut:Ar*(Ut*Ut-Ut)+Ut,Ut=T%Ur,Ut<-Lr?Ut+=Ur:Ut>Lr&&(Ut-=Ur),Ut=Ut<0?Or*Ut+kr*Ut*Ut:Or*Ut-kr*Ut*Ut,H=Ut<0?Ar*(Ut*-Ut-Ut)+Ut:Ar*(Ut*Ut-Ut)+Ut,Ut=(T+Gr)%Ur,Ut<-Lr?Ut+=Ur:Ut>Lr&&(Ut-=Ur),Ut=Ut<0?Or*Ut+kr*Ut*Ut:Or*Ut-kr*Ut*Ut,q=Ut<0?Ar*(Ut*-Ut-Ut)+Ut:Ar*(Ut*Ut-Ut)+Ut,Ut=w%Ur,Ut<-Lr?Ut+=Ur:Ut>Lr&&(Ut-=Ur),Ut=Ut<0?Or*Ut+kr*Ut*Ut:Or*Ut-kr*Ut*Ut,$=Ut<0?Ar*(Ut*-Ut-Ut)+Ut:Ar*(Ut*Ut-Ut)+Ut,Ut=(w+Gr)%Ur,Ut<-Lr?Ut+=Ur:Ut>Lr&&(Ut-=Ur),Ut=Ut<0?Or*Ut+kr*Ut*Ut:Or*Ut-kr*Ut*Ut,ye=Ut<0?Ar*(Ut*-Ut-Ut)+Ut:Ar*(Ut*Ut-Ut)+Ut,Ye=q*ye,Ze=W*$+P*H*ye,Je=P*$-W*H*ye,Qe=-q*$,et=W*ye-P*H*$,at=P*ye+W*H*$,ht=H,ft=-P*q,gt=W*q;let At=this.#Ps,Ot=this.#Bs,kt=this.#Is;if(this.renderTextureWidth&&(At*=this.renderTextureWidth,Ot*=this.renderTextureHeight),b[0]=Ye*At,b[1]=Ze*At,b[2]=Je*At,b[3]=0,b[4]=Qe*Ot,b[5]=et*Ot,b[6]=at*Ot,b[7]=0,b[8]=ht*kt,b[9]=ft*kt,b[10]=gt*kt,b[11]=0,(this.#Ms||this.#ws||this.#Cs)&&(xt=b[0],vt=b[1],bt=b[2],yt=b[3],St=b[4],Tt=b[5],Mt=b[6],wt=b[7],Ct=b[8],Rt=b[9],Pt=b[10],Bt=b[11],It=b[12],Et=b[13],Dt=b[14],Lt=b[15],Ge=1,Ke=0,je=0,Xe=0,b[0]=Ge*xt+Ke*St+je*Ct+Xe*It,b[1]=Ge*vt+Ke*Tt+je*Rt+Xe*Et,b[2]=Ge*bt+Ke*Mt+je*Pt+Xe*Dt,b[3]=Ge*yt+Ke*wt+je*Bt+Xe*Lt,Ge=0,Ke=1,je=0,Xe=0,b[4]=Ge*xt+Ke*St+je*Ct+Xe*It,b[5]=Ge*vt+Ke*Tt+je*Rt+Xe*Et,b[6]=Ge*bt+Ke*Mt+je*Pt+Xe*Dt,b[7]=Ge*yt+Ke*wt+je*Bt+Xe*Lt,Ge=0,Ke=0,je=1,Xe=0,b[8]=Ge*xt+Ke*St+je*Ct+Xe*It,b[9]=Ge*vt+Ke*Tt+je*Rt+Xe*Et,b[10]=Ge*bt+Ke*Mt+je*Pt+Xe*Dt,b[11]=Ge*yt+Ke*wt+je*Bt+Xe*Lt,_?m?.modelMatrix?(Ge=-this.#Ms,Ke=-this.#ws,je=-this.#Cs,Xe=1):(Ge=-this.#Ms/y,Ke=-this.#ws/T,je=-this.#Cs,Xe=1):(Ge=-this.#Ms,Ke=-this.#ws,je=-this.#Cs,Xe=1),b[12]=Ge*xt+Ke*St+je*Ct+Xe*It,b[13]=Ge*vt+Ke*Tt+je*Rt+Xe*Et,b[14]=Ge*bt+Ke*Mt+je*Pt+Xe*Dt,b[15]=Ge*yt+Ke*wt+je*Bt+Xe*Lt),m?.modelMatrix){const i=m.modelMatrix,g=this.localMatrix,_=this.modelMatrix,b=i[0],y=i[1],T=i[2],w=i[3],P=i[4],H=i[5],$=i[6],W=i[7],q=i[8],ye=i[9],Ge=i[10],Ke=i[11],je=i[12],Xe=i[13],Ye=i[14],Ze=i[15];let Je=g[0],Qe=g[1],et=g[2],at=g[3];_[0]=Je*b+Qe*P+et*q+at*je,_[1]=Je*y+Qe*H+et*ye+at*Xe,_[2]=Je*T+Qe*$+et*Ge+at*Ye,_[3]=Je*w+Qe*W+et*Ke+at*Ze,Je=g[4],Qe=g[5],et=g[6],at=g[7],_[4]=Je*b+Qe*P+et*q+at*je,_[5]=Je*y+Qe*H+et*ye+at*Xe,_[6]=Je*T+Qe*$+et*Ge+at*Ye,_[7]=Je*w+Qe*W+et*Ke+at*Ze,Je=g[8],Qe=g[9],et=g[10],at=g[11],_[8]=Je*b+Qe*P+et*q+at*je,_[9]=Je*y+Qe*H+et*ye+at*Xe,_[10]=Je*T+Qe*$+et*Ge+at*Ye,_[11]=Je*w+Qe*W+et*Ke+at*Ze,Je=g[12],Qe=g[13],et=g[14],at=g[15],_[12]=Je*b+Qe*P+et*q+at*je,_[13]=Je*y+Qe*H+et*ye+at*Xe,_[14]=Je*T+Qe*$+et*Ge+at*Ye,_[15]=Je*w+Qe*W+et*Ke+at*Ze}else{const{modelMatrix:i,localMatrix:m}=this;i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7],i[8]=m[8],i[9]=m[9],i[10]=m[10],i[11]=m[11],i[12]=m[12],i[13]=m[13],i[14]=m[14],i[15]=m[15]}}Ke||(this.#Zs=!1),this.dirtyTransform=!1,this.#Fs=null,this.#Ns=null}if(P.useTAA&&this.#Js){const{gpuRenderInfo:i}=this,{vertexUniformBuffer:g,vertexUniformInfo:_}=i,{members:b}=_,{members:y}=b.matrixList;this.#Vs&&y.prevModelMatrix&&(this.#Js.set(this.#Vs,y.prevModelMatrix.uniformOffsetForData/Float32Array.BYTES_PER_ELEMENT),this.#Zs||m.gpuDevice.queue.writeBuffer(g.gpuBuffer,y.prevModelMatrix.uniformOffset,this.#Vs));{this.#Vs||(this.#Vs=new Float32Array(16));const i=this.#Vs,m=this.modelMatrix;i[0]=m[0],i[1]=m[1],i[2]=m[2],i[3]=m[3],i[4]=m[4],i[5]=m[5],i[6]=m[6],i[7]=m[7],i[8]=m[8],i[9]=m[9],i[10]=m[10],i[11]=m[11],i[12]=m[12],i[13]=m[13],i[14]=m[14],i[15]=m[15]}}else this.#Vs=null;let et=this.passFrustumCulling=!0,at=0;const ht=this.#eo.LODList,ft=ht.length;if(T&&Ke||this.#eo.LODList.length){const{rawCamera:i}=g,m=this.boundingAABB,_=i.x-m.centerX,b=i.y-m.centerY,y=i.z-m.centerZ;at=_*_+b*b+y*y}if(T&&Ke){const i=this.boundingAABB.geometryRadius;at>w+i*i&&(et=!1)}if(b&&et&&!this.#As){const{rawCamera:i}=g,m=this.boundingAABB;if(i instanceof IsometricController){const{centerX:g,centerY:_,centerZ:b,geometryRadius:y}=m,T=i,{left:w,right:P,top:H,bottom:$,nearClipping:W,farClipping:q}=T,{x:ye,y:Ge,z:Ke}=T;{const i=g-ye,m=_-Ge,T=b-Ke,je=45*(Math.PI/180),Xe=Math.cos(je),Ye=Math.sin(je),Ze=i*Xe+T*Ye,Je=-i*Ye+T*Xe;(Ze+y<w||Ze-y>P||m+y<$||m-y>H||Je+y<W||Je-y>q)&&(et=!1)}}else{const i=b[0],g=b[1],_=b[2],y=b[3],T=b[4],w=b[5],P=m.centerX,H=m.centerY,$=m.centerZ,W=m.geometryRadius;(i[0]*P+i[1]*H+i[2]*$+i[3]<=-W||g[0]*P+g[1]*H+g[2]*$+g[3]<=-W||_[0]*P+_[1]*H+_[2]*$+_[3]<=-W||y[0]*P+y[1]*H+y[2]*$+y[3]<=-W||T[0]*P+T[1]*H+T[2]*$+T[3]<=-W||w[0]*P+w[1]*H+w[2]*$+w[3]<=-W)&&(et=!1)}}et&&(this.gltfLoaderInfo?.activeAnimations?.length&&(i.animationList[i.animationList.length]=this.gltfLoaderInfo?.activeAnimations),Qe&&(this.currentShaderModuleName.includes(Er)||(Je=!0),this.currentShaderModuleName===`${Er}_${Qe.joints?.length}`&&(i.skinList[i.skinList.length]=this,Ye=!1))),this.passFrustumCulling=et;const{displacementTexture:gt,displacementScale:xt}=je||{};if((Je||je?.dirtyPipeline||y[Xe])&&(y[Xe]=!0),Ke){i.num3DObjects++,P.changedMSAA&&(Je=!0,this.dirtyLOD=!0),this.gpuRenderInfo||this.initGPURenderInfos();const m=!!gt;this.useDisplacementTexture!==m&&(this.useDisplacementTexture=m,Je=!0),(Je||y[Xe])&&(updateMeshDirtyPipeline(this,i),this.#zs=null,this.#Hs=null)}else i.num3DGroups++;if(Ke&&et){const{gpuRenderInfo:m}=this,{vertexUniformBuffer:_,vertexUniformInfo:b}=m,{members:y}=b,{members:T}=y.matrixList,{gpuBuffer:w}=_;if(this.#Js||(this.#Js=new Float32Array(y.matrixList.endOffset/Float32Array.BYTES_PER_ELEMENT)),void 0!==y.displacementScale&&this.#Qs!==xt&&(this.#Qs=xt,Fr[0]=xt,H.queue.writeBuffer(w,y.displacementScale.uniformOffset,Fr)),this.#Zs){{const i=this.is2DMeshType?multiply(create$2(),this.modelMatrix,fromValues$1(this.width,0,0,0,0,this.height,0,0,0,0,1,0,0,0,0,1)):this.modelMatrix;this.#Js.set(i,T.modelMatrix.uniformOffsetForData/Float32Array.BYTES_PER_ELEMENT)}if(this.#Ys&&T.normalModelMatrix){this.#Ys=!1;const i=this.modelMatrix,m=this.normalModelMatrix,g=i[0],_=i[1],b=i[2],y=i[4],T=i[5],w=i[6],P=i[8],H=i[9],$=i[10],W=g*(T*$-w*H)-_*(y*$-w*P)+b*(y*H-T*P);if(0===W)m[0]=1,m[1]=0,m[2]=0,m[3]=0,m[4]=0,m[5]=1,m[6]=0,m[7]=0,m[8]=0,m[9]=0,m[10]=1,m[11]=0,m[12]=0,m[13]=0,m[14]=0,m[15]=1;else{const i=1/W;m[0]=(T*$-w*H)*i,m[1]=(w*P-y*$)*i,m[2]=(y*H-T*P)*i,m[3]=0,m[4]=(b*H-_*$)*i,m[5]=(g*$-b*P)*i,m[6]=(_*P-g*H)*i,m[7]=0,m[8]=(_*w-b*T)*i,m[9]=(b*y-g*w)*i,m[10]=(g*T-_*y)*i,m[11]=0,m[12]=0,m[13]=0,m[14]=0,m[15]=1}}this.#Js.set(this.normalModelMatrix,T.normalModelMatrix.uniformOffsetForData/Float32Array.BYTES_PER_ELEMENT),T.localMatrix&&this.#Js.set(this.localMatrix,T.localMatrix.uniformOffsetForData/Float32Array.BYTES_PER_ELEMENT),Ye=!0,this.#Zs=!1,H.queue.writeBuffer(w,y.matrixList.startOffset,this.#Js)}this.dirtyOpacity&&(Ze=!0,y.combinedOpacity&&(Fr[0]=this.getCombinedOpacity(),H.queue.writeBuffer(w,y.combinedOpacity.uniformOffset,Fr)),this.dirtyOpacity=!1);const{bundleListRender2PathLayer:P,bundleListParticleLayer:$,bundleListTransparentLayer:W,bundleListAlphaLayer:q,bundleListBasicList:Ge}=i;{const{fragmentUniformBindGroup:m}=je.gpuRenderInfo;if((!this.#zs||Je||this.#Ws!==m||this.#Ks[i.viewIndex]!==g.systemUniform_Vertex_UniformBindGroup||this.dirtyLOD)&&this.#io(i),i.numDrawCalls++,Ke.indexBuffer){const{indexBuffer:m}=Ke,{indexCount:g,triangleCount:_}=m;i.numTriangles+=_,i.numPoints+=g}else{const{vertexBuffer:m}=Ke,{vertexCount:g,triangleCount:_}=m;i.numTriangles+=_,i.numPoints+=g}let _=this.#Hs;if(ft){let i=this.#no;(i<0||i>=ft)&&(i=-1);let m=!1;if(-1===i)at>=ht[0].distanceSquared&&(m=!0);else if(i===ft-1)at<ht[i].distanceSquared&&(m=!0);else{const g=ht[i].distanceSquared,_=ht[i+1].distanceSquared;(at<g||at>=_)&&(m=!0)}if(m){let m=-1;for(let i=0;i<ft&&at>=ht[i].distanceSquared;i++)m=i;m!==i&&(this.#no=m,m>=0&&m<ft&&(_=this.#$s[m]))}else i>=0&&i<ft&&(_=this.#$s[i])}je.use2PathRender?P[P.length]=_:this.meshType===Qn.PARTICLE?$[$.length]=_:je.transparent?(W[W.length]=_,_.mesh=this):2===je.alphaBlend||je.opacity<1||!this.depthStencilState.depthWriteEnabled?q[q.length]=_:Ge[Ge.length]=_}this.#Us&&(ye.castingList[ye.castingList.length]=this)}(this.castShadow||this.castShadow&&!Ke)&&(Ge[Ge.length]=this),this.#Gs&&this.#ks.render(i);const{children:vt}=this;let bt=0;const yt=vt.length;for(this.dirtyTransform=!1;bt<yt;bt++){const m=vt[bt];Ye&&(m.dirtyTransform=Ye),Ze&&(m.dirtyOpacity=Ze),m.render(i)}}initGPURenderInfos(){this.gpuRenderInfo=new VertexGPURenderInfo(null,null,null,null,null,null,null,null),updateMeshDirtyPipeline(this)}createMeshVertexShaderModuleBASIC=(i,m,g,_)=>{const{redGPUContext:b}=this,{gpuRenderInfo:y}=this;return y.vertexUniformInfo!==g&&(y.vertexUniformInfo=g,y.vertexStructInfo=m,createMeshVertexUniformBuffers(this)),y.vertexShaderSourceVariant=m.shaderSourceVariant,y.vertexShaderVariantConditionalBlocks=m.conditionalBlocks,y.vertexUniformBindGroup=b.gpuDevice.createBindGroup(getBasicMeshVertexBindGroupDescriptor(this)),this.#pn(i),this.gpuRenderInfo.vertexShaderModule};#ao(i,m){let g=m-i;for(;g>180;)g-=360;for(;g<-180;)g+=360;return i+g}#so=()=>{const{gpuDevice:i,redGPUContext:m}=this,{resourceManager:g}=m;this.#to.length=0;const _=g.getGPUBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout);this.LODManager.LODList.forEach((i,b)=>{const y={code:i.source},T=g.createGPUShaderModule(i.label,y);this.#to[b]={pipeline:createBasePipeline({vertexStateBuffers:i.geometry.gpuRenderInfo.buffers,primitiveState:this.primitiveState,depthStencilState:this.depthStencilState,geometry:i.geometry,material:i.material||this.material,redGPUContext:m,gpuRenderInfo:this.gpuRenderInfo},T,_),vertexUniformBindGroup:m.gpuDevice.createBindGroup(getBasicMeshVertexBindGroupDescriptor({redGPUContext:m,material:i.material||this.material,gpuRenderInfo:{vertexBindGroupLayout:_,vertexUniformBuffer:this.gpuRenderInfo.vertexUniformBuffer}}))}}),this.#no=-1};#io(i){const{view:m}=i;this.#Hs=this.#oo(m,this._geometry,this._material),this.dirtyLOD&&(this.#so(),this.dirtyLOD=!1),this.#$s.length=0,this.LODManager.LODList.forEach((i,g)=>{this.#$s[g]=this.#oo(m,i.geometry,i.material||this._material,g)})}#oo(i,m,g,_=null){const{gpuDevice:b}=this.redGPUContext,{renderViewStateData:y}=i,{vertexBuffer:T,indexBuffer:w}=m,{fragmentUniformBindGroup:P}=g.gpuRenderInfo;this.#uo(m,_);const H=null!==_,$=b.createRenderBundleEncoder({...i.basicRenderBundleEncoderDescriptor,label:this.uuid});H||(this.#zs=$,this.#Ks[y.viewIndex]=i.systemUniform_Vertex_UniformBindGroup,this.#Ws=P);const{gpuBuffer:W}=T,q=H?this.#to[_].pipeline:this.gpuRenderInfo.pipeline,ye=H?this.#to[_].vertexUniformBindGroup:this.gpuRenderInfo.vertexUniformBindGroup;$.setPipeline(q),$.setVertexBuffer(0,W),this.particleBuffers?.length&&this.particleBuffers.forEach((i,m)=>{$.setVertexBuffer(m+1,i)}),$.setBindGroup(0,i.systemUniform_Vertex_UniformBindGroup),$.setBindGroup(1,ye),$.setBindGroup(2,P);let Ge=this.#js;if(null!==_&&(Ge=this.#Xs[_]),w){const{gpuBuffer:i,format:m}=w;$.setIndexBuffer(i,m),$.drawIndexedIndirect(Ge.buffer,4*Ge.commandOffset)}else $.drawIndirect(Ge.buffer,4*Ge.commandOffset);const Ke=$.finish({label:`${this.name}_LOD${_||0}`});return Ke.mesh=null,Ke}#ro(){this.#js||(this.#js=this.#qs.allocateDrawCommand(this.name))}#uo(i,m=null){const{vertexBuffer:g,indexBuffer:_}=i,b=this.#qs;let y=this.#js;if(null!==m&&(this.#Xs[m]||(this.#Xs[m]=this.#qs.allocateDrawCommand(`${this.name}_LOD${m}`)),y=this.#Xs[m]),this.#ro(),_){const{indexCount:i}=_;this.particleBuffers?b.setIndexedIndirectCommand(y,i,this.particleNum,0,0,0):b.setIndexedIndirectCommand(y,i,1,0,0,0)}else{const{vertexCount:i}=g;b.setIndirectCommand(y,i,1,0,0)}}#pn(i){const{gpuDevice:m,resourceManager:g}=this.redGPUContext,_=this.#gn(),b=`${i}_${_}`;let y=g.getGPUShaderModule(b);if(!y){let i=this.gpuRenderInfo.vertexShaderSourceVariant.getVariant(_);if(i)if(this.animationInfo?.skinInfo){const m=`${this.animationInfo.skinInfo.joints.length}`;i=i.replaceAll("#JOINT_NUM",m),this.gpuRenderInfo.vertexShaderSourceVariant.getVariant(_),y=g.createGPUShaderModule(`${b}_${m}`,{code:i})}else y=g.createGPUShaderModule(b,{code:i});else console.warn("⚠️ 버텍스 바리안트 소스를 찾을 수 없음:",_),y=this.gpuRenderInfo.vertexShaderModule}this.gpuRenderInfo.vertexShaderModule=y}#gn(){const{vertexShaderVariantConditionalBlocks:i}=this.gpuRenderInfo,m=new Set;for(const g of i)this[g]&&m.add(g);const g=m.size>0?Array.from(m).sort().join("+"):"none";return m.size,g}}Object.defineProperty(Mesh.prototype,"meshType",{value:Qn.MESH,writable:!1}),Xn.defineByPreset(Mesh,[Xn.PRESET_BOOLEAN.RECEIVE_SHADOW]),Xn.defineBoolean(Mesh,[["useDisplacementTexture",!1],["disableJitter",!1]]),Object.freeze(Mesh);const Vr=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include calcTintBlendMode;\n#redgpu_include drawPicking;\n#redgpu_include FragmentOutput;\nstruct Uniforms { useDiffuseTexture:u32, opacity:f32, useTint:u32, tint:vec4<f32>, tintBlendMode:u32,\n};\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\n@group(2) @binding(1) var diffuseTextureSampler:sampler;\n@group(2) @binding(2) var diffuseTexture:texture_2d<f32>;\nstruct InputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(11) combinedOpacity:f32, @location(13) shadowPos:vec3<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\n@fragment\nfn main(inputData:InputData) -> FragmentOutput { var output:FragmentOutput; var finalColor:vec4<f32>=textureSample(diffuseTexture,diffuseTextureSampler,inputData.uv); finalColor=vec4<f32>(finalColor.rgb/finalColor.a,finalColor.a * uniforms.opacity * inputData.combinedOpacity); #redgpu_if useTint finalColor=calcTintBlendMode(finalColor,uniforms.tintBlendMode,uniforms.tint); #redgpu_endIf if (finalColor.a==0.0) { discard; } output.color=finalColor; output.gBufferMotionVector=vec4<f32>( 0.0,0.0,1.0,1.0 ); return output;\n};\n");class TextFieldMaterial extends ABitmapBaseMaterial{dirtyPipeline=!1;constructor(i,m,g){super(i,"TEXT_FILED_MATERIAL",Vr,2),g&&(this.name=g),this.diffuseTexture=m,this.diffuseTextureSampler=new Sampler(this.redGPUContext),this.initGPURenderInfos()}}In.defineByPreset(TextFieldMaterial,[In.PRESET_TEXTURE.DIFFUSE_TEXTURE,In.PRESET_SAMPLER.DIFFUSE_TEXTURE_SAMPLER]),Object.freeze(TextFieldMaterial);const zr=";box-sizing:content-box;white-space:nowrap;",Hr={padding:0,background:"transparent",color:"#fff",fontFamily:"Arial",fontSize:16,fontWeight:"normal",fontStyle:"normal",letterSpacing:0,wordBreak:"keep-all",verticalAlign:"middle",textAlign:"center",borderRadius:0,lineHeight:1.4,border:"",boxShadow:"none",boxSizing:"border-box",filter:""};class ATextField extends Mesh{#lo;#co;#ho;#fo;#do;#mo;#po;#go=!0;#l;#xo;#_o=!1;#vo;#bo;constructor(i,m,g=!0){super(i),this.#l=i,this.#go=g,this.#po=m,this._material=new TextFieldMaterial(i),this._material.transparent=!0,this._material.diffuseTextureSampler=new Sampler(i,g?{minFilter:bt.LINEAR,magFilter:bt.LINEAR,mipmapFilter:yt.LINEAR}:{minFilter:bt.NEAREST,magFilter:bt.NEAREST,mipmapFilter:null}),this.depthStencilState.depthWriteEnabled=!1,this.#yo(),this.#So(),this.#To(),this.#Mo(),this.#wo()}get text(){return this.#mo}set text(i){if(this.#mo===i)return;this.#mo=i;const m=this.#ho.querySelector("foreignObject div"),g=this.#Co(i);this.#fo.innerHTML=g,m.innerHTML=g,this.#_o=!0}render(i){this.#po(this.#vo,this.#bo),this.#Ro(),super.render(i)}#Co(i){return i.toString().replace(/\<br\/>/gi,"<div/>")}#yo(){"undefined"!=typeof OffscreenCanvas?this.#lo=new OffscreenCanvas(100,100):this.#lo=document.createElement("canvas"),this.#co=this.#lo.getContext("2d")}#Po(){const i=this.#fo.getBoundingClientRect();const m=i.width+3+3,g=i.height+3+3;return{width:-2&Math.ceil(m),height:-2&Math.ceil(g),extraTop:3,extraRight:3,extraBottom:3,extraLeft:3}}#Bo(){const i=this.#ho,m=i.querySelector("foreignObject"),{width:g,height:_,extraTop:b,extraRight:y,extraBottom:T,extraLeft:w}=this.#Po();m.setAttribute("width",g.toString()),m.setAttribute("height",_.toString()),m.style.padding=`${b}px ${y}px ${T}px ${w}px`,i.setAttribute("width",g.toString()),i.setAttribute("height",_.toString()),this.#do.src="data:image/svg+xml;charset=utf-8,"+encodeURIComponent(i.outerHTML)}#Mo(){this.#do=new Image,this.#do.style.cssText="position:absolute;bottom:0px;left:0;",this.#do.onload=i=>{let m,g;const{width:_,height:b}=this.#Po(),y=(this.#go,2),T=this.#go?1:2;m=_*y,g=b*y,this.#do.width=m/T,this.#do.height=g/T,this.#lo.width=m,this.#lo.height=g,this.#lo instanceof OffscreenCanvas||(this.#lo.style.width=m/y+"px",this.#lo.style.height=g/y+"px"),this.#co.imageSmoothingEnabled=!0,this.#co.imageSmoothingQuality="high",this.#co.clearRect(0,0,m,g),this.#co.fillStyle="rgba(0,0,0,0)",this.#co.fillRect(0,0,m,g),this.#co.drawImage(this.#do,0,0,m,g),this.dirtyTransform=!0;const callback=i=>{if(this.material.diffuseTexture){const i=this.material.diffuseTexture.src,m="string"==typeof i&&i?.startsWith?.("blob:");this.material.diffuseTexture.destroy(),this.material.diffuseTexture=null,m&&URL.revokeObjectURL(i)}this.material.diffuseTexture=new BitmapTexture(this.#l,URL.createObjectURL(i),!0,i=>{this.#vo=this.#do.width,this.#bo=this.#do.height},null,null,!0)};this.#lo instanceof OffscreenCanvas?this.#lo.convertToBlob({type:"image/png"}).then(callback):this.#lo.toBlob(callback,"image/png")}}#Ro(){this.#_o&&(this.#xo&&cancelAnimationFrame(this.#xo),this.#xo=requestAnimationFrame(()=>{this.#Bo()})),this.#_o=!1}#Io=(i,m)=>{const g=this.#ho.querySelector("foreignObject > div").style,_=this.#fo.style,b=`_${i}`;this[b]=m,Object.defineProperty(this,i,{get:()=>this[b],set:m=>{const y=this[b];this[b]=m;const T=(i=>"number"==typeof i)(m)&&(i=>!["lineHeight","fontWeight"].includes(i))(i)?`${m}px`:m;g[i]=T,_[i]=T,y!==m&&(this.#_o=!0)}}),this[i]=m};#So(){this.#fo=document.createElement("div"),this.#fo.style.cssText=zr+";position:absolute;top:200px;left:0;visibility:hidden;text-rendering:optimizeLegibility",document.body.appendChild(this.#fo)}#To(){const i=this.#ho=document.createElementNS("http://www.w3.org/2000/svg","svg");i.setAttribute("xmlns","http://www.w3.org/2000/svg"),i.setAttribute("text-rendering","optimizeLegibility"),i.style.cssText="position:absolute;top:0px;left:0px;z-index:1;margin:0;padding:0;overflow:visible;background:transparent",i.innerHTML=` <rect x="0" y="0" width="100%" height="100%" fill="rgba(0,0,0,0)"/> <foreignObject width="100%" height="100%" style="margin:0;padding:0;" overflow="visible"> <div xmlns="http://www.w3.org/1999/xhtml" style="${zr}"></div> </foreignObject>`}#wo(){for(const[i,m]of Object.entries(Hr))this.#Io(i,m);this.#_o=!0}}Object.freeze(ATextField);var $r="#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include getBillboardMatrix;\nstruct MatrixList{ modelMatrix:mat4x4<f32>, normalModelMatrix:mat4x4<f32>,\n}\nstruct VertexUniforms { pickingId:u32, matrixList:MatrixList, normalModelMatrix:mat4x4<f32>, useBillboardPerspective:u32, useBillboard:u32, combinedOpacity:f32,\n};\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\nstruct InputData { @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>,\n};\nstruct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(11) combinedOpacity:f32, @location(13) shadowPos:vec3<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\nstruct OutputShadowData { @builtin(position) position:vec4<f32>,\n};\n@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; let u_resolution=systemUniforms.resolution; let u_noneJitterProjectionMatrix=systemUniforms.noneJitterProjectionMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_normalModelMatrix=vertexUniforms.matrixList.normalModelMatrix; let u_useBillboardPerspective=vertexUniforms.useBillboardPerspective; let u_useBillboard=vertexUniforms.useBillboard; let input_position=inputData.position; let input_vertexNormal=inputData.vertexNormal; let input_positionVec4=vec4<f32>(input_position,1.0); let input_vertexNormalVec4=vec4<f32>(input_vertexNormal,1.0); let input_uv=inputData.uv; var position:vec4<f32>; var normalPosition:vec4<f32>; let cameraPosition=vec3<f32>((u_cameraMatrix * u_modelMatrix)[3].xyz); let objectPosition=input_position.xyz; let distance=length(cameraPosition - objectPosition); let scaleFactor=distance; var scaleMatrix:mat4x4<f32>=mat4x4<f32>( 10.0,0.0,0.0,0.0, 0.0,10.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0 ); #redgpu_if useBillboard { if (u_useBillboardPerspective !=1) { scaleMatrix=mat4x4<f32>( scaleFactor,0.0,0.0,0.0, 0.0,scaleFactor,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0 ); } position=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * scaleMatrix * vec4<f32>(objectPosition,1.0); normalPosition=getBillboardMatrix(u_cameraMatrix,u_normalModelMatrix) * scaleMatrix * vec4<f32>(input_vertexNormal,1.0); output.position=u_noneJitterProjectionMatrix * position; if (u_useBillboardPerspective !=1) { var temp=output.position/output.position.w; output.position=vec4<f32>( temp.xy + objectPosition.xy * vec2<f32>( (u_noneJitterProjectionMatrix * u_modelMatrix)[0][0], (u_noneJitterProjectionMatrix * u_modelMatrix)[1][1] ), temp.zw ); } } #redgpu_else { position=u_cameraMatrix * u_modelMatrix * scaleMatrix * vec4<f32>(objectPosition,1.0); normalPosition=u_cameraMatrix * u_normalModelMatrix * scaleMatrix * vec4<f32>(input_vertexNormal,1.0); output.position=u_noneJitterProjectionMatrix * position; } #redgpu_endIf output.vertexPosition=position.xyz; output.vertexNormal=normalPosition.xyz; output.uv=input_uv; output.combinedOpacity=vertexUniforms.combinedOpacity; return output;\n}\nfn drawDirectionalShadowDepth(inputData:InputData) -> OutputShadowData { var output:OutputShadowData; return output;\n}\n@vertex\nfn picking(inputData:InputData) -> OutputData { var output:OutputData; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_noneJitterProjectionMatrix=systemUniforms.noneJitterProjectionMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_normalModelMatrix=vertexUniforms.matrixList.normalModelMatrix; let u_useBillboardPerspective=vertexUniforms.useBillboardPerspective; let u_useBillboard=vertexUniforms.useBillboard; let input_position=inputData.position; let input_positionVec4=vec4<f32>(input_position,1.0); let input_uv=inputData.uv; var position:vec4<f32>; let cameraPosition=vec3<f32>((u_cameraMatrix * u_modelMatrix)[3].xyz); let objectPosition=input_position.xyz; let distance=length(cameraPosition - objectPosition); let scaleFactor=distance; var scaleMatrix:mat4x4<f32>=mat4x4<f32>( 10.0,0.0,0.0,0.0, 0.0,10.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0 ); if (u_useBillboard==1) { if (u_useBillboardPerspective !=1) { scaleMatrix=mat4x4<f32>( scaleFactor,0.0,0.0,0.0, 0.0,scaleFactor,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0 ); } position=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * scaleMatrix * vec4<f32>(objectPosition,1.0); output.position=u_noneJitterProjectionMatrix * position; if (u_useBillboardPerspective !=1) { var temp=output.position/output.position.w; output.position=vec4<f32>( temp.xy + objectPosition.xy * vec2<f32>( (u_noneJitterProjectionMatrix * u_modelMatrix)[0][0], (u_noneJitterProjectionMatrix * u_modelMatrix)[1][1] ), temp.zw ); } } else { position=u_cameraMatrix * u_modelMatrix * scaleMatrix * vec4<f32>(objectPosition,1.0); output.position=u_noneJitterProjectionMatrix * position; } output.pickingId=unpack4x8unorm(vertexUniforms.pickingId); return output;\n}\n";const Kr=parseWGSL($r),Wr=Kr.uniforms.vertexUniforms;class TextField3D extends ATextField{#Eo=1;#Do=1;constructor(i,m){super(i,(i,m)=>{const g=this.#Eo,_=this.#Do;this.#Eo=i/1024,this.#Do=m/1024,g===this.#Eo&&_===this.#Do||(this.dirtyTransform=!0)}),this._geometry=new Plane(i),m&&(this.text=m)}get geometry(){return this._geometry}set geometry(i){console.error("TextField3D can not change geometry")}get material(){return this._material}set material(i){console.error("TextField3D can not change material")}get renderTextureWidth(){return this.#Eo}get renderTextureHeight(){return this.#Do}createCustomMeshVertexShaderModule=()=>this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_TEXT_FIELD_3D",Kr,Wr,$r)}Xn.defineByPreset(TextField3D,[[Xn.PRESET_BOOLEAN.USE_BILLBOARD_PERSPECTIVE,!0],Xn.PRESET_BOOLEAN.USE_BILLBOARD]),Object.freeze(TextField3D);class ADrawDebuggerLight{#l;#Lo;#Uo;constructor(i,m,g=32){this.#l=i;const _=this.createLightDebugGeometry(i,g);this.#Lo=new ColorMaterial(i),this.#Lo.color.setColorByRGB(m[0],m[1],m[2]),this.#Uo=new Mesh(i,_,this.#Lo),this.#Uo.primitiveState.cullMode="none",this.#Uo.primitiveState.topology=Zn.LINE_LIST}get lightMaterial(){return this.#Lo}get lightDebugMesh(){return this.#Uo}updateVertexBuffer(i,m){const g=m.data;let _=0;const b=Math.min(i.length,Math.floor(g.length/16));for(let m=0;m<b;m++){const[b,y]=i[m];g[_++]=b[0],g[_++]=b[1],g[_++]=b[2],g[_++]=0,g[_++]=0,g[_++]=1,g[_++]=0,g[_++]=0,g[_++]=y[0],g[_++]=y[1],g[_++]=y[2],g[_++]=0,g[_++]=0,g[_++]=1,g[_++]=0,g[_++]=0}m.updateAllData(g)}createLightDebugGeometry(i,m){const g=new Float32Array(2*m*8),_=new VertexInterleavedStruct({vertexPosition:VertexInterleaveType.float32x3,vertexNormal:VertexInterleaveType.float32x3,texcoord:VertexInterleaveType.float32x2},`lightDebugStruct_${Math.random()}`),b=new VertexBuffer(i,g,_);return new Geometry(i,b)}}class DrawDebuggerDirectionalLight extends ADrawDebuggerLight{#Ba;#Ao;#Oo=[0,10,0];constructor(i,m){super(i,[255,255,0],8),this.#Ba=m,this.#Ao=new TextField3D(i),this.#Ao.useBillboard=!0,this.#Ao.fontSize=40,this.#Ao.text="☀️",this.lightDebugMesh.addChild(this.#Ao)}render(i){if(!i.view.systemUniform_Vertex_UniformBindGroup)return;if(!this.#Ba.enableDebugger)return;this.#ko(this.#Ba,this.lightDebugMesh.geometry.vertexBuffer),this.lightDebugMesh.setPosition(0,0,0),this.lightDebugMesh.setRotation(0,0,0),this.lightDebugMesh.setScale(1,1,1),this.lightDebugMesh.render(i);const m=this.#Ba.direction,g=this.#Oo,_=Math.sqrt(m[0]*m[0]+m[1]*m[1]+m[2]*m[2]),b=[m[0]/_,m[1]/_,m[2]/_];this.#Ao.setPosition(g[0]-0*b[0],g[1]-0*b[1],g[2]-0*b[2])}#ko(i,m){const g=this.#Oo,_=i.direction||[0,-1,0],b=Math.sqrt(_[0]*_[0]+_[1]*_[1]+_[2]*_[2]),y=[_[0]/b,_[1]/b,_[2]/b],T=[g[0]+3*y[0],g[1]+3*y[1],g[2]+3*y[2]],w=.3;let P=[0,1,0];Math.abs(y[1])>.99&&(P=[1,0,0]);const H=[y[1]*P[2]-y[2]*P[1],y[2]*P[0]-y[0]*P[2],y[0]*P[1]-y[1]*P[0]],$=Math.sqrt(H[0]*H[0]+H[1]*H[1]+H[2]*H[2]),W=[H[0]/$,H[1]/$,H[2]/$],q=[W[1]*y[2]-W[2]*y[1],W[2]*y[0]-W[0]*y[2],W[0]*y[1]-W[1]*y[0]],ye=[[g,T],[T,[T[0]+-.5*y[0]+W[0]*w,T[1]+-.5*y[1]+W[1]*w,T[2]+-.5*y[2]+W[2]*w]],[T,[T[0]+-.5*y[0]-W[0]*w,T[1]+-.5*y[1]-W[1]*w,T[2]+-.5*y[2]-W[2]*w]],[T,[T[0]+-.5*y[0]+q[0]*w,T[1]+-.5*y[1]+q[1]*w,T[2]+-.5*y[2]+q[2]*w]],[T,[T[0]+-.5*y[0]-q[0]*w,T[1]+-.5*y[1]-q[1]*w,T[2]+-.5*y[2]-q[2]*w]],[[g[0]-.3,g[1],g[2]],[g[0]+.3,g[1],g[2]]],[[g[0],g[1]-.3,g[2]],[g[0],g[1]+.3,g[2]]],[[g[0],g[1],g[2]-.3],[g[0],g[1],g[2]+.3]]];this.updateVertexBuffer(ye,m)}}Object.freeze(DrawDebuggerDirectionalLight);class DrawDebuggerPointLight extends ADrawDebuggerLight{#Ba;#Ao;constructor(i,m){super(i,[0,255,255],51),this.#Ba=m,this.#Ao=new TextField3D(i),this.#Ao.useBillboard=!0,this.#Ao.fontSize=40,this.#Ao.text="💡",this.lightDebugMesh.addChild(this.#Ao)}render(i){i.view.systemUniform_Vertex_UniformBindGroup&&this.#Ba.enableDebugger&&(this.#Go(this.#Ba,this.lightDebugMesh.geometry.vertexBuffer),this.lightDebugMesh.setPosition(0,0,0),this.lightDebugMesh.setRotation(0,0,0),this.lightDebugMesh.setScale(1,1,1),this.lightDebugMesh.render(i),this.#Ao.setPosition(...this.#Ba.position))}#Go(i,m){const g=i.position||[0,0,0],_=i.radius||1,b=16,y=[];for(let i=0;i<b;i++){const m=i/b*Math.PI*2,T=(i+1)/b*Math.PI*2,w=g[0]+Math.cos(m)*_,P=g[1]+Math.sin(m)*_,H=g[2],$=g[0]+Math.cos(T)*_,W=g[1]+Math.sin(T)*_,q=g[2];y.push([[w,P,H],[$,W,q]])}for(let i=0;i<b;i++){const m=i/b*Math.PI*2,T=(i+1)/b*Math.PI*2,w=g[0]+Math.cos(m)*_,P=g[1],H=g[2]+Math.sin(m)*_,$=g[0]+Math.cos(T)*_,W=g[1],q=g[2]+Math.sin(T)*_;y.push([[w,P,H],[$,W,q]])}for(let i=0;i<b;i++){const m=i/b*Math.PI*2,T=(i+1)/b*Math.PI*2,w=g[0],P=g[1]+Math.cos(m)*_,H=g[2]+Math.sin(m)*_,$=g[0],W=g[1]+Math.cos(T)*_,q=g[2]+Math.sin(T)*_;y.push([[w,P,H],[$,W,q]])}const T=.2*_;y.push([[g[0]-T,g[1],g[2]],[g[0]+T,g[1],g[2]]]),y.push([[g[0],g[1]-T,g[2]],[g[0],g[1]+T,g[2]]]),y.push([[g[0],g[1],g[2]-T],[g[0],g[1],g[2]+T]]),this.updateVertexBuffer(y,m)}}Object.freeze(DrawDebuggerPointLight);class DrawDebuggerSpotLight extends ADrawDebuggerLight{#Ba;#Ao;constructor(i,m){super(i,[255,255,0],80),this.#Ba=m,this.#Ao=new TextField3D(i),this.#Ao.useBillboard=!0,this.#Ao.fontSize=40,this.#Ao.text="🔦",this.lightDebugMesh.addChild(this.#Ao)}render(i){i.view.systemUniform_Vertex_UniformBindGroup&&this.#Ba.enableDebugger&&(this.#Fo(this.#Ba,this.lightDebugMesh.geometry.vertexBuffer),this.lightDebugMesh.setPosition(0,0,0),this.lightDebugMesh.setRotation(0,0,0),this.lightDebugMesh.setScale(1,1,1),this.lightDebugMesh.render(i),this.#Ao.setPosition(...this.#Ba.position))}#Fo(i,m){const g=i.position||[0,0,0],_=i.direction||[0,-1,0],b=i.radius||5,y=i.outerCutoff||22.5,T=i.innerCutoff||15,w=[],P=Math.sqrt(_[0]*_[0]+_[1]*_[1]+_[2]*_[2]),H=[_[0]/P,_[1]/P,_[2]/P],$=[g[0]+H[0]*b,g[1]+H[1]*b,g[2]+H[2]*b],W=b*Math.tan(y*Math.PI/180),q=b*Math.tan(T*Math.PI/180);let ye=[0,1,0];Math.abs(H[1])>.99&&(ye=[1,0,0]);const Ge=[H[1]*ye[2]-H[2]*ye[1],H[2]*ye[0]-H[0]*ye[2],H[0]*ye[1]-H[1]*ye[0]],Ke=Math.sqrt(Ge[0]*Ge[0]+Ge[1]*Ge[1]+Ge[2]*Ge[2]),je=[Ge[0]/Ke,Ge[1]/Ke,Ge[2]/Ke],Xe=[je[1]*H[2]-je[2]*H[1],je[2]*H[0]-je[0]*H[2],je[0]*H[1]-je[1]*H[0]],Ye=16;for(let i=0;i<Ye;i++){const m=i/Ye*Math.PI*2,_=(i+1)/Ye*Math.PI*2,b=Math.cos(m),y=Math.sin(m),T=Math.cos(_),P=Math.sin(_),H=[$[0]+(je[0]*b+Xe[0]*y)*W,$[1]+(je[1]*b+Xe[1]*y)*W,$[2]+(je[2]*b+Xe[2]*y)*W],q=[$[0]+(je[0]*T+Xe[0]*P)*W,$[1]+(je[1]*T+Xe[1]*P)*W,$[2]+(je[2]*T+Xe[2]*P)*W];w.push([H,q]),w.push([g,H])}for(let i=0;i<Ye;i++){const m=i/Ye*Math.PI*2,g=(i+1)/Ye*Math.PI*2,_=Math.cos(m),b=Math.sin(m),y=Math.cos(g),T=Math.sin(g),P=[$[0]+(je[0]*_+Xe[0]*b)*q,$[1]+(je[1]*_+Xe[1]*b)*q,$[2]+(je[2]*_+Xe[2]*b)*q],H=[$[0]+(je[0]*y+Xe[0]*T)*q,$[1]+(je[1]*y+Xe[1]*T)*q,$[2]+(je[2]*y+Xe[2]*T)*q];w.push([P,H])}w.push([g,$]);const Ze=.3;w.push([[g[0]-Ze,g[1],g[2]],[g[0]+Ze,g[1],g[2]]]),w.push([[g[0],g[1]-Ze,g[2]],[g[0],g[1]+Ze,g[2]]]),w.push([[g[0],g[1],g[2]-Ze],[g[0],g[1],g[2]+Ze]]);for(let i=0;i<4;i++){const m=i/4*Math.PI*2,_=Math.cos(m),b=Math.sin(m),y=[$[0]+(je[0]*_+Xe[0]*b)*W,$[1]+(je[1]*_+Xe[1]*b)*W,$[2]+(je[2]*_+Xe[2]*b)*W];w.push([g,y])}this.updateVertexBuffer(w,m)}}Object.freeze(DrawDebuggerSpotLight);class PickingEvent{pickingId;mouseX;mouseY;target;time;type;movementX=0;movementY=0;localX=0;localY=0;localZ=0;altKey=!1;ctrlKey=!1;shiftKey=!1;constructor(i,m,g,_,b,y,T){this.pickingId=i,this.mouseX=m,this.mouseY=g,this.target=_,this.time=b,this.type=y,this.altKey=T.altKey,this.ctrlKey=T.ctrlKey,this.shiftKey=T.shiftKey}}class PickingManager{lastMouseEvent;lastMouseClickEvent;#No;#Vo;#zo;#Ho;#l;#Rt;#$o=[];#Ko=0;#Wo=0;#jo;#Xo;#F=0;get videoMemorySize(){return this.#F}get mouseX(){return this.#Ko}set mouseX(i){this.#Ko=i}get mouseY(){return this.#Wo}set mouseY(i){this.#Wo=i}get castingList(){return this.#$o}get pickingGPUTexture(){return this.#zo}get pickingGPUTextureView(){return this.#Ho}get pickingDepthGPUTextureView(){return this.#Vo}resetCastingList(){this.#$o.length=0}destroy(){this.#zo&&(this.#zo.destroy(),this.#No.destroy(),this.#zo=null,this.#Ho=null,this.#No=null,this.#Vo=null)}checkTexture(i){const{redGPUContext:m}=i,{resourceManager:g}=m;this.#Rt=i,this.#l=m,this.#zo?.width===this.#Rt.pixelRectObject.width&&this.#zo?.height===this.#Rt.pixelRectObject.height||(this.destroy(),this.#zo=this.#qo("picking",navigator.gpu.getPreferredCanvasFormat()),this.#Ho=g.getGPUResourceBitmapTextureView(this.#zo),this.#No=this.#qo("pickingDepth","depth32float"),this.#Vo=g.getGPUResourceBitmapTextureView(this.#No),this.#Zn())}checkEvents(i,m){this.castingList.length&&(this.#Yo(i,m),this.resetCastingList())}#Zn(){const i=this.#zo;if(!i)return 0;this.#F=calculateTextureByteSize(i)+calculateTextureByteSize(this.#No)}#qo(i,m){const{resourceManager:g}=this.#l;return g.createManagedTexture({size:[this.#Rt.pixelRectObject.width,this.#Rt.pixelRectObject.height,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC,format:m,sampleCount:1,label:`${this.#Rt.name}_${i}_${this.#Rt.pixelRectObject.width}x${this.#Rt.pixelRectObject.height}`})}#Yo=async(i,m,g=1,_=1)=>{const{gpuDevice:b}=i.redGPUContext,{pixelRectArray:y}=i,T=this.#Ko,w=this.#Wo;if(T<=0||T>=y[2]||w<=0||w>=y[3])return;const P=this.#Zo();let H=this.#Jo(b,g,_,T,w);const $=await this.#Qo(H);H.destroy(),H=null,$?(this.#eu($,T,w,m,P),this.#tu($,T,w,m,P)):this.#nu(),this.lastMouseEvent=null,this.lastMouseClickEvent=null};#Zo=()=>this.#$o.reduce((i,m)=>(i[m.pickingId]=m,i),{});#Jo=(i,m,g,_,b)=>{const y=i.createCommandEncoder({label:"PickingManager_ReadPixel_CommandEncoder"}),T=i.createBuffer({size:4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:"readPixelBuffer"}),w={texture:this.#zo,origin:{x:_,y:b,z:0}},P={buffer:T,bytesPerRow:256,rowsPerImage:1};return y.copyTextureToBuffer(w,P,{width:1,height:1,depthOrArrayLayers:1}),i.queue.submit([y.finish()]),T};#eu=(m,g,_,b,y)=>{const T=y[m],w=this.lastMouseClickEvent?.type;if(w===i.CLICK){const i=new PickingEvent(m,g,_,T,b,w,this.lastMouseClickEvent);this.#ru(w,i)}};#tu=(m,g,_,b,y)=>{const T=y[m],w=this.lastMouseEvent?.type;if(w){const y=new PickingEvent(m,g,_,T,b,w,this.lastMouseEvent);switch(this.#jo&&(y.movementX=g-this.#jo.mouseX,y.movementY=_-this.#jo.mouseY),w){case i.DOWN:case i.UP:this.#ru(w,y);break;case i.MOVE:this.#iu(m,T,y)}this.#jo=y}};#iu=(m,g,_)=>{const b=this.#jo?.pickingId;b!==m?(this.#jo&&b&&b!==m&&this.#nu(),this.#Xo!==g&&(this.#ru(i.OVER,_),document.body.style.cursor="pointer"),this.#Xo=g):this.#ru(i.MOVE,_)};#nu=()=>{this.#jo&&this.#ru(i.OUT,this.#jo),this.#jo=null,this.#Xo=null,document.body.style.cursor="default"};async#Qo(i){await i.mapAsync(GPUMapMode.READ);const m=new DataView(i.getMappedRange()),g="rgba8unorm"==this.#zo.format?[0,1,2,3]:[2,1,0,3],_=m.getUint8(g[0]),b=m.getUint8(g[1]),y=m.getUint8(g[2]);return(m.getUint8(g[3])<<24|y<<16|b<<8|_)>>>0}#ru(i,m){m.target.events[i]&&m.target.events[i](m)}}Object.freeze(PickingManager);class FXAA extends ASinglePassPostEffect{#au=.75;#su=.166;#ou=.0833;constructor(i){super(i);this.init(i,"POST_EFFECT_FXAA",createBasicPostEffectCode(this,"\nlet index=vec2<u32>(global_id.xy);\nlet dims=textureDimensions(sourceTexture);\nlet i_index=vec2<i32>(index);\n\n//1. 현재 픽셀 및 주변 4방향 루마(Luma) 및 알파 샘플링\nlet colorM4=textureLoad(sourceTexture,index);\nlet colorM=colorM4.rgb;\nlet lumaM=getLuma(colorM);\n\nlet colorN4=fetchColor4(i_index + vec2<i32>(0,-1),dims);\nlet colorS4=fetchColor4(i_index + vec2<i32>(0,1),dims);\nlet colorW4=fetchColor4(i_index + vec2<i32>(-1,0),dims);\nlet colorE4=fetchColor4(i_index + vec2<i32>(1,0),dims);\n\nlet lumaN=getLuma(colorN4.rgb);\nlet lumaS=getLuma(colorS4.rgb);\nlet lumaW=getLuma(colorW4.rgb);\nlet lumaE=getLuma(colorE4.rgb);\n\n//2. 로컬 대비(Contrast) 분석을 통한 조기 종료 결정\nlet lumaMin=min(lumaM,min(min(lumaN,lumaS),min(lumaW,lumaE)));\nlet lumaMax=max(lumaM,max(max(lumaN,lumaS),max(lumaW,lumaE)));\nlet range=lumaMax - lumaMin;\n\nif (range < max(uniforms.edgeThresholdMin,lumaMax * uniforms.edgeThreshold)) { textureStore(outputTexture,index,colorM4); return;\n}\n\n//3. 대각선 루마 샘플링 (3x3 영역 완성)\nlet lumaNW=getLuma(fetchColor4(i_index + vec2<i32>(-1,-1),dims).rgb);\nlet lumaNE=getLuma(fetchColor4(i_index + vec2<i32>(1,-1),dims).rgb);\nlet lumaSW=getLuma(fetchColor4(i_index + vec2<i32>(-1,1),dims).rgb);\nlet lumaSE=getLuma(fetchColor4(i_index + vec2<i32>(1,1),dims).rgb);\n\n//4. 엣지 방향 판단 (수직 vs 수평)\nlet edgeVer=abs(lumaNW + lumaSW - 2.0 * lumaW) + abs(lumaN + lumaS - 2.0 * lumaM) * 2.0 + abs(lumaNE + lumaSE - 2.0 * lumaE);\nlet edgeHor=abs(lumaNW + lumaNE - 2.0 * lumaN) + abs(lumaW + lumaE - 2.0 * lumaM) * 2.0 + abs(lumaSW + lumaSE - 2.0 * lumaS);\nlet isHorizontal=edgeHor >=edgeVer;\n\n//5. 엣지 방향에 따른 기울기 및 오프셋 설정\nlet luma1=select(lumaW,lumaN,isHorizontal);\nlet luma2=select(lumaE,lumaS,isHorizontal);\nlet gradient1=luma1 - lumaM;\nlet gradient2=luma2 - lumaM;\nlet is1Steeper=abs(gradient1) >=abs(gradient2);\nlet gradientScaled=0.25 * max(abs(gradient1),abs(gradient2));\n\nvar lumaLocalAverage=0.0;\nvar edgeStep=vec2<i32>(0,0);\nif (is1Steeper) { edgeStep=select(vec2<i32>(-1,0),vec2<i32>(0,-1),isHorizontal); lumaLocalAverage=0.5 * (luma1 + lumaM);\n} else { edgeStep=select(vec2<i32>(1,0),vec2<i32>(0,1),isHorizontal); lumaLocalAverage=0.5 * (luma2 + lumaM);\n}\n\n//6. 언리얼급 품질을 위한 엣지 탐색 루프 (Edge Search Iteration)\nvar posP=i_index + edgeStep;\nvar posN=i_index + edgeStep;\nlet searchStep=select(vec2<i32>(1,0),vec2<i32>(0,1),isHorizontal);\n\nvar doneP=false;\nvar doneN=false;\nfor (var i=0;i < 10;i++) { if (!doneP) { if (abs(getLuma(fetchColor4(posP,dims).rgb) - lumaLocalAverage) >=gradientScaled) { doneP=true;} else { posP +=searchStep;} } if (!doneN) { if (abs(getLuma(fetchColor4(posN,dims).rgb) - lumaLocalAverage) >=gradientScaled) { doneN=true;} else { posN -=searchStep;} } if (doneP && doneN) { break;}\n}\n\n//7. 탐색된 끝점까지의 거리를 기반으로 한 엣지 블렌딩 계산\nlet distP=select(f32(posP.x - i_index.x),f32(posP.y - i_index.y),isHorizontal);\nlet distN=select(f32(i_index.x - posN.x),f32(i_index.y - posN.y),isHorizontal);\nlet distMin=min(abs(distP),abs(distN));\nlet edgeBlend=saturate(0.5 - distMin/(abs(distP) + abs(distN)));\n\n//8. 서브픽셀 필터링 (고주파 노이즈 제거용)\nlet lumaL=(lumaN + lumaS + lumaW + lumaE) * 2.0;\nlet lumaCorners=lumaNW + lumaNE + lumaSW + lumaSE;\nlet subpixFilter=saturate(abs((lumaL + lumaCorners)/12.0 - lumaM)/range);\nlet subpixBlend=smoothstep(0.0,1.0,subpixFilter) * uniforms.subpix;\n\n//9. 최종 블렌딩 및 알파 채널 보존 합성\nlet finalBlend=max(edgeBlend,subpixBlend);\nlet colorTarget4=fetchColor4(i_index + edgeStep,dims);\n\n//RGBA 전체를 보간하여 투명도 유지\nlet finalColor4=mix(colorM4,colorTarget4,finalBlend);\n\ntextureStore(outputTexture,index,finalColor4);\n","\nstruct Uniforms { subpix:f32, edgeThreshold:f32, edgeThresholdMin:f32, padding:f32\n};\n\nfn getLuma(rgb:vec3<f32>) -> f32 { return dot(rgb,vec3<f32>(0.299,0.587,0.114));\n}\n\nfn fetchColor4(pos:vec2<i32>,dims:vec2<u32>) -> vec4<f32> { let p=vec2<u32>(clamp(vec2<u32>(pos),vec2<u32>(0),dims - 1)); return textureLoad(sourceTexture,p);\n}\n")),this.subpix=this.#au,this.edgeThreshold=this.#su,this.edgeThresholdMin=this.#ou}get subpix(){return this.#au}set subpix(i){validateNumberRange(i,0,1),this.#au=i,this.updateUniform("subpix",i)}get edgeThreshold(){return this.#su}set edgeThreshold(i){validateNumberRange(i,1e-4,.25),this.#su=i,this.updateUniform("edgeThreshold",i)}get edgeThresholdMin(){return this.#ou}set edgeThresholdMin(i){validateNumberRange(i,1e-5,.1),this.#ou=i,this.updateUniform("edgeThresholdMin",i)}}Object.freeze(FXAA);class TAA{#l;#Hn;#_n;#vn;#bn;#yn;#Pn;#Bn;#In;#En;#Dn;#h;#Ln;#Un;#An;#uu=new Map;#lu=new Map;#cu=new Map;#hu=null;#fu;#du;#mu;#pu;#gu;#xu;#Gn=8;#Fn=8;#Nn=1;#$n=[];#F=0;#_u=0;#vu=.5;#Kn;#Wn;#bu=[0,0];#yu=create$2();constructor(i){this.#l=i,this.#Hn=i.antialiasingManager;const m=this.#Su();this.#ft(i,"POST_EFFECT_TAA",{msaa:m.msaa,nonMsaa:m.nonMsaa}),this.jitterStrength=this.#vu}get prevNoneJitterProjectionCameraMatrix(){return this.#yu}get frameIndex(){return this.#_u}get videoMemorySize(){return this.#F}get jitterStrength(){return this.#vu}set jitterStrength(i){this.#vu=i}render(i,m,g,_){const b=_.textureView;_.texture;const{gpuDevice:y,antialiasingManager:T}=this.#l,{useMSAA:w,msaaID:P}=T;this.#_u++,this.#Bn&&(this.updateUniform("frameIndex",this.#_u),this.updateUniform("currJitterOffset",i.jitterOffset),this.updateUniform("prevJitterOffset",this.#bu),copy$1(this.#yu,i.noneJitterProjectionCameraMatrix),this.#bu=[...i.jitterOffset]),this.#jn(i),this.#Kn!==w||this.#Wn,this.#Xn([b]),this.#Tu(i,[b],w,this.#l,y),this.#Mu(y,m,g);{const i=y.createCommandEncoder({label:"TAA_CopyTexture_CommandEncoder_compute"});i.copyTextureToTexture({texture:this.#fu},{texture:this.#mu},[m,g,1]),y.queue.submit([i.finish()])}return this.#_u<=20||this.#_u,this.#Kn=w,this.#Wn=P,{texture:this.#fu,textureView:this.#du}}clear(){this.#mu&&(this.#mu.destroy(),this.#mu=null,this.#pu=null),this.#fu&&(this.#fu.destroy(),this.#fu=null,this.#du=null),this.#uu.clear(),this.#lu.clear(),this.#cu.clear(),this.#hu=null}updateUniform(i,m){this.#Bn.writeOnlyBuffer(this.#In.members[i],m)}#Su(){const createCode=i=>` \nstruct Uniforms { frameIndex:f32, currJitterOffset:vec2<f32>, prevJitterOffset:vec2<f32>,\n};\nstruct NeighborhoodStats { minColor:vec3<f32>, maxColor:vec3<f32>, mean:vec3<f32>, stdDev:vec3<f32>, minAlpha:f32, maxAlpha:f32, meanAlpha:f32,\n};\nstruct SampledColor { rgb:vec3<f32>, ycocg:vec3<f32>, alpha:f32,\n};\nfn rgb_to_ycocg(rgb:vec3<f32>) -> vec3<f32> { let y=dot(rgb,vec3<f32>(0.25,0.5,0.25)); let co=dot(rgb,vec3<f32>(0.5,0.0,-0.5)); let cg=dot(rgb,vec3<f32>(-0.25,0.5,-0.25)); return vec3<f32>(y,co,cg);\n}\nfn ycocg_to_rgb(ycocg:vec3<f32>) -> vec3<f32> { let y=ycocg.x; let co=ycocg.y; let cg=ycocg.z; return vec3<f32>(y + co - cg,y + cg,y - co - cg);\n}\nfn get_depth_confidence(currDepth:f32,prevDepth:f32) -> f32 { let depthDiff=abs(currDepth - prevDepth); return 1.0 - clamp((depthDiff - 0.01)/0.02,0.0,1.0);\n}\nfn fetch_depth_bilinear(tex:texture_depth_2d,uv:vec2<f32>,screenSize:vec2<f32>) -> f32 { let samplePos=uv * screenSize - 0.5; let f=fract(samplePos); let base=vec2<i32>(floor(samplePos)); let size=vec2<i32>(textureDimensions(tex)); let d00=textureLoad(tex,clamp(base + vec2<i32>(0,0),vec2<i32>(0),size - 1),0); let d10=textureLoad(tex,clamp(base + vec2<i32>(1,0),vec2<i32>(0),size - 1),0); let d01=textureLoad(tex,clamp(base + vec2<i32>(0,1),vec2<i32>(0),size - 1),0); let d11=textureLoad(tex,clamp(base + vec2<i32>(1,1),vec2<i32>(0),size - 1),0); return mix(mix(d00,d10,f.x),mix(d01,d11,f.x),f.y);\n}\nfn calculate_neighborhood_stats_ycocg(pixelCoord:vec2<i32>,screenSizeU:vec2<u32>) -> NeighborhoodStats { let screenSize=vec2<f32>(screenSizeU); var m1=vec3<f32>(0.0); var m2=vec3<f32>(0.0); var m1A=0.0; var minC=vec3<f32>(1e5); var maxC=vec3<f32>(-1e5); var minA=1e5; var maxA=-1e5; for (var y:i32=-1;y <=1;y++) { for (var x:i32=-1;x <=1;x++) { let sampleCoord=clamp(pixelCoord + vec2<i32>(x,y),vec2<i32>(0),vec2<i32>(screenSizeU) - 1); let colorRGBA=textureLoad(sourceTexture,sampleCoord,0); let colorYCoCg=rgb_to_ycocg(colorRGBA.rgb); let alpha=colorRGBA.a; m1 +=colorYCoCg; m2 +=colorYCoCg * colorYCoCg; m1A +=alpha; minC=min(minC,colorYCoCg); maxC=max(maxC,colorYCoCg); minA=min(minA,alpha); maxA=max(maxA,alpha); } } let sampleCount=9.0; var stats:NeighborhoodStats; stats.mean=m1/sampleCount; stats.stdDev=sqrt(max((m2/sampleCount) - (stats.mean * stats.mean),vec3<f32>(0.0))); stats.minColor=minC; stats.maxColor=maxC; stats.minAlpha=minA; stats.maxAlpha=maxA; stats.meanAlpha=m1A/sampleCount; return stats;\n}\nfn get_color_discrepancy_weight(stats:NeighborhoodStats,histYCoCg:vec3<f32>) -> f32 { let diff=abs(stats.mean.x - histYCoCg.x); let threshold=max(stats.stdDev.x * 0.45,0.01); return smoothstep(threshold,threshold * 2.0,diff);\n}\nfn sample_texture_catmull_rom_antiflicker(tex:texture_2d<f32>,smp:sampler,uv:vec2<f32>,texSize:vec2<f32>) -> SampledColor { let samplePos=uv * texSize; let texPos1=floor(samplePos - 0.5) + 0.5; let f=samplePos - texPos1; let w0=f * (-0.5 + f * (1.0 - 0.5 * f)); let w1=1.0 + f * f * (-2.5 + 1.5 * f); let w2=f * (0.5 + f * (2.0 - 1.5 * f)); let w3=f * f * (-0.5 + 0.5 * f); let w12=w1 + w2; let offset12=w2/w12; let invTexSize=1.0/texSize; let coords=array<vec2<f32>,5>( (texPos1 + vec2<f32>(offset12.x,-1.0)) * invTexSize, (texPos1 + vec2<f32>(-1.0,offset12.y)) * invTexSize, (texPos1 + offset12) * invTexSize, (texPos1 + vec2<f32>(2.0,offset12.y)) * invTexSize, (texPos1 + vec2<f32>(offset12.x,2.0)) * invTexSize ); let weights=array<f32,5>( w12.x * w0.y,w0.x * w12.y,w12.x * w12.y,w3.x * w12.y,w12.x * w3.y ); var sumRGB=vec3<f32>(0.0); var sumYCoCg=vec3<f32>(0.0); var sumAlpha=0.0; var sumW=0.0; for(var i=0;i < 5;i++) { let sampleRGBA=textureSampleLevel(tex,smp,coords[i],0.0); let sampleRGB=max(sampleRGBA.rgb,vec3<f32>(0.0)); let sampleYCoCg=rgb_to_ycocg(sampleRGB); let w=weights[i] * (1.0/(1.0 + sampleYCoCg.x)); sumRGB +=sampleRGB * w; sumYCoCg +=sampleYCoCg * w; sumAlpha +=sampleRGBA.a * w; sumW +=w; } var result:SampledColor; let invSumW=1.0/max(sumW,0.0001); result.rgb=sumRGB * invSumW; result.ycocg=sumYCoCg * invSumW; result.alpha=sumAlpha * invSumW; return result;\n}\nfn clip_history_ycocg(historyYCoCg:vec3<f32>,stats:NeighborhoodStats,motion:f32) -> vec3<f32> { let gamma=mix(0.2,0.7,motion); let v_min=min(stats.minColor,stats.mean - stats.stdDev * gamma); let v_max=max(stats.maxColor,stats.mean + stats.stdDev * gamma); return clamp(historyYCoCg,v_min,v_max);\n}\n  @group(0) @binding(0) var sourceTexture:texture_2d<f32>; @group(0) @binding(1) var historyTexture:texture_2d<f32>; @group(0) @binding(2) var motionVectorTexture:texture_2d<f32>; @group(0) @binding(3) var taaTextureSampler:sampler; @group(0) @binding(4) var depthTexture:texture_depth_2d; @group(0) @binding(5) var historyDepthTexture:texture_depth_2d;  @group(1) @binding(0) var outputTexture:texture_storage_2d<rgba16float,write>; ${_n} @group(1) @binding(2) var<uniform> uniforms:Uniforms;  @compute @workgroup_size(${this.#Gn},${this.#Fn},${this.#Nn}) fn main(@builtin(global_invocation_id) global_id:vec3<u32>) { { let pixelCoord=vec2<i32>(global_id.xy); let screenSizeU=textureDimensions(sourceTexture); let screenSize=vec2<f32>(screenSizeU); let yFlipVec2=vec2<f32>(1.0,-1.0); if (any(pixelCoord >=vec2<i32>(screenSizeU))) { return; } let currentUV=(vec2<f32>(pixelCoord) + 0.5 - uniforms.currJitterOffset * yFlipVec2)/screenSize; let stats=calculate_neighborhood_stats_ycocg(pixelCoord,screenSizeU); let currentRGBA=textureSampleLevel(sourceTexture,taaTextureSampler,currentUV,0.0); let currentRGB=currentRGBA.rgb; let currentAlpha=currentRGBA.a; let currentYCoCg=rgb_to_ycocg(currentRGB); let currentDepth=textureLoad(depthTexture,pixelCoord,0); var closestDepth=1.0; var closestCoord=pixelCoord; for(var y:i32=-1;y <=1;y++) { for(var x:i32=-1;x <=1;x++) { let sc=clamp(pixelCoord + vec2<i32>(x,y),vec2<i32>(0),vec2<i32>(screenSizeU) - 1); let d=textureLoad(depthTexture,sc,0); if(d < closestDepth) { closestDepth=d; closestCoord=sc; } } } let motionData=textureLoad(motionVectorTexture,closestCoord,0); let velocity=motionData.xy; let jitterDisabled=motionData.z > 0.5; if (jitterDisabled) { textureStore(outputTexture,pixelCoord,vec4<f32>(currentRGB,currentAlpha)); return; } let historyUV=(vec2<f32>(pixelCoord) + 0.5 - uniforms.currJitterOffset * yFlipVec2 + uniforms.prevJitterOffset * yFlipVec2)/screenSize - velocity; var finalRGB:vec3<f32>; var finalAlpha:f32; if (any(historyUV < vec2<f32>(0.0)) || any(historyUV > vec2<f32>(1.0))) { finalRGB=currentRGB; finalAlpha=currentAlpha; } else { let prevDepth=fetch_depth_bilinear(historyDepthTexture,historyUV,screenSize); let historyData=sample_texture_catmull_rom_antiflicker(historyTexture,taaTextureSampler,historyUV,screenSize); let motionLen=length(velocity * screenSize); let motionSoft=smoothstep(0.0,1.0,motionLen); let clippedYCoCg=clip_history_ycocg(historyData.ycocg,stats,motionSoft); let clippedAlpha=clamp(historyData.alpha,stats.minAlpha,stats.maxAlpha); let clippedHistoryRGB=ycocg_to_rgb(clippedYCoCg); let lumaWeight=get_color_discrepancy_weight(stats,clippedYCoCg); var blendFactor=mix(0.08,0.4,motionSoft); let depthConfidence=get_depth_confidence(currentDepth,prevDepth); blendFactor=max(blendFactor,1.0 - depthConfidence * depthConfidence); blendFactor=max(blendFactor,lumaWeight * 0.5); let currentRGBA=vec4<f32>(currentRGB,currentAlpha); let clippedHistoryRGBA=vec4<f32>(clippedHistoryRGB,clippedAlpha); let finalRGBA=mix(clippedHistoryRGBA,currentRGBA,blendFactor); finalRGB=finalRGBA.rgb; finalAlpha=finalRGBA.a; } textureStore(outputTexture,pixelCoord,vec4<f32>(finalRGB,finalAlpha));\n} } `;return{msaa:createCode(),nonMsaa:createCode()}}#ft(i,m,g){this.#h=m;const{resourceManager:_}=i;this.#_n=_.createGPUShaderModule(`${m}_MSAA`,{code:g.msaa}),this.#vn=_.createGPUShaderModule(`${m}_NonMSAA`,{code:g.nonMsaa}),this.#Ln=parseWGSL(g.msaa),this.#Un=parseWGSL(g.nonMsaa);const b=this.#Ln.storage,y=this.#Ln.uniforms;if(this.#Dn=b,this.#In=y.uniforms,this.#En=y.systemUniforms,this.#In){const m=new ArrayBuffer(this.#In.arrayBufferByteLength);this.#Bn=new UniformBuffer(i,m,"TAA_UniformBuffer")}}#Mu(i,m,g){const _=i.createCommandEncoder({label:"TAA_Execute_CommandEncoder_compute"}),b=_.beginComputePass();b.setPipeline(this.#Pn),b.setBindGroup(0,this.#gu),b.setBindGroup(1,this.#xu),b.dispatchWorkgroups(Math.ceil(m/this.#Gn),Math.ceil(g/this.#Fn)),b.end(),i.queue.submit([_.finish()])}#Tu(i,m,g,_,b){const y=[],T=[];y.push({binding:0,resource:m[0]}),y.push({binding:1,resource:this.#pu}),y.push({binding:4,resource:i.viewRenderTextureManager.depthTextureView}),y.push({binding:5,resource:i.viewRenderTextureManager.prevDepthTextureView});const w=g?i.viewRenderTextureManager.gBufferMotionVectorResolveTextureView:i.viewRenderTextureManager.gBufferMotionVectorTextureView;y.push({binding:2,resource:w}),y.push({binding:3,resource:i.redGPUContext.resourceManager.basicSampler.gpuSampler}),T.push({binding:0,resource:this.#du}),this.#En&&T.push({binding:this.#En.binding,resource:{buffer:i.postEffectManager.postEffectSystemUniformBuffer.gpuBuffer,offset:0,size:i.postEffectManager.postEffectSystemUniformBuffer.size}}),this.#Bn&&this.#In&&T.push({binding:this.#In.binding,resource:{buffer:this.#Bn.gpuBuffer,offset:0,size:this.#Bn.size}}),this.#qn(y,T,g,_,b),this.#wu(g,_,b)}#qn(i,m,g,_,b){const y=g?this.#Ln:this.#Un,T=`${this.#h}_BIND_GROUP_LAYOUT_0_USE_MSAA_${g}`,w=`${this.#h}_BIND_GROUP_LAYOUT_1_USE_MSAA_${g}`;if(!this.#uu.has(T)){const i=_.resourceManager.getGPUBindGroupLayout(T)||_.resourceManager.createBindGroupLayout(T,getComputeBindGroupLayoutDescriptorFromShaderInfo(y,0,g));this.#uu.set(T,i)}if(!this.#uu.has(w)){const i=_.resourceManager.getGPUBindGroupLayout(w)||_.resourceManager.createBindGroupLayout(w,getComputeBindGroupLayoutDescriptorFromShaderInfo(y,1,g));this.#uu.set(w,i)}this.#bn=this.#uu.get(T),this.#yn=this.#uu.get(w),this.#gu=b.createBindGroup({label:`${this.#h}_FRAME_BIND_GROUP_0_USE_MSAA_${g}`,layout:this.#bn,entries:i}),this.#xu=b.createBindGroup({label:`${this.#h}_FRAME_BIND_GROUP_1_USE_MSAA_${g}`,layout:this.#yn,entries:m})}#wu(i,m,g){const _=`${this.#h}_COMPUTE_PIPELINE_USE_MSAA_${i}`,b=`${this.#h}_PIPELINE_LAYOUT_USE_MSAA_${i}`;if(this.#hu!==i||!this.#cu.has(_)){if(!this.#lu.has(b)){const m=g.createPipelineLayout({label:`${this.#h}_PIPELINE_LAYOUT_USE_MSAA_${i}`,bindGroupLayouts:[this.#bn,this.#yn]});this.#lu.set(b,m)}const m=i?this.#_n:this.#vn,y=g.createComputePipeline({label:_,layout:this.#lu.get(b),compute:{module:m,entryPoint:"main"}});this.#cu.set(_,y),this.#hu=i}this.#Pn=this.#cu.get(_)}#jn(i){const{redGPUContext:m,viewRenderTextureManager:g,name:_}=i,{gBufferColorTexture:b}=g,{resourceManager:y}=m,{width:T,height:w}=b,P=T!==this.#An?.width||w!==this.#An?.height||!this.#fu||!this.#mu||!this.#fu;return P&&(gt(`TAA 텍스처 재생성:${T}x${w},이전 프레임 히스토리 리셋`),this.#_u=0,this.clear(),this.#fu=y.createManagedTexture({size:{width:T,height:w},format:"rgba16float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,label:`${_}_${this.#h}_currentFrame_${T}x${w}`}),this.#du=y.getGPUResourceBitmapTextureView(this.#fu,{dimension:"2d",format:"rgba16float",label:`${this.#h}_currentFrame_View`}),this.#mu=y.createManagedTexture({size:{width:T,height:w},format:"rgba16float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST,label:`${_}_${this.#h}_previousFrame_${T}x${w}`}),this.#pu=y.getGPUResourceBitmapTextureView(this.#mu,{dimension:"2d",format:"rgba16float",label:`${this.#h}_previousFrame`})),this.#An={width:T,height:w},this.#Zn(),P}#Zn(){this.#F=0,this.#fu&&(this.#F+=calculateTextureByteSize(this.#fu)),this.#mu&&(this.#F+=calculateTextureByteSize(this.#mu))}#Xn(i){if(!this.#$n||this.#$n.length!==i.length)return this.#$n=[...i],!0;for(let m=0;m<i.length;m++)if(this.#$n[m]!==i[m])return this.#$n=[...i],!0;return!1}}Object.freeze(TAA);class Box extends Primitive{#di=function(){let i,m;return m=function(m,g,_,b,y,T,w,P,H,$,W,q,ye){let Ge,Ke,je=P/W,Xe=H/q,Ye=P/2,Ze=H/2,Je=$/2,Qe=W+1,et=q+1,at=0,ht=[];for(Ke=0;Ke<et;Ke++){let i=Ke*Xe-Ze;for(Ge=0;Ge<Qe;Ge++){let g=Ge*je-Ye;ht[_]=g*T,ht[b]=i*w,ht[y]=Je,m.push(ht.x,ht.y,ht.z),ht[_]=0,ht[b]=0,ht[y]=$>0?1:-1,m.push(ht.x,ht.y,ht.z),m.push(Ge/W*ye,Ke/q*ye),at+=1}}for(Ke=0;Ke<q;Ke++)for(Ge=0;Ge<W;Ge++){let m=i+Ge+Qe*Ke,_=i+Ge+Qe*(Ke+1),b=i+(Ge+1)+Qe*(Ke+1),y=i+(Ge+1)+Qe*Ke;g.push(m,_,y,_,b,y)}i+=at},function(g,_,b,y,T,w,P,H,$){let W=[],q=[];return i=0,m(W,q,"z","y","x",-1,-1,T,y,b,H,P,$),m(W,q,"z","y","x",1,-1,T,y,-b,H,P,$),m(W,q,"x","z","y",1,1,b,T,y,w,H,$),m(W,q,"x","z","y",1,-1,b,T,-y,w,H,$),m(W,q,"x","y","z",1,-1,b,y,T,w,P,$),m(W,q,"x","y","z",-1,-1,b,y,-T,w,P,$),createPrimitiveGeometry(_,W,q,g)}}();constructor(i,m=1,g=1,_=1,b=1,y=1,T=1,w=1){super(i);const P=`PRIMITIVE_BOX_W${m}_H${g}_D${_}_WS${b}_HS${y}_DS${T}_UV${w}`,H=i.resourceManager.cachedBufferState;let $=H[P];$||($=H[P]=this.#di(P,i,m,g,_,b,y,T,w)),this._setData($)}}class Cylinder extends Primitive{#di=function(){let i,m;return function(g,_,b,y,T,w,P,H,$,W){const q=[],ye=[];let Ge=0;const Ke=[],je=T/2;return i=function(){let i,m;const g=[],_=[],H=(y-b)/T;for(m=0;m<=P;m++){const ye=[],Xe=m/P,Ye=Xe*(y-b)+b;for(i=0;i<=w;i++){const m=i/w,b=m*W+$,y=Math.sin(b),P=Math.cos(b);_[0]=Ye*y,_[1]=-Xe*T+je,_[2]=Ye*P,q.push(_[0],_[1],_[2]),g[0]=y,g[1]=H,g[2]=P,normalize(g,g),q.push(g[0],g[1],g[2]),q.push(m,Xe),ye.push(Ge++)}Ke.push(ye)}for(i=0;i<w;i++)for(m=0;m<P;m++){const g=Ke[m][i],_=Ke[m+1][i],b=Ke[m+1][i+1],y=Ke[m][i+1];ye.push(g,_,y),ye.push(_,b,y)}},m=function(i){let m,g,_;const T=[],P=[],H=!0===i?b:y,Ke=!0===i?1:-1;for(g=Ge,m=1;m<=w;m++)q.push(0,je*Ke,0),q.push(0,Ke,0),q.push(.5,.5),Ge++;for(_=Ge,m=0;m<=w;m++){const i=m/w*W+$,g=Math.cos(i),_=Math.sin(i);P[0]=H*_,P[1]=je*Ke,P[2]=H*g,q.push(P[0],P[1],P[2]),q.push(0,Ke,0),T[0]=.5*g+.5,T[1]=.5*_*Ke+.5,q.push(T[0],1-T[1]),Ge++}for(m=0;m<w;m++){const b=g+m,y=_+m;!0===i?ye.push(y,y+1,b):ye.push(y+1,y,b)}},i(),!1===H&&(b>0&&m(!0),y>0&&m(!1)),createPrimitiveGeometry(_,q,ye,g)}}();constructor(i,m=1,g=1,_=1,b=8,y=8,T=!1,w=0,P=2*Math.PI){super(i);const H=`PRIMITIVE_CYLINDER_RT${m}_RB${g}_H${_}_RS${b}_HS${y}_TS${T}_TS${w}_TL${P}`,$=i.resourceManager.cachedBufferState;let W=$[H];W||(W=$[H]=this.#di(H,i,m,g,_,b,y,T,w,P)),this._setData(W)}}class Sphere extends Primitive{#di=function(){let i,m,g,_,b,y,T,w,P=[];const H=new Float32Array(3),$=new Float32Array(3);return function(W,q,ye,Ge,Ke,je,Xe,Ye,Ze,Je){i=Ye+Ze,_=0,P.length=0;const Qe=[],et=[];for(g=0;g<=Ke;g++){const i=[],b=g/Ke;for(m=0;m<=Ge;m++){const g=m/Ge;H[0]=-ye*Math.cos(je+g*Xe)*Math.sin(Ye+b*Ze),H[1]=ye*Math.cos(Ye+b*Ze),H[2]=ye*Math.sin(je+g*Xe)*Math.sin(Ye+b*Ze),Qe.push(H[0],H[1],H[2]),$[0]=H[0],$[1]=H[1],$[2]=H[2],normalize($,$),Qe.push($[0],$[1],$[2]),Qe.push(g*Je,b*Je),i.push(_++)}P.push(i)}for(g=0;g<Ke;g++)for(m=0;m<Ge;m++)b=P[g][m+1],y=P[g][m],T=P[g+1][m],w=P[g+1][m+1],(0!==g||Ye>0)&&et.push(b,y,w),(g!==Ke-1||i<Math.PI)&&et.push(y,T,w);return createPrimitiveGeometry(q,Qe,et,W)}}();constructor(i,m=1,g=16,_=16,b=0,y=2*Math.PI,T=0,w=Math.PI,P=1){super(i);const H=`PRIMITIVE_SPHERE_R${m}_WS${g}_HS${_}_PS${b}_PL${y}_TS${T}_TL${w}_UV${P}`,$=i.resourceManager.cachedBufferState;let W=$[H];W||(W=$[H]=this.#di(H,i,m,g,_,b,y,T,w,P)),this._setData(W)}}class DrawDebuggerAxis extends Mesh{constructor(i){super(i,null,null);const m=new Mesh(i,new Sphere(i,.5),new ColorMaterial(i));this.addChild(m);const g=new Box(i);this.addChild(this.#Cu(g,"#ff0000",[5,.1,.1],[2.5,0,0])),this.addChild(this.#Ru(i,"#ff0000",[.5,1.25],[5.5,0,0],[0,0,90])),this.addChild(this.#Cu(g,"#00ff00",[.1,5,.1],[0,2.5,0])),this.addChild(this.#Ru(i,"#00ff00",[.5,1.25],[0,5.5,0],[180,0,0])),this.addChild(this.#Cu(g,"#0000ff",[.1,.1,5],[0,0,2.5])),this.addChild(this.#Ru(i,"#0000ff",[.5,1.25],[0,0,5.5],[-90,0,0]))}#Cu(i,m,g,_){const{redGPUContext:b}=this,y=new Mesh(b,i,new ColorMaterial(b,m));return y.setScale(...g),y.setPosition(..._),y}#Ru(i,m,g,_,b){const y=new Mesh(i,new Cylinder(i,g[0],.001,g[1],32,1),new ColorMaterial(i,m));return y.setScale(g[0],g[1],g[0]),y.setPosition(..._),y.setRotation(...b),y}}var jr="#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include FragmentOutput;\n#redgpu_include calculateMotionVector;\nstruct VertexIn { @location(0) position:vec4<f32>, @location(1) color:vec4<f32>,\n}\nstruct VertexOut { @builtin(position) position:vec4<f32>, @location(0) color:vec4<f32>, @location(1) worldPos:vec3<f32>, @location(2) currentClipPos:vec4<f32>, @location(3) prevClipPos:vec4<f32>,\n}\nstruct GridArgs { lineColor:vec4<f32>,\n}\n@group(1) @binding(0) var<uniform> gridArgs:GridArgs;\nconst FADE_START:f32=20.0;\nconst FADE_END:f32=80.0;\nconst AXIS_THRESHOLD:f32=0.8;\nconst AXIS_ALPHA:f32=0.8;\n@vertex\nfn vertexMain(inputData:VertexIn) -> VertexOut { var output:VertexOut; let modelPos=inputData.position; let viewProj=systemUniforms.noneJitterProjectionCameraMatrix; let prevViewProj=systemUniforms.prevNoneJitterProjectionCameraMatrix; output.position=viewProj * modelPos; output.worldPos=modelPos.xyz; output.color=inputData.color; output.currentClipPos=output.position; output.prevClipPos=prevViewProj * modelPos; return output;\n}\n@fragment\nfn fragmentMain(inputData:VertexOut) -> FragmentOutput { var output:FragmentOutput; let distanceToCamera=length(inputData.worldPos - systemUniforms.camera.cameraPosition); let distanceFade=clamp(1.0 - saturate((distanceToCamera - FADE_START)/(FADE_END - FADE_START)),0.5,1.0); var finalColor:vec3<f32>; var baseAlpha:f32; let isXAxis=inputData.color.r > AXIS_THRESHOLD; let isZAxis=inputData.color.b > AXIS_THRESHOLD; if (isXAxis) { finalColor=vec3<f32>(1.0,0.0,0.0); baseAlpha=AXIS_ALPHA; } else if (isZAxis) { finalColor=vec3<f32>(0.0,0.0,1.0); baseAlpha=AXIS_ALPHA; } else { finalColor=gridArgs.lineColor.rgb; baseAlpha=gridArgs.lineColor.a; } output.color=vec4<f32>(finalColor,baseAlpha * distanceFade); let motion=calculateMotionVector(inputData.currentClipPos,inputData.prevClipPos); output.gBufferMotionVector=vec4<f32>(motion,0.0,1.0); return output;\n}\n";const Xr=parseWGSL(jr),qr=Xr.uniforms.gridArgs;class DrawDebuggerGrid{#Xr;#qr;#Bn;#Pu;#Bu;#Iu;#Qt;#en;#Eu;#Ft=100;#f;#h;#qs;#js;#zs;#Hs;#Du;constructor(i){validateRedGPUContext(i),this.#qs=DrawBufferManager.getInstance(i),this.#f=InstanceIdGenerator.getNextId(this.constructor);const{resourceManager:m,gpuDevice:g}=i,_={code:jr},b=m.createGPUShaderModule("VERTEX_MODULE_GRID",_);this.#Qt=new BlendState(this,En.SRC_ALPHA,En.ONE_MINUS_SRC_ALPHA,Dn.ADD),this.#en=new BlendState(this,En.SRC_ALPHA,En.ONE_MINUS_SRC_ALPHA,Dn.ADD),this.#Eu=new ColorRGBA(128,128,128,.25);const y=m.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),T=i.resourceManager.getGPUBindGroupLayout("GRID_MATERIAL_BIND_GROUP_LAYOUT")||i.resourceManager.createBindGroupLayout("GRID_MATERIAL_BIND_GROUP_LAYOUT",getFragmentBindGroupLayoutDescriptorFromShaderInfo(Xr,1));this.#Lu(i),this.#Pu=g.createBindGroup({label:"FRAGMENT_BIND_GROUP_DESCRIPTOR_GRID",layout:T,entries:[{binding:0,resource:{buffer:this.#Bn.gpuBuffer,offset:0,size:this.#Bn.size}}]});const w={label:"PIPELINE_DESCRIPTOR_GRID",layout:g.createPipelineLayout({label:"DRAW_DEBUGGER_GRID_PIPELINE_LAYOUT",bindGroupLayouts:[y,T]}),vertex:{module:b,entryPoint:"vertexMain",buffers:[{arrayStride:this.#Xr.interleavedStruct.arrayStride,attributes:this.#Xr.interleavedStruct.attributes}]},primitive:{topology:"line-list"},fragment:{module:b,entryPoint:"fragmentMain",targets:[{format:"rgba16float",blend:{color:this.#Qt.state,alpha:this.#en.state}},{format:navigator.gpu.getPreferredCanvasFormat(),blend:void 0},{format:"rgba16float",blend:void 0}]},depthStencil:{format:"depth32float",depthWriteEnabled:!0,depthCompare:Ft.LESS_EQUAL}};this.#Bu=g.createRenderPipeline(w),this.#Iu=g.createRenderPipeline({...w,multisample:{count:4}});const P=this.#qs;this.#js||(this.#js=P.allocateDrawCommand(this.name),P.setIndexedIndirectCommand(this.#js,this.#qr.indexCount,1,0,0,0))}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get size(){return this.#Ft}set size(i){this.#Ft=i}get lineColor(){return this.#Eu}render(i){const{view:m,currentRenderPassEncoder:g}=i,{redGPUContext:_}=m,{gpuDevice:b,antialiasingManager:y}=_,{useMSAA:T,changedMSAA:w}=y;set(create$1(),m.rawCamera.x,m.rawCamera.y,m.rawCamera.z),i.num3DObjects++,i.numDrawCalls++;const P=m.systemUniform_Vertex_UniformBindGroup!==this.#Du;if(this.#Bu){const _=2*(2*(this.#Ft+1));(!this.#zs||w||P)&&(this.#zs=b.createRenderBundleEncoder({...m.basicRenderBundleEncoderDescriptor,label:this.name}),this.#zs.setPipeline(m.redGPUContext.antialiasingManager.useMSAA?this.#Iu:this.#Bu),this.#zs.setBindGroup(0,m.systemUniform_Vertex_UniformBindGroup),this.#zs.setBindGroup(1,this.#Pu),this.#zs.setVertexBuffer(0,this.#Xr.gpuBuffer),this.#zs.setIndexBuffer(this.#qr.gpuBuffer,this.#qr.format),this.#zs.drawIndexedIndirect(this.#js.buffer,4*this.#js.commandOffset),this.#Hs=this.#zs.finish()),i.numTriangles+=0,i.numPoints+=_,g.executeBundles([this.#Hs])}this.#Du=m.systemUniform_Vertex_UniformBindGroup}#Uu(i){const m=[],g=[],_=i/2;let b=0;for(let i=-_;i<=_;i+=1){const y=0===i?[0,0,1,1]:[.5,.5,.5,1];m.push(i,0,-_,...y,i,0,_,...y),g.push(b,b+1),b+=2}for(let i=-_;i<=_;i+=1){const y=0===i?[1,0,0,1]:[.5,.5,.5,1];m.push(-_,0,i,...y,_,0,i,...y),g.push(b,b+1),b+=2}return{interleaveData:m,indexData:g}}#Lu(i){const m=this.#Ft,{resourceManager:g}=i,{cachedBufferState:_}=g;{const g=`VertexBuffer_Grid_${m}`;let b=_[g];if(!b){const{interleaveData:y}=this.#Uu(m);b=new VertexBuffer(i,y,new VertexInterleavedStruct({position:VertexInterleaveType.float32x3,color:VertexInterleaveType.float32x4}),void 0,g),_[g]=b}this.#Xr=b}{const g=`IndexBuffer_Grid_${m}`;let b=_[g];if(!b){const{indexData:y}=this.#Uu(m);b=new IndexBuffer(i,y,void 0,g),_[g]=b}this.#qr=b}{const m="UniformBuffer_Grid";let g=_[m];if(!g){const b=new ArrayBuffer(qr.arrayBufferByteLength);g=new UniformBuffer(i,b),_[m]=g}this.#Bn=g}this.#Bn.writeOnlyBuffer(qr.members.lineColor,this.#Eu.rgbaNormalLinear)}}class ABaseLight{drawDebugger;#Au;#er;#Gs=!1;constructor(i,m=1){this.#Au=i,this.#er=m}get enableDebugger(){return this.#Gs}set enableDebugger(i){this.#Gs=i}get color(){return this.#Au}set color(i){this.#Au=i}get intensity(){return this.#er}set intensity(i){this.#er=i}}Object.freeze(ABaseLight);class AmbientLight extends ABaseLight{constructor(i="#ADD8E6",m=.1){super(new ColorRGB(...convertHexToRgb(i,!0)),m)}}Object.freeze(AmbientLight);class DirectionalLight extends ABaseLight{#Ou=-1;#ku=-1;#Gu=-1;constructor(i=[-1,-1,-1],m="#fff",g=1){super(new ColorRGB(...convertHexToRgb(m,!0)),g),this.#Ou=i[0],this.#ku=i[1],this.#Gu=i[2]}get directionX(){return this.#Ou}set directionX(i){this.#Ou=i}get directionY(){return this.#ku}set directionY(i){this.#ku=i}get directionZ(){return this.#Gu}set directionZ(i){this.#Gu=i}get direction(){return[this.#Ou,this.#ku,this.#Gu]}set direction(i){this.#Ou=i[0],this.#ku=i[1],this.#Gu=i[2]}}Object.freeze(DirectionalLight);class PointLight extends ABaseLight{#Qn=1;#Mt=0;#wt=0;#Ct=0;constructor(i="#fff",m=1){super(new ColorRGB(...convertHexToRgb(i,!0)),m)}get x(){return this.#Mt}set x(i){this.#Mt=i}get y(){return this.#wt}set y(i){this.#wt=i}get z(){return this.#Ct}set z(i){this.#Ct=i}get position(){return[this.#Mt,this.#wt,this.#Ct]}get radius(){return this.#Qn}set radius(i){this.#Qn=i}setPosition(i,m,g){Array.isArray(i)?[this.#Mt,this.#wt,this.#Ct]=i:(this.#Mt=i,this.#wt=m,this.#Ct=g)}}Object.freeze(PointLight);class SpotLight extends ABaseLight{#Qn=1;#Mt=0;#wt=2;#Ct=0;#Ou=0;#ku=-1;#Gu=0;#Fu=15;#Nu=22.5;constructor(i="#fff",m=1){super(new ColorRGB(...convertHexToRgb(i,!0)),m)}get x(){return this.#Mt}set x(i){this.#Mt=i}get y(){return this.#wt}set y(i){this.#wt=i}get z(){return this.#Ct}set z(i){this.#Ct=i}get position(){return[this.#Mt,this.#wt,this.#Ct]}get radius(){return this.#Qn}set radius(i){this.#Qn=i}get directionX(){return this.#Ou}set directionX(i){this.#Ou=i}get directionY(){return this.#ku}set directionY(i){this.#ku=i}get directionZ(){return this.#Gu}set directionZ(i){this.#Gu=i}get direction(){return[this.#Ou,this.#ku,this.#Gu]}set direction(i){this.#Ou=i[0],this.#ku=i[1],this.#Gu=i[2]}get innerCutoff(){return this.#Fu}set innerCutoff(i){this.#Fu=i}get outerCutoff(){return this.#Nu}set outerCutoff(i){this.#Nu=i}get innerCutoffCos(){return Math.cos(this.#Fu*Math.PI/180)}get outerCutoffCos(){return Math.cos(this.#Nu*Math.PI/180)}setPosition(i,m,g){Array.isArray(i)?[this.#Mt,this.#wt,this.#Ct]=i:(this.#Mt=i,this.#wt=m,this.#Ct=g)}lookAt(i,m,g){let _,b,y;Array.isArray(i)?[_,b,y]=i:(_=i,b=m,y=g);const T=_-this.#Mt,w=b-this.#wt,P=y-this.#Ct,H=Math.sqrt(T*T+w*w+P*P);H>0&&(this.#Ou=T/H,this.#ku=w/H,this.#Gu=P/H)}}Object.freeze(SpotLight);class LightManager{#Vu=3;#zu=Pt.MAX_CLUSTER_LIGHTS;#Hu=[];#$u=[];#Ku=[];#Wu;#ju=create$2();get spotLights(){return this.#Ku}get spotLightCount(){return this.#Ku.length}get limitClusterLightCount(){return this.#zu}get pointLights(){return this.#$u}get pointLightCount(){return this.#$u.length}get limitDirectionalLightCount(){return this.#Vu}get directionalLightCount(){return this.#Hu.length}get directionalLights(){return this.#Hu}get ambientLight(){return this.#Wu}set ambientLight(i){i instanceof AmbientLight||consoleAndThrowError("allow only AmbientLight instance"),this.#Wu=i}addSpotLight(i){i instanceof SpotLight||consoleAndThrowError("allow only SpotLight instance");this.#Ku.length+this.#$u.length>this.#zu&&consoleAndThrowError("Cannot add more cluster lights. The limit has been reached."),this.#Ku.push(i)}addPointLight(i){i instanceof PointLight||consoleAndThrowError("allow only PointLight instance");this.#Ku.length+this.#$u.length>this.#zu&&consoleAndThrowError("Cannot add more cluster lights. The limit has been reached."),this.#$u.push(i)}addDirectionalLight(i){i instanceof DirectionalLight||consoleAndThrowError("allow only DirectionalLight instance");this.#Hu.length>this.#Vu&&consoleAndThrowError("Cannot add more directional lights. The limit has been reached."),this.#Hu.push(i)}removeSpotLight(i){const m=this.#Ku.indexOf(i);-1!==m&&this.#Ku.splice(m,1)}removePointLight(i){const m=this.#$u.indexOf(i);-1!==m&&this.#$u.splice(m,1)}removeDirectionalLight(i){const m=this.#Hu.indexOf(i);-1!==m&&this.#Hu.splice(m,1)}removeAllSpotLight(){this.#Ku=[]}removeAllPointLight(){this.#$u=[]}removeAllDirectionalLight(){this.#Hu=[]}removeAllLight(){this.removeAllPointLight(),this.removeAllSpotLight(),this.removeAllDirectionalLight(),this.#Wu=null}getDirectionalLightProjectionViewMatrix(i){return multiply(create$2(),this.getDirectionalLightProjectionMatrix(i),this.getDirectionalLightViewMatrix(i))}getDirectionalLightProjectionMatrix(i){const m=create$2(),g=i.rawCamera instanceof Camera2D?fromValues(0,0,0):fromValues(i.rawCamera.x,i.rawCamera.y,i.rawCamera.z),_=Math.max(distance(g,create$1()),1);return w(m,-_,_,-_,_,3*-_,3*_),m}getDirectionalLightViewMatrix(i){identity(this.#ju);const m=i.rawCamera instanceof Camera2D?fromValues(0,0,0):fromValues(i.rawCamera.x,i.rawCamera.y,i.rawCamera.z),g=Math.max(distance(m,create$1()),1),_=fromValues(0,1,0),b=fromValues(0,0,0),y=i.scene.lightManager.directionalLights.length?fromValues(-i.scene.lightManager.directionalLights[0].direction[0]*g,-i.scene.lightManager.directionalLights[0].direction[1]*g,-i.scene.lightManager.directionalLights[0].direction[2]*g):create$1(),T=create$2();return lookAt(T,y,b,_),T}}Object.freeze(LightManager);class DirectionalShadowManager{#Xu=2048;#tr=.005;#qu;#Yu;#Zu;#l;#$o=[];#F=0;get videoMemorySize(){return this.#F}get castingList(){return this.#$o}get shadowDepthTextureView(){return this.#Yu}get shadowDepthTextureViewEmpty(){return this.#Zu}get bias(){return this.#tr}set bias(i){validatePositiveNumberRange(i,0,1),this.#tr=i}get shadowDepthTextureSize(){return this.#Xu}set shadowDepthTextureSize(i){validateUintRange(i,1),this.#Xu=i}reset(){this.destroy()}resetCastingList(){this.#$o.length=0}update(i){this.#l=i,this.#Ju()}destroy(){this.#qu&&(this.#qu.destroy(),this.#qu=null,this.#Yu=null)}#Zn(){const i=this.#qu;if(!i)return 0;this.#F=calculateTextureByteSize(i)}#Ju(){this.#qu?.width!==this.#Xu&&(this.destroy(),this.#Qu(),this.#Zn())}#el(i){const m=i.createTexture({size:[1,1,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,format:"depth32float",label:`DirectionalShadowManager_EmptyDepthTexture_1x1_${Date.now()}`});this.#Zu=m.createView({label:m.label})}#Qu(){const{gpuDevice:i,resourceManager:m}=this.#l;this.#qu=m.createManagedTexture({size:[this.#Xu,this.#Xu,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,format:"depth32float",label:`DirectionalShadowManager_shadowDepthTextureSize_${this.#Xu}x${this.#Xu}_${Date.now()}`}),this.#Yu=this.#qu.createView({label:this.#qu.label}),this.#Zu||this.#el(i)}}Object.freeze(DirectionalShadowManager);class ShadowManager{#tl=new DirectionalShadowManager;constructor(){}get directionalShadowManager(){return this.#tl}update(i){this.#tl.update(i)}}Object.freeze(ShadowManager);class Scene extends Object3DContainer{#f;#h;#nl=new ColorRGBA;#rl=!1;#il=new LightManager;#al=new ShadowManager;constructor(i){super(),this.#f=InstanceIdGenerator.getNextId(this.constructor),this.#h=i}get lightManager(){return this.#il}get shadowManager(){return this.#al}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get backgroundColor(){return this.#nl}set backgroundColor(i){i instanceof ColorRGBA||consoleAndThrowError("allow only ColorRGBA instance"),this.#nl=i}get useBackgroundColor(){return this.#rl}set useBackgroundColor(i){this.#rl=i}}class ViewTransform{onResize=null;#l;#sl=create$2();#ol=create$2();#Ii;#Mt=0;#wt=0;#pt;#gt;#xt=[0,0,0,0];#ul=0;#ll=0;constructor(i){validateRedGPUContext(i),this.#l=i,this.setSize("100%","100%")}get redGPUContext(){return this.#l}get camera(){return this.#Ii}set camera(i){i instanceof PerspectiveCamera||i instanceof Camera2D||i instanceof Camera2D||i instanceof OrthographicCamera||i instanceof AController||consoleAndThrowError("allow PerspectiveCamera or OrthographicCamera or AController instance"),this.#Ii=i}get x(){return this.#Mt}set x(i){this.setPosition(i,this.y)}get y(){return this.#wt}set y(i){this.setPosition(this.x,i)}get width(){return this.#pt}set width(i){this.setSize(i,this.#gt)}get height(){return this.#gt}set height(i){this.setSize(this.#pt,i)}get pixelRectArray(){return this.#xt}get pixelRectObject(){return{x:this.#xt[0],y:this.#xt[1],width:this.#xt[2],height:this.#xt[3]}}get screenRectObject(){return{x:this.#xt[0]/devicePixelRatio,y:this.#xt[1]/devicePixelRatio,width:this.#xt[2]/devicePixelRatio,height:this.#xt[3]/devicePixelRatio}}get aspect(){return this.#xt[2]/this.#xt[3]}get frustumPlanes(){return this.#Ii instanceof AController?computeViewFrustumPlanes(this.projectionMatrix,this.#Ii.camera.modelMatrix):computeViewFrustumPlanes(this.projectionMatrix,this.#Ii.modelMatrix)}get rawCamera(){return this.#Ii instanceof AController?this.#Ii.camera:this.#Ii}get noneJitterProjectionMatrix(){const{pixelRectObject:i,redGPUContext:m}=this;if(this.rawCamera instanceof OrthographicCamera){const{nearClipping:i,farClipping:m}=this.rawCamera;orthoZO(this.#ol,this.rawCamera.left,this.rawCamera.right,this.rawCamera.bottom,this.rawCamera.top,i,m)}else if(this.rawCamera instanceof Camera2D)w(this.#ol,-.5,.5,-.5,.5,-1e5,1e5),scale(this.#ol,this.#ol,[m.renderScale,m.renderScale,1]),translate(this.#ol,this.#ol,[-.5,.5,0]),scale(this.#ol,this.#ol,[1/i.width*window.devicePixelRatio,-1/i.height*window.devicePixelRatio,1]),identity(this.rawCamera.modelMatrix);else{const{fieldOfView:i,nearClipping:m,farClipping:g}=this.rawCamera;T(this.#ol,Math.PI/180*i,this.aspect,m,g)}return this.#ol}get projectionMatrix(){const{redGPUContext:i}=this,{antialiasingManager:m}=i;this.#sl=clone(this.noneJitterProjectionMatrix);if("View3D"===this.constructor.name&&!(this.camera instanceof IsometricController)&&m.useTAA&&this.rawCamera instanceof PerspectiveCamera&&(0!==this.#ul||0!==this.#ll)){const i=this.#ul/this.pixelRectObject.width*2,m=this.#ll/this.pixelRectObject.height*2;this.#sl[8]+=i,this.#sl[9]+=m}return this.#sl}get inverseProjectionMatrix(){return invert(create$2(),this.#sl)}get jitterOffset(){return[this.#ul,this.#ll]}setJitterOffset(i,m){this.#ul=i,this.#ll=m}clearJitterOffset(){this.#ul=0,this.#ll=0}setPosition(i=this.#Mt,m=this.#wt){const{sizeManager:g}=this.#l;RedGPUContextSizeManager.validatePositionValue(i),RedGPUContextSizeManager.validatePositionValue(m),this.#Mt=i,this.#wt=m;const _=g.pixelRectObject,b=RedGPUContextSizeManager.getPixelDimension(_,"width",i),y=RedGPUContextSizeManager.getPixelDimension(_,"height",m);this.#xt[0]=Math.floor(b*(this.#Mt.toString().includes("%")?1:g.renderScale*window.devicePixelRatio)),this.#xt[1]=Math.floor(y*(this.#wt.toString().includes("%")?1:g.renderScale*window.devicePixelRatio))}setSize(i=this.#pt,m=this.#gt){const{sizeManager:g}=this.#l;RedGPUContextSizeManager.validateSizeValue(i),RedGPUContextSizeManager.validateSizeValue(m),this.#pt=i,this.#gt=m;const _=g.pixelRectObject,b=RedGPUContextSizeManager.getPixelDimension(_,"width",i),y=RedGPUContextSizeManager.getPixelDimension(_,"height",m);this.#xt[2]=Math.floor(b*(this.#pt.toString().includes("%")?1:g.renderScale*window.devicePixelRatio)),this.#xt[3]=Math.floor(y*(this.#gt.toString().includes("%")?1:g.renderScale*window.devicePixelRatio)),this.onResize&&this.onResize(this.screenRectObject.width,this.screenRectObject.height)}}Object.freeze(ViewTransform);class AView extends ViewTransform{#h;#cl;#f;#hl=new PickingManager;#fl=!0;#dl=!1;#ml=50;#pl;#gl;#xl;#_l;constructor(i,m,g,_){super(i),this.scene=m,this.camera=g,_&&(this.name=_)}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get scene(){return this.#cl}set scene(i){i instanceof Scene||consoleAndThrowError("allow only Scene instance"),this.#cl=i}get pickingManager(){return this.#hl}get useFrustumCulling(){return this.#fl}set useFrustumCulling(i){this.#fl=i}get useDistanceCulling(){return this.#dl}set useDistanceCulling(i){this.#dl=i}get distanceCulling(){return this.#ml}set distanceCulling(i){this.#ml=i}get grid(){return this.#pl}set grid(i){if("boolean"==typeof i)i=!0===i?new DrawDebuggerGrid(this.redGPUContext):null;else if(!(i instanceof DrawDebuggerGrid)&&null!==i)throw new TypeError("grid must be of type 'DrawDebuggerGrid','boolean',or 'null'.");this.#pl=i}get axis(){return this.#gl}set axis(i){if("boolean"==typeof i)i=!0===i?new DrawDebuggerAxis(this.redGPUContext):null;else if(!(i instanceof DrawDebuggerAxis)&&null!==i)throw new TypeError("axis must be of type 'DrawDebuggerAxis','boolean',or 'null'.");this.#gl=i}get fxaa(){return this.#_l||(this.#_l=new FXAA(this.redGPUContext)),this.#_l}get taa(){return this.#xl||(this.#xl=new TAA(this.redGPUContext)),this.#xl}screenToWorld(i,m){return screenToWorld(i,m,this)}checkMouseInViewBounds(){const{pixelRectObject:i,pickingManager:m}=this,{mouseX:g,mouseY:_}=m;return 0<g&&g<i.width&&0<_&&_<i.height}}Object.freeze(AView);class RenderViewStateData{useDistanceCulling;cullingDistanceSquared;distanceCulling;num3DGroups;num3DObjects;numDrawCalls;numDirtyPipelines;numInstances;numTriangles;numPoints;viewRenderTime;viewportSize;viewIndex;swapBufferIndex=1;usedVideoMemory;currentRenderPassEncoder;frustumPlanes;prevVertexGpuBuffer;prevFragmentUniformBindGroup;dirtyVertexUniformFromMaterial={};bundleListAlphaLayer=[];bundleListTransparentLayer=[];bundleListParticleLayer=[];bundleListRender2PathLayer=[];skinList=[];animationList=[];bundleListBasicList=[];timestamp;prevTimestamp=0;startTime;isScene2DMode=!1;needResetRenderLayer=!1;#Rt;#vl;constructor(i){this.#Rt=i}get view(){return this.#Rt}reset(i,m){if(!m||!this.#Rt)throw new Error("Invalid parameters provided");const g=this.#Rt,{useFrustumCulling:_,frustumPlanes:b,scene:y,postEffectManager:T,pickingManager:w,viewRenderTextureManager:P}=g,{gBufferColorTexture:H,depthTexture:$}=g.viewRenderTextureManager,{shadowManager:W}=y;if(!H||!$)throw new Error("Invalid view properties");this.useDistanceCulling=g.useDistanceCulling,this.distanceCulling=g.distanceCulling,this.cullingDistanceSquared=this.distanceCulling*this.distanceCulling,this.num3DGroups=0,this.num3DObjects=0,this.numDrawCalls=0,this.numInstances=0,this.numDirtyPipelines=0,this.numTriangles=0,this.numPoints=0,this.viewRenderTime=0,this.currentRenderPassEncoder=i,this.timestamp=m,this.prevVertexGpuBuffer=null,this.prevFragmentUniformBindGroup=null,this.dirtyVertexUniformFromMaterial={},this.bundleListAlphaLayer.length=0,this.bundleListTransparentLayer.length=0,this.bundleListParticleLayer.length=0,this.bundleListRender2PathLayer.length=0,this.bundleListBasicList.length=0,this.needResetRenderLayer=!1,this.#vl=this.#Rt.redGPUContext.antialiasingManager.msaaID,this.skinList.length=0,this.animationList.length=0,this.startTime=performance.now(),this.isScene2DMode=g.camera instanceof Camera2D,this.viewIndex=g.redGPUContext.getViewIndex(g),this.swapBufferIndex=this.swapBufferIndex?0:1,this.viewportSize={x:g.x,y:g.y,width:g.width,height:g.height,pixelRectArray:g.pixelRectArray};try{this.usedVideoMemory=P.videoMemorySize+W.directionalShadowManager.videoMemorySize+T.videoMemorySize+w.videoMemorySize}catch(i){throw new Error("Could not calculate texture size:"+i.message)}this.frustumPlanes=_?b:null}}class ViewRenderTextureManager{#bl;#yl;#Sl;#Tl;#Ml;#wl;#Cl;#F=0;#l;#Rt;#Rl=new Map;#Pl={};#Bl;constructor(i){validateRedGPUContext(i.redGPUContext),this.#l=i.redGPUContext,this.#Rt=i}get videoMemorySize(){return this.#F}get renderPath1ResultTextureDescriptor(){return this.#Sl}get depthTexture(){return this.#Rt.renderViewStateData.swapBufferIndex?this.#Ml:this.#Tl}get depthTextureView(){return this.#Qu(),this.#Rt.renderViewStateData.swapBufferIndex?this.#Cl:this.#wl}get prevDepthTextureView(){return this.#Qu(),this.#Rt.renderViewStateData.swapBufferIndex?this.#wl:this.#Cl}get renderPath1ResultTextureView(){return this.#yl}get renderPath1ResultTexture(){return this.#Il("rgba16float"),this.#bl}get gBufferColorTexture(){return this.#Rl.get("gBufferColor")?.texture}get gBufferColorResolveTexture(){return this.#Rl.get("gBufferColor")?.resolveTexture}get gBufferColorTextureView(){return this.#El("gBufferColor","rgba16float"),this.#Rl.get("gBufferColor")?.textureView}get gBufferColorResolveTextureView(){return this.#Rl.get("gBufferColor")?.resolveTextureView}get gBufferNormalTexture(){return this.#Rl.get("gBufferNormal")?.texture}get gBufferNormalResolveTexture(){return this.#Rl.get("gBufferNormal")?.resolveTexture}get gBufferNormalTextureView(){return this.#El("gBufferNormal"),this.#Rl.get("gBufferNormal")?.textureView}get gBufferNormalResolveTextureView(){return this.#Rl.get("gBufferNormal")?.resolveTextureView}get gBufferMotionVectorTexture(){return this.#Rl.get("gBufferMotionVector")?.texture}get gBufferMotionVectorResolveTexture(){return this.#Rl.get("gBufferMotionVector")?.resolveTexture}get gBufferMotionVectorTextureView(){return this.#El("gBufferMotionVector","rgba16float"),this.#Rl.get("gBufferMotionVector")?.textureView}get gBufferMotionVectorResolveTextureView(){return this.#Rl.get("gBufferMotionVector")?.resolveTextureView}#Dl(){const i=[this.#Rl.get("gBufferColor")?.texture,this.#Rl.get("gBufferColor")?.resolveTexture,this.#Tl,this.#bl,this.#Rl.get("gBufferNormal")?.texture,this.#Rl.get("gBufferNormal")?.resolveTexture].filter(Boolean);this.#F=i.reduce((i,m)=>i+calculateTextureByteSize(m),0)}#El(i,m){const{antialiasingManager:g,resourceManager:_}=this.#l,{useMSAA:b}=g,y=this.#Rl.get(i),T=y?.texture,{pixelRectObject:w,name:P}=this.#Rt,{width:H,height:$}=w,W=T?.width!==H||T?.height!==$,q=this.#Pl[i]!==b,ye=!T||W||q;if(this.#Pl[i]=b,ye){gt(`새 텍스처 생성 중:${i}`),T&&(T?.destroy(),y.texture=null,y.textureView=null,y.resolveTexture?.destroy(),y.resolveTexture=null,y.resolveTextureView=null,this.#Rl.delete(i));const g={texture:null,textureView:null,resolveTexture:null,resolveTextureView:null},w=_.createManagedTexture({size:[Math.max(H,1),Math.max($,1),1],sampleCount:b?4:1,label:`${P}_${i}_texture_${H}x${$}`,format:m||navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});if(g.texture=w,g.textureView=_.getGPUResourceBitmapTextureView(w),b){const b=_.createManagedTexture({size:{width:Math.max(H,1),height:Math.max($,1),depthOrArrayLayers:1},sampleCount:1,label:`${P}_${i}_resolveTexture_${H}x${$}`,format:m||navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});g.resolveTexture=b,g.resolveTextureView=_.getGPUResourceBitmapTextureView(b)}this.#Rl.set(i,g),this.#Dl()}}#Il(i){const{resourceManager:m}=this.#l,g=this.#bl,{pixelRectObject:_,name:b}=this.#Rt,{width:y,height:T}=_;(!g||(g?.width!==y||g?.height!==T))&&(g&&(this.#bl=null,this.#yl=null),this.#Sl={size:{width:Math.max(1,y),height:Math.max(1,T),depthOrArrayLayers:1},format:i,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,mipLevelCount:getMipLevelCount(y,T),label:`${b}_renderPath1ResultTexture_${y}x${T}`},this.#bl=m.createManagedTexture(this.#Sl),this.#yl=m.getGPUResourceBitmapTextureView(this.#bl),this.#Dl(),requestAnimationFrame(()=>{g?.destroy()}))}#Qu(){const{antialiasingManager:i,resourceManager:m}=this.#l,{useMSAA:g}=i,_=this.#Tl,{pixelRectObject:b,name:y}=this.#Rt,{width:T,height:w}=b,P=_?.width!==T||_?.height!==w,H=this.#Pl.depth!==g,$=!_||P||H;if(this.#Pl.depth=g,$){_&&(_?.destroy(),this.#Ml?.destroy(),this.#Tl=null,this.#Ml=null,this.#wl=null,this.#Cl=null);const i=m.createManagedTexture({size:[Math.max(T,1),Math.max(w,1),1],sampleCount:g?4:1,label:`${y}_depth0_${T}x${w}`,format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});this.#Tl=i,this.#wl=m.getGPUResourceBitmapTextureView(i);{const i=m.createManagedTexture({size:[Math.max(T,1),Math.max(w,1),1],sampleCount:g?4:1,label:`${y}_depth1_${T}x${w}`,format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});this.#Ml=i,this.#Cl=m.getGPUResourceBitmapTextureView(i)}this.#Dl()}}}Object.freeze(ViewRenderTextureManager);const Yr={LINEAR:"linear",KHRONOS_PBR_NEUTRAL:"khronosPBRNeutral",ACES_FILMIC_HILL:"ACESFilmicHill",ACES_FILMIC_NARKOWICZ:"ACESFilmicNarkowicz"};Object.freeze(Yr);var Zr="struct Uniforms { exposure:f32, contrast:f32, brightness:f32, _pad:f32,\n};\nfn linearToSRGB(linearColor:vec3<f32>) -> vec3<f32> { let a=0.055; let cutoff=0.0031308; let gamma=2.4; var srgb:vec3<f32>; for (var i=0;i < 3;i++) { let c=linearColor[i]; if (c <=cutoff) { srgb[i]=12.92 * c; } else { srgb[i]=(1.0 + a) * pow(c,1.0/gamma) - a; } } return srgb;\n}\nfn linearToneMapping(color:vec3<f32>,exposure:f32) -> vec3<f32> { let exposed=color * exposure; return exposed;\n}\nfn khronosPBRNeutralToneMapping(color:vec3<f32>,exposure:f32) -> vec3<f32> { let startCompression:f32=0.8 - 0.04; let desaturation:f32=0.15; var col=color * exposure; let x=min(col.r,min(col.g,col.b)); var offset:f32; if (x < 0.08) { offset=x - 6.25 * x * x; } else { offset=0.04; } col=col - vec3<f32>(offset); let peak=max(col.r,max(col.g,col.b)); if (peak < startCompression) { return clamp(col,vec3<f32>(0.0),vec3<f32>(1.0)); } let d=1.0 - startCompression; let newPeak=1.0 - d * d/(peak + d - startCompression); col=col * (newPeak/peak); let g=1.0 - 1.0/(desaturation * (peak - newPeak) + 1.0); return clamp(mix(col,vec3<f32>(newPeak),g),vec3<f32>(0.0),vec3<f32>(1.0));\n}\nfn acesFilmicNarkowiczToneMapping(color:vec3<f32>,exposure:f32) -> vec3<f32> { let x=color * exposure; let a=2.51; let b=0.03; let c=2.43; let d=0.59; let e=0.14; return clamp((x * (a * x + b))/(x * (c * x + d) + e),vec3<f32>(0.0),vec3<f32>(1.0));\n}\nfn acesFilmicHillToneMapping(color:vec3<f32>,exposure:f32) -> vec3<f32> { let v=color * exposure; let a1=v.r * 0.59719 + v.g * 0.35458 + v.b * 0.04823; let a2=v.r * 0.07600 + v.g * 0.90834 + v.b * 0.01566; let a3=v.r * 0.02840 + v.g * 0.13383 + v.b * 0.83777; let a=vec3<f32>(a1,a2,a3); let b=(a * (a + 0.0245786) - 0.000090537)/(a * (0.983729 * a + 0.4329510) + 0.238081); let r=b.r * 1.60475 - b.g * 0.53108 - b.b * 0.07367; let g=b.r * -0.10208 + b.g * 1.10813 - b.b * 0.00605; let bl=b.r * -0.00327 - b.g * 0.07276 + b.b * 1.07602; return clamp(vec3<f32>(r,g,bl),vec3<f32>(0.0),vec3<f32>(1.0));\n}\nfn getFinalSRGB(toneMappedColor:vec3<f32>,contrast:f32,brightness:f32) -> vec3<f32> { let contrastRGB=applyContrast(toneMappedColor,uniforms.contrast); let finalLinearRGB=applyBrightness(contrastRGB,uniforms.brightness); let finalSRGB=clamp(linearToSRGB(finalLinearRGB),vec3<f32>(0.0),vec3<f32>(1.0)); return finalSRGB;\n}\nfn applyContrast(color:vec3<f32>,contrast:f32) -> vec3<f32> { return 0.5 + contrast * (color - 0.5);\n}\nfn applyBrightness(color:vec3<f32>,brightness:f32) -> vec3<f32> { return color + brightness;\n}";class AToneMappingEffect extends ASinglePassPostEffect{#Ll=1;#ar=1;#Ul=0;constructor(i){super(i)}get exposure(){return this.#Ll}set exposure(i){this.#Ll=Math.max(.1,Math.min(5,i)),this.updateUniform("exposure",this.#Ll)}get contrast(){return this.#ar}set contrast(i){this.#ar=Math.max(.5,Math.min(2,i)),this.updateUniform("contrast",this.#ar)}get brightness(){return this.#Ul}set brightness(i){this.#Ul=Math.max(-1,Math.min(1,i)),this.updateUniform("brightness",this.#Ul)}updateUniforms(){this.updateUniform("exposure",this.#Ll),this.updateUniform("contrast",this.#ar),this.updateUniform("brightness",this.#Ul)}}Object.freeze(AToneMappingEffect);class ToneLinear extends AToneMappingEffect{constructor(i){super(i),this.init(i,"POST_EFFECT_TONE_MAPPING_LINEAR",createBasicPostEffectCode(this,"{ let index=vec2<i32>(global_id.xy); let inputColor=textureLoad(sourceTexture,index); let toneMappedColor=linearToneMapping(inputColor.rgb,uniforms.exposure); let finalSRGB=getFinalSRGB( toneMappedColor,uniforms.contrast,uniforms.brightness ); textureStore(outputTexture,index,vec4<f32>(finalSRGB,inputColor.a));\n}",Zr)),this.updateUniforms()}}Object.freeze(ToneLinear);class ToneKhronosPBRNeutral extends AToneMappingEffect{constructor(i){super(i),this.init(i,"POST_EFFECT_TONE_MAPPING_KHRONOS_PBR_NEUTRAL",createBasicPostEffectCode(this,"{ let index=vec2<i32>(global_id.xy); let inputColor=textureLoad(sourceTexture,index); let toneMappedColor=khronosPBRNeutralToneMapping(inputColor.rgb,uniforms.exposure); let finalSRGB=getFinalSRGB( toneMappedColor,uniforms.contrast,uniforms.brightness ); textureStore(outputTexture,index,vec4<f32>(finalSRGB,inputColor.a));\n}",Zr)),this.updateUniforms()}}Object.freeze(ToneKhronosPBRNeutral);class ToneACESFilmicNarkowicz extends AToneMappingEffect{constructor(i){super(i),this.init(i,"POST_EFFECT_TONE_MAPPING_ACES_FILMIC_NARKOWICZ",createBasicPostEffectCode(this,"{ let index=vec2<i32>(global_id.xy); let inputColor=textureLoad(sourceTexture,index); let toneMappedColor=acesFilmicNarkowiczToneMapping(inputColor.rgb,uniforms.exposure); let finalSRGB=getFinalSRGB( toneMappedColor,uniforms.contrast,uniforms.brightness ); textureStore(outputTexture,index,vec4<f32>(finalSRGB,inputColor.a));\n}",Zr)),this.updateUniforms()}}Object.freeze(ToneACESFilmicNarkowicz);class ToneACESFilmicHill extends AToneMappingEffect{constructor(i){super(i),this.init(i,"POST_EFFECT_TONE_MAPPING_ACES_FILMIC_HILL",createBasicPostEffectCode(this,"{ let index=vec2<i32>(global_id.xy); let inputColor=textureLoad(sourceTexture,index); let toneMappedColor=acesFilmicHillToneMapping(inputColor.rgb,uniforms.exposure); let finalSRGB=getFinalSRGB( toneMappedColor,uniforms.contrast,uniforms.brightness ); textureStore(outputTexture,index,vec4<f32>(finalSRGB,inputColor.a));\n}",Zr)),this.updateUniforms()}}Object.freeze(ToneACESFilmicHill);class ToneMappingManager{#l;#Rt;#Al;#Ol=Yr.KHRONOS_PBR_NEUTRAL;#Ll=1;#ar=1;#Ul=0;constructor(i){this.#l=i.redGPUContext,this.#Rt=i}get toneMapping(){return this.#kl(),this.#Al}get mode(){return this.#Ol}set mode(i){this.#Ol!==i&&(this.#Ol=i,this.#Al&&(this.#Al.clear(),this.#Al=void 0))}get exposure(){return this.#Ll}set exposure(i){validatePositiveNumberRange(i,0),this.#Ll=i,this.#Al&&(this.#Al.exposure=i)}get contrast(){return this.#ar}set contrast(i){validatePositiveNumberRange(i,0,2),this.#ar=i,this.#Al&&(this.#Al.contrast=i)}get brightness(){return this.#Ul}set brightness(i){validateNumberRange(i,-1,1),this.#Ul=i,this.#Al&&(this.#Al.brightness=i)}render(i,m,g){const _=this.toneMapping;return _?_.render(this.#Rt,i,m,g):g}#kl(){if(!this.#Al){switch(this.#Ol){case Yr.LINEAR:this.#Al=new ToneLinear(this.#l);break;case Yr.KHRONOS_PBR_NEUTRAL:this.#Al=new ToneKhronosPBRNeutral(this.#l);break;case Yr.ACES_FILMIC_NARKOWICZ:this.#Al=new ToneACESFilmicNarkowicz(this.#l);break;case Yr.ACES_FILMIC_HILL:this.#Al=new ToneACESFilmicHill(this.#l);break;default:this.#Al=new ToneKhronosPBRNeutral(this.#l)}this.#Al&&(this.#Al.exposure=this.#Ll,this.#Al.contrast=this.#ar,this.#Al.brightness=this.#Ul)}}}const Jr=parseWGSL(Et.SYSTEM_UNIFORM).uniforms.systemUniforms;let Qr=create$2(),ei=create$2();create$2();class View3D extends AView{#Gl=Jr;#Fl;#Nl;#Vl;#zl;#Hl;#$l;#Kl;#Wl;#jl={};#Xl;#ze;#ql;#At;#Yl;#Zl;#Jl;#Ql=void 0;#ec=void 0;#tc;#nc;#Br;#Ir;#Er;#rc=create$2();constructor(i,m,g,_){super(i,m,g,_),this.#ft(),this.#Wl=new ViewRenderTextureManager(this),this.#Hl=new RenderViewStateData(this),this.#$l=new PostEffectManager(this),this.#Kl=new ToneMappingManager(this),this.#Br=new ArrayBuffer(this.systemUniform_Vertex_StructInfo.endOffset),this.#Ir=new Float32Array(this.#Br),this.#Er=new Uint32Array(this.#Br)}get viewRenderTextureManager(){return this.#Wl}get systemUniform_Vertex_StructInfo(){return this.#Gl}get systemUniform_Vertex_UniformBindGroup(){return this.#Fl}get systemUniform_Vertex_UniformBuffer(){return this.#Nl}get passLightClustersBound(){return this.#Jl}get ibl(){return this.#zl}set ibl(i){this.#zl=i}get postEffectManager(){return this.#$l}get toneMappingManager(){return this.#Kl}get renderViewStateData(){return this.#Hl}get skybox(){return this.#Vl}set skybox(i){const{resourceManager:m}=this.redGPUContext,g=this.#Vl?.skyboxTexture,_=i?.skyboxTexture;g&&g!==_&&this.#ic(m,g.cacheKey,!1),this.#Vl=i}get basicRenderBundleEncoderDescriptor(){const{antialiasingManager:i}=this.redGPUContext,{useMSAA:m}=i;return{colorFormats:["rgba16float",navigator.gpu.getPreferredCanvasFormat(),"rgba16float"],depthStencilFormat:"depth32float",sampleCount:m?4:1}}get noneJitterProjectionCameraMatrix(){return this.#rc}update(i=!1,m=!1,g){const{scene:_,redGPUContext:b}=this,{shadowManager:y}=_;y.update(b);const{directionalShadowManager:T}=y,w=this.ibl,P=w?.iblTexture?.gpuTexture,H=w?.irradianceTexture?.gpuTexture;let $=i?T.shadowDepthTextureViewEmpty:T.shadowDepthTextureView;const W=this.redGPUContext.viewList.indexOf(this),q=`${W}_${i?"shadowRender":"basic"}_2path${!!g}`;if(W>-1){let i=!0,m=this.#jl[q];m&&(i=m.ibl!==w||m.ibl_iblTexture!==P||m.ibl_irradianceTexture!==H||m.renderPath1ResultTextureView!==g||m.shadowDepthTextureView!==$||!this.#Zl),i?this.#ac(q,$,this.ibl,g):this.#Fl=this.#jl[q].vertexUniformBindGroup,this.#jl[q]={ibl:w,ibl_iblTexture:P,ibl_irradianceTexture:H,renderPath1ResultTextureView:g,shadowDepthTextureView:$,vertexUniformBindGroup:this.#Fl}}this.#sc(m),this.#oc()}#Vr(i){i.forEach(({key:i,value:m,dataView:g,targetMembers:_})=>{const b=_[i];g.set("number"==typeof m?[m]:m,b.uniformOffset/b.View.BYTES_PER_ELEMENT)})}#oc(){const{inverseProjectionMatrix:i,noneJitterProjectionMatrix:m,projectionMatrix:g,rawCamera:_}=this,{redGPUContext:b,systemUniform_Vertex_UniformBuffer:y}=this,{gpuDevice:T}=b,{lightManager:w,shadowManager:P}=this.scene,{modelMatrix:H,position:$}=_,W=this.systemUniform_Vertex_StructInfo,{gpuBuffer:q}=y,ye=_ instanceof Camera2D,{members:Ge}=W;{const{members:y}=W,T=y.camera.members;this.#rc=multiply(ei,m,H),this.#Vr([{key:"projectionMatrix",value:g,dataView:this.#Ir,targetMembers:y},{key:"projectionCameraMatrix",value:multiply(Qr,g,H),dataView:this.#Ir,targetMembers:y},{key:"noneJitterProjectionMatrix",value:m,dataView:this.#Ir,targetMembers:y},{key:"noneJitterProjectionCameraMatrix",value:this.#rc,dataView:this.#Ir,targetMembers:y},{key:"inverseProjectionMatrix",value:i,dataView:this.#Ir,targetMembers:y},{key:"prevNoneJitterProjectionCameraMatrix",value:b.antialiasingManager.useTAA?this.taa.prevNoneJitterProjectionCameraMatrix:this.#rc,dataView:this.#Ir,targetMembers:y},{key:"resolution",value:[this.pixelRectObject.width,this.pixelRectObject.height],dataView:this.#Ir,targetMembers:y},{key:"cameraMatrix",value:H,dataView:this.#Ir,targetMembers:T},{key:"cameraPosition",value:$,dataView:this.#Ir,targetMembers:T},{key:"nearClipping",value:ye?0:_.nearClipping,dataView:this.#Ir,targetMembers:T},{key:"farClipping",value:ye?0:_.farClipping,dataView:this.#Ir,targetMembers:T},{key:"useIblTexture",value:this.ibl?.iblTexture?.gpuTexture?1:0,dataView:this.#Er,targetMembers:y},{key:"time",value:this.renderViewStateData.timestamp||0,dataView:this.#Ir,targetMembers:y},{key:"isView3D",value:this.constructor===View3D?1:0,dataView:this.#Er,targetMembers:y},{key:"shadowDepthTextureSize",value:P.directionalShadowManager.shadowDepthTextureSize,dataView:this.#Er,targetMembers:y},{key:"bias",value:P.directionalShadowManager.bias,dataView:this.#Ir,targetMembers:y},{key:"directionalLightCount",value:w.directionalLightCount,dataView:this.#Er,targetMembers:y},{key:"directionalLightProjectionViewMatrix",value:w.getDirectionalLightProjectionViewMatrix(this),dataView:this.#Ir,targetMembers:y},{key:"directionalLightProjectionMatrix",value:w.getDirectionalLightProjectionMatrix(this),dataView:this.#Ir,targetMembers:y},{key:"directionalLightViewMatrix",value:w.getDirectionalLightViewMatrix(this),dataView:this.#Ir,targetMembers:y}])}w.directionalLights.forEach((i,m)=>{const{directionalLights:g}=Ge;i.enableDebugger&&(i.drawDebugger||(i.drawDebugger=new DrawDebuggerDirectionalLight(b,i)),i.drawDebugger.render(this.renderViewStateData));const _=g.memberList[m];this.#Vr([{key:"direction",value:i.direction,dataView:this.#Ir,targetMembers:_},{key:"color",value:i.color.rgbNormalLinear,dataView:this.#Ir,targetMembers:_},{key:"intensity",value:i.intensity,dataView:this.#Ir,targetMembers:_}])});{const i=w.ambientLight,{ambientLight:m}=Ge,g=m.members;i&&this.#Vr([{key:"color",value:i.color.rgbNormalLinear,dataView:this.#Ir,targetMembers:g},{key:"intensity",value:i.intensity,dataView:this.#Ir,targetMembers:g}])}T.queue.writeBuffer(q,0,this.#Br)}#ac(i,m,g,_){this.#sc(!0);const b=g?.iblTexture,y=g?.irradianceTexture,{redGPUContext:T}=this,{gpuDevice:w,resourceManager:P}=T,H={layout:P.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),label:`SYSTEM_UNIFORM_bindGroup_${i}`,entries:[{binding:0,resource:{buffer:this.#Nl.gpuBuffer,offset:0,size:this.#Nl.size}},{binding:1,resource:this.#Xl},{binding:2,resource:m},{binding:3,resource:this.#ze},{binding:5,resource:{buffer:this.#At,offset:0,size:this.#At.size}},{binding:6,resource:{buffer:this.#Zl.clusterLightsBuffer,offset:0,size:this.#Zl.clusterLightsBuffer.size}},{binding:7,resource:this.#ze},{binding:8,resource:_||P.emptyBitmapTextureView},{binding:9,resource:this.#ql},{binding:10,resource:P.getGPUResourceCubeTextureView(b,b?.viewDescriptor||CubeTexture.defaultViewDescriptor)},{binding:11,resource:P.getGPUResourceCubeTextureView(y,y?.viewDescriptor||CubeTexture.defaultViewDescriptor)}]};this.#Fl=w.createBindGroup(H),this.#uc(P,b,y)}#uc(i,m,g){[[this.#tc,m],[this.#nc,g]].forEach(([m,g])=>{m&&m!==g&&this.#ic(i,m.cacheKey,!1),g&&m!==g&&this.#ic(i,g.cacheKey,!0)}),this.#tc=m,this.#nc=g}#ic(i,m,g){const _=i.managedCubeTextureState,b=_?.table.get(m);b&&(g?b.useNum++:b.useNum--)}#ft(){const i=new ArrayBuffer(Jr.arrayBufferByteLength);this.#Nl=new UniformBuffer(this.redGPUContext,i,"SYSTEM_UNIFORM_BUFFER_VERTEX","SYSTEM_UNIFORM_BUFFER_VERTEX"),this.#Yl=new Float32Array(16*Pt.MAX_CLUSTER_LIGHTS+4),this.#At=this.redGPUContext.resourceManager.createGPUBuffer("VIEW_CLUSTER_LIGHTS_BUFFER",{size:this.#Yl.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),this.redGPUContext.gpuDevice.queue.writeBuffer(this.#At,0,this.#Yl),this.#Xl=new Sampler(this.redGPUContext,{addressModeU:vt.CLAMP_TO_EDGE,addressModeV:vt.CLAMP_TO_EDGE,addressModeW:vt.CLAMP_TO_EDGE,compare:Ft.LESS_EQUAL}).gpuSampler,this.#ze=new Sampler(this.redGPUContext).gpuSampler,this.#ql=new Sampler(this.redGPUContext,{addressModeU:vt.REPEAT,addressModeV:vt.REPEAT}).gpuSampler}#sc(i=!1){if(!i)return;const{redGPUContext:m,scene:g,renderViewStateData:_}=this;if(this.#Jl||(this.#Jl=new PassClusterLightBound(m,this)),this.#Zl&&(this.#Jl.render(),this.#Ql=this.pixelRectArray[2],this.#ec=this.pixelRectArray[3]),this.#Zl||(this.#Zl=new PassClustersLight(m,this)),g){const{pointLights:i,spotLights:b}=g.lightManager,y=i.length,T=b.length;if(y){let g=y;for(;g--;){const b=i[g],y=4+16*g;this.#Yl.set([...b.position,b.radius,...b.color.rgbNormalLinear,b.intensity,0],y),b.enableDebugger&&(b.drawDebugger||(b.drawDebugger=new DrawDebuggerPointLight(m,b)),b.drawDebugger.render(_))}}if(T){const i=16,g=y*i;let w=T;for(;w--;){const y=b[w],T=4+i*w+g;this.#Yl.set([...y.position,y.radius,...y.color.rgbNormalLinear,y.intensity,1,...y.direction,y.outerCutoff,y.innerCutoff],T),y.enableDebugger&&(y.drawDebugger||(y.drawDebugger=new DrawDebuggerSpotLight(m,y)),y.drawDebugger.render(_))}}this.#Yl.set([y,T,0,0],0),this.redGPUContext.gpuDevice.queue.writeBuffer(this.#At,0,this.#Yl),this.#Zl.render()}}}Object.freeze(View3D);class RedGPUContextViewContainer{#lc=[];constructor(){}get viewList(){return this.#lc}get numViews(){return this.#lc.length}contains(i){return this.#lc.includes(i)}addView(i){this.#cc(i),this.#lc.push(i)}addViewAt(i,m){this.#cc(i),validateUintRange(m);const g=this.#lc.length;g<m&&(m=g),this.#lc[m]=i}getViewAt(i){return validateUintRange(i),this.#lc[i]}getViewIndex(i){return this.#cc(i),this.#lc.indexOf(i)}setViewIndex(i,m){this.#cc(i),validateUintRange(m);const g=this.#lc.length,_=m>=g,b=this.#lc.indexOf(i);-1===b&&consoleAndThrowError("입력하신 View 는 RedGPUContext instance 에 등록되지 않은 View 입니다."),_&&consoleAndThrowError(`index must be smaller than the viewList length./index:${m}/this.#viewList.length:${g}`),this.#lc.splice(b,1),this.#lc.splice(m,0,i)}swapViews(i,m){this.#cc(i),this.#cc(m);const g=this.#lc.indexOf(i),_=this.#lc.indexOf(m);-1!==g&&-1!==_||consoleAndThrowError((-1===g?"view1":"view2")+" is not child of this RedGPUContext instance."),this.swapViewsAt(g,_)}swapViewsAt(i,m){i===m&&consoleAndThrowError("The indices to swap cannot be the same."),validateUintRange(i),validateUintRange(m);const g=this.#lc.length;(i>=g||m>=g)&&consoleAndThrowError(`index1,index2 must be smaller than the viewList length./index1:${i}/index2:${m}/this.#viewList.length:${g}`);const _=this.#lc[i];this.#lc[i]=this.#lc[m],this.#lc[m]=_}removeView(i){this.#cc(i);const m=this.#lc.indexOf(i);m>-1?this.#lc.splice(m,1):consoleAndThrowError("View3D is not found in the view list.")}removeViewAt(i){validateUintRange(i);const m=this.#lc.length;i<m?this.#lc.splice(i,1):consoleAndThrowError(`Index ${i} is out of range. View list length is ${m}.`)}removeAllViews(){this.#lc.length=0}#cc(i){i instanceof View3D||consoleAndThrowError("allow only View3D instance")}}class RedGPUContext extends RedGPUContextViewContainer{currentRequestAnimationFrame;onResize=null;currentTime;#hc;#fc;#dc;#mc;#c;#_t;#pc;#gc;#nn;#nl=new ColorRGBA(0,0,0,1);#xc=!1;#_c={};#Hn;#vc;constructor(i,m,g,_,b){super(),this.#fc=m,this.#c=g,this.#mc=_,this.#dc=b,this.#_t=i,this.#pc=new RedGPUContextSizeManager(this),this.#gc=new RedGPUContextDetector(this),this.#nn=new ResourceManager(this),this.#Hn=new AntialiasingManager(this),this.#bc()}get boundingClientRect(){return this.#vc}get antialiasingManager(){return this.#Hn}get useDebugPanel(){return this.#xc}set useDebugPanel(i){this.#xc=i}get backgroundColor(){return this.#nl}set backgroundColor(i){i instanceof ColorRGBA||consoleAndThrowError("allow only ColorRGBA instance"),this.#nl=i}get detector(){return this.#gc}get configurationDescription(){return this.#hc}get gpuAdapter(){return this.#fc}get alphaMode(){return this.#dc}set alphaMode(i){this.#dc=i,this.#yc()}get gpuContext(){return this.#mc}get gpuDevice(){return this.#c}get htmlCanvas(){return this.#_t}get keyboardKeyBuffer(){return this.#_c}set keyboardKeyBuffer(i){this.#_c=i}get resourceManager(){return this.#nn}get sizeManager(){return this.#pc}get width(){return this.#pc.width}set width(i){this.#pc.width=i}get height(){return this.#pc.height}set height(i){this.#pc.height=i}get screenRectObject(){return this.#pc.screenRectObject}get renderScale(){return this.#pc.renderScale}set renderScale(i){this.#pc.renderScale=i,this.viewList.forEach(i=>{i.setPosition(),i.setSize()})}destroy(){this.#c.destroy()}setSize(i=this.width,m=this.height){this.sizeManager.setSize(i,m)}#bc(){this.#yc(),this.sizeManager.setSize("100%","100%"),window?.addEventListener("resize",()=>{this.#vc=this.#_t.getBoundingClientRect(),this.sizeManager.setSize(),this.viewList.forEach(i=>{i.setSize(),i.setPosition()})}),this.#vc=this.#_t.getBoundingClientRect();(this.detector.isMobile?["click","touchmove","touchstart","touchend"]:["click","mousemove","mousedown","mouseup"]).forEach(m=>{const g=this.detector.isMobile?{click:i.CLICK,touchmove:i.MOVE,touchstart:i.DOWN,touchend:i.UP}:{click:i.CLICK,mousemove:i.MOVE,mousedown:i.DOWN,mouseup:i.UP};this.#_t.addEventListener(m,m=>{const _=g[m.type];this.viewList.forEach(g=>{this.detector.isMobile&&m instanceof TouchEvent&&m.touches.length>0?(g.pickingManager.mouseX=m.touches[0].clientX*devicePixelRatio-g.pixelRectObject.x,g.pickingManager.mouseY=m.touches[0].clientY*devicePixelRatio-g.pixelRectObject.y):m instanceof MouseEvent&&(g.pickingManager.mouseX=m.offsetX*devicePixelRatio-g.pixelRectObject.x,g.pickingManager.mouseY=m.offsetY*devicePixelRatio-g.pixelRectObject.y),_===i.CLICK?g.pickingManager.lastMouseClickEvent={...m,type:_}:g.pickingManager.lastMouseEvent={...m,type:_}})})});{const HD_keyDown=i=>{this.#_c[i.key]=!0},HD_keyUp=i=>{this.#_c[i.key]=!1};window?.addEventListener("keyup",HD_keyUp),window?.addEventListener("keydown",HD_keyDown)}new ResizeObserver(i=>{}).observe(this.#_t)}#yc(){const i=navigator.gpu.getPreferredCanvasFormat();this.#hc={device:this.#c,format:i,alphaMode:this.#dc},this.#mc.configure(this.#hc)}}Object.freeze(RedGPUContext);const init=async(i,m,g,_,b="premultiplied",y={powerPreference:"high-performance",forceFallbackAdapter:!1})=>{if(isSearchEngineBot())return void gt("🤖 Search engine bot detected - skipping WebGPU initialization");const{gpu:T}=navigator;if(!T){const i="WebGPU is not supported in this browser. Please use a modern browser with WebGPU enabled.";return void g?.(i)}const errorHandler=(i,m)=>{const _=generateErrorMessage(i,m);console.error("\n============\n",_,"\n============\n"),g?.(_)},validateAndRequestDevice=async m=>{const g=[];m?.features.has("texture-compression-astc")&&g.push("texture-compression-astc");const _={requiredFeatures:g};try{const g=await m.requestDevice(_);validateAndInitializeContext(i,m,g)}catch(i){errorHandler(null,`Failed to request device. Adapter was ${m},error message is ${i.message}`)}},validateAndInitializeContext=(i,g,y)=>{const T=i.getContext("webgpu");if(T)try{{const i=y.createShaderModule.bind(y);y.createShaderModule=function(m){m.code=ensureVertexIndexBuiltin(m.code);return i(m)}}const w=new RedGPUContext(i,g,y,T,b);m(w),y.addEventListener("uncapturederror",i=>{console.warn("TODO A WebGPU error was not captured:",i),console.warn(i.error?.message),window.cancelAnimationFrame(w.currentRequestAnimationFrame)}),y.lost.then(i=>{console.warn(i),console.warn(`Device lost occurred:${i.message}`),"destroyed"===i.reason&&_?.(i)});const clearDevice=()=>{if(w.gpuContext)try{w.gpuContext.unconfigure(),gt("🧹 Canvas Context unconfigure 완료")}catch(i){gt("⚠️ Canvas Context unconfigure 실패:",i)}window?.cancelAnimationFrame(w.currentRequestAnimationFrame),w.gpuDevice.destroy()};window?.addEventListener("beforeunload",()=>{w&&w.gpuDevice&&(gt("🧹 페이지 종료 시 GPU 디바이스 정리"),clearDevice())}),window?.addEventListener("pageshow",i=>{i.persisted&&(gt("🔄 bfcache에서 복원됨 (뒤로가기 또는 앞으로가기) - 페이지 재로드"),window.location.reload())}),window?.addEventListener("pagehide",i=>{i.persisted&&(gt("💾 bfcache에 저장됨"),w&&w.gpuDevice&&clearDevice())})}catch(i){errorHandler(i,"")}else errorHandler(new Error(`Failed to get context from canvas:${i.id||i}`),"Failed to get webgpu initialize from canvas")},initializeWebGPU=async()=>{m instanceof Function?i instanceof HTMLCanvasElement?await(async i=>{i||errorHandler(null,"Cannot find navigator.gpu");try{const m=await i.requestAdapter(y);await validateAndRequestDevice(m)}catch(m){errorHandler(m,`Failed to request adapter or validate device with target GPU:${i},error message is ${m.message}`)}})(T):errorHandler(null,`Expected HTMLCanvasElement,but received:${i}`):errorHandler(null,`Expected onWebGPUInitialized,but received:${m}`)};try{await initializeWebGPU()}catch(i){errorHandler(i,`Unexpected error occurred during WebGPU initialization:${i.message}`)}},generateErrorMessage=(i,m)=>{let g=m;return i instanceof Error?(g=i.message??m,"string"==typeof i.stack&&(g+=`\nStack Trace:${i.stack}`)):console.warn("generateErrorMessage function expected an Error instance,but got:",i),g},isSearchEngineBot=()=>{if("undefined"==typeof navigator||"undefined"==typeof window)return!0;const i=navigator.userAgent.toLowerCase();return["googlebot","bingbot","slurp","duckduckbot","baiduspider","yandexbot","facebookexternalhit","twitterbot","rogerbot","linkedinbot","embedly","quora link preview","showyoubot","outbrain","pinterest/0.","developers.google.com/+/web/snippet","www.google.com/webmasters/tools/richsnippets","slackbot","vkshare","w3c_validator","redditbot","applebot","whatsapp","flipboard","tumblr","bitlybot","skypeuripreview","nuzzel","line","discordbot","telegrambot","crawler","spider","bot"].some(m=>i.includes(m))};class TextureLoaderData{src;texture;loadEnd;loadSuccess;srcInfo;idx;constructor(i,m,g){this.src=i,this.texture=null,this.loadEnd=!1,this.loadSuccess=!1,this.srcInfo=m,this.idx=g}}class TextureLoader{textures=[];#Sc=0;#l;#Tc;#Za;#Mc;constructor(i,m=[],g,_){this.#l=i,this.#Tc=m,this.#Za=g,this.#Mc=_,this.#Tc.length?this.#Tc.forEach((i,m)=>this.#wc(i,m)):this.#Cc()}getTextureByIndex(i){if(this.textures[i])return this.textures[i].texture}#wc(i,m){let g,_,b=BitmapTexture;_=i.hasOwnProperty("src")?i.src:i,_ instanceof Array&&(b=CubeTexture),g=new TextureLoaderData(_,i,m);const onLoadHandler=()=>{g.loadSuccess=!0,g.loadEnd=!0,this.#Rc()},onErrorHandler=()=>{g.loadSuccess=!1,g.loadEnd=!0,this.#Rc()};g.texture=b===BitmapTexture?new b(this.#l,{src:i.src,cacheKey:i.cacheKey},i.useMipmap,onLoadHandler,onErrorHandler,i.format,!1):new b(this.#l,{src:i.src,cacheKey:i.cacheKey},i.useMipmap,onLoadHandler,onErrorHandler,i.format),this.textures.push(g),this.#Pc()}#Pc(){const i=this.#Tc.length,m=this.#Sc;this.#Mc&&this.#Mc.call(this,{total:i,loaded:m,percent:Math.min(100,parseFloat((m/i*100).toFixed(2)))})}#Rc(){this.#Sc++,this.#Pc(),this.#Sc===this.#Tc.length&&this.#Cc()}#Cc(){requestAnimationFrame(()=>{this.#Za&&this.#Za.call(this,this)})}}const checkProgress=(i,m,g)=>{const _=m.buffers.length;i.loadingProgressInfo.buffers={loaded:g,total:_,percent:Math.min(100,parseFloat((g/_*100).toFixed(2)))}},ti=new Map,ni=new Map,arrayBufferLoader=(i,m,g)=>{if(i=getAbsoluteURL(window.location.href,i),ti.has(i))return void m?.(ti.get(i));if(ni.has(i))return void ni.get(i).then(i=>m?.(i)).catch(i=>g?.(i));const _=fetch(i).then(i=>{if(!i.ok)throw new Error(`Network response was not ok:${i.statusText}`);return i.arrayBuffer()}).then(m=>(ti.set(i,m),m)).finally(()=>{ni.delete(i)});ni.set(i,_),_.then(i=>m?.(i)).catch(i=>g?.(i))},ri={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array};Object.freeze(ri);class AccessorInfo_GLTF{accessor;bufferView;bufferGlTfId;buffer;bufferURIDataView;componentType;componentType_BYTES_PER_ELEMENT;getMethod;accessorBufferOffset;bufferViewOffset;bufferViewByteStride;startIndex;constructor(i,m,g){switch(this.accessor=m.accessors[g],this.bufferView=m.bufferViews[this.accessor.bufferView],this.bufferGlTfId=this.bufferView.buffer,this.buffer=m.buffers[this.bufferGlTfId],this.bufferURIDataView=null,this.buffer.uri&&(this.bufferURIDataView=i.parsingResult.uris.buffers[this.bufferGlTfId]),this.componentType=ri[this.accessor.componentType],this.componentType_BYTES_PER_ELEMENT=this.componentType.BYTES_PER_ELEMENT,this.componentType){case Float32Array:this.getMethod="getFloat32";break;case Uint32Array:this.getMethod="getUint32";break;case Uint16Array:this.getMethod="getUint16";break;case Int16Array:this.getMethod="getInt16";break;case Uint8Array:this.getMethod="getUint8";break;case Int8Array:this.getMethod="getInt8";break;default:consoleAndThrowError("파싱할수없는 타입",this.componentType)}this.accessorBufferOffset=this.accessor.byteOffset||0,this.bufferViewOffset=this.bufferView.byteOffset||0,this.bufferViewByteStride=this.bufferView.byteStride||0,this.startIndex=(this.bufferViewOffset+this.accessorBufferOffset)/this.componentType_BYTES_PER_ELEMENT}}class AnimationData_GLTF{gltfLoader;scenesData;accessorGlTfId;dataList;constructor(i,m,g){this.gltfLoader=i,this.scenesData=m,this.accessorGlTfId=g;const _=new AccessorInfo_GLTF(this.gltfLoader,this.scenesData,this.accessorGlTfId),{accessor:b,startIndex:y,componentType_BYTES_PER_ELEMENT:T,bufferURIDataView:w,getMethod:P}=_,{type:H,count:$}=b;let W=y,q=1;switch(H){case"SCALAR":q=1;break;case"VEC4":q=4;break;case"VEC3":q=3}const ye=[];let Ge=0;for(;Ge<$*q;W++,Ge++)ye[Ge]=w[P](W*T,!0);this.dataList=new Float32Array(ye)}}class AniTrack_GLTF{lastPrevIdx;key;timeAnimationInfo;aniDataAnimationInfo;interpolation;weightMeshes;animationTargetMesh;cacheTable={};#Bc;#Pn;#Ic;#Bn;#Br;#Ec=new Map;constructor(i,m,g,_,b,y){this.key=i,this.timeAnimationInfo=m,this.aniDataAnimationInfo=g,this.interpolation=_,this.animationTargetMesh=b,this.weightMeshes=y,this.#Br=new Float32Array(8)}async renderWeight(i,m,g,_,b,y){const{gpuDevice:T}=i;this.#Bc||this.#Dc(i),this.#Ec.has(g)||this.#Lc(i,g);const w=this.#Ec.get(g);this.#Br.set([_,b,y,g.animationInfo.morphInfo.morphInfoDataList.length,g.geometry.vertexBuffer.stride,g.geometry.vertexBuffer.vertexCount,0,0]),T.queue.writeBuffer(this.#Bn,0,this.#Br),m.setPipeline(this.#Pn),m.setBindGroup(0,w.bindGroup);const P=Math.ceil(g.geometry.vertexBuffer.vertexCount/64);m.dispatchWorkgroups(P)}#Dc(i){const{gpuDevice:m}=i;this.#Bc=m.createShaderModule({code:"struct Uniforms { interpolation_value:f32, prev_time_data_index:f32, next_time_data_index:f32, morph_length:f32, vertex_stride:f32, vertex_count:f32, padding1:f32, padding2:f32,\n};\n@group(0) @binding(0) var<storage,read> animation_data_list:array<f32>;\n@group(0) @binding(1) var<uniform> uniforms:Uniforms;\n@group(0) @binding(2) var<storage,read_write> vertices:array<f32>;\n@group(0) @binding(3) var<storage,read> origin_data:array<f32>;\n@group(0) @binding(4) var<storage,read> morph_interleave_data:array<f32>;\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>) { let vertex_index=global_id.x; let vertex_count=u32(uniforms.vertex_count); let stride=u32(uniforms.vertex_stride); let morph_length=u32(uniforms.morph_length); let base_vertex_index=vertex_index * stride; let base_vertex_index2=vertex_index * 3u; let prev_time_offset=u32(uniforms.prev_time_data_index) * morph_length; let next_time_offset=u32(uniforms.next_time_data_index) * morph_length; var prev_weight=origin_data[base_vertex_index]; var next_weight=origin_data[base_vertex_index]; var prev_weight1=origin_data[base_vertex_index + 1u]; var next_weight1=origin_data[base_vertex_index + 1u]; var prev_weight2=origin_data[base_vertex_index + 2u]; var next_weight2=origin_data[base_vertex_index + 2u]; for (var morph_index=0u;morph_index < morph_length;morph_index++) { let prev_animation_data=animation_data_list[prev_time_offset + morph_index]; let next_animation_data=animation_data_list[next_time_offset + morph_index]; let morph_base_offset=morph_index * vertex_count * 3u; let temp_weight_x=morph_interleave_data[morph_base_offset + base_vertex_index2]; prev_weight +=prev_animation_data * temp_weight_x; next_weight +=next_animation_data * temp_weight_x; let temp_weight_y=morph_interleave_data[morph_base_offset + base_vertex_index2 + 1u]; prev_weight1 +=prev_animation_data * temp_weight_y; next_weight1 +=next_animation_data * temp_weight_y; let temp_weight_z=morph_interleave_data[morph_base_offset + base_vertex_index2 + 2u]; prev_weight2 +=prev_animation_data * temp_weight_z; next_weight2 +=next_animation_data * temp_weight_z; } let interpolation_diff_x=next_weight - prev_weight; let interpolation_diff_y=next_weight1 - prev_weight1; let interpolation_diff_z=next_weight2 - prev_weight2; let final_x=prev_weight + uniforms.interpolation_value * interpolation_diff_x; let final_y=prev_weight1 + uniforms.interpolation_value * interpolation_diff_y; let final_z=prev_weight2 + uniforms.interpolation_value * interpolation_diff_z; vertices[base_vertex_index]=final_x; vertices[base_vertex_index + 1u]=final_y; vertices[base_vertex_index + 2u]=final_z;\n}\n"}),this.#Pn=m.createComputePipeline({layout:"auto",compute:{module:this.#Bc,entryPoint:"main"}}),this.#Ic=m.createBuffer({size:4*this.aniDataAnimationInfo.dataList.length,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.#Bn=m.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),m.queue.writeBuffer(this.#Ic,0,this.aniDataAnimationInfo.dataList)}#Lc(i,m){const{gpuDevice:g}=i,_=m.animationInfo.morphInfo,b=m.geometry.vertexBuffer,y=g.createBuffer({size:4*_.origin.length,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),T=_.morphInfoDataList.flatMap(i=>Array.from(i.interleaveData)),w=g.createBuffer({size:4*T.length,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});g.queue.writeBuffer(y,0,_.origin),g.queue.writeBuffer(w,0,new Float32Array(T));const P=g.createBindGroup({layout:this.#Pn.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.#Ic}},{binding:1,resource:{buffer:this.#Bn}},{binding:2,resource:{buffer:b.gpuBuffer}},{binding:3,resource:{buffer:y}},{binding:4,resource:{buffer:w}}]});this.#Ec.set(m,{bindGroup:P,originBuffer:y,morphInterleavedBuffer:w})}}const parseAnimations=(i,m)=>new Promise(async g=>{m.animations||(m.animations=[]);const{parsingResult:_}=i,{animations:b}=_,{animations:y}=m;if(y.length){const g=y.map(async g=>{const{samplers:_,channels:y}=g,T=[];T.minTime=1e7,T.maxTime=-1,T.name=g.name,b.push(T),await Promise.all(y.map(async g=>((i,m,g,_,b)=>{let y,T;const{nodes:w,meshes:P}=b,H=[],{sampler:$,target:W}=g,q=_[$],{node:ye,path:Ge}=W,Ke=w[ye];if("mesh"in Ke){y=Ke.Mesh;const{primitives:i}=P[Ke.mesh];let m=i.length;for(;m--;)H.push(i[m].Mesh)}else{let m;if(!i.parsingResult.groups[ye])return;m=i.parsingResult.groups[ye],y=m}if("scale"!=Ge&&"rotation"!=Ge&&"translation"!=Ge&&"weights"!=Ge||(T=new AniTrack_GLTF(Ge,new AnimationData_GLTF(i,b,q.input),new AnimationData_GLTF(i,b,q.output),q.interpolation,y,H),m.push(T)),T){const{timeAnimationInfo:i}=T,{dataList:g}=i;m.minTime>g[0]&&(m.minTime=g[0]),m.maxTime<g[g.length-1]&&(m.maxTime=g[g.length-1])}})(i,T,g,_,m)))});await Promise.all(g),b.length&&b.forEach(m=>i.playAnimation(m))}g()});class ParsedSkinInfo_GLTF{joints;inverseBindMatrices;skeletonMesh;vertexStorageInfo;vertexStorageBuffer;prevVertexStorageBuffer;invertNodeGlobalTransform;usedJoints=null;WORK_SIZE=64;jointData;uniformBuffer;computeShader;computePipeline;bindGroup;constructor(){this.joints=[],this.inverseBindMatrices=null,this.skeletonMesh=null}getUsedJointIndices(i){const m=new Set,{jointBuffer:g}=i.animationInfo;if(!g.data.length)return[];const _=g.data,b=_.length;for(let i=0;i<b;i++){const g=i;for(let i=0;i<4;i++){const b=Math.floor(_[g+i]);b>=0&&b<this.joints.length&&m.add(b)}}return Array.from(m)}createCompute(i,m,g,_,b){const y=` struct Uniforms { invertNodeGlobalTransform: mat4x4<f32>, jointModelMatrices: array<mat4x4<f32>,${this.usedJoints.length}>, inverseBindMatrices: array<mat4x4<f32>,${this.joints.length}>, searchJointIndexTable: array<vec4<u32>,${this.joints.length}>, };  @group(0) @binding(0) var<storage,read> vertexWeight: array<vec4<f32>>; @group(0) @binding(1) var<storage,read> vertexJoint: array<vec4<u32>>; @group(0) @binding(2) var<storage,read_write> skinMatrixBuffer: array<mat4x4<f32>>; @group(0) @binding(3) var<storage,read_write> prevSkinMatrixBuffer: array<mat4x4<f32>>; @group(0) @binding(4) var<uniform> uniforms: Uniforms;  @compute @workgroup_size(${this.WORK_SIZE},1,1) fn main(@builtin(global_invocation_id) global_id:vec3<u32>) {  let idx=global_id.x; if (idx >=arrayLength(&vertexWeight)) { return; }  let weights=vertexWeight[idx]; let joints=vertexJoint[idx]; prevSkinMatrixBuffer[idx]=skinMatrixBuffer[idx]; skinMatrixBuffer[idx]=uniforms.invertNodeGlobalTransform * ( weights.x * ( \tuniforms.jointModelMatrices[uniforms.searchJointIndexTable[joints.x].x] * uniforms.inverseBindMatrices[joints.x] ) + weights.y * ( \tuniforms.jointModelMatrices[uniforms.searchJointIndexTable[joints.y].x] * uniforms.inverseBindMatrices[joints.y] ) + weights.z * ( \tuniforms.jointModelMatrices[uniforms.searchJointIndexTable[joints.z].x] * uniforms.inverseBindMatrices[joints.z] ) + weights.w * ( \tuniforms.jointModelMatrices[uniforms.searchJointIndexTable[joints.w].x] * uniforms.inverseBindMatrices[joints.w] ) ); } `;this.jointData=new Float32Array(16*(1+this.usedJoints.length)),this.computeShader=i.resourceManager.createGPUShaderModule(`calcSkinMatrix_${this.usedJoints.length}`,{code:y}),this.computePipeline=m.createComputePipeline({label:"calcSkinMatrix",layout:"auto",compute:{module:this.computeShader,entryPoint:"main"}}),this.uniformBuffer=m.createBuffer({size:this.jointData.byteLength+16*this.joints.length*4+4*this.joints.length*4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),m.queue.writeBuffer(this.uniformBuffer,this.jointData.byteLength,new Float32Array(this.inverseBindMatrices.map(i=>Array.from(i)).flat()));const T=new Uint32Array(4*this.joints.length);T.fill(0),this.usedJoints.forEach((i,m)=>{T[4*i]=m}),m.queue.writeBuffer(this.uniformBuffer,this.jointData.byteLength+16*this.joints.length*4,T),this.bindGroup=m.createBindGroup({layout:this.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:_.gpuBuffer}},{binding:1,resource:{buffer:b.gpuBuffer}},{binding:2,resource:{buffer:this.vertexStorageBuffer}},{binding:3,resource:{buffer:this.prevVertexStorageBuffer}},{binding:4,resource:{buffer:this.uniformBuffer}}]})}}const parseJoint_GLTF=(i,m,g,_)=>{const{redGPUContext:b}=i,y=g[_].Mesh;y?m.joints.push(y):requestAnimationFrame(function(){parseJoint_GLTF(i,m,g,_)})},parseAttributeInfo_GLTF=function(i,m,g,_,b,y,T,w,P,H,$){const{accessor:W,startIndex:q,getMethod:ye,bufferViewByteStride:Ge,bufferURIDataView:Ke,componentType_BYTES_PER_ELEMENT:je}=m,{type:Xe,count:Ye}=W;let Ze=0;const Je=Ge/je;let Qe,et=q;switch(Xe){case"VEC4":if(Ge)for(Qe=et+Ye*(Ge/je);et<Qe;et++)Ze%Je<4&&("WEIGHTS_0"==i?w.push(Ke[ye](et*je,!0)):"JOINTS_0"==i?P.push(Ke[ye](et*je,!0)):"COLOR_0"==i?H.push(Ke[ye](et*je,!0)):"TANGENT"==i?$.push(Ke[ye](et*je,!0)):consoleAndThrowError("VEC4에서 현재 지원하고 있지 않는 키",i)),Ze++;else for(Qe=et+4*Ye;et<Qe;et++)"WEIGHTS_0"==i?w.push(Ke[ye](et*je,!0)):"JOINTS_0"==i?P.push(Ke[ye](et*je,!0)):"COLOR_0"==i?H.push(Ke[ye](et*je,!0)):"TANGENT"==i?$.push(Ke[ye](et*je,!0)):consoleAndThrowError("VEC4에서 현재 지원하고 있지 않는 키",i),Ze++;break;case"VEC3":if(Ge)for(Qe=et+Ye*(Ge/je);et<Qe;et++)Ze%Je<3&&("NORMAL"==i?T.push(Ke[ye](et*je,!0)):"POSITION"==i?g.push(Ke[ye](et*je,!0)):"COLOR_0"==i?(H.push(Ke[ye](et*je,!0)),Ze%Je==2&&H.push(1)):"TANGENT"==i?$.push(Ke[ye](et*je,!0)):consoleAndThrowError("VEC3에서 현재 지원하고 있지 않는 키",i)),Ze++;else for(Qe=et+3*Ye;et<Qe;et++)"NORMAL"==i?T.push(Ke[ye](et*je,!0)):"POSITION"==i?g.push(Ke[ye](et*je,!0)):"COLOR_0"==i?(H.push(Ke[ye](et*je,!0)),Ze%3==2&&H.push(1)):"TANGENT"==i?$.push(Ke[ye](et*je,!0)):consoleAndThrowError("VEC3에서 현재 지원하고 있지 않는 키",i),Ze++;break;case"VEC2":if(Ge)for(Qe=et+Ye*(Ge/je);et<Qe;et++)Ze%Je<2&&("TEXCOORD_0"==i?_.push(Ke[ye](et*je,!0)):"TEXCOORD_1"==i&&b.push(Ke[ye](et*je,!0))),Ze++;else for(Qe=et+2*Ye;et<Qe;et++)"TEXCOORD_0"==i?_.push(Ke[ye](et*je,!0)):"TEXCOORD_1"==i&&b.push(Ke[ye](et*je,!0)),Ze++}},parseSparse_GLTF=(i,m,g,_,b)=>{const y=g.sparse;if(!y)return;const{values:T,indices:w,count:P}=y,H=_.bufferViews,$=H[T.bufferView],W=$.buffer,q=_.buffers,ye=q[W],Ge=[],Ke=[],je=H[w.bufferView],Xe=je.buffer,Ye=q[Xe];let Ze;ye.uri&&(Ze=i.parsingResult.uris.buffers[W]);const Je=ri[g.componentType],{BYTES_PER_ELEMENT:Qe}=Je;let et;switch(Je){case Float32Array:et="getFloat32";break;case Uint32Array:et="getUint32";break;case Uint16Array:et="getUint16";break;case Int16Array:et="getInt16";break;case Uint8Array:et="getUint8";break;case Int8Array:et="getInt8"}const at=g.byteOffset||0;let ht,ft,gt=(($.byteOffset||0)+at)/Qe;switch(g.type){case"VEC3":for(ht=gt+Qe*P/Qe*3;gt<ht;gt++){const i=Ze[et](gt*Qe,!0);"NORMAL"==m||"POSITION"==m&&Ge.push(i)}break;case"VEC2":for(ht=gt+Qe*P/Qe*2;gt<ht;gt++)"TEXCOORD_0"==m&&Ke.push(Ze[et](gt*Qe,!0))}Ye.uri&&(ft=i.parsingResult.uris.buffers[Xe]);const xt=ri[w.componentType],vt=xt.BYTES_PER_ELEMENT,bt=xt===Uint16Array?"getUint16":"getUint8",yt=w.byteOffset||0;let St=((je.byteOffset||0)+yt)/vt;const Tt=St+vt*P/vt;let Mt=0;for(;St<Tt;St++){const i=ft[bt](St*vt,!0);b[3*i]=Ge[3*Mt],b[3*i+1]=Ge[3*Mt+1],b[3*i+2]=Ge[3*Mt+2],Mt++}};class MorphInfoData_GLTF{vertices=[];verticesColor_0=[];normals=[];uvs=[];uvs1=[];uvs2=[];jointWeights=[];joints=[];tangents=[];interleaveData;constructor(i=[],m=[],g=[],_=[],b=[],y=[],T=[],w=[],P=[]){this.vertices=i,this.verticesColor_0=m,this.normals=g,this.uvs=_,this.uvs1=b,this.uvs2=b,this.jointWeights=T,this.joints=w,this.tangents=P}}class MorphInfo_GLTF{morphInfoDataList=[];weights;cacheData={};origin;constructor(i,m,g,_){g.targets&&(this.morphInfoDataList=g.targets.map(g=>{const b=new MorphInfoData_GLTF;for(let _ in g){const{vertices:y,verticesColor_0:T,normals:w,uvs:P,uvs1:H,uvs2:$,jointWeights:W,joints:q,tangents:ye}=b,Ge=g[_],Ke=new AccessorInfo_GLTF(i,m,Ge),{accessor:je}=Ke;parseAttributeInfo_GLTF(_,Ke,y,P,H,0,w,W,q,T,ye),je.sparse&&parseSparse_GLTF(i,_,je,m,y)}return _.length&&(b.interleaveData=new Float32Array(b.vertices)),b})),this.weights=_||[],this.origin=null}}const parseMaterialTexture=(i,m,g,_,b,y=!0)=>{const{redGPUContext:T,gltfData:w}=i,{textureRawList:P}=i.parsingResult,H=g.index,$=w.textures[H],W=$.extensions?.EXT_texture_webp?.source||$.source,q=getURL(i,w,W);if(q){const H=$.sampler,ye=getSamplerInfo(i,w,H),{parsedURI:Ge,cacheKey:Ke}=q,je=`${_}SourceGlTfId_${W}`;if(P[je]?(P[je].materialList.push(m),P[je].samplerList.push(new Sampler(T,ye))):P[je]={src:Ge,cacheKey:Ke,targetTextureKey:_,targetSamplerKey:`${_}Sampler`,materialList:[m],samplerList:[new Sampler(T,ye)],format:b||navigator.gpu.getPreferredCanvasFormat(),useMipmap:y},m[`${_}_texCoord_index`]=g.texCoord||0,"extensions"in g){const{extensions:i}=g,{KHR_texture_transform:b}=i;b&&((i,m,g)=>{i[`${m}_KHR_texture_transform_offset`]=g.offset||[0,0],i[`${m}_KHR_texture_transform_scale`]=g.scale||[1,1],i[`${m}_KHR_texture_transform_rotation`]=g.rotation||0,i[`use_${m}_KHR_texture_transform`]=!0})(m,_,b)}}},getURL=function(i,m,g){if(!m.images[g])return null;const{uri:_}=m.images[g];let b;const y=`${i.url}_${g}`;return b=_.indexOf("blob:http")>-1?_:(_.indexOf(";base64,")>-1?"":i.filePath)+_,{parsedURI:b,cacheKey:y}},getSamplerInfo=function(i,m,g){const _={magFilter:yt.LINEAR,minFilter:yt.LINEAR,mipmapFilter:yt.LINEAR,addressModeU:vt.REPEAT,addressModeV:vt.REPEAT,addressModeW:vt.REPEAT},b={33071:vt.CLAMP_TO_EDGE,33648:vt.MIRRORED_REPEAT,10497:vt.REPEAT},y={9728:yt.NEAREST,9729:yt.LINEAR},T={9728:yt.NEAREST,9729:yt.LINEAR};if(m.samplers){let i=m.samplers[g];i&&("magFilter"in i&&(_.magFilter=y[i.magFilter]||yt.LINEAR),"minFilter"in i&&(_.minFilter=T[i.minFilter]||yt.LINEAR),"wrapS"in i&&(_.addressModeU=b[i.wrapS]),"wrapT"in i&&(_.addressModeV=b[i.wrapT]))}return _.string=JSON.stringify(_),_},parseMaterialInfo_GLTF=(i,m,g)=>{const{redGPUContext:_}=i;let b,y=!1,T="OPAQUE",w=.5;if("material"in g){b=new PBRMaterial(_);const P=g.material,H=m.materials[P];y=!!H.doubleSided,T=H.alphaMode??T,w=H.alphaCutoff??w;const{pbrMetallicRoughness:$,normalTexture:W,emissiveTexture:q,occlusionTexture:ye}=H;if(b.emissiveFactor=H.emissiveFactor||[0,0,0],$){const{metallicRoughnessTexture:m,baseColorTexture:g}=$;let _,y;b.baseColorFactor=$.baseColorFactor||[1,1,1,1],"metallicFactor"in $&&(_=$.metallicFactor),"roughnessFactor"in $&&(y=$.roughnessFactor),b.metallicFactor=null!=_?_:1,b.roughnessFactor=null!=y?y:1,g&&parseMaterialTexture(i,b,g,"baseColorTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`),m&&parseMaterialTexture(i,b,m,"metallicRoughnessTexture",null,!1)}if(W){parseMaterialTexture(i,b,W,"normalTexture");const{scale:m}=W;b.normalScale=null!=m?m:1}if(q&&parseMaterialTexture(i,b,q,"emissiveTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`),ye&&(parseMaterialTexture(i,b,ye,"occlusionTexture",null,!1),b.occlusionStrength=H.occlusionTexture.strength||1),"extensions"in H){const{extensions:m}=H,{KHR_materials_clearcoat:g,KHR_materials_emissive_strength:_,KHR_materials_transmission:y,KHR_materials_diffuse_transmission:w,KHR_materials_volume:P,KHR_materials_unlit:$,KHR_materials_ior:W,KHR_materials_sheen:q,KHR_materials_specular:ye,KHR_materials_dispersion:Ge,KHR_materials_anisotropy:Ke,KHR_materials_iridescence:je}=m;if(je&&((i,m,g)=>{i.useKHR_materials_iridescence=!0,i.KHR_iridescenceFactor=m.iridescenceFactor||0,i.KHR_iridescenceIor=m.iridescenceIor||1.3,i.KHR_iridescenceThicknessMinimum=m.iridescenceThicknessMinimum||100,i.KHR_iridescenceThicknessMaximum=m.iridescenceThicknessMaximum||400,i.transparent=!0;{const{iridescenceTexture:_,iridescenceThicknessTexture:b}=m;_&&parseMaterialTexture(g,i,_,"KHR_iridescenceTexture",null,!1),b&&parseMaterialTexture(g,i,b,"KHR_iridescenceThicknessTexture",null,!1)}})(b,je,i),Ke&&((i,m,g)=>{i.useKHR_materials_anisotropy=!0,i.KHR_anisotropyStrength=m.anisotropyStrength||0,i.KHR_anisotropyRotation=m.anisotropyRotation||0;const{anisotropyTexture:_}=m;_&&parseMaterialTexture(g,i,_,"KHR_anisotropyTexture")})(b,Ke,i),g&&((i,m,g)=>{i.KHR_clearcoatFactor=m.clearcoatFactor||0,i.KHR_clearcoatRoughnessFactor=m.clearcoatRoughnessFactor||0,i.useKHR_materials_clearcoat=!0;const{clearcoatTexture:_,clearcoatNormalTexture:b,clearcoatRoughnessTexture:y}=m;_&&parseMaterialTexture(g,i,_,"KHR_clearcoatTexture",null,!1),b&&parseMaterialTexture(g,i,b,"KHR_clearcoatNormalTexture"),y&&parseMaterialTexture(g,i,y,"KHR_clearcoatRoughnessTexture",null,!1)})(b,g,i),_){const{emissiveStrength:i}=_;b.emissiveStrength=null!=i?i:1}if(y&&(((i,m,g)=>{i.useKHR_materials_transmission=!0,i.KHR_transmissionFactor=m.transmissionFactor||0,i.use2PathRender=!0;{const _=m.transmissionTexture;_&&parseMaterialTexture(g,i,_,"KHR_transmissionTexture",null,!1)}})(b,y,i),b.transparent="BLEND"===T),w&&((i,m,g)=>{i.useKHR_materials_diffuse_transmission=!0,i.KHR_diffuseTransmissionFactor=m.diffuseTransmissionFactor||0,i.KHR_diffuseTransmissionColorFactor=m.diffuseTransmissionColorFactor||[1,1,1],i.transparent=!0;{const _=m.diffuseTransmissionTexture;_&&parseMaterialTexture(g,i,_,"KHR_diffuseTransmissionTexture",null,!1);const b=m.diffuseTransmissionColorTexture;b&&parseMaterialTexture(g,i,b,"KHR_diffuseTransmissionColorTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`,!1)}})(b,w,i),P&&(((i,m,g)=>{i.useKHR_materials_volume=!0,i.KHR_thicknessFactor=m.thicknessFactor||1,i.KHR_attenuationDistance=m.attenuationDistance||1,i.KHR_attenuationColor=m.attenuationColor||[1,1,1],i.use2PathRender=!0,i.transparent=!0;{const _=m.thicknessTexture;_&&parseMaterialTexture(g,i,_,"KHR_thicknessTexture",null,!1)}})(b,P,i),T="BLEND"),$&&(b.useKHR_materials_unlit=!0),W){const{ior:i}=W;b.KHR_materials_ior=null!=i?i:1.5,b.use2PathRender=!0,b.transparent=!0}if(Ge){const{dispersion:i}=Ge;b.KHR_dispersion=i||0,b.use2PathRender=!0,b.transparent=!0}q&&((i,m,g)=>{i.KHR_sheenColorFactor=m.sheenColorFactor||[0,0,0],i.KHR_sheenRoughnessFactor=m.sheenRoughnessFactor||0,i.useKHR_materials_sheen=!0;const{sheenColorTexture:_,sheenRoughnessTexture:b}=m;_&&parseMaterialTexture(g,i,_,"KHR_sheenColorTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`,!1),b&&parseMaterialTexture(g,i,b,"KHR_sheenRoughnessTexture",null,!1)})(b,q,i),ye&&((i,m,g)=>{i.useKHR_materials_specular=!0,i.KHR_specularFactor=m.specularFactor??1,i.KHR_specularColorFactor=m.specularColorFactor||[1,1,1];const{specularTexture:_,specularColorTexture:b}=m;_&&parseMaterialTexture(g,i,_,"KHR_specularTexture"),b&&parseMaterialTexture(g,i,b,"KHR_specularColorTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`)})(b,ye,i)}}else b=new PBRMaterial(_);Object.hasOwn(g.attributes,"COLOR_0")&&(b.useVertexColor=!0),b.doubleSided=y,b.cutOff=w;const{blendColorState:P,blendAlphaState:H}=b;switch(T){case"BLEND":b.alphaBlend=2,P.srcFactor=En.SRC_ALPHA,P.dstFactor=En.ONE_MINUS_SRC_ALPHA,H.srcFactor=En.SRC_ALPHA,H.dstFactor=En.ONE_MINUS_SRC_ALPHA,b.transparent=!0;break;case"MASK":b.alphaBlend=1,b.useCutOff=!0,P.srcFactor=En.ONE,P.dstFactor=En.ZERO,H.srcFactor=En.ONE,H.dstFactor=En.ZERO;break;default:P.srcFactor=En.ONE,P.dstFactor=En.ZERO,H.srcFactor=En.ONE,H.dstFactor=En.ZERO,b.alphaBlend=0}return b},parseIndicesInfo_GLTF=(i,m)=>{const{accessor:g,startIndex:_,getMethod:b,bufferURIDataView:y,componentType_BYTES_PER_ELEMENT:T}=i,{type:w,count:P}=g;let H,$=_;if("SCALAR"===w)for(H=$+P;$<H;$++)m.push(y[b]($*T,!0))},parseInterleaveData_GLTF=(i,m,g,_,b,y,T,w,P,H,$=!1,W=!1)=>{let q,ye,Ge,Ke,je,Xe,Ye,Ze,Je,Qe=0,et=m.length/3,at=0;const ht=m.length,ft=_.length,gt=y.length,xt=g.length,vt=w.length,bt=P.length,yt=H.length;if(q=Ge=Xe=0,ye=Ke=Ye=1,je=Ze=2,Je=3,$)for(;Qe<et;Qe++)vt?(i[at++]=w[Xe],i[at++]=w[Ye],i[at++]=w[Ze],i[at++]=w[Je]):(i[at++]=0,i[at++]=0,i[at++]=0,i[at++]=0),q+=2,ye+=2,Ge+=3,Ke+=3,je+=3,Xe+=4,Ye+=4,Ze+=4,Je+=4;else if(W)for(;Qe<et;Qe++)bt?(i[at++]=P[Xe],i[at++]=P[Ye],i[at++]=P[Ze],i[at++]=P[Je]):(i[at++]=0,i[at++]=0,i[at++]=0,i[at++]=0),q+=2,ye+=2,Ge+=3,Ke+=3,je+=3,Xe+=4,Ye+=4,Ze+=4,Je+=4;else for(;Qe<et;Qe++)ht&&(i[at++]=m[Ge],i[at++]=m[Ke],i[at++]=m[je]),ft?(i[at++]=_[Ge],i[at++]=_[Ke],i[at++]=_[je]):(i[at++]=0,i[at++]=0,i[at++]=0),b.length||b.push(0,0),b.length&&(i[at++]=b[q],i[at++]=b[ye]),gt?(i[at++]=y[q],i[at++]=y[ye]):b.length&&(i[at++]=b[q],i[at++]=b[ye]),xt?(i[at++]=g[Xe],i[at++]=g[Ye],i[at++]=g[Ze],i[at++]=g[Je]):(i[at++]=0,i[at++]=0,i[at++]=0,i[at++]=0),yt?(i[at++]=H[Xe],i[at++]=H[Ye],i[at++]=H[Ze],i[at++]=H[Je]):(i[at++]=0,i[at++]=0,i[at++]=0,i[at++]=0),q+=2,ye+=2,Ge+=3,Ke+=3,je+=3,Xe+=4,Ye+=4,Ze+=4,Je+=4},ii=180/Math.PI,setMeshRotation=(i,m)=>{m.setRotation(i[0]*ii,i[1]*ii,i[2]*ii)},parseTRSAndMATRIX_GLTF=(i,m)=>{const{matrix:g,rotation:_,translation:b,scale:y}=m;let T,w;if(T=create$2(),"matrix"in m){w=create$1(),mat4ToEuler(g,w),setMeshRotation(w,i),i.setPosition(g[12],g[13],g[14]);const m=fromValues(1,1,1);getScaling(m,g),i.setScale(m[0],m[1],m[2])}else"rotation"in m&&(w=create$1(),quaternionToRotationMat4(_,T),mat4ToEuler(T,w),setMeshRotation(w,i)),"translation"in m&&i.setPosition(b[0],b[1],b[2]),"scale"in m&&(i.setScale(y[0],y[1],y[2]),(y[0]<0||y[1]<0||y[2]<0)&&(i.primitiveState.frontFace=_r.CW))},parseChildrenAndSkin=(i,m,g,_,b)=>{if("children"in _){const b=_.children,y=b.length;for(let _=0;_<y;_++)parseNode_GLTF(i,m,b[_],g)}"skin"in _&&((i,m,g,_)=>{const b=new ParsedSkinInfo_GLTF,y=[],{nodes:T}=m,{joints:w,skeleton:P}=g;{let m=0;const g=w.length;for(;m<g;m++){const g=w[m];parseJoint_GLTF(i,b,T,g)}}P&&(b.skeletonMesh=T[P].Mesh);const H=g.inverseBindMatrices,$=new AccessorInfo_GLTF(i,m,H),{startIndex:W,accessor:q,componentType_BYTES_PER_ELEMENT:ye,bufferViewByteStride:Ge,bufferURIDataView:Ke,getMethod:je}=$,{type:Xe,count:Ye}=q;let Ze=0;const Je=Ge/ye;let Qe,et=W;if("MAT4"===Xe)if(Ge)for(Qe=et+Ye*(Ge/ye);et<Qe;et++)Ze%Je<16&&y.push(Ke[je](et*ye,!0)),Ze++;else for(Qe=et+16*Ye;et<Qe;et++)y.push(Ke[je](et*ye,!0)),Ze++;b.inverseBindMatrices=[];for(let i=0;i<w.length;i++)b.inverseBindMatrices.push(new Float32Array([y[16*i],y[16*i+1],y[16*i+2],y[16*i+3],y[16*i+4],y[16*i+5],y[16*i+6],y[16*i+7],y[16*i+8],y[16*i+9],y[16*i+10],y[16*i+11],y[16*i+12],y[16*i+13],y[16*i+14],y[16*i+15]]));_.animationInfo.skinInfo=b,_.material.useSkin=!!_.animationInfo.skinInfo})(i,m,b[_.skin],g)},parseNode_GLTF=(i,m,g,_)=>{const{redGPUContext:b,parsingResult:y}=i,{nodes:T,meshes:w,skins:P}=m,{groups:H,cameras:$}=y,W=T[g];if("mesh"in W){const b=function(i,m,g,_){const{redGPUContext:b}=i;let y;g.name&&(y=g.name);const T=[],{primitives:w}=g;let P=0;const H=w.length;for(;P<H;P++){const H=w[P];let $,W,q,ye=[],Ge=[],Ke=[],je=[],Xe=[],Ye=[],Ze=[],Je=[],Qe=[],et=[];const{attributes:at}=H,ht=new Map;if(at)for(const g in at){const _=at[g],b=new AccessorInfo_GLTF(i,m,_),y=g.indexOf("TEXCOORD_")>-1;if(y){const i=`TEXCOORD_${ht.size}`;ht.set(g,i)}parseAttributeInfo_GLTF(y?ht.get(g):g,b,Ge,je,Xe,0,Ze,Je,Qe,Ke,et),b.accessor.sparse&&parseSparse_GLTF(i,g,b.accessor,m,Ge)}if("indices"in H){let g=H.indices,_=new AccessorInfo_GLTF(i,m,g);parseIndicesInfo_GLTF(_,ye)}W=parseMaterialInfo_GLTF(i,m,H),W instanceof PBRMaterial&&i.parsingResult.materials.push(W);let ft,gt=!1;if("mode"in H)switch(H.mode){case 0:q=Zn.POINT_LIST;break;case 1:case 2:q=Zn.LINE_LIST;break;case 3:q=Zn.LINE_STRIP,gt=!0;break;case 4:case 6:q=Zn.TRIANGLE_LIST;break;case 5:q=Zn.TRIANGLE_STRIP,gt=!0}Ke.length&&(W.useVertexColor_0=!0),ft=Ze.length?Ze:calculateNormals(Ge,ye),et.length&&(W.useVertexTangent=!0);let xt,vt=[];parseInterleaveData_GLTF(vt,Ge,Ke,ft,je,Xe,0,Je,Qe,et);let bt={};Ge.length&&(bt.aVertexPosition=VertexInterleaveType.float32x3),ft.length&&(bt.aVertexNormal=VertexInterleaveType.float32x3),je.length&&(bt.aTexcoord=VertexInterleaveType.float32x2),(Ye.length||Xe.length||je.length)&&(bt.aTexcoord1=VertexInterleaveType.float32x2),bt.aVertexColor_0=VertexInterleaveType.float32x4,bt.aVertexTangent=VertexInterleaveType.float32x4;const yt=[],St=[];parseInterleaveData_GLTF(yt,Ge,Ke,ft,je,Xe,0,Je,Qe,et,!0),parseInterleaveData_GLTF(St,Ge,Ke,ft,je,Xe,0,Je,Qe,et,!1,!0);const Tt=new VertexBuffer(b,yt,new VertexInterleavedStruct({aVertexWeight:VertexInterleaveType.float32x4}),void 0,`Weight_${i.url}_${_}_${P}`),Mt=new IndexBuffer(b,St,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,`Joint_${i.url}_${_}_${P}`);let wt=new MorphInfo_GLTF(i,m,H,g.weights);const Ct=`Vertex_${i.url}_${_}_${P}_${wt.weights.length?createUUID():""}`,Rt=b.resourceManager.managedVertexBufferState.table.get(Ct)?.buffer;if(xt=new Geometry(b,Rt||new VertexBuffer(b,vt,new VertexInterleavedStruct(bt,"PBR"),void 0,Ct),!gt&&ye.length?new IndexBuffer(b,new Uint32Array(ye),void 0,`Index_${i.url}_${_}_${P}`):null),W||consoleAndThrowError("재질을 파싱할수없는경우 ",H),$=new Mesh(b,xt,W),$.animationInfo.weightBuffer=Tt,$.animationInfo.jointBuffer=Mt,y&&($.name=y,i.parsingOption))for(let m in i.parsingOption)y.toLowerCase().indexOf(m)>-1&&i.parsingOption[m]($);$.primitiveState.topology=q||Zn.TRIANGLE_LIST,$.material.doubleSided&&($.primitiveState.cullMode=xr.NONE),$.material.use2PathRender&&($.primitiveState.cullMode=xr.NONE,$.depthStencilState.depthCompare=Ft.LESS_EQUAL),2===$.material.alphaBlend&&($.depthStencilState.depthCompare=Ft.LESS_EQUAL),$.animationInfo.morphInfo=wt,$.animationInfo.morphInfo.origin=new Float32Array(vt);let Pt=$.geometry.vertexBuffer.data;$.gpuRenderInfo||$.initGPURenderInfos();let Bt=0;for(const i in bt)Bt+=bt[i].numElements;if(!Rt){const i=$.animationInfo.morphInfo.morphInfoDataList;let m=0;const g=i.length,_=Pt.length;for(;m<g;){const g=i[m].vertices;let b=0,y=_/Bt,T=null==$.animationInfo.morphInfo.weights[m]?.5:$.animationInfo.morphInfo.weights[m];for(;b<y;)Pt[b*Bt]+=g[3*b]*T,Pt[b*Bt+1]+=g[3*b+1]*T,Pt[b*Bt+2]+=g[3*b+2]*T,b++;m++}}$.geometry.vertexBuffer.updateAllData(Pt),$.animationInfo.morphInfo.origin=new Float32Array(Pt),H.Mesh=$,T.push($)}return T}(i,m,w[W.mesh],g),y=b.length;for(let g=0;g<y;g++){let y=b[g];_.addChild(W.Mesh=y),parseTRSAndMATRIX_GLTF(y,W),parseChildrenAndSkin(i,m,y,W,P)}}else{let y;H[g]?(y=H[g],W.Mesh=y):(y=new Mesh(b),_.addChild(y),W.Mesh=y,y.name=W.name,H[g]=y),parseTRSAndMATRIX_GLTF(y,W),parseChildrenAndSkin(i,m,y,W,P)}},parseGLTF=(i,m,g,_)=>{m.extensionsUsed?.includes("KHR_draco_mesh_compression")&&alert("RedGPU GLTFLoader does not support the KHR_draco_mesh_compression extension. Models using this extension may not load properly."),requestAnimationFrame(()=>{(i=>{const m=i?.asset;m||consoleAndThrowError("GLTFLoader - asset must be defined"),m.version||consoleAndThrowError("GLTFLoader - asset version must be defined");const g=parseFloat(m.version);isNaN(g)&&consoleAndThrowError("GLTFLoader - asset version must be a numerical value"),g<2&&consoleAndThrowError("GLTFLoader - asset version must be 2.0 or higher")})(m),requestAnimationFrame(()=>{((i,m,g,_)=>{const{parsingResult:b}=i,{uris:y}=b,T="buffers",w=y[T],P=m.buffers,H=P.length;let $=0;checkProgress(i,m,$),P.forEach((b,y)=>{var P;function checkLoadingStatus(){checkProgress(i,m,$),_?.(i.loadingProgressInfo),$===H&&g&&g()}b._redURIkey=T,b._redURIIndex=y,b.uri instanceof ArrayBuffer?(P=new DataView(b.uri),$++,w[y]=P,checkLoadingStatus()):function(m){const g=m.startsWith("data:")?m:i.filePath+m;arrayBufferLoader(g,function(i){$++,w[y]=new DataView(i),checkLoadingStatus()},function(i,m){})}(b.uri)})})(i,m,()=>{requestAnimationFrame(()=>{((i,m,g)=>{const{scenes:_}=m;_[0].nodes.forEach(g=>{parseNode_GLTF(i,m,g,i.resultMesh)}),g?.()})(i,m,()=>{requestAnimationFrame(()=>{((i,m)=>{const{cameras:g}=m;g&&g.forEach(function(m){let g=new PerspectiveCamera;"orthographic"==m.type||(g.fieldOfView=180*m.perspective.yfieldOfView/Math.PI,g.farClipping=m.perspective.zfar,g.nearClipping=m.perspective.znear),i.parsingResult.cameras.push(g)})})(i,m),new TextureLoader(i.redGPUContext,Object.values(i.parsingResult.textureRawList),_=>{_.textures.forEach(i=>{const{targetTextureKey:m,targetSamplerKey:g,samplerList:_}=i.srcInfo;i.srcInfo.materialList.forEach((b,y)=>{b[m]=i.texture,_[y]&&(b[g]=_[y])})}),parseAnimations(i,m).then(i=>{g&&g()})},m=>{i.loadingProgressInfo.textures=m,_?.(i.loadingProgressInfo)})})})})},_)})})},ai=new Map,si=new Map,parseFileGLB=async(i,m,g)=>{const _=getAbsoluteURL(window.location.href,i.filePath+i.fileName),progress=()=>{if(g){const m=ai.get(_);i.loadingProgressInfo.model={loaded:m.byteLength,total:m.byteLength,lengthComputable:!0,percent:100,transferred:"Cached",totalSize:"Cached"},g(i.loadingProgressInfo)}};if(ai.has(_))return gt("GLB Model parsing has cache",_),progress(),void await parseArrayBuffer(i,ai.get(_),m,g);if(si.has(_))return await si.get(_),progress(),void await parseArrayBuffer(i,ai.get(_),m,g);const b=new Promise((m,b)=>{(async(i,m,g=()=>{},_=()=>{})=>{try{const g=await fetch(i);if(!g.ok)throw new Error(`HTTP error! status:${g.status}`);const b=g.headers.get("content-length"),y=b?parseInt(b,10):0,T=y>0,w=T?formatBytes(y):"Unknown";if(!g.body)return void m(new ArrayBuffer(0));const P=g.body.getReader();let H=0;const $=[];for(;;){const{done:i,value:m}=await P.read();if(i)break;m&&($.push(m),H+=m.length,_({loaded:H,total:y,lengthComputable:T,percent:T?Math.min(100,parseFloat((H/y*100).toFixed(2))):0,transferred:formatBytes(H),totalSize:w}))}if(0===H)return void m(new ArrayBuffer(0));const W=new Blob($);m(await W.arrayBuffer())}catch(i){g?g(i):console.error("getArrayBufferFromSrc 로딩 중 오류 발생:",i)}})(_,i=>{ai.set(_,i),gt("GLB Model parsing set cache",_),si.delete(_),m(i)},i=>{gt("GLB Model parsing error",i),si.delete(_),b(i)},m=>{i.loadingProgressInfo.model=m,g?.(i.loadingProgressInfo)})});si.set(_,b);try{const _=await b;await parseArrayBuffer(i,_,m,g)}catch(i){}},parseArrayBuffer=async(i,m,g,_)=>{const{content:b,binaryChunk:y}=parseBuffer(m);if(null===b)throw new Error("JSON content not found");const T=JSON.parse(b);processImagesIfExist(T,y),T.buffers[0].uri=y,i.gltfData=T,parseGLTF(i,T,g,_)},parseBuffer=i=>{let m=null,g=null;const _=new DataView(i,12),b=_.byteLength;for(let y=0;y<b;){const b=_.getUint32(y,!0);y+=4;const T=_.getUint32(y,!0);switch(y+=4,T){case 1313821514:const _=new Uint8Array(i,12+y,b);m=convertUint8ArrayToString(_);break;case 5130562:const T=12+y;g=i.slice(T,T+b)}y+=b}return{content:m,binaryChunk:g}},processImagesIfExist=(i,m)=>{const{images:g,bufferViews:_}=i,b=["image/png","image/jpeg","image/gif","image/webp"],y=new Map;if(g)for(let i=0;i<g.length;i++){const T=g[i],{mimeType:w,bufferView:P}=T;if(b.includes(w)&&void 0!==P){const i=_[P].byteOffset||0,g=_[P].byteLength,b=`${i}_${g}_${w}`;if(y.has(b))T.uri=y.get(b);else{const _=m.slice(i,i+g),P=new Blob([new Uint8Array(_)],{type:w}),H=URL.createObjectURL(P);y.set(b,H),T.uri=H}}}return y},convertUint8ArrayToString=i=>{let m="";for(let g of i)m+=String.fromCharCode(g);return m},oi=new Map,ui=new Map,getData=i=>({...i,meshes:JSON.parse(JSON.stringify(i.meshes))});class GLTFLoader{parsingResult;resultMesh;parsingOption;activeAnimations=[];#l;#Uc;#Ac;#Oc;#kc;#Gc;#z;#H;#Fc;#Nc={url:"",model:{loaded:0,total:0,lengthComputable:!0,percent:0,transferred:"0",totalSize:"0"}};constructor(i,m,g,_,b){validateRedGPUContext(i),this.#l=i,this.#Oc=m,this.#Uc=getFilePath(m),this.#Ac=getFileName(m),this.#kc=getFileExtension(m),this.#z=g,this.#Fc=_,this.#H=b,this.parsingResult={groups:[],materials:[],uris:{buffers:[]},textures:{},textureRawList:[],cameras:[],animations:[]},this.resultMesh=new Mesh(this.#l),this.resultMesh.gltfLoaderInfo=this,this.resultMesh.animationInfo.animationsList=this.parsingResult.animations,this.#Nc.url=getFileName(m),this.#Vc()}get loadingProgressInfo(){return this.#Nc}get redGPUContext(){return this.#l}get filePath(){return this.#Uc}get gltfData(){return this.#Gc}set gltfData(i){this.#Gc=i}get fileName(){return this.#Ac}get url(){return this.#Oc}stopAnimation(){this.activeAnimations.length=0}playAnimation(i){const{activeAnimations:m}=this;m.push(new PlayAnimationInfo(performance.now(),i))}async#Vc(){try{"glb"===this.#kc?parseFileGLB(this,()=>this.#z(this),this.#Fc):"gltf"===this.#kc?(async(i,m,g)=>{const _=getAbsoluteURL(window.location.href,i.filePath+i.fileName),cachedProgress=()=>{if(g){const m=oi.get(_);i.loadingProgressInfo.model={loaded:m.byteLength,total:m.byteLength,lengthComputable:!0,percent:100,transferred:"Cached",totalSize:"Cached"},g(i.loadingProgressInfo)}};if(oi.has(_))return i.gltfData=getData(oi.get(_)),cachedProgress(),void requestAnimationFrame(()=>{parseGLTF(i,i.gltfData,m,g)});if(ui.has(_))return await ui.get(_),cachedProgress(),i.gltfData=getData(oi.get(_)),void requestAnimationFrame(()=>{parseGLTF(i,i.gltfData,m,g)});const b=new Promise(async(m,b)=>{try{const b=await fetch(i.url);if(!b.ok)throw new Error("GLTF 네트워크 오류:"+b.status);const y=b.headers.get("content-length"),T=y?parseInt(y,10):0;gt(`전체 사이즈:${T} bytes`);const w=await b.json();oi.set(_,w),i.loadingProgressInfo.model={loaded:T,total:T,lengthComputable:!0,percent:100,transferred:formatBytes(T),totalSize:formatBytes(T)};{gt(w);const m=w.buffers.length;if(m){let g=0;i.loadingProgressInfo.buffers={loaded:g,total:m,percent:Math.min(100,parseFloat((g/m*100).toFixed(2)))}}}g?.(i.loadingProgressInfo),m(w)}catch(i){b(i)}finally{ui.delete(_)}});ui.set(_,b);const y=await b;i.gltfData=getData(y),requestAnimationFrame(()=>{parseGLTF(i,i.gltfData,m,g)})})(this,()=>this.#z(this),this.#Fc):consoleAndThrowError("Unknown file extension:"+this.#kc)}catch(i){this.#H?.(i)}}}Object.freeze(GLTFLoader);class PlayAnimationInfo{startTime;targetGLTFParsedSingleClip;constructor(i,m){this.startTime=i,this.targetGLTFParsedSingleClip=m}}var li=Object.freeze({__proto__:null,AABB:AABB,OBB:OBB,calculateGeometryAABB:calculateGeometryAABB,calculateMeshAABB:calculateMeshAABB,calculateMeshCombinedAABB:calculateMeshCombinedAABB,calculateMeshOBB:calculateMeshOBB}),ci=Object.freeze({__proto__:null,AController:AController});const hi=Math.PI/180;let fi=create$2();const di=create$2(),mi=create$1();const pi=Math.PI/180,gi=create$2(),xi=create$1();const _i=Math.PI/180,vi=create$2();var bi=Object.freeze({__proto__:null,Camera2D:Camera2D,Core:ci,FollowController:class extends AController{#zc=10;#Hc=10;#$c=.1;#Kc=5;#Wc=5;#jc=.1;#Xc=1;#qc=0;#Yc=0;#Zc=.1;#Jc=20;#Qc=20;#eh=.1;#th=!0;#nh=0;#rh=0;#ih=0;#ia;#ah=create$1();constructor(i,m){super(i,{HD_Wheel:i=>{this.#Hc+=i.deltaY/100},HD_TouchPinch:i=>{const m=i-1;this.#Hc-=m*this.#Hc}}),this.#ia=m,this.#ia.setIgnoreFrustumCullingRecursively(!0),copy(this.#ah,this.#sh())}get distance(){return this.#Hc}set distance(i){validateNumberRange(i,.1),this.#Hc=i}get distanceInterpolation(){return this.#$c}set distanceInterpolation(i){validateNumberRange(i,.01,1),this.#$c=i}get height(){return this.#Wc}set height(i){validateNumber(i),this.#Wc=i}get heightInterpolation(){return this.#jc}set heightInterpolation(i){validateNumberRange(i,.01,1),this.#jc=i}get pan(){return this.#Yc}set pan(i){validateNumber(i),this.#Yc=i}get panInterpolation(){return this.#Zc}set panInterpolation(i){validateNumberRange(i,.01,1),this.#Zc=i}get tilt(){return this.#Qc}set tilt(i){validateNumber(i),this.#Qc=Math.max(-89,Math.min(89,i))}get tiltInterpolation(){return this.#eh}set tiltInterpolation(i){validateNumberRange(i,.01,1),this.#eh=i}get interpolation(){return this.#Xc}set interpolation(i){validateNumberRange(i,.01,1),this.#Xc=i}get followTargetRotation(){return this.#th}set followTargetRotation(i){this.#th=i}get targetOffsetX(){return this.#nh}set targetOffsetX(i){validateNumber(i),this.#nh=i}get targetOffsetY(){return this.#rh}set targetOffsetY(i){validateNumber(i),this.#rh=i}get targetOffsetZ(){return this.#ih}set targetOffsetZ(i){validateNumber(i),this.#ih=i}get targetMesh(){return this.#ia}set targetMesh(i){if(!i)throw new Error("FollowController:targetMesh cannot be null or undefined");this.#ia=i,this.#ia.setIgnoreFrustumCullingRecursively(!0),copy(this.#ah,this.#sh())}setTargetOffset(i,m=0,g=0){validateNumber(i),validateNumber(m),validateNumber(g),this.#nh=i,this.#rh=m,this.#ih=g}update(i,m){super.update(i,m,()=>{this.#zc+=(this.#Hc-this.#zc)*this.#$c,this.#Kc+=(this.#Wc-this.#Kc)*this.#jc,this.#qc+=(this.#Yc-this.#qc)*this.#Zc,this.#Jc+=(this.#Qc-this.#Jc)*this.#eh,lerp$1(this.#ah,this.#ah,this.#sh(),this.#Xc),this.camera.setPosition(this.#ah[0],this.#ah[1],this.#ah[2]);const i=this.#oh();this.camera.lookAt(i[0],i[1],i[2])})}#sh(){const i=this.#qc*pi,m=this.#Jc*pi,g=Math.cos(m),_=Math.sin(m),b=Math.cos(i),y=Math.sin(i),T=this.#ia.modelMatrix,w=T[12],P=T[13],H=T[14];return this.#th?(set(xi,y*this.#zc*g,_*this.#zc+this.#Kc,b*this.#zc*g),copy$1(gi,T),gi[12]=gi[13]=gi[14]=0,transformMat4(xi,xi,gi),fromValues(w+xi[0],P+xi[1],H+xi[2])):fromValues(w+this.#zc*g*y,P+this.#Kc+this.#zc*_,H+this.#zc*g*b)}#oh(){set(xi,this.#nh,this.#rh,this.#ih);const i=this.#ia.modelMatrix,m=i[12],g=i[13],_=i[14];return!this.#th||0===this.#nh&&0===this.#rh&&0===this.#ih||(copy$1(gi,i),gi[12]=gi[13]=gi[14]=0,transformMat4(xi,xi,gi)),fromValues(m+xi[0],g+xi[1],_+xi[2])}},FreeController:class extends AController{#la={moveForward:"w",moveBack:"s",moveLeft:"a",moveRight:"d",moveUp:"t",moveDown:"g",turnLeft:"q",turnRight:"e",turnUp:"r",turnDown:"f"};#oa=.5;#uh=.1;#lh=1;#ch=0;#hh=1;#fh=.1;#dh=[0,0,0];#mh=0;#ph=0;#ia;constructor(i){super(i,{HD_Move:(i,m)=>{this.#mh-=i*this.#hh*.1,this.#ph-=m*this.#hh*.1},useKeyboard:!0}),this.#zi()}get x(){return this.#ia.x}set x(i){validateNumber(i),this.#ia.x=i,this.#dh[0]=i}get y(){return this.#ia.y}set y(i){validateNumber(i),this.#ia.y=i,this.#dh[1]=i}get z(){return this.#ia.z}set z(i){validateNumber(i),this.#ia.z=i,this.#dh[2]=i}get pan(){return this.#mh}set pan(i){validateNumber(i),this.#ia.rotationY=i,this.#mh=i}get tilt(){return this.#ph}set tilt(i){validateNumber(i);const m=Math.max(-90,Math.min(90,i));this.#ia.rotationX=m,this.#ph=m}get moveSpeed(){return this.#oa}set moveSpeed(i){validateNumberRange(i,.01),this.#oa=i}get moveSpeedInterpolation(){return this.#uh}set moveSpeedInterpolation(i){validateNumberRange(i,.01,1),this.#uh=i}get rotationSpeed(){return this.#hh}set rotationSpeed(i){validateNumberRange(i,.01),this.#hh=i}get rotationSpeedInterpolation(){return this.#fh}set rotationSpeedInterpolation(i){validateNumberRange(i,.01,1),this.#fh=i}get maxAcceleration(){return this.#lh}set maxAcceleration(i){this.#lh=i}get keyNameMapper(){return{...this.#la}}setMoveForwardKey(i){this.#la.moveForward=i}setMoveBackKey(i){this.#la.moveBack=i}setMoveLeftKey(i){this.#la.moveLeft=i}setMoveRightKey(i){this.#la.moveRight=i}setMoveUpKey(i){this.#la.moveUp=i}setMoveDownKey(i){this.#la.moveDown=i}setTurnLeftKey(i){this.#la.turnLeft=i}setTurnRightKey(i){this.#la.turnRight=i}setTurnUpKey(i){this.#la.turnUp=i}setTurnDownKey(i){this.#la.turnDown=i}update(i,m){super.update(i,m,()=>{this.#fa(i,m)})}#zi(){const{redGPUContext:i}=this;this.#ia=new Mesh(i)}#fa(i,m){const g=this.#uh,_=this.#fh,b=this.#dh,y=this.#ia;y.rotationY+=(this.#mh-y.rotationY)*_,y.rotationX+=(this.#ph-y.rotationX)*_,this.#gh(i)&&(fi=y.modelMatrix,identity(di),rotateY(di,di,y.rotationY*hi),rotateX(di,di,y.rotationX*hi),translate(di,di,mi),identity(fi),translate(fi,fi,y.position),multiply(fi,fi,di),b[0]=fi[12],b[1]=fi[13],b[2]=fi[14]),y.x+=(b[0]-y.x)*g,y.y+=(b[1]-y.y)*g,y.z+=(b[2]-y.z)*g,y.rotationY+=(this.#mh-y.rotationY)*_,y.rotationX+=(this.#ph-y.rotationX)*_,fi=y.modelMatrix,identity(fi),translate(fi,fi,y.position),rotateY(fi,fi,y.rotationY*hi),rotateX(fi,fi,y.rotationX*hi);const T=clone(fi);translate(T,T,[0,0,.01]),this.camera.setPosition(T[12],T[13],T[14]),this.camera.lookAt(y.x,y.y,y.z)}#gh(i){if(!this.checkKeyboardInput(i,this.#la))return!1;const{keyboardKeyBuffer:m}=i.redGPUContext,g=this.#oa,_=this.#hh,b=this.#la;let y=!1,T=!1,w=0,P=0;mi[0]=0,mi[1]=0,mi[2]=0;const H=this.#ch*g;return m[b.turnLeft]&&(T=!0,w=_),m[b.turnRight]&&(T=!0,w=-_),m[b.turnUp]&&(T=!0,P=_),m[b.turnDown]&&(T=!0,P=-_),m[b.moveForward]&&(y=!0,mi[2]=-H),m[b.moveBack]&&(y=!0,mi[2]=H),m[b.moveLeft]&&(y=!0,mi[0]=-H),m[b.moveRight]&&(y=!0,mi[0]=H),m[b.moveUp]&&(y=!0,mi[1]=H),m[b.moveDown]&&(y=!0,mi[1]=-H),T||y?(this.#ch+=.1,this.#ch>this.#lh&&(this.#ch=this.#lh)):(this.#ch-=.1,this.#ch<0&&(this.#ch=0)),T&&(this.#mh+=w,this.#ph+=P),y||T}},IsometricController:IsometricController,OrbitController:class extends AController{#xh=0;#_h=0;#vh=0;#bh=15;#yh=2;#$c=.1;#Sh=.1;#hr=1/0;#mh=0;#ph=-35;#Th=3;#fh=.1;#Mh=-90;#wh=90;#qc=0;#Jc=0;#zc=0;constructor(i){super(i,{HD_Move:(i,m)=>{this.#mh-=i*this.#Th*.1,this.#ph-=m*this.#Th*.1},HD_Wheel:i=>{this.#bh+=i.deltaY/100*this.#yh,this.#bh<this.#Sh&&(this.#bh=this.#Sh),this.#bh>this.#hr&&(this.#bh=this.#hr)},HD_TouchPinch:i=>{const m=(i-1)*this.#yh;this.#bh-=m*this.#bh,this.#bh<this.#Sh&&(this.#bh=this.#Sh),this.#bh>this.#hr&&(this.#bh=this.#hr)}})}get centerX(){return this.#xh}set centerX(i){this.#xh=i}get centerY(){return this.#_h}set centerY(i){this.#_h=i}get centerZ(){return this.#vh}set centerZ(i){this.#vh=i}get distance(){return this.#bh}set distance(i){validateNumberRange(i,0),this.#bh=i}get speedDistance(){return this.#yh}set speedDistance(i){validateNumberRange(i,.01),this.#yh=i}get distanceInterpolation(){return this.#$c}set distanceInterpolation(i){validateNumberRange(i,.01,1),this.#$c=i}get minDistance(){return this.#Sh}set minDistance(i){validateNumberRange(i,.1),this.#Sh=i}get maxDistance(){return this.#hr}set maxDistance(i){validateNumberRange(i,.1),this.#hr=i}get speedRotation(){return this.#Th}set speedRotation(i){validateNumberRange(i,.01),this.#Th=i}get rotationInterpolation(){return this.#fh}set rotationInterpolation(i){validateNumberRange(i,.01,1),this.#fh=i}get pan(){return this.#mh}set pan(i){this.#mh=i}get tilt(){return this.#ph}set tilt(i){validateNumberRange(i,-90,90),this.#ph=i}get minTilt(){return this.#Mh}set minTilt(i){validateNumberRange(i,-90,90),this.#Mh=i}get maxTilt(){return this.#wh}set maxTilt(i){validateNumberRange(i,-90,90),this.#wh=i}fitMeshToScreenCenter(i,m){this.#Ch(i,m);const g=i.combinedBoundingAABB;if(!g||g.minX===1/0||isNaN(g.centerX))return;const _=m.rawCamera.fieldOfView*Math.PI/180,b=Math.tan(_/2),y=b*m.aspect,T=g.xSize,w=g.ySize,P=g.zSize,H=T/2/y,$=w/2/b,W=1.15*Math.max(H,$)+P/2;if(this.centerX=g.centerX,this.centerY=g.centerY,this.centerZ=g.centerZ,this.distance=Math.max(W,2*m.rawCamera.nearClipping),this.distance<1){const m=1/this.distance;i.setScale(m),this.centerX*=m,this.centerY*=m,this.centerZ*=m,this.distance=1}this.speedDistance=Math.max(.1,.1*W)}update(i,m){super.update(i,m,()=>{this.#fa()})}#Ch(i,m){const g=create$2();identity(g),translate(g,g,[i.x,i.y,i.z]),rotateX(g,g,i.rotationX*Math.PI/180),rotateY(g,g,i.rotationY*Math.PI/180),rotateZ(g,g,i.rotationZ*Math.PI/180),scale(g,g,[i.scaleX,i.scaleY,i.scaleZ]),copy$1(i.localMatrix,g),i.parent?multiply(i.modelMatrix,i.parent?.modelMatrix,g):copy$1(i.modelMatrix,g);let _=i.children.length;for(let g=0;g<_;g++){const _=i.children[g];_ instanceof Mesh&&this.#Ch(_,m)}}#fa(){this.#ph<this.#Mh&&(this.#ph=this.#Mh),this.#ph>this.#wh&&(this.#ph=this.#wh);const{camera:i}=this,m=this.#mh-this.#qc;Math.abs(m)>.01&&(this.#qc+=m*this.#fh);const g=this.#ph-this.#Jc;Math.abs(g)>.01&&(this.#Jc+=g*this.#fh),this.#bh<i.nearClipping&&(this.#bh=i.nearClipping),this.#bh<this.#Sh&&(this.#bh=this.#Sh),this.#bh>this.#hr&&(this.#bh=this.#hr);const _=this.#bh-this.#zc;Math.abs(_)>.01&&(this.#zc+=_*this.#$c),this.#zc<i.nearClipping&&(this.#zc=i.nearClipping),identity(vi),translate(vi,vi,[this.#xh,this.#_h,this.#vh]),rotateY(vi,vi,this.#qc*_i),rotateX(vi,vi,this.#Jc*_i),translate(vi,vi,[0,0,this.#zc]),i.x=vi[12],i.y=vi[13],i.z=vi[14],this.camera.lookAt(this.#xh,this.#_h,this.#vh)}},OrthographicCamera:OrthographicCamera,PerspectiveCamera:PerspectiveCamera}),yi=Object.freeze({__proto__:null,RedGPUContextDetector:RedGPUContextDetector,RedGPUContextSizeManager:RedGPUContextSizeManager,RedGPUContextViewContainer:RedGPUContextViewContainer}),Si=Object.freeze({__proto__:null,Core:yi,RedGPUContext:RedGPUContext}),Ti=Object.freeze({__proto__:null,ColorRGB:ColorRGB,ColorRGBA:ColorRGBA,convertHexToRgb:convertHexToRgb,convertRgbToHex:convertRgbToHex});const Mi=parseWGSL("#redgpu_include FragmentOutput\nstruct Uniforms { opacity:f32, blur:f32, transitionProgress:f32,\n};\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\n@group(2) @binding(1) var skyboxTextureSampler:sampler;\n@group(2) @binding(2) var skyboxTexture:texture_cube<f32>;\n@group(2) @binding(3) var transitionTexture:texture_cube<f32>;\n@group(2) @binding(4) var transitionAlphaTexture:texture_2d<f32>;\nstruct InputData { @location(0) vertexPosition:vec4<f32>,\n};\nfn sphericalToUV(dir:vec3<f32>) -> vec2<f32> { let normalizedDir=normalize(dir); let phi=atan2(normalizedDir.z,normalizedDir.x); let theta=acos(clamp(normalizedDir.y,-1.0,1.0)); let u=(phi + 3.14159265359)/(2.0 * 3.14159265359); let v=theta/3.14159265359; return vec2<f32>(u,v);\n}\n@fragment\nfn main(inputData:InputData) -> FragmentOutput { var cubemapVec=(inputData.vertexPosition.xyz); let mipmapCount:f32=f32(textureNumLevels(skyboxTexture) - 1); let blurCurve=uniforms.blur * uniforms.blur; let skyboxColor=textureSampleLevel(skyboxTexture,skyboxTextureSampler,cubemapVec,mipmapCount * blurCurve); var sampleColor=skyboxColor; let u_transitionProgress=uniforms.transitionProgress; if (u_transitionProgress > 0.0) { let transitionSample=textureSampleLevel(transitionTexture,skyboxTextureSampler,cubemapVec,mipmapCount * blurCurve); #redgpu_if transitionAlphaTexture let uv=sphericalToUV(normalize(cubemapVec)); let transitionAlphaSample=textureSampleLevel(transitionAlphaTexture,skyboxTextureSampler,uv,0.0); let transitionAlphaValue=dot(transitionAlphaSample.rgb,vec3<f32>(0.299,0.587,0.114)); let threshold=u_transitionProgress; let noiseInfluence=0.3; let edgeSoftness=0.1; let maskValue=smoothstep( threshold - edgeSoftness, threshold + edgeSoftness, transitionAlphaValue + (u_transitionProgress - 0.5) * noiseInfluence ); sampleColor=mix(transitionSample,skyboxColor,maskValue * (1.0 - u_transitionProgress)); #redgpu_else sampleColor=mix(skyboxColor,transitionSample,u_transitionProgress); #redgpu_endIf } var outColor=vec4<f32>(sampleColor.rgb,sampleColor.a * uniforms.opacity); if (outColor.a==0.0) { discard; } var output:FragmentOutput; output.color=outColor; return output;\n}\n");class SkyBoxMaterial extends ABitmapBaseMaterial{dirtyPipeline=!1;constructor(i,m){super(i,"SKYBOX_MATERIAL",Mi,2),this.skyboxTexture=m,this.skyboxTextureSampler=new Sampler(this.redGPUContext,{addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge"}),this.initGPURenderInfos()}}In.definePositiveNumber(SkyBoxMaterial,[["blur",0]]),In.definePositiveNumber(SkyBoxMaterial,[["transitionProgress",0]]),In.defineCubeTexture(SkyBoxMaterial,["transitionTexture"]),In.defineTexture(SkyBoxMaterial,["transitionAlphaTexture"]),In.defineCubeTexture(SkyBoxMaterial,["skyboxTexture"]),In.defineSampler(SkyBoxMaterial,["skyboxTextureSampler"]),Object.freeze(SkyBoxMaterial);var wi="#redgpu_include SYSTEM_UNIFORM;\nstruct InputData { @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>,\n};\nstruct OutData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec4<f32>,\n};\nstruct VertexUniforms { modelMatrix:mat4x4<f32>,\n};\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\n@vertex\nfn main(inputData:InputData) -> OutData { var outData:OutData; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; outData.position=u_projectionCameraMatrix * vertexUniforms.modelMatrix * vec4<f32>(inputData.position,1.0); outData.vertexPosition=vec4<f32>(inputData.position,1.0); return outData;\n}\n";const Ci=parseWGSL(wi),Ri=Ci.uniforms.vertexUniforms;class SkyBox{modelMatrix=create$2();gpuRenderInfo;#Rh=!0;#Hs;#Ph;#Ia;#l;#vs;#bs;#Bh;#Ih;#Eh=0;#Dh=0;#Lh=0;#Du;constructor(i,m){validateRedGPUContext(i),this.#l=i,this.#Ph=new Box(i),this.#Bh=m,this.#Ia=new SkyBoxMaterial(i,this.#Bh),this.#vs=new PrimitiveState(this),this.#vs.cullMode=xr.NONE,this.#bs=new DepthStencilState(this)}get transitionDuration(){return this.#Dh}get transitionElapsed(){return this.#Lh}get transitionProgress(){return this.#Ia.transitionProgress}get blur(){return this.#Ia.blur}set blur(i){validatePositiveNumberRange(1,0,1),this.#Ia.blur=i}get opacity(){return this.#Ia.opacity}set opacity(i){validatePositiveNumberRange(1,0,1),this.#Ia.opacity=i}get skyboxTexture(){return this.#Bh}set skyboxTexture(i){i?(this.#Bh=i,this.#Ia.skyboxTexture=i):consoleAndThrowError("SkyBox requires a valid CubeTexture | HDRTexture")}get transitionTexture(){return this.#Ih}transition(i,m=300,g){this.#Ih=i,this.#Ia.transitionTexture=i,this.#Dh=m,this.#Eh=performance.now(),this.#Ia.transitionAlphaTexture=g}render(i){const{currentRenderPassEncoder:m,startTime:g,view:_}=i,{indexBuffer:b}=this.#Ph,{triangleCount:y,indexCount:T,format:w}=b,{gpuDevice:P,antialiasingManager:H}=this.#l,{useMSAA:$,changedMSAA:W}=H;if(this.#Uh(),this.gpuRenderInfo||this.#Ah(this.#l),this.#Eh)if(this.#Lh=Math.max(g-this.#Eh,0),this.#Lh>this.#Dh)this.#Eh=0,this.#Ia.transitionProgress=0,this.skyboxTexture=this.#Ih,this.#Ia.transitionTexture=null,this.#Rh=!0;else{const i=this.#Lh/this.#Dh;this.#Ia.transitionProgress=i<0?0:i>1?1:i}if(this.#Rh||this.#Ia.dirtyPipeline||this.#Du!==_.systemUniform_Vertex_UniformBindGroup){this.gpuRenderInfo.pipeline=this.#Oh(),this.#Rh=!1,i.numDirtyPipelines++,this.#Du=_.systemUniform_Vertex_UniformBindGroup;{this.#Ia.dirtyPipeline=!1;const i=P.createRenderBundleEncoder({..._.basicRenderBundleEncoderDescriptor,label:"skybox"}),{gpuRenderInfo:m}=this,{vertexUniformBindGroup:g,pipeline:y}=m;i.setPipeline(y),i.setBindGroup(0,_.systemUniform_Vertex_UniformBindGroup),i.setVertexBuffer(0,this.#Ph.vertexBuffer.gpuBuffer),i.setBindGroup(1,g),i.setBindGroup(2,this.#Ia.gpuRenderInfo.fragmentUniformBindGroup),i.setIndexBuffer(b.gpuBuffer,w),i.drawIndexed(b.indexCount,1,0,0,0),this.#Hs=i.finish({label:"renderBundle skybox"})}}m.executeBundles([this.#Hs]),i.num3DObjects++,i.numDrawCalls++,i.numTriangles+=y,i.numPoints+=T}#Uh(){const{changedMSAA:i}=this.#l.antialiasingManager;i&&(this.#Rh=!0)}#Ah(i){const{resourceManager:m}=this.#l,g=m.getGPUBindGroupLayout("SKYBOX_VERTEX_BIND_GROUP_LAYOUT")||m.createBindGroupLayout("SKYBOX_VERTEX_BIND_GROUP_LAYOUT",getVertexBindGroupLayoutDescriptorFromShaderInfo(Ci,1)),_=new ArrayBuffer(Ri.arrayBufferByteLength),b=new UniformBuffer(i,_,"SKYBOX_VERTEX_UNIFORM_BUFFER","SKYBOX_VERTEX_UNIFORM_BUFFER");identity(this.modelMatrix),scale(this.modelMatrix,this.modelMatrix,[1e4,1e4,1e4]),b.writeOnlyBuffer(Ri.members.modelMatrix,this.modelMatrix);const y={layout:g,label:"VERTEX_BIND_GROUP_DESCRIPTOR_SKYBOX",entries:[{binding:0,resource:{buffer:b.gpuBuffer,offset:0,size:b.size}}]},T=i.gpuDevice.createBindGroup(y);this.gpuRenderInfo=new VertexGPURenderInfo(null,Ci.shaderSourceVariant,Ci.conditionalBlocks,Ri,g,b,T,this.#Oh())}#Oh(){const{resourceManager:i,gpuDevice:m,antialiasingManager:g}=this.#l,_={code:wi},b={module:i.createGPUShaderModule("VERTEX_MODULE_SKYBOX",_),entryPoint:"main",buffers:this.#Ph.gpuRenderInfo.buffers},y=i.getGPUBindGroupLayout("SKYBOX_VERTEX_BIND_GROUP_LAYOUT")||i.createBindGroupLayout("SKYBOX_VERTEX_BIND_GROUP_LAYOUT",getVertexBindGroupLayoutDescriptorFromShaderInfo(Ci,1)),T={bindGroupLayouts:[i.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),y,this.#Ia.gpuRenderInfo.fragmentBindGroupLayout]},w={label:"PIPELINE_DESCRIPTOR_SKYBOX",layout:i.createGPUPipelineLayout("SKYBOX_PIPELINE_LAYOUT",T),vertex:b,fragment:this.#Ia.gpuRenderInfo.fragmentState,primitive:this.#vs.state,depthStencil:this.#bs.state,multisample:{count:g.useMSAA?4:1}};return m.createRenderPipeline(w)}}Object.freeze(SkyBox);var Pi=Object.freeze({__proto__:null,SkyBoxMaterial:SkyBoxMaterial});const Bi={NORMAL:0,MULTIPLY:1,LIGHTEN:2,SCREEN:3,LINEAR_DODGE:4,SUBTRACT:5,DIFFERENCE:6,EXCLUSION:7};function mixInMesh2D(i){const m=class extends i{#kh=0;#Gh=Bi.NORMAL;get blendMode(){const i=Object.entries(Bi).find(([,i])=>i===this.#Gh);if(!i)throw new Error(`Invalid blendMode value:${this.#Gh}`);return i[0]}set blendMode(i){let m;if("string"==typeof i){if(!(i in Bi))throw new Error(`Invalid blendMode key:${i}`);m=Bi[i]}else{if("number"!=typeof i||!Object.values(Bi).includes(i))throw new Error(`Invalid blendMode:${i}`);m=i}this.#Gh=m,this.#Fh(m)}get rotation(){return this.#kh}set rotation(i){this.#kh=i,super.rotationZ=i}setScale(i,m){m=m??i,super.setScale(i,m,1)}setPosition(i,m){m=m??i,super.setPosition(i,m,0)}setRotation(i){this.rotation=i}#Fh(i){const{blendColorState:m,blendAlphaState:g}=this._material;switch(i){case Bi.NORMAL:m.operation=Dn.ADD,m.srcFactor=En.SRC_ALPHA,m.dstFactor=En.ONE_MINUS_SRC_ALPHA,g.operation=Dn.ADD,g.srcFactor=En.SRC_ALPHA,g.dstFactor=En.ONE_MINUS_SRC_ALPHA;break;case Bi.MULTIPLY:m.operation=Dn.ADD,m.srcFactor=En.ONE_MINUS_DST_ALPHA,m.dstFactor=En.ONE_MINUS_SRC_ALPHA,g.operation=Dn.ADD,g.srcFactor=En.SRC_ALPHA,g.dstFactor=En.ONE_MINUS_SRC_ALPHA;break;case Bi.LIGHTEN:m.operation=Dn.MAX,m.srcFactor=En.ONE,m.dstFactor=En.ONE,g.operation=Dn.ADD,g.srcFactor=En.SRC_ALPHA,g.dstFactor=En.ONE_MINUS_SRC_ALPHA;break;case Bi.SCREEN:m.operation=Dn.ADD,m.srcFactor=En.ONE,m.dstFactor=En.ONE_MINUS_SRC,g.operation=Dn.ADD,g.srcFactor=En.SRC_ALPHA,g.dstFactor=En.ONE_MINUS_SRC_ALPHA;break;case Bi.LINEAR_DODGE:m.operation=Dn.ADD,m.srcFactor=En.ONE,m.dstFactor=En.ONE,g.operation=Dn.ADD,g.srcFactor=En.SRC_ALPHA,g.dstFactor=En.ONE;break;case Bi.SUBTRACT:m.operation=Dn.REVERSE_SUBTRACT,m.srcFactor=En.SRC_ALPHA,m.dstFactor=En.ONE_MINUS_SRC_ALPHA,g.operation=Dn.REVERSE_SUBTRACT,g.srcFactor=En.ONE,g.dstFactor=En.ONE;break;case Bi.DIFFERENCE:m.operation=Dn.SUBTRACT,m.srcFactor=En.ONE,m.dstFactor=En.ONE,g.operation=Dn.SUBTRACT,g.srcFactor=En.ONE,g.dstFactor=En.ONE;break;case Bi.EXCLUSION:m.operation=Dn.ADD,m.srcFactor=En.ONE_MINUS_DST_ALPHA,m.dstFactor=En.ONE_MINUS_SRC_ALPHA,g.operation=Dn.ADD,g.srcFactor=En.ONE,g.dstFactor=En.ONE;break;default:console.warn(`Unsupported blend mode:${i}`)}}};return Object.defineProperty(m.prototype,"is2DMeshType",{value:!0,writable:!1}),m}var Ii=Object.freeze({__proto__:null,LODManager:LODManager,MeshBase:MeshBase,Object3DContainer:Object3DContainer,VertexGPURenderInfo:VertexGPURenderInfo,createMeshVertexUniformBuffers:createMeshVertexUniformBuffers,mixInMesh2D:mixInMesh2D}),Ei=Object.freeze({__proto__:null,AView:AView,RenderViewStateData:RenderViewStateData,ViewRenderTextureManager:ViewRenderTextureManager,ViewTransform:ViewTransform});class View2D extends View3D{constructor(i,m,g){super(i,m,new Camera2D,g)}}Object.freeze(View2D);const Di=Math.PI/180;class GroupBase extends Object3DContainer{modelMatrix=create$2();localMatrix=create$2();#f;#h;#Ss;#Mt=0;#Ct=0;#wt=0;#Ts=[0,0,0];#Ms=0;#ws=0;#Cs=0;#Ps=1;#Bs=1;#Is=1;#Es=[1,1,1];#pi=0;#gi=0;#xi=0;#Ds=[0,0,0];#Nh=!0;constructor(i){super(),i&&(this.name=i)}get dirtyTransform(){return this.#Nh}set dirtyTransform(i){this.#Nh=i}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get parent(){return this.#Ss}set parent(i){this.#Ss=i}get pivotX(){return this.#Ms}set pivotX(i){this.#Ms=i,this.dirtyTransform=!0}get pivotY(){return this.#ws}set pivotY(i){this.#ws=i,this.dirtyTransform=!0}get pivotZ(){return this.#Cs}set pivotZ(i){this.#Cs=i,this.dirtyTransform=!0}get x(){return this.#Mt}set x(i){this.#Mt=this.#Ts[0]=i,this.dirtyTransform=!0}get y(){return this.#wt}set y(i){this.#wt=this.#Ts[1]=i,this.dirtyTransform=!0}get z(){return this.#Ct}set z(i){this.#Ct=this.#Ts[2]=i,this.dirtyTransform=!0}get position(){return this.#Ts}get scaleX(){return this.#Ps}set scaleX(i){this.#Ps=this.#Es[0]=i,this.dirtyTransform=!0}get scaleY(){return this.#Bs}set scaleY(i){this.#Bs=this.#Es[1]=i,this.dirtyTransform=!0}get scaleZ(){return this.#Is}set scaleZ(i){this.#Is=this.#Es[2]=i,this.dirtyTransform=!0}get scale(){return this.#Ts}get rotationX(){return this.#pi}set rotationX(i){this.#pi=this.#Ds[0]=i,this.dirtyTransform=!0}get rotationY(){return this.#gi}set rotationY(i){this.#gi=this.#Ds[1]=i,this.dirtyTransform=!0}get rotationZ(){return this.#xi}set rotationZ(i){this.#xi=this.#Ds[2]=i,this.dirtyTransform=!0}get rotation(){return this.#Ds}setScale(i,m,g){m=m??i,g=g??i;const _=this.#Es;this.#Ps=_[0]=i,this.#Bs=_[1]=m,this.#Is=_[2]=g,this.dirtyTransform=!0}setPosition(i,m,g){m=m??i,g=g??i;const _=this.#Ts;this.#Mt=_[0]=i,this.#wt=_[1]=m,this.#Ct=_[2]=g,this.dirtyTransform=!0}setRotation(i,m,g){m=m??i,g=g??i;const _=this.#Ds;this.#pi=_[0]=i,this.#gi=_[1]=m,this.#xi=_[2]=g,this.dirtyTransform=!0}render(i){const{view:m,isScene2DMode:g}=i;let _;if(g&&(this.#Ct=0,this.#Cs=0),this.dirtyTransform){_=!0;{const{pixelRectObject:i}=m,g=this.parent,_=this.localMatrix;identity(_),translate(_,_,[this.#Mt,this.#wt,this.#Ct]),rotateX(_,_,this.#pi*Di),rotateY(_,_,this.#gi*Di),rotateZ(_,_,this.#xi*Di);let b=[this.#Ps,this.#Bs,this.#Is];if(this.renderTextureWidth&&(b[0]*=this.renderTextureWidth/i.height,b[1]*=this.renderTextureHeight/i.height),scale(_,_,b),this.#Ms||this.#ws||this.#Cs){translate(_,_,[-this.#Ms,-this.#ws,-this.#Cs])}g?.modelMatrix?multiply(this.modelMatrix,g.modelMatrix,this.localMatrix):copy$1(this.modelMatrix,this.localMatrix)}}this.dirtyTransform&&(_=!0,this.dirtyTransform=!1),i.num3DGroups++;const{children:b}=this;let y=0;const T=b.length;for(;y<T;y++)_&&(b[y].dirtyTransform=_),b[y].render(i)}}Object.defineProperty(GroupBase.prototype,"meshType",{value:Qn.MESH,writable:!1}),Object.freeze(GroupBase);class Group2D extends GroupBase{#f;#h;#kh=0;constructor(i){super(),i&&(this.name=i)}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get rotation(){return this.#kh}set rotation(i){this.#kh=i,super.rotationZ=i}setScale(i,m){m=m??i,super.setScale(i,m,1)}setPosition(i,m){m=m??i,super.setPosition(i,m,0)}setRotation(i){this.rotation=i}}Object.defineProperty(Group2D.prototype,"is2DMeshType",{value:!0,writable:!1}),Object.freeze(Group2D);class Group3D extends GroupBase{#f;#h;constructor(i){super(),i&&(this.name=i)}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}}Object.defineProperty(Group3D.prototype,"meshType",{value:Qn.MESH,writable:!1}),Object.freeze(Group3D);var Li=Object.freeze({__proto__:null,AGroupBase:GroupBase});const Ui={Linear:0,QuintIn:1,QuintOut:2,QuintInOut:3,BackIn:4,BackOut:5,BackInOut:6,CircIn:7,CircOut:8,CircInOut:9,CubicIn:10,CubicOut:11,CubicInOut:12,ExpoIn:13,ExpoOut:14,ExpoInOut:15,QuadIn:16,QuadOut:17,QuadInOut:18,QuartIn:19,QuartOut:20,QuartInOut:21,SineIn:22,SineOut:23,SineInOut:24,ElasticIn:25,ElasticOut:26,ElasticInOut:27};const Ai=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include calcTintBlendMode;\n#redgpu_include drawPicking;\n#redgpu_include FragmentOutput;\n#redgpu_include calculateMotionVector;\nstruct Uniforms { opacity:f32, useTint:u32, tint:vec4<f32>, tintBlendMode:u32,\n};\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\n@group(2) @binding(1) var diffuseTextureSampler:sampler;\n@group(2) @binding(2) var diffuseTexture:texture_2d<f32>;\nstruct InputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\n@fragment\nfn main(inputData:InputData) -> FragmentOutput { var output:FragmentOutput; var finalColor:vec4<f32>=vec4<f32>(0.0); #redgpu_if diffuseTexture finalColor=textureSample(diffuseTexture,diffuseTextureSampler,inputData.uv); #redgpu_endIf let alpha2D=select(finalColor.a,1.0,systemUniforms.isView3D==1u); finalColor=vec4<f32>(finalColor.rgb * alpha2D,finalColor.a * uniforms.opacity * inputData.combinedOpacity); #redgpu_if useTint finalColor=calcTintBlendMode(finalColor,uniforms.tintBlendMode,uniforms.tint); #redgpu_endIf if (systemUniforms.isView3D==1 && finalColor.a==0.0) { discard; } output.color=finalColor; output.gBufferMotionVector=vec4<f32>(calculateMotionVector(inputData.currentClipPos,inputData.prevClipPos),0.0,1.0 ); return output;\n};\n");class BitmapMaterial extends ABitmapBaseMaterial{dirtyPipeline=!1;constructor(i,m,g){super(i,"BITMAP_MATERIAL",Ai,2),g&&(this.name=g),this.diffuseTexture=m,this.diffuseTextureSampler=new Sampler(this.redGPUContext),this.initGPURenderInfos()}}In.defineByPreset(BitmapMaterial,[In.PRESET_TEXTURE.DIFFUSE_TEXTURE,In.PRESET_SAMPLER.DIFFUSE_TEXTURE_SAMPLER]),Object.freeze(BitmapMaterial);var Oi="#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include getBillboardMatrix;\nstruct MatrixList{ modelMatrix:mat4x4<f32>, normalModelMatrix:mat4x4<f32>,\n}\nstruct VertexUniforms { matrixList:MatrixList, pickingId:u32, useBillboardPerspective:u32, useBillboard:u32, combinedOpacity:f32,\n};\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\nstruct InputData { @location(0) a_position:vec3<f32>, @location(1) a_normal:vec3<f32>, @location(2) a_uv:vec2<f32>, @location(3) position:vec3<f32>, @location(4) alpha:f32, @location(5) rotation:vec3<f32>, @location(6) scale:f32,\n};\nstruct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(14) @interpolate(flat) receiveShadow:f32, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\nfn mat4_inverse(a:mat4x4<f32>) -> mat4x4<f32> { var a00:f32=a[0][0]; var a01:f32=a[0][1]; var a02:f32=a[0][2]; var a03:f32=a[0][3]; var a10:f32=a[1][0]; var a11:f32=a[1][1]; var a12:f32=a[1][2]; var a13:f32=a[1][3]; var a20:f32=a[2][0]; var a21:f32=a[2][1]; var a22:f32=a[2][2]; var a23:f32=a[2][3]; var a30:f32=a[3][0]; var a31:f32=a[3][1]; var a32:f32=a[3][2]; var a33:f32=a[3][3]; var b00:f32=a00*a11 - a01*a10; var b01:f32=a00*a12 - a02*a10; var b02:f32=a00*a13 - a03*a10; var b03:f32=a01*a12 - a02*a11; var b04:f32=a01*a13 - a03*a11; var b05:f32=a02*a13 - a03*a12; var b06:f32=a20*a31 - a21*a30; var b07:f32=a20*a32 - a22*a30; var b08:f32=a20*a33 - a23*a30; var b09:f32=a21*a32 - a22*a31; var b10:f32=a21*a33 - a23*a31; var b11:f32=a22*a33 - a23*a32; var det:f32=b00*b11 - b01*b10 + b02*b09 + b03*b08 - b04*b07 + b05*b06; if (det !=0.0) { det=1.0/det; return mat4x4<f32>( (a11*b11 - a12*b10 + a13*b09) * det, (a02*b10 - a01*b11 - a03*b09) * det, (a31*b05 - a32*b04 + a33*b03) * det, (a22*b04 - a21*b05 - a23*b03) * det, (a12*b08 - a10*b11 - a13*b07) * det, (a00*b11 - a02*b08 + a03*b07) * det, (a32*b02 - a30*b05 - a33*b01) * det, (a20*b05 - a22*b02 + a23*b01) * det, (a10*b10 - a11*b08 + a13*b06) * det, (a01*b08 - a00*b10 - a03*b06) * det, (a30*b04 - a31*b02 + a33*b00) * det, (a21*b02 - a20*b04 - a23*b00) * det, (a11*b07 - a10*b09 - a12*b06) * det, (a00*b09 - a01*b07 + a02*b06) * det, (a31*b01 - a30*b03 - a32*b00) * det, (a20*b03 - a21*b01 + a22*b00) * det ); } return mat4x4<f32>( 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0 );\n}\nfn rotationMTX(t:vec3<f32>)->mat4x4<f32>\n{ var s:f32=sin(t.x); var c:f32=cos(t.x); var m1=mat4x4<f32>(1,0,0,0, 0,c,-s,0, 0,s,c,0, 0,0,0,1); s=sin(t[1]);c=cos(t[1]); var m2=mat4x4<f32>(c,0,s,0, 0,1,0,0, -s,0,c,0, 0,0,0,1); s=sin(t[2]);c=cos(t[2]); var m3=mat4x4<f32>(c,-s,0,0, s,c,0,0, 0,0,1,0, 0,0,0,1); return m1 * m2 * m3;\n}\n@vertex\nfn main( inputData:InputData) -> OutputData { var output:OutputData; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_resolution=systemUniforms.resolution; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_normalModelMatrix=vertexUniforms.matrixList.normalModelMatrix; let u_useBillboardPerspective=vertexUniforms.useBillboardPerspective==1u; let u_useBillboard=vertexUniforms.useBillboard==1u; let input_position=inputData.position; var position:vec4<f32>; var normalPosition:vec4<f32>; var scaleMTX=mat4x4<f32>( inputData.scale,0,0,0, 0,inputData.scale,0,0, 0,0,inputData.scale,0, 0,0,0,1 ); var translateTX=mat4x4<f32>( 1,0,0,0, 0,1,0,0, 0,0,1,0, inputData.position.x,inputData.position.y,inputData.position.z,1 ); var temp:mat4x4<f32>; if(u_useBillboard){ var rotateMTX2=rotationMTX( vec3(0,0,inputData.rotation.z) ); temp=translateTX * rotateMTX2; position=rotateMTX2 * vec4<f32>(inputData.a_position,1); output.position=u_projectionMatrix * getBillboardMatrixNoScaleRatio( u_cameraMatrix,temp ) * scaleMTX * position; }else{ var rotateMTX=rotationMTX( inputData.rotation ); temp=translateTX * rotateMTX * scaleMTX; position=temp * vec4<f32>(inputData.a_position,1); output.position=u_projectionCameraMatrix * position; } output.vertexPosition=position.xyz; output.vertexNormal=(transpose(mat4_inverse(temp) ) * vec4<f32>(inputData.a_normal,1.0)).xyz; output.uv=inputData.a_uv; output.combinedOpacity=inputData.alpha; return output;\n}\nstruct OutputShadowData { @builtin(position) position:vec4<f32>,\n};\n";const ki=parseWGSL(Oi),Gi=ki.uniforms.vertexUniforms;class ParticleEmitter extends Mesh{#Vh=1e3;#zh=5e3;#Hh=0;#$h=0;#Kh=0;#Wh=0;#jh=0;#Xh=0;#qh=-5;#Yh=-5;#Zh=-5;#Jh=5;#Qh=5;#ef=5;#tf=1;#nf=1;#rf=1;#if=1;#af=0;#sf=1;#of=0;#uf=0;#lf=-360;#cf=-360;#hf=-360;#ff=360;#df=360;#mf=360;#pf=-360;#gf=-360;#xf=-360;#_f=360;#vf=360;#bf=360;#yf=Ui.CubicOut;#Sf=Ui.CubicOut;#Tf=Ui.CubicOut;#Mf=Ui.Linear;#wf=Ui.Linear;#Cf=Ui.CubicOut;#Rf=Ui.CubicOut;#Pf=Ui.CubicOut;#Bf;#If;#Ef;#Pn;#Df;#Lf=2e3;constructor(i){super(i),this.geometry=new Plane(i),this.material=new BitmapMaterial(i),this.ignoreFrustumCulling=!0,this.useBillboard=!0}get vertexStateBuffers(){return[{arrayStride:32,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x3"},{shaderLocation:2,offset:24,format:"float32x2"}]},{arrayStride:48,stepMode:"instance",attributes:[{shaderLocation:3,offset:16,format:"float32x3"},{shaderLocation:4,offset:28,format:"float32"},{shaderLocation:5,offset:32,format:"float32x3"},{shaderLocation:6,offset:44,format:"float32"}]}]}get particleNum(){return this.#Lf}set particleNum(i){this.#Lf=Math.max(Math.min(i,5e5),1),this.#Bf||this.#ft(),this.#Uf()}get minLife(){return this.#Vh}set minLife(i){this.#Vh=i}get maxLife(){return this.#zh}set maxLife(i){this.#zh=i}get minStartX(){return this.#Hh}set minStartX(i){this.#Hh=i}get minStartY(){return this.#$h}set minStartY(i){this.#$h=i}get minStartZ(){return this.#Kh}set minStartZ(i){this.#Kh=i}get maxStartX(){return this.#Wh}set maxStartX(i){this.#Wh=i}get maxStartY(){return this.#jh}set maxStartY(i){this.#jh=i}get maxStartZ(){return this.#Xh}set maxStartZ(i){this.#Xh=i}get minEndX(){return this.#qh}set minEndX(i){this.#qh=i}get minEndY(){return this.#Yh}set minEndY(i){this.#Yh=i}get minEndZ(){return this.#Zh}set minEndZ(i){this.#Zh=i}get maxEndX(){return this.#Jh}set maxEndX(i){this.#Jh=i}get maxEndY(){return this.#Qh}set maxEndY(i){this.#Qh=i}get maxEndZ(){return this.#ef}set maxEndZ(i){this.#ef=i}get minStartAlpha(){return this.#tf}set minStartAlpha(i){this.#tf=i}get maxStartAlpha(){return this.#nf}set maxStartAlpha(i){this.#nf=i}get minEndAlpha(){return this.#rf}set minEndAlpha(i){this.#rf=i}get maxEndAlpha(){return this.#if}set maxEndAlpha(i){this.#if=i}get minStartScale(){return this.#af}set minStartScale(i){this.#af=i}get maxStartScale(){return this.#sf}set maxStartScale(i){this.#sf=i}get minEndScale(){return this.#of}set minEndScale(i){this.#of=i}get maxEndScale(){return this.#uf}set maxEndScale(i){this.#uf=i}get minStartRotationX(){return this.#lf}set minStartRotationX(i){this.#lf=i}get minStartRotationY(){return this.#cf}set minStartRotationY(i){this.#cf=i}get minStartRotationZ(){return this.#hf}set minStartRotationZ(i){this.#hf=i}get maxStartRotationX(){return this.#ff}set maxStartRotationX(i){this.#ff=i}get maxStartRotationY(){return this.#df}set maxStartRotationY(i){this.#df=i}get maxStartRotationZ(){return this.#mf}set maxStartRotationZ(i){this.#mf=i}get minEndRotationX(){return this.#pf}set minEndRotationX(i){this.#pf=i}get minEndRotationY(){return this.#gf}set minEndRotationY(i){this.#gf=i}get minEndRotationZ(){return this.#xf}set minEndRotationZ(i){this.#xf=i}get maxEndRotationX(){return this.#_f}set maxEndRotationX(i){this.#_f=i}get maxEndRotationY(){return this.#vf}set maxEndRotationY(i){this.#vf=i}get maxEndRotationZ(){return this.#bf}set maxEndRotationZ(i){this.#bf=i}get easeX(){return this.#yf}set easeX(i){this.#yf=i}get easeY(){return this.#Sf}set easeY(i){this.#Sf=i}get easeZ(){return this.#Tf}set easeZ(i){this.#Tf=i}get easeAlpha(){return this.#Mf}set easeAlpha(i){this.#Mf=i}get easeScale(){return this.#wf}set easeScale(i){this.#wf=i}get easeRotationX(){return this.#Cf}set easeRotationX(i){this.#Cf=i}get easeRotationY(){return this.#Rf}set easeRotationY(i){this.#Rf=i}get easeRotationZ(){return this.#Pf}set easeRotationZ(i){this.#Pf=i}get particleBuffers(){return this.#If}render(i){this.#Bf||this.#ft(),this.#Af(i.timestamp),super.render(i)}createCustomMeshVertexShaderModule=()=>this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_PARTICLE_EMITTER",ki,Gi,Oi);#ft(){this.#Ef=new Float32Array(46);let i={size:this.#Ef.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST};const{gpuDevice:m}=this.redGPUContext;this.#Bf=m.createBuffer(i),m.queue.writeBuffer(this.#Bf,0,this.#Ef),this.#Uf(),this.depthStencilState.depthWriteEnabled=!1}#Uf(){this.dirtyPipeline=!0;let i=this.redGPUContext;const m=new Float32Array(12*this.#Lf),g=new Float32Array(12*this.#Lf),_=new Float32Array(12*this.#Lf),b=new Float32Array(4*this.#Lf),y=new Float32Array(4*this.#Lf),T=performance.now(),w=this.localToWorld(this.x,this.y,this.z);for(let i=0;i<this.#Lf;++i){let P=Math.random()*this.#zh,H=Math.random()*P;const $=w[0]+Math.random()*(this.#Wh-this.#Hh)+this.#Hh,W=w[1]+Math.random()*(this.#jh-this.#$h)+this.#$h,q=w[2]+Math.random()*(this.#Xh-this.#Kh)+this.#Kh,ye=Math.random()*(this.#ff-this.#lf)+this.#lf,Ge=Math.random()*(this.#df-this.#cf)+this.#cf,Ke=Math.random()*(this.#mf-this.#hf)+this.#hf;Math.random(),this.#sf,this.#af,this.#af,Math.random(),this.#nf,this.#tf,this.#tf,m[12*i]=T-H,m[12*i+1]=P,m[12*i+4]=$,m[12*i+5]=W,m[12*i+6]=q,m[12*i+7]=0,m[12*i+8]=ye,m[12*i+9]=Ge,m[12*i+10]=Ke,m[12*i+11]=0,g[4*i]=$,g[4*i+1]=Math.random()*(this.#Jh-this.#qh)+this.#qh,g[4*i+2]=this.#yf,g[4*i+3]=w[0],g[4*i+4]=W,g[4*i+5]=Math.random()*(this.#Qh-this.#Yh)+this.#Yh,g[4*i+6]=this.#Sf,g[4*i+7]=w[1],g[4*i+8]=q,g[4*i+9]=Math.random()*(this.#ef-this.#Zh)+this.#Zh,g[4*i+10]=this.#Tf,g[4*i+11]=w[2],_[4*i]=ye,_[4*i+1]=Math.random()*(this.#_f-this.#pf)+this.#pf,_[4*i+2]=this.#Cf,_[4*i+3]=0,_[4*i+4]=Ge,_[4*i+5]=Math.random()*(this.#vf-this.#gf)+this.#gf,_[4*i+6]=this.#Rf,_[4*i+7]=0,_[4*i+8]=Ke,_[4*i+9]=Math.random()*(this.#bf-this.#xf)+this.#xf,_[4*i+10]=this.#Pf,_[4*i+11]=0,b[4*i]=0,b[4*i+1]=Math.random()*(this.#uf-this.#of)+this.#of,b[4*i+2]=this.#wf,b[4*i+3]=0,y[4*i]=0,y[4*i+1]=Math.random()*(this.#if-this.#rf)+this.#rf,y[4*i+2]=this.#Mf,y[4*i+3]=0}const P=this.#If;this.#If=[];const H=[m,g,_,b,y];H.forEach((m,g)=>{const _=i.gpuDevice.createBuffer({size:m.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC|GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE});i.gpuDevice.queue.writeBuffer(_,0,m),this.#If.push(_),P?.length&&copyGPUBuffer(i.gpuDevice,P[g],_)}),P&&P.forEach(i=>i.destroy());let $={code:"\nstruct Info { startValue:f32, endValue:f32, easeType:f32, birthCenterValue:f32\n};\nstruct InfoGroup { infoX:Info, infoY:Info, infoZ:Info,\n};\nstruct Particle { startTime:f32, life:f32, valuePosition:vec3<f32>, valueAlpha:f32, valueRotation:vec3<f32>, valueScale:f32,\n};\nstruct SimParams { time:f32, currentPositionX:f32,currentPositionY:f32,currentPositionZ:f32, minLife:f32,maxLife:f32, minStartX:f32,maxStartX:f32,minEndX:f32,maxEndX:f32,easeX:f32, minStartY:f32,maxStartY:f32,minEndY:f32,maxEndY:f32,easeY:f32, minStartZ:f32,maxStartZ:f32,minEndZ:f32,maxEndZ:f32,easeZ:f32, minStartAlpha:f32,maxStartAlpha:f32,minEndAlpha:f32,maxEndAlpha:f32,easeAlpha:f32, minStartScale:f32,maxStartScale:f32,minEndScale:f32,maxEndScale:f32,easeScale:f32, minStartRotationX:f32,maxStartRotationX:f32,minEndRotationX:f32,maxEndRotationX:f32,easeRotationX:f32, minStartRotationY:f32,maxStartRotationY:f32,minEndRotationY:f32,maxEndRotationY:f32,easeRotationY:f32, minStartRotationZ:f32,maxStartRotationZ:f32,minEndRotationZ:f32,maxEndRotationZ:f32,easeRotationZ:f32,\n};\n@group(0) @binding(0) var<uniform> params:SimParams;\n@group(0) @binding(1) var<storage,read_write> particles:array<Particle>;\n@group(0) @binding(2) var<storage,read_write> infoPosition:array<InfoGroup>;\n@group(0) @binding(3) var<storage,read_write> infoRotation:array<InfoGroup>;\n@group(0) @binding(4) var<storage,read_write> infoScale:array<Info>;\n@group(0) @binding(5) var<storage,read_write> infoAlpha:array<Info>;\nconst PI:f32=3.141592653589793;\nconst HPI:f32=PI * 0.5;\nconst PI2:f32=PI * 2.0;\nfn calEasing(n:f32,easingType:f32) -> f32 { var m:f32=n; let easingInt:i32=i32(easingType); switch (easingInt) { case 0:{ m=m;} case 1:{ m=m * m * m * m * m;} case 2:{ m -=1.0; m=(m * m * m * m * m) + 1.0; } case 3:{ if(m * 2.0 < 1.0) { m *=2.0; m=m * m * m * m * m * 0.5; } else { m=m * 2.0 - 2.0; m=0.5 * (m * m * m * m * m + 2.0); } } case 4:{ m=m * m * (m * 1.70158 + m - 1.70158);} case 5:{ m -=1.0; m=m * m * (m * 1.70158 + m + 1.70158) + 1.0; } case 6:{ if(m * 2.0 < 1.0) { m *=2.0; m=0.5 * m * m * (m * 1.70158 + m - 1.70158); } else { m=m * 2.0 - 2.0; m=0.5 * m * m * (m * 1.70158 + m + 1.70158) + 1.0; } } case 7:{ m=-1.0 * (sqrt(1.0 - m * m) - 1.0);} case 8:{ m -=1.0; m=sqrt(1.0 - m * m); } case 9:{ if(m * 2.0 < 1.0) { m *=2.0; m=-0.5 * (sqrt(1.0 - m * m) - 1.0); } else { m=m * 2.0 - 2.0; m=0.5 * sqrt(1.0 - m * m) + 0.5; } } case 10:{ m=m * m * m;} case 11:{ m -=1.0; m=m * m * m + 1.0; } case 12:{ if(m * 2.0 < 1.0) { m *=2.0; m=m * m * m * 0.5; } else { m=m * 2.0 - 2.0; m=0.5 * (m * m * m + 2.0); } } case 13:{ if (m==0.0) { m=0.0;} else { m=pow(2.0,10.0 * (m - 1.0));} } case 14:{ if (m==1.0) { m=1.0;} else { m=-pow(2.0,-10.0 * m) + 1.0;} } case 15:{ if(m * 2.0 < 1.0) { if (m==0.0) { m=0.0;} else { m *=2.0;m=0.5 * pow(2.0,10.0 * (m - 1.0));} } else { if (m==2.0) { m=1.0;} else { m=m * 2.0 - 1.0;m=-0.5 * pow(2.0,-10.0 * m) + 1.0;} } } case 16:{ m=m * m;} case 17:{ m=(2.0 - m) * m;} case 18:{ if(m * 2.0 < 1.0) { m *=2.0; m=m * m * 0.5; } else { m=2.0 - m; m=0.5 * (m * m + 1.0); } } case 19:{ m=m * m * m * m;} case 20:{ m -=1.0; m=1.0 - (m * m * m * m); } case 21:{ if(m * 2.0 < 1.0) { m *=2.0; m=m * m * m * m * 0.5; } else { m=m * 2.0 - 2.0; m=1.0 - (m * m * m * m * 0.5); } } case 22:{ m=-cos(m * HPI) + 1.0;} case 23:{ m=sin(m * HPI);} case 24:{ m=(-cos(m * PI) + 1.0) * 0.5;} case 25:{ if (m==0.0) { m=0.0;} else if (m==1.0) { m=1.0;} else { m -=1.0;m=-1.0 * pow(2.0,10.0 * m) * sin((m - 0.075) * (PI2)/0.3);} } case 26:{ if (m==0.0) { m=0.0; } else if (m==1.0) { m=1.0; } else { m -=1.0; m=-pow(2.0,10.0 * m) * sin((m - 0.075) * PI2/0.3); } } case 27:{ if (m==0.0) { m=0.0; } else if (m==1.0) { m=1.0; } else { m=pow(2.0,-10.0 * m) * sin((m - 0.075) * PI2/0.3) + 1.0; } } default:{ m=m;} } return m;\n}\nfn rand(n:f32) -> f32 { return fract(sin(n) * 43758.5453123);\n}\nfn randomRange(min:f32,max:f32,v:f32)->f32\n{ var newValue:f32=rand(v); return (newValue * (max-min)) + min;\n}\nfn compute_value(tInfo:Info,lifeRatio:f32) -> f32 { return tInfo.startValue + ((tInfo.endValue - tInfo.startValue) * calEasing(lifeRatio,tInfo.easeType));\n}\n@compute @workgroup_size(256,1,1)\nfn main( @builtin(global_invocation_id) global_id:vec3<u32> ) { let index:u32=(global_id.x); let age:f32=(params.time - particles[index].startTime); var lifeRatio:f32=(age/particles[index].life); if (lifeRatio >=1.0 ) { let uuid:f32=(params.time + f32(index)); particles[index].startTime=params.time; particles[index].life=randomRange( params.minLife,params.maxLife,uuid ); infoPosition[index].infoX.startValue=randomRange( params.minStartX + params.currentPositionX,params.maxStartX + params.currentPositionX,(uuid + 1.0) ); infoPosition[index].infoX.endValue=randomRange( params.minEndX + params.currentPositionX,params.maxEndX + params.currentPositionX,(uuid + 2.0) ); infoPosition[index].infoX.easeType=params.easeX; infoPosition[index].infoX.birthCenterValue=params.currentPositionX; infoPosition[index].infoY.startValue=randomRange( params.minStartY +params.currentPositionY,params.maxStartY+params.currentPositionY,(uuid + 3.0) ); infoPosition[index].infoY.endValue=randomRange( params.minEndY+params.currentPositionY,params.maxEndY+params.currentPositionY,(uuid + 4.0) ); infoPosition[index].infoY.easeType=params.easeY; infoPosition[index].infoY.birthCenterValue=params.currentPositionY; infoPosition[index].infoZ.startValue=randomRange( params.minStartZ+params.currentPositionZ,params.maxStartZ+params.currentPositionZ,(uuid + 5.0) ); infoPosition[index].infoZ.endValue=randomRange( params.minEndZ+params.currentPositionZ,params.maxEndZ+params.currentPositionZ,(uuid + 6.0) ); infoPosition[index].infoZ.easeType=params.easeZ; infoPosition[index].infoZ.birthCenterValue=params.currentPositionZ; infoAlpha[index].startValue=randomRange( params.minStartAlpha,params.maxStartAlpha,(uuid + 7.0) ); infoAlpha[index].endValue=randomRange( params.minEndAlpha,params.maxEndAlpha,(uuid + 8.0) ); infoAlpha[index].easeType=params.easeAlpha; infoScale[index].startValue=randomRange( params.minStartScale,params.maxStartScale,(uuid + 9.0) ); infoScale[index].endValue=randomRange( params.minEndScale,params.maxEndScale,(uuid + 10.0)); infoScale[index].easeType=params.easeScale; infoRotation[index].infoX.startValue=randomRange( params.minStartRotationX,params.maxStartRotationX,(uuid + 11.0)); infoRotation[index].infoX.endValue=randomRange( params.minEndRotationX,params.maxEndRotationX,(uuid + 12.0)); infoRotation[index].infoX.easeType=params.easeRotationX; infoRotation[index].infoY.startValue=randomRange( params.minStartRotationY,params.maxStartRotationY,(uuid + 13.0)); infoRotation[index].infoY.endValue=randomRange( params.minEndRotationY,params.maxEndRotationY,(uuid + 14.0)); infoRotation[index].infoY.easeType=params.easeRotationY; infoRotation[index].infoZ.startValue=randomRange( params.minStartRotationZ,params.maxStartRotationZ,(uuid + 15.0)); infoRotation[index].infoZ.endValue=randomRange( params.minEndRotationZ,params.maxEndRotationZ,(uuid + 16.0)); infoRotation[index].infoZ.easeType=params.easeRotationZ; lifeRatio=0.0; } var targetInfo:Info; let targetParticle=particles[index]; targetInfo=infoPosition[index].infoX; particles[index].valuePosition.x=compute_value(targetInfo,lifeRatio); targetInfo=infoPosition[index].infoY; particles[index].valuePosition.y=compute_value(targetInfo,lifeRatio); targetInfo=infoPosition[index].infoZ; particles[index].valuePosition.z=compute_value(targetInfo,lifeRatio); targetInfo=infoAlpha[index]; particles[index].valueAlpha=compute_value(targetInfo,lifeRatio); targetInfo=infoScale[index]; particles[index].valueScale=compute_value(targetInfo,lifeRatio); targetInfo=infoRotation[index].infoX; particles[index].valueRotation.x=compute_value(targetInfo,lifeRatio) * PI/180.0; targetInfo=infoRotation[index].infoY; particles[index].valueRotation.y=compute_value(targetInfo,lifeRatio) * PI/180.0; targetInfo=infoRotation[index].infoZ; particles[index].valueRotation.z=compute_value(targetInfo,lifeRatio) * PI/180.0;\n}\n"},W=i.resourceManager.createGPUShaderModule("PARTICLE_EMITTER_MODULE",$);const q=[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}],ye=[{binding:0,resource:{buffer:this.#Bf,offset:0,size:this.#Ef.byteLength}}];H.forEach((i,m)=>{q.push({binding:m+1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}),ye.push({binding:m+1,resource:{buffer:this.#If[m],offset:0,size:i.byteLength}})});const Ge=i.gpuDevice.createBindGroupLayout({entries:q}),Ke=i.gpuDevice.createPipelineLayout({bindGroupLayouts:[Ge]});this.#Df=i.gpuDevice.createBindGroup({label:"PARTICLE_EMITTER_BIND_GROUP",layout:Ge,entries:ye}),this.#Pn=i.gpuDevice.createComputePipeline({label:"PARTICLE_EMITTER_PIPELINE",layout:Ke,compute:{module:W,entryPoint:"main"}})}#Af(i){const m=this.localToWorld(this.x,this.y,this.z);this.#Ef.set([i,...m,this.#Vh,this.#zh,this.#Hh,this.#Wh,this.#qh,this.#Jh,this.#yf,this.#$h,this.#jh,this.#Yh,this.#Qh,this.#Sf,this.#Kh,this.#Xh,this.#Zh,this.#ef,this.#Tf,this.#tf,this.#nf,this.#rf,this.#if,this.#Mf,this.#af,this.#sf,this.#of,this.#uf,this.#wf,this.#lf,this.#ff,this.#pf,this.#_f,this.#Cf,this.#cf,this.#df,this.#gf,this.#vf,this.#Rf,this.#hf,this.#mf,this.#xf,this.#bf,this.#Pf],0);const{gpuDevice:g}=this.redGPUContext;g.queue.writeBuffer(this.#Bf,0,this.#Ef);const _=g.createCommandEncoder({label:"PARTICLE_EMITTER_COMPUTE_COMMAND_ENCODER"}),b=_.beginComputePass({label:"PARTICLE_EMITTER_COMPUTE_PASS"});b.setPipeline(this.#Pn),b.setBindGroup(0,this.#Df),b.dispatchWorkgroups(Math.ceil(this.#Lf/256)),b.end(),g.queue.submit([_.finish()])}}Object.defineProperty(ParticleEmitter.prototype,"meshType",{value:Qn.PARTICLE,writable:!1}),Xn.defineByPreset(ParticleEmitter,[Xn.PRESET_BOOLEAN.USE_BILLBOARD]),Xn.definePositiveNumber(ParticleEmitter,[]),Object.freeze(ParticleEmitter);const Fi=mixInMesh2D(Mesh);class Sprite2D extends Fi{#pt=1;#gt=1;constructor(i,m){super(i,new Plane(i,1,1,1,1,1,!0),m),this.primitiveState.cullMode=xr.FRONT}get width(){return this.#pt}set width(i){validatePositiveNumberRange(i),this.#pt=i,this.dirtyTransform=!0}get height(){return this.#gt}set height(i){validatePositiveNumberRange(i),this.#gt=i,this.dirtyTransform=!0}setSize(i,m){this.width=i,this.height=void 0!==m?m:i}}Object.freeze(Sprite2D);var Ni="#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include getBillboardMatrix;\nstruct MatrixList{ modelMatrix:mat4x4<f32>, normalModelMatrix:mat4x4<f32>,\n}\nstruct VertexUniforms { matrixList:MatrixList, pickingId:u32, useBillboardPerspective:u32, useBillboard:u32, billboardFixedScale:f32, combinedOpacity:f32,\n};\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\nstruct InputData { @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>,\n};\nstruct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\nstruct OutputShadowData { @builtin(position) position:vec4<f32>,\n};\n@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; let u_resolution=systemUniforms.resolution; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_normalModelMatrix=vertexUniforms.matrixList.normalModelMatrix; let u_useBillboardPerspective=vertexUniforms.useBillboardPerspective; let u_useBillboard=vertexUniforms.useBillboard; let u_billboardFixedScale=vertexUniforms.billboardFixedScale; let input_position=inputData.position; let input_vertexNormal=inputData.vertexNormal; let input_positionVec4=vec4<f32>(input_position,1.0); let input_vertexNormalVec4=vec4<f32>(input_vertexNormal,1.0); let input_uv=inputData.uv; var position:vec4<f32>; var normalPosition:vec4<f32>; #redgpu_if useBillboard {  let projectionModelMatrix=u_projectionMatrix * u_modelMatrix; let billboardMatrix=getBillboardMatrix(u_cameraMatrix,u_modelMatrix); let billboardNormalMatrix=getBillboardMatrix(u_cameraMatrix,u_normalModelMatrix); if (u_useBillboardPerspective==1) { position=billboardMatrix * input_positionVec4; normalPosition=billboardNormalMatrix * input_vertexNormalVec4; } else { position=billboardMatrix * input_positionVec4; normalPosition=billboardNormalMatrix * input_vertexNormalVec4; } output.position=u_projectionMatrix * position; if (u_useBillboardPerspective !=1) { var temp=output.position/output.position.w; let aspectRatio=u_resolution.x/u_resolution.y; let scaleX=clamp((projectionModelMatrix)[1][1],-1.0,1.0)/aspectRatio; let scaleY=clamp((projectionModelMatrix)[1][1],-1.0,1.0); output.position=vec4<f32>( temp.xy + input_position.xy * vec2<f32>(scaleX * u_billboardFixedScale,scaleY * u_billboardFixedScale), temp.zw ); } } #redgpu_else { position=u_cameraMatrix * u_modelMatrix * input_positionVec4; normalPosition=u_cameraMatrix * u_normalModelMatrix * input_vertexNormalVec4; output.position=u_projectionMatrix * position; } #redgpu_endIf output.vertexPosition=position.xyz; output.vertexNormal=normalPosition.xyz; output.uv=input_uv; output.combinedOpacity=vertexUniforms.combinedOpacity; return output;\n}\n@vertex\nfn drawDirectionalShadowDepth(inputData:InputData) -> OutputShadowData { var output:OutputShadowData; let u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix; let u_directionalLightProjectionMatrix=systemUniforms.directionalLightProjectionMatrix; let u_directionalLightViewMatrix=systemUniforms.directionalLightViewMatrix; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_useBillboardPerspective=vertexUniforms.useBillboardPerspective; let u_useBillboard=vertexUniforms.useBillboard; let u_billboardFixedScale=vertexUniforms.billboardFixedScale; let input_position=inputData.position; let input_positionVec4=vec4<f32>(input_position,1.0); var position:vec4<f32>; output.position=u_directionalLightProjectionViewMatrix * u_modelMatrix * input_positionVec4; return output;\n}\n@vertex\nfn picking(inputData:InputData) -> OutputData { var output:OutputData; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_cameraMatrix=systemUniforms.camera.cameraMatrix; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_useBillboardPerspective=vertexUniforms.useBillboardPerspective; let u_useBillboard=vertexUniforms.useBillboard; let u_billboardFixedScale=vertexUniforms.billboardFixedScale; let input_position=inputData.position; let input_positionVec4=vec4<f32>(input_position,1.0); let u_resolution=systemUniforms.resolution; var position:vec4<f32>; if (u_useBillboard==1) { let projectionModelMatrix=u_projectionMatrix * u_modelMatrix; let billboardMatrix=getBillboardMatrix(u_cameraMatrix,u_modelMatrix); if (u_useBillboardPerspective==1) { position=billboardMatrix * input_positionVec4; } else { position=billboardMatrix * input_positionVec4; } output.position=u_projectionMatrix * position; if (u_useBillboardPerspective !=1) { var temp=output.position/output.position.w; let aspectRatio=u_resolution.x/u_resolution.y; let scaleX=clamp((projectionModelMatrix)[1][1],-1.0,1.0)/aspectRatio; let scaleY=clamp((projectionModelMatrix)[1][1],-1.0,1.0); output.position=vec4<f32>( temp.xy + input_position.xy * vec2<f32>(scaleX * u_billboardFixedScale,scaleY * u_billboardFixedScale), temp.zw ); } } else { position=u_cameraMatrix * u_modelMatrix * input_positionVec4; output.position=u_projectionMatrix * position; } output.pickingId=unpack4x8unorm(vertexUniforms.pickingId); return output;\n}\n";const Vi=parseWGSL(Ni),zi=Vi.uniforms.vertexUniforms;class Sprite3D extends Mesh{constructor(i,m,g){super(i),this._geometry=g||new Plane(i),this._material=m,this._material.transparent=!0,this.dirtyPipeline=!0,this.dirtyTransform=!0,this.primitiveState.cullMode=xr.NONE}createCustomMeshVertexShaderModule=()=>this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_SPRITE_3D",Vi,zi,Ni)}Xn.defineByPreset(Sprite3D,[[Xn.PRESET_BOOLEAN.USE_BILLBOARD_PERSPECTIVE,!0],[Xn.PRESET_BOOLEAN.USE_BILLBOARD,!0],[Xn.PRESET_POSITIVE_NUMBER.BILLBOARD_FIXED_SCALE,.1,.1]]),Object.freeze(Sprite3D);class ASpriteSheet extends Mesh{#Of=0;#kf=0;#Gf=0;#Ff=!0;#Nf=!0;#Vf;#zf;#Hf="play";constructor(i,m,g){super(i),this.#zf=g,this._material=new BitmapMaterial(i),this._material.transparent=!0,this.dirtyPipeline=!0,this.dirtyTransform=!0,this.spriteSheetInfo=m,this._material.diffuseTextureSampler=new Sampler(i),this._material.diffuseTextureSampler.addressModeU=vt.REPEAT,this._material.diffuseTextureSampler.addressModeV=vt.REPEAT}get state(){return this.#Hf}get loop(){return this.#Nf}set loop(i){this.#Nf=i}get frameRate(){return this.#Of}set frameRate(i){i<0&&(i=0),0===this.#Of&&i&&(this.#kf=0),this.#Of=i,this.#Gf=1e3/this.#Of}get geometry(){return this._geometry}set geometry(i){consoleAndThrowError("ASpriteSheet can not change geometry")}get material(){return this._material}set material(i){consoleAndThrowError("ASpriteSheet can not change material")}get spriteSheetInfo(){return this.#Vf}set spriteSheetInfo(i){this.#Vf=i,this.frameRate=i.frameRate,this.segmentW=i.segmentW,this.segmentH=i.segmentH,this.totalFrame=i.totalFrame,this.currentIndex=i.startIndex,this.#Nf=!0,this.#kf=0,this._material.diffuseTexture=i.texture}play(){this.#Ff=!0,this.#Hf="play",this.#kf=0}pause(){this.#Ff=!1,this.#Hf="pause"}stop(){this.#Ff=!1,this.currentIndex=0,this.#Hf="stop"}render(i){const{diffuseTexture:m}=this._material;this.#zf(m,this.segmentW,this.segmentH);const{timestamp:g}=i;if(this.#kf||(this.#kf=this.#Gf+g),this.#Ff&&this.#kf<g&&this.#Of){const i=Math.floor((g-this.#kf)/this.#Gf),m=(Number.isFinite(i)?i:0)||1;this.#kf=this.#Gf+g,this.currentIndex+=m,this.currentIndex>=this.totalFrame&&(this.loop?(this.#Ff=!0,this.currentIndex=0):(this.#Ff=!1,this.currentIndex=this.totalFrame-1))}super.render(i)}}Xn.definePositiveNumber(ASpriteSheet,[["segmentW",5],["segmentH",3],["totalFrame",15],["currentIndex",0]]),Object.freeze(ASpriteSheet);var Hi=Object.freeze({__proto__:null,ASpriteSheet:ASpriteSheet}),$i="#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include getBillboardMatrix;\nstruct MatrixList{ modelMatrix:mat4x4<f32>, normalModelMatrix:mat4x4<f32>,\n}\nstruct VertexUniforms { matrixList:MatrixList, pickingId:u32, segmentW:f32, segmentH:f32, totalFrame:f32, currentIndex:f32, combinedOpacity:f32,\n};\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\nstruct InputData { @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>,\n};\nstruct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\n@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_normalModelMatrix=vertexUniforms.matrixList.normalModelMatrix; let input_position=inputData.position; let input_vertexNormal=inputData.vertexNormal; let input_uv=inputData.uv; var position:vec4<f32>; var normalPosition:vec4<f32>; position=u_cameraMatrix * u_modelMatrix * vec4<f32>(input_position,1.0); normalPosition=u_cameraMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0); output.position=u_projectionMatrix * position; output.vertexPosition=position.xyz; output.vertexNormal=normalPosition.xyz; output.combinedOpacity=vertexUniforms.combinedOpacity; let uv=vec2<f32>( input_uv.x * 1/vertexUniforms.segmentW + ((vertexUniforms.currentIndex % vertexUniforms.segmentW)/vertexUniforms.segmentW), input_uv.y * 1/vertexUniforms.segmentH - (floor(vertexUniforms.currentIndex/vertexUniforms.segmentH)/vertexUniforms.segmentH) ); output.uv=uv; return output;\n}\n@vertex\nfn picking(inputData:InputData) -> OutputData { var output:OutputData; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_normalModelMatrix=vertexUniforms.matrixList.normalModelMatrix; let input_position=inputData.position; let input_vertexNormal=inputData.vertexNormal; let input_uv=inputData.uv; var position:vec4<f32>; var normalPosition:vec4<f32>; position=u_cameraMatrix * u_modelMatrix * vec4<f32>(input_position,1.0); normalPosition=u_cameraMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0); output.position=u_projectionMatrix * position; output.pickingId=unpack4x8unorm(vertexUniforms.pickingId); return output;\n}\n";const Ki=parseWGSL($i),Wi=Ki.uniforms.vertexUniforms,ji=mixInMesh2D(ASpriteSheet);class SpriteSheet2D extends ji{#pt=1;#gt=1;constructor(i,m){super(i,m,(i,m,g)=>{if(i){const{gpuTexture:_}=i,b=_?.width/m,y=_?.height/g;b===this.#pt&&y===this.#gt||(this.#pt=_?.width/m,this.#gt=_?.height/g,this.dirtyTransform=!0)}else this.#pt=1,this.#gt=1}),this._geometry=new Plane(i,1,1,1,1,1,!0),this.primitiveState.cullMode=xr.FRONT}get width(){return this.#pt}get height(){return this.#gt}get geometry(){return this._geometry}set geometry(i){consoleAndThrowError("SpriteSheet2D can not change geometry")}get material(){return this._material}set material(i){consoleAndThrowError("SpriteSheet2D can not change material")}createCustomMeshVertexShaderModule=()=>this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_SPRITE_SHEET_2D",Ki,Wi,$i)}Object.freeze(SpriteSheet2D);var Xi="#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include getBillboardMatrix;\nstruct MatrixList{ modelMatrix:mat4x4<f32>, normalModelMatrix:mat4x4<f32>,\n}\nstruct VertexUniforms { matrixList:MatrixList, pickingId:u32, useBillboardPerspective:u32, useBillboard:u32, segmentW:f32, segmentH:f32, totalFrame:f32, currentIndex:f32, billboardFixedScale:f32, _renderRatioX:f32, _renderRatioY:f32, combinedOpacity:f32,\n};\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\nstruct InputData { @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>,\n};\nstruct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\nstruct OutputShadowData { @builtin(position) position:vec4<f32>,\n};\n@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; let u_resolution=systemUniforms.resolution; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_normalModelMatrix=vertexUniforms.matrixList.normalModelMatrix; let u_useBillboardPerspective=vertexUniforms.useBillboardPerspective; let u_useBillboard=vertexUniforms.useBillboard; let u_billboardFixedScale=vertexUniforms.billboardFixedScale; let u_renderRatioX=vertexUniforms._renderRatioX; let u_renderRatioY=vertexUniforms._renderRatioY; var ratioScaleMatrix:mat4x4<f32>=mat4x4<f32>( u_renderRatioX,0,0,0, 0,u_renderRatioY,0,0, 0,0,1,0, 0,0,0,1 ); let input_position=inputData.position; let input_vertexNormal=inputData.vertexNormal; let input_uv=inputData.uv; var position:vec4<f32>; var normalPosition:vec4<f32>; #redgpu_if useBillboard { if (u_useBillboardPerspective==1) { position=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * ratioScaleMatrix * vec4<f32>(input_position,1.0); normalPosition=getBillboardMatrix(u_cameraMatrix,u_normalModelMatrix) * ratioScaleMatrix * vec4<f32>(input_vertexNormal,1.0); } else { position=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * ratioScaleMatrix * vec4<f32>(input_position,1.0); normalPosition=getBillboardMatrix(u_cameraMatrix,u_normalModelMatrix) * ratioScaleMatrix * vec4<f32>(input_vertexNormal,1.0); } output.position=u_projectionMatrix * position; if (u_useBillboardPerspective !=1) { var temp=output.position/output.position.w; let aspectRatio=u_resolution.x/u_resolution.y; let scaleX=clamp((u_projectionMatrix)[1][1],-1.0,1.0)/aspectRatio * u_renderRatioX; let scaleY=clamp((u_projectionMatrix)[1][1],-1.0,1.0) * u_renderRatioY; output.position=vec4<f32>( temp.xy + input_position.xy * vec2<f32>(scaleX * u_billboardFixedScale,scaleY * u_billboardFixedScale), temp.zw ); } } #redgpu_else { position=u_cameraMatrix * u_modelMatrix * ratioScaleMatrix * vec4<f32>(input_position,1.0); normalPosition=u_cameraMatrix * u_normalModelMatrix * ratioScaleMatrix * vec4<f32>(input_vertexNormal,1.0); output.position=u_projectionMatrix * position; } #redgpu_endIf output.vertexPosition=position.xyz; output.vertexNormal=normalPosition.xyz; output.combinedOpacity=vertexUniforms.combinedOpacity; let uv=vec2<f32>( input_uv.x * 1/vertexUniforms.segmentW + ((vertexUniforms.currentIndex % vertexUniforms.segmentW)/vertexUniforms.segmentW), input_uv.y * 1/vertexUniforms.segmentH - (floor(vertexUniforms.currentIndex/vertexUniforms.segmentH)/vertexUniforms.segmentH) ); output.uv=uv; return output;\n}\n@vertex\nfn drawDirectionalShadowDepth(inputData:InputData) -> OutputShadowData { var output:OutputShadowData; return output;\n}\n@vertex\nfn picking(inputData:InputData) -> OutputData { var output:OutputData; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_cameraMatrix=systemUniforms.camera.cameraMatrix; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_useBillboardPerspective=vertexUniforms.useBillboardPerspective; let u_useBillboard=vertexUniforms.useBillboard; let u_billboardFixedScale=vertexUniforms.billboardFixedScale; let u_renderRatioX=vertexUniforms._renderRatioX; let u_renderRatioY=vertexUniforms._renderRatioY; var ratioScaleMatrix:mat4x4<f32>=mat4x4<f32>( u_renderRatioX,0,0,0, 0,u_renderRatioY,0,0, 0,0,1,0, 0,0,0,1 ); let input_position=inputData.position; let u_resolution=systemUniforms.resolution; var position:vec4<f32>; if (u_useBillboard==1) { if (u_useBillboardPerspective==1) { position=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * ratioScaleMatrix * vec4<f32>(input_position,1.0); } else { position=getBillboardMatrix(u_cameraMatrix,u_modelMatrix) * ratioScaleMatrix * vec4<f32>(input_position,1.0); } output.position=u_projectionMatrix * position; if (u_useBillboardPerspective !=1) { var temp=output.position/output.position.w; let aspectRatio=u_resolution.x/u_resolution.y; let scaleX=clamp((u_projectionMatrix)[1][1],-1.0,1.0)/aspectRatio * u_renderRatioX; let scaleY=clamp((u_projectionMatrix)[1][1],-1.0,1.0) * u_renderRatioY; output.position=vec4<f32>( temp.xy + input_position.xy * vec2<f32>(scaleX * u_billboardFixedScale,scaleY * u_billboardFixedScale), temp.zw ); } } else { position=u_cameraMatrix * u_modelMatrix * ratioScaleMatrix * vec4<f32>(input_position,1.0); output.position=u_projectionMatrix * position; } output.pickingId=unpack4x8unorm(vertexUniforms.pickingId); return output;\n}\n";const qi=parseWGSL(Xi),Yi=qi.uniforms.vertexUniforms;class SpriteSheet3D extends ASpriteSheet{#Eo=1;#Do=1;constructor(i,m){super(i,m,(i,m,g)=>{if(i){const{gpuTexture:_}=i,b=_?.width/m,y=_?.height/g;b===this.#Eo&&y===this.#Do||(this.#Eo=_?.width/m,this.#Do=_?.height/g,this.#Do>this.#Eo?(this._renderRatioX=1,this._renderRatioY=this.#Do/this.#Eo):(this._renderRatioX=this.#Eo/this.#Do,this._renderRatioY=1),this.dirtyTransform=!0)}else this.#Eo=1,this.#Do=1}),this._geometry=new Plane(i)}get geometry(){return this._geometry}set geometry(i){consoleAndThrowError("SpriteSheet3D can not change geometry")}get material(){return this._material}set material(i){consoleAndThrowError("SpriteSheet3D can not change material")}createCustomMeshVertexShaderModule=()=>this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_SPRITE_SHEET_3D",qi,Yi,Xi)}Xn.definePositiveNumber(SpriteSheet3D,[["_renderRatioX",1],["_renderRatioY",1]]),Xn.defineByPreset(SpriteSheet3D,[[Xn.PRESET_BOOLEAN.USE_BILLBOARD_PERSPECTIVE,!0],[Xn.PRESET_BOOLEAN.USE_BILLBOARD,!0],[Xn.PRESET_POSITIVE_NUMBER.BILLBOARD_FIXED_SCALE,.1,.1]]),Object.freeze(SpriteSheet3D);class SpriteSheetInfo{#$f=0;#Kf=0;#Wf=0;#jf=0;#Of=0;#Nf=!0;#Xf;constructor(i,m,g,_,b,y,T=!0,w=60){validateRedGPUContext(i),validateUintRange(g),validateUintRange(_),validateUintRange(b),validateUintRange(y),validateUintRange(w),this.#$f=g,this.#Kf=_,this.#Wf=b,this.#jf=y,this.#Xf=new BitmapTexture(i,m),this.#Nf=T,this.#Of=w}get segmentW(){return this.#$f}get segmentH(){return this.#Kf}get totalFrame(){return this.#Wf}get startIndex(){return this.#jf}get texture(){return this.#Xf}get frameRate(){return this.#Of}get loop(){return this.#Nf}}Object.freeze(SpriteSheetInfo);const Zi=parseWGSL("#redgpu_include drawPicking;\n#redgpu_include FragmentOutput;\n#redgpu_include calculateMotionVector;\nstruct Uniforms { opacity:f32\n};\nstruct InputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexColor:vec4<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n}\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\n@fragment\nfn main(inputData:InputData) -> FragmentOutput { var output:FragmentOutput; output.color=inputData.vertexColor; output.gBufferMotionVector=vec4<f32>(calculateMotionVector(inputData.currentClipPos,inputData.prevClipPos),0.0,1.0 ); return output;\n}\n");class LineMaterial extends ABaseMaterial{constructor(i,m){super(i,"LINE_MATERIAL",Zi,2),m&&(this.name=m),this.initGPURenderInfos()}}Object.freeze(LineMaterial);class LinePoint{position;colorRGBA;constructor(i=0,m=0,g=0,_){this.position=[i,m,g],this.colorRGBA=_}}const getPointsOnBezierCurveWithSplitting=(i,m,g,_)=>{let b=_||[];if(((i,m)=>{let g=i[m].position,_=i[m+1].position,b=i[m+2].position,y=i[m+3].position,T=3*_[0]-2*g[0]-y[0],w=3*_[1]-2*g[1]-y[1],P=3*b[0]-2*y[0]-g[0],H=3*b[1]-2*y[1]-g[1];return T*=T,w*=w,P*=P,H*=H,T<P&&(T=P),w<H&&(w=H),T+w})(i,m)<g)b.push(i[m],i[m+3]);else{let _=.5,y=i[m],T=i[m+1],w=i[m+2],P=i[m+3],H=lerp$1(create$1(),y.position,T.position,_),$=lerp$1(create$1(),T.position,w.position,_),W=lerp$1(create$1(),w.position,P.position,_),q=lerp$1(create$1(),H,$,_),ye=lerp$1(create$1(),$,W,_),Ge=lerp$1(create$1(),q,ye,_);Ge=new LinePoint(Ge[0],Ge[1],Ge[2],y.colorRGBA),H=new LinePoint(H[0],H[1],H[2],H.colorRGBA),W=new LinePoint(W[0],W[1],W[2],W.colorRGBA),q=new LinePoint(q[0],q[1],q[2],q.colorRGBA),ye=new LinePoint(ye[0],ye[1],ye[2],ye.colorRGBA),getPointsOnBezierCurveWithSplitting([y,H,q,Ge],0,g,b),getPointsOnBezierCurveWithSplitting([Ge,ye,W,P],0,g,b)}return b};class LinePointWithInOut{inLinePoint;linePoint;outLinePoint;constructor(i=0,m=0,g=0,_=0,b=0,y=0,T=0,w=0,P=0,H,$){let W=[...convertHexToRgb(H,!0)];W=[W[0]/255,W[1]/255,W[2]/255,$],this.inLinePoint=new LinePoint(_,b,y,W),this.linePoint=new LinePoint(i,m,g,W),this.outLinePoint=new LinePoint(T,w,P,W)}}const lineVec2DistanceToSegmentSq=function(i,m,g){i=[i[0],i[1]],m=[m[0],m[1]],g=[g[0],g[1]];let _=sqrDist(m,g);if(0===_)return sqrDist(i,m);let b=((i[0]-m[0])*(g[0]-m[0])+(i[1]-m[1])*(g[1]-m[1]))/_;return b=Math.max(0,Math.min(1,b)),sqrDist(i,function(i,m,g,_){var b=m[0],y=m[1];return i[0]=b+_*(g[0]-b),i[1]=y+_*(g[1]-y),i}([0,0],m,g,b))},lineSimplifyPoints=(i,m,g,_,b)=>{let y=b||[],T=i[m],w=i[g-1],P=0,H=1,$=m+1;for(;$<g-1;++$){let m=lineVec2DistanceToSegmentSq(i[$].position,T.position,w.position);m>P&&(P=m,H=$)}return Math.sqrt(P)>_?(lineSimplifyPoints(i,m,H+1,_,y),lineSimplifyPoints(i,H,g,_,y)):y.push(T,w),y},Ji={LINEAR:"linear",CATMULL_ROM:"catmullRom",BEZIER:"bezier"};Object.freeze(Ji);var Qi="#redgpu_include SYSTEM_UNIFORM;\nstruct MatrixList{ modelMatrix:mat4x4<f32>, prevModelMatrix:mat4x4<f32>, normalModelMatrix:mat4x4<f32>,\n}\nstruct VertexUniforms { matrixList:MatrixList, pickingId:u32,\n};\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\nstruct InputData { @location(0) position:vec3<f32>, @location(1) vertexColor:vec4<f32>,\n};\nstruct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexColor:vec4<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\nstruct OutputShadowData { @builtin(position) position:vec4<f32>,\n};\n@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_noneJitterProjectionCameraMatrix=systemUniforms.noneJitterProjectionCameraMatrix; let u_prevNoneJitterProjectionCameraMatrix=systemUniforms.prevNoneJitterProjectionCameraMatrix; let u_matrixList=vertexUniforms.matrixList; let u_modelMatrix=u_matrixList.modelMatrix; let u_prevModelMatrix=u_matrixList.prevModelMatrix; let input_position=inputData.position; let input_vertexColor=inputData.vertexColor; let input_position_vec4=vec4<f32>(input_position,1.0); var position:vec4<f32>; position=u_modelMatrix * input_position_vec4; output.position=u_projectionCameraMatrix * position; output.vertexPosition=position.xyz; output.vertexColor=input_vertexColor; { output.currentClipPos=u_noneJitterProjectionCameraMatrix * position; output.prevClipPos=u_prevNoneJitterProjectionCameraMatrix * u_prevModelMatrix * input_position_vec4; } return output;\n}\n@vertex\nfn picking(inputData:InputData) -> OutputData { var output:OutputData; return output;\n}\n";const ea=parseWGSL(Qi),ta=ea.uniforms.vertexUniforms;class Line3D extends Mesh{baseColor;#qf;#Yf=1;#Zf=.01;#bh=.01;#Jf=[];#Qf=[];#ed;constructor(i,m=Ji.LINEAR,g="#fff"){super(i),this.primitiveState.topology=Zn.LINE_STRIP,this.baseColor=g,this.#qf=m,this._geometry=new Geometry(i,new VertexBuffer(i,this.#Jf,new VertexInterleavedStruct({vertexPosition:VertexInterleaveType.float32x3,vertexColor:VertexInterleaveType.float32x4}))),this._material=new LineMaterial(i)}get originalPoints(){return this.#Qf}get type(){return this.#qf}set type(i){this.#qf=i,this.#td()}get interleaveData(){return this.#Jf}get tension(){return this.#Yf}set tension(i){validatePositiveNumberRange(i),this.#Yf=i,this.#td()}get tolerance(){return this.#Zf}set tolerance(i){validatePositiveNumberRange(i),this.#Zf=i,this.#td()}get distance(){return this.#bh}set distance(i){validatePositiveNumberRange(i),this.#bh=i,this.#td()}get numPoints(){return this.#Qf.length}get geometry(){return this._geometry}set geometry(i){consoleAndThrowError("Line3D can not change geometry")}get material(){return this._material}set material(i){consoleAndThrowError("Line3D can not change material")}createCustomMeshVertexShaderModule=()=>this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_LINE_3D",ea,ta,Qi);addPoint(i=0,m=0,g=0,_=this.baseColor,b=1,y=0,T=0,w=0,P=0,H=0,$=0){this.#Qf.push(new LinePointWithInOut(i,m,g,y,T,w,P,H,$,_,b)),this.#td()}addPointAt(i,m=0,g=0,_=0,b=this.baseColor,y=1,T=0,w=0,P=0,H=0,$=0,W=0){this.#Qf.length<i&&(i=this.#Qf.length),null!=i?this.#Qf.splice(i,0,new LinePointWithInOut(m,g,_,T,w,P,H,$,W,b,y)):this.#Qf.push(new LinePointWithInOut(m,g,_,T,w,P,H,$,W,b,y)),this.#td()}removePointAt(i){validateUintRange(i),this.#Qf[i]?this.#Qf.splice(i,1):consoleAndThrowError("removeChildAt","index 해당인덱스에 위치한 포인트가 없음.","입력값:"+i),this.#td()}removeAllPoint(){this.#Qf.length=0,this.#td()}#$t(){if(this._geometry,this.#Qf.length){const{redGPUContext:i}=this;this._geometry=new Geometry(i,new VertexBuffer(i,this.#Jf,new VertexInterleavedStruct({vertexPosition:VertexInterleaveType.float32x3,vertexColor:VertexInterleaveType.float32x4})))}this.dirtyPipeline=!0}#td(){const i=this.#Qf,m=this.#Yf,g=this.#Zf,_=this.#bh;let b,y,T,w;switch(this.#Jf.length=0,this.#qf){case Ji.CATMULL_ROM:case Ji.BEZIER:if(i.length>1)for(this.#ed=(i=>{let m,g=[],_=0,b=0;const y=i.length;for(;_<y;_++){m=i[_];const{inLinePoint:y,linePoint:T,outLinePoint:w}=m;0===b?(g[b++]=T,g[b++]=w):(g[b++]=y,g[b++]=T,i[_+1]&&(g[b++]=w))}return g})(Ji.CATMULL_ROM===this.#qf?((i,m=1)=>{const g=i.length,_=g-2;for(let b=0;b<g-1;b++){const g=b?i[b-1].linePoint.position:i[b].linePoint.position,y=i[b].linePoint.position,T=i[b+1].linePoint.position,w=b===_?T:i[b+2].linePoint.position;i[b].outLinePoint.position=[y[0]+(T[0]-g[0])/6*m,y[1]+(T[1]-g[1])/6*m,y[2]+(T[2]-g[2])/6*m],i[b+1].inLinePoint.position=[T[0]-(w[0]-y[0])/6*m,T[1]-(w[1]-y[1])/6*m,T[2]-(w[2]-y[2])/6*m]}return i})(i,m):i),b=((i,m)=>{let g=[],_=(i.length-1)/3;_=Math.floor(_);let b,y=0;for(;y<_;++y)b=3*y,getPointsOnBezierCurveWithSplitting(i,b,m,g);return g})(this.#ed,g),b=lineSimplifyPoints(b,0,b.length,_),y=0,T=b.length;y<T;y++)w=b[y],this.#Jf.push(...w.position,...w.colorRGBA);else this.#Jf.push(0,0,0,1,1,1,1);break;default:for(y=0,T=i.length;y<T;y++){const{linePoint:m}=i[y],g=m.colorRGBA;this.interleaveData.push(...m.position,...g)}}this.#$t()}}Object.freeze(Line3D);const na=parseWGSL(Qi),ra=na.uniforms.vertexUniforms;var ia=Object.freeze({__proto__:null,ATextField:ATextField,TextFieldMaterial:TextFieldMaterial}),aa="#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include getBillboardMatrix;\nstruct MatrixList{ modelMatrix:mat4x4<f32>, normalModelMatrix:mat4x4<f32>,\n}\nstruct VertexUniforms { pickingId:u32, matrixList:MatrixList, combinedOpacity:f32,\n};\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\nstruct InputData { @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>,\n};\nstruct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(11) combinedOpacity:f32, @location(13) shadowPos:vec3<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\nstruct OutputShadowData { @builtin(position) position:vec4<f32>,\n};\n@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_normalModelMatrix=vertexUniforms.matrixList.normalModelMatrix; let input_position=inputData.position; let input_vertexNormal=inputData.vertexNormal; let input_uv=inputData.uv; var position:vec4<f32>; var normalPosition:vec4<f32>; position=u_cameraMatrix * u_modelMatrix * vec4<f32>(input_position,1.0); normalPosition=u_cameraMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0); output.position=u_projectionMatrix * position; output.vertexPosition=position.xyz; output.vertexNormal=normalPosition.xyz; output.uv=input_uv; output.combinedOpacity=vertexUniforms.combinedOpacity; return output;\n}\n@vertex\nfn picking(inputData:InputData) -> OutputData { var output:OutputData; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_normalModelMatrix=vertexUniforms.matrixList.normalModelMatrix; let input_position=inputData.position; let input_vertexNormal=inputData.vertexNormal; let input_uv=inputData.uv; var position:vec4<f32>; var normalPosition:vec4<f32>; position=u_cameraMatrix * u_modelMatrix * vec4<f32>(input_position,1.0); normalPosition=u_cameraMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0); output.position=u_projectionMatrix * position; output.pickingId=unpack4x8unorm(vertexUniforms.pickingId); return output;\n}\n";const sa=parseWGSL(aa),oa=sa.uniforms.vertexUniforms,ua=mixInMesh2D(ATextField);class TextField2D extends ua{#pt=1;#gt=1;#nd=!0;constructor(i,m=!0){super(i,(i,m)=>{this.#pt===i&&this.#gt===m||(this.dirtyTransform=!0),this.#pt=i,this.#gt=m},!1),this._geometry=new Plane(i,1,1,1,1,1,!0),this.useSmoothing=m,this.primitiveState.cullMode=xr.FRONT,gt(this)}get useSmoothing(){return this.#nd}set useSmoothing(i){this.#nd=i,this.useSmoothing?(this._material.diffuseTextureSampler.minFilter=bt.LINEAR,this._material.diffuseTextureSampler.magFilter=bt.LINEAR,this._material.diffuseTextureSampler.mipmapFilter=yt.LINEAR):(this._material.diffuseTextureSampler.minFilter=bt.NEAREST,this._material.diffuseTextureSampler.magFilter=bt.NEAREST,this._material.diffuseTextureSampler.mipmapFilter=null)}get width(){return this.#pt}get height(){return this.#gt}get geometry(){return this._geometry}set geometry(i){console.error("TextField2D can not change geometry")}get material(){return this._material}set material(i){console.error("TextField2D can not change material")}createCustomMeshVertexShaderModule=()=>this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_TEXT_FIELD_2D",sa,oa,aa)}Object.freeze(TextField2D);const la=3.141592653589793,ca=6.283185307179586,ha=.225,fa=1.27323954,da=.405284735,ma=1.5707963267948966,pa=Math.PI/180;class InstancingMeshObject3D{modelMatrix=create$2();localMatrix=create$2();normalModelMatrix=create$2();#Mt=0;#Ct=0;#wt=0;#Ts=[0,0,0];#Ps=1;#Bs=1;#Is=1;#Es=[1,1,1];#pi=0;#gi=0;#xi=0;#Ds=[0,0,0];#rd=0;#id;#l;#Os=1;constructor(i,m,g){validateRedGPUContext(i),this.#l=i,this.#id=g,this.#rd=m,this.#ad()}get opacity(){return this.#Os}set opacity(i){validatePositiveNumberRange(i,0,1),this.#Os=i,this.#ad()}get x(){return this.#Mt}set x(i){this.#Mt=this.#Ts[0]=i,this.#ad()}get y(){return this.#wt}set y(i){this.#wt=this.#Ts[1]=i,this.#ad()}get z(){return this.#Ct}set z(i){this.#Ct=this.#Ts[2]=i,this.#ad()}get position(){return this.#Ts}set position(i){this.#Mt=this.#Ts[0]=i,this.#wt=this.#Ts[1]=i,this.#Ct=this.#Ts[2]=i,this.#ad()}get scaleX(){return this.#Ps}set scaleX(i){this.#Ps=this.#Es[0]=i,this.#ad()}get scaleY(){return this.#Bs}set scaleY(i){this.#Bs=this.#Es[1]=i,this.#ad()}get scaleZ(){return this.#Is}set scaleZ(i){this.#Is=this.#Es[2]=i,this.#ad()}get scale(){return this.#Ts}set scale(i){this.#Ps=this.#Es[0]=i,this.#Bs=this.#Es[1]=i,this.#Is=this.#Es[2]=i,this.#ad()}get rotationX(){return this.#pi}set rotationX(i){this.#pi=this.#Ds[0]=i,this.#ad()}get rotationY(){return this.#gi}set rotationY(i){this.#gi=this.#Ds[1]=i,this.#ad()}get rotationZ(){return this.#xi}set rotationZ(i){this.#xi=this.#Ds[2]=i,this.#ad()}get rotation(){return this.#Ds}set rotation(i){this.#pi=this.#Ds[0]=i,this.#gi=this.#Ds[1]=i,this.#xi=this.#Ds[2]=i,this.#ad()}setScale(i,m,g){m=m??i,g=g??i;const _=this.#Es;this.#Ps=_[0]=i,this.#Bs=_[1]=m,this.#Is=_[2]=g,this.#ad()}setPosition(i,m,g){m=m??i,g=g??i;const _=this.#Ts;this.#Mt=_[0]=i,this.#wt=_[1]=m,this.#Ct=_[2]=g,this.#ad()}setRotation(i,m,g){m=m??i,g=g??i;const _=this.#Ds;this.#pi=_[0]=i,this.#gi=_[1]=m,this.#xi=_[2]=g,this.#ad()}#ad(){let i,m,g,_,b,y,T,w,P,H,$,W,q,ye,Ge,Ke,je,Xe,Ye,Ze,Je,Qe,et,at,ht,ft,gt,xt,vt,bt,yt,St,Tt,Mt,wt,Ct,Rt,Pt;{const q=this.localMatrix;let je;H=1,$=0,W=0,ye=0,Ge=1,Ke=0,Xe=0,Ye=0,Ze=1,q[12]=this.#Mt,q[13]=this.#wt,q[14]=this.#Ct,q[15]=1,T=this.#pi*pa,w=this.#gi*pa,P=this.#xi*pa,je=T%ca,je<-la?je+=ca:je>la&&(je-=ca),je=je<0?fa*je+da*je*je:fa*je-da*je*je,i=je<0?ha*(je*-je-je)+je:ha*(je*je-je)+je,je=(T+ma)%ca,je<-la?je+=ca:je>la&&(je-=ca),je=je<0?fa*je+da*je*je:fa*je-da*je*je,_=je<0?ha*(je*-je-je)+je:ha*(je*je-je)+je,je=w%ca,je<-la?je+=ca:je>la&&(je-=ca),je=je<0?fa*je+da*je*je:fa*je-da*je*je,m=je<0?ha*(je*-je-je)+je:ha*(je*je-je)+je,je=(w+ma)%ca,je<-la?je+=ca:je>la&&(je-=ca),je=je<0?fa*je+da*je*je:fa*je-da*je*je,b=je<0?ha*(je*-je-je)+je:ha*(je*je-je)+je,je=P%ca,je<-la?je+=ca:je>la&&(je-=ca),je=je<0?fa*je+da*je*je:fa*je-da*je*je,g=je<0?ha*(je*-je-je)+je:ha*(je*je-je)+je,je=(P+ma)%ca,je<-la?je+=ca:je>la&&(je-=ca),je=je<0?fa*je+da*je*je:fa*je-da*je*je,y=je<0?ha*(je*-je-je)+je:ha*(je*je-je)+je,bt=b*y,yt=_*g+i*m*y,St=i*g-_*m*y,Tt=-b*g,Mt=_*y-i*m*g,wt=i*y+_*m*g,Ct=m,Rt=-i*b,Pt=_*b;let Je=this.#Ps,Qe=this.#Bs,et=this.#Is;q[0]=bt*Je,q[1]=yt*Je,q[2]=St*Je,q[3]=0,q[4]=Tt*Qe,q[5]=Mt*Qe,q[6]=wt*Qe,q[7]=0,q[8]=Ct*et,q[9]=Rt*et,q[10]=Pt*et,q[11]=0}this.modelMatrix=this.localMatrix;{let i=this.normalModelMatrix,m=this.modelMatrix;H=m[0],$=m[1],W=m[2],q=m[3],ye=m[4],Ge=m[5],Ke=m[6],je=m[7],Xe=m[8],Ye=m[9],Ze=m[10],Je=m[11],et=m[12],at=m[13],ht=m[14],ft=m[15],Qe=H*Ge-$*ye,gt=H*Ke-W*ye,xt=H*je-q*ye,vt=$*Ke-W*Ge,bt=$*je-q*Ge,yt=W*je-q*Ke,St=Xe*at-Ye*et,Tt=Xe*ht-Ze*et,Mt=Xe*ft-Je*et,Ct=Ye*ft-Je*at,wt=Ze*ft-Je*ht,Pt=Qe*wt-gt*Ct+xt*wt+vt*Mt-bt*Tt+yt*St,Pt=1/Pt,i[0]=(Ge*wt-Ke*Ct+je*wt)*Pt,i[4]=(-$*wt+W*Ct-q*wt)*Pt,i[8]=(at*yt-ht*bt+ft*vt)*Pt,i[12]=(-Ye*yt+Ze*bt-Je*vt)*Pt,i[1]=(-ye*wt+Ke*Mt-je*Tt)*Pt,i[5]=(H*wt-W*Mt+q*Tt)*Pt,i[9]=(-et*yt+ht*xt-ft*gt)*Pt,i[13]=(Xe*yt-Ze*xt+Je*gt)*Pt,i[2]=(ye*Ct-Ge*Mt+je*St)*Pt,i[6]=(-H*Ct+$*Mt-q*St)*Pt,i[10]=(et*bt-at*xt+ft*Qe)*Pt,i[14]=(-Xe*bt+Ye*xt-Je*Qe)*Pt,i[3]=(-ye*wt+Ge*Tt-Ke*St)*Pt,i[7]=(H*wt-$*Tt+W*St)*Pt,i[11]=(-et*vt+at*gt-ht*Qe)*Pt,i[15]=(Xe*vt-Ye*gt+Ze*Qe)*Pt}if(this.#id.gpuRenderInfo){const{vertexUniformBuffer:i,vertexUniformInfo:m}=this.#id.gpuRenderInfo,{dataViewF32:g}=i,{members:_}=m,b=_.instanceModelMatrixs,y=_.instanceNormalModelMatrix,T=_.instanceOpacity;g.set(this.modelMatrix,(b.uniformOffset+b.stride*this.#rd)/4),g.set(this.normalModelMatrix,(y.uniformOffset+y.stride*this.#rd)/4),g.set([this.opacity],(T.uniformOffset+T.stride*this.#rd)/4),this.#id.dirtyInstanceMeshObject3D=!0}}}var ga=Object.freeze({__proto__:null,instancingMeshObject3D:InstancingMeshObject3D});class ResourceStateStorageBuffer{static dirtyList=[];buffer;uuid;#Ot=0;constructor(i){this.buffer=i,this.uuid=i.uuid}get useNum(){return this.#Ot}set useNum(i){this.#Ot=i,ResourceStateStorageBuffer.dirtyList.push(this)}}class StorageBuffer extends AUniformBaseBuffer{constructor(i,m,g="",_=""){super(i,"managedStorageBufferState",GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,m,g);const{table:b}=this.targetResourceManagedState,y=b.get(_);if(y)return y.buffer;_&&(this.name=_,this[xn]=_),this.redGPUContext.resourceManager.registerManagementResource(this,new ResourceStateStorageBuffer(this))}}Object.freeze(StorageBuffer);var xa="struct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(3) uv1:vec2<f32>, @location(4) vertexColor_0:vec4<f32>, @location(5) vertexTangent:vec4<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(10) localNodeScale_volumeScale:vec2<f32>, @location(11) instanceOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(14) @interpolate(flat) receiveShadow:f32, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\n";const _a="VERTEX_MODULE_INSTANCING";class InstancingMesh extends Mesh{dirtyInstanceMeshObject3D=!0;dirtyInstanceNum=!0;#l;#sd=1;#od=1;#ud=[];#Qs;#ld;#cd;#hd;#fd;#dd;#md=0;#pd=0;#gd;#to=[];constructor(i,m,g,_,b){super(i,_,b),this.#l=i,this.#ft(),this.maxInstanceCount=m,this.instanceCount=g}get instanceCount(){return this.#sd}set instanceCount(i){validateUintRange(i),this.#sd=Math.min(i,this.#od),this.gpuRenderInfo.vertexUniformInfo=parseWGSL(this.#xd(this.geometry,this.material)).storage.instanceUniforms,this.#_d(),this.#ud.length>this.#sd&&(this.#ud.length=this.#sd);let m=this.#sd;for(;m--;)this.#ud[m]||(this.#ud[m]=new InstancingMeshObject3D(this.#l,m,this));this.#vd(),this.#Ah(this.#l),this.dirtyInstanceNum=!0}get maxInstanceCount(){return this.#od}set maxInstanceCount(i){validateUintRange(i);const m=InstancingMesh.getLimitSize();i=Math.min(i,m),this.#od=i,this.#sd>this.#od&&(this.instanceCount=this.#od)}get instanceChildren(){return this.#ud}static getLimitSize(){const i=Math.floor(Math.min(268435456,134217728));return Math.floor((i-80)/132)}render(i,m=!1){if(this.dirtyLOD)return this.#vd(),this.#Ah(this.#l),this.dirtyInstanceNum=!0,void(this.dirtyLOD=!1);const{view:g,currentRenderPassEncoder:_}=i,{scene:b}=g,{shadowManager:y}=b,{directionalShadowManager:T}=y,{castingList:w}=T;this.dirtyTransform&&this.#bd(),this.geometry?i.num3DObjects++:i.num3DGroups++;const P=this.#l;if(this.geometry){const{antialiasingManager:g}=P;g.changedMSAA&&(this.dirtyPipeline=!0),this.gpuRenderInfo||this.#Ah(P);(this.dirtyPipeline||this.material.dirtyPipeline)&&this.#yd(i),m||this.#Sd(i),this.#Td(i,m,_)}this.castShadow&&(w[w.length]=this);const{children:H}=this;let $=H.length;for(;$--;)H[$].dirtyTransform=this.dirtyTransform,H[$].render(i);this.dirtyTransform=!1}#bd(){identity(this.localMatrix),translate(this.localMatrix,this.localMatrix,[this.x,this.y,this.z]),rotateX(this.localMatrix,this.localMatrix,this.rotationX),rotateY(this.localMatrix,this.localMatrix,this.rotationY),rotateZ(this.localMatrix,this.localMatrix,this.rotationZ),scale(this.localMatrix,this.localMatrix,[this.scaleX,this.scaleY,this.scaleZ]);const i=this.parent;i?.modelMatrix?multiply(this.modelMatrix,this.localMatrix,i.modelMatrix):this.modelMatrix=clone(this.localMatrix)}#yd(i){this.dirtyTransform=!0,this.material.dirtyPipeline&&this.material._updateFragmentState(),this.#Md(),this.material.dirtyPipeline=!1,this.dirtyPipeline=!1,i.numDirtyPipelines++}#Td(i,m,g){const{gpuRenderInfo:_}=this,{pipeline:b,shadowPipeline:y}=_;this.#wd(),this.#Cd();const{fragmentUniformBindGroup:T}=this.material.gpuRenderInfo;g.setBindGroup(0,i.view.systemUniform_Vertex_UniformBindGroup),g.setBindGroup(2,T),g.setPipeline(m?y:b);this.#Rd(g,this.geometry,this.gpuRenderInfo.vertexUniformBindGroup,this.material.gpuRenderInfo.fragmentUniformBindGroup,0,20),this.LODManager.LODList.forEach((i,m)=>{const _=this.#to[m];g.setPipeline(_.pipeline),this.#Rd(g,i.geometry,_.vertexUniformBindGroup,i.material?i.material.gpuRenderInfo.fragmentUniformBindGroup:this.material.gpuRenderInfo.fragmentUniformBindGroup,m+1,20)}),i.numDrawCalls++,i.numInstances++}#Rd(i,m,g,_,b,y){const{vertexBuffer:T,indexBuffer:w}=m,P=y*b;if(i.setBindGroup(1,g),i.setBindGroup(2,_),i.setVertexBuffer(0,T.gpuBuffer),w){const{gpuBuffer:m,format:g}=w;i.setIndexBuffer(m,g),i.drawIndexedIndirect(this.#gd,P)}else i.drawIndirect(this.#gd,P)}#wd(){const{vertexUniformBuffer:i,vertexUniformInfo:m}=this.gpuRenderInfo,{displacementTexture:g,displacementScale:_}=this.material||{},{members:b}=m;void 0!==b.displacementScale&&this.#Qs!==_&&(this.#Qs=_,i.dataViewF32.set(new b.displacementScale.View([_]),b.displacementScale.uniformOffset/4)),void 0!==b.useDisplacementTexture&&this.#ld!==!!g&&(this.#ld=!!g,i.dataViewF32.set(new b.useDisplacementTexture.View([g?1:0]),b.useDisplacementTexture.uniformOffset/4))}#Cd(){const{vertexUniformBuffer:i,vertexUniformInfo:m}=this.gpuRenderInfo,{gpuDevice:g}=this.#l,{members:_}=m;this.dirtyTransform&&(i.dataViewF32.set(this.modelMatrix,_.instanceGroupModelMatrix.uniformOffset/4),g.queue.writeBuffer(i.gpuBuffer,_.instanceGroupModelMatrix.uniformOffset,new _.instanceGroupModelMatrix.View(this.modelMatrix))),(this.dirtyInstanceMeshObject3D||this.dirtyInstanceNum)&&(g.queue.writeBuffer(i.gpuBuffer,0,i.data),this.dirtyInstanceMeshObject3D=!1,this.dirtyInstanceNum=!1)}#ft(){const{gpuDevice:i}=this.#l;this.gpuRenderInfo=new VertexGPURenderInfo(null,null,null,null,null,null,null,null);this.#gd=i.createBuffer({size:160,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,label:`IndirectDrawBuffer_${this.uuid}`});const m=new Float32Array(40);this.#fd=new StorageBuffer(this.#l,m.buffer,`CullingUniformBuffer_${this.uuid}`)}#Ah(i){this.dirtyPipeline=!0;const m=new ArrayBuffer(this.#md*(this.LODManager.LODList.length+1));this.#dd?.destroy(),this.#dd=new StorageBuffer(i,m,`VisibilityBuffer_${this.uuid}`),this.#Md(),this.#Pd(this.#l)}#Pd(i){const{gpuDevice:m,resourceManager:g}=i,_={code:this.#Bd()},b=g.createGPUShaderModule(`CULLING_COMPUTE_MODULE_INSTANCING_${this.#od}_${this.uuid}`,_),y=m.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});this.#cd=m.createComputePipeline({layout:m.createPipelineLayout({bindGroupLayouts:[y]}),compute:{module:b,entryPoint:"main"}}),this.#hd=m.createBindGroup({layout:y,entries:[{binding:0,resource:{buffer:this.gpuRenderInfo.vertexUniformBuffer.gpuBuffer}},{binding:1,resource:{buffer:this.#fd.gpuBuffer}},{binding:2,resource:{buffer:this.#dd.gpuBuffer}},{binding:3,resource:{buffer:this.#gd}}]})}#Id(i){const{view:m}=i,{gpuDevice:g}=this.#l,{data:_,dataViewU32:b,dataViewF32:y}=this.#fd;b.set([this.#sd],0),b.set([this.#pd],1),b.set([this.LODManager.LODList.length],2),y.set(m.rawCamera.position,4),y.set(m.frustumPlanes.flat(),8),y.set([...this.LODManager.LODList.map(i=>i.distance)],32),g.queue.writeBuffer(this.#fd.gpuBuffer,0,_)}#Sd(i){const{gpuDevice:m}=this.#l;this.#Id(i);const g=this.geometry.indexBuffer?this.geometry.indexBuffer.indexCount:this.geometry.vertexBuffer.vertexCount,_=new Uint32Array([g,0,0,0,0]);m.queue.writeBuffer(this.#gd,0,_),this.LODManager.LODList.forEach((i,g)=>{const _=i.geometry.indexBuffer.indexCount,b=new Uint32Array([_,0,0,0,0]),y=20*(g+1);m.queue.writeBuffer(this.#gd,y,b)});const b=m.createCommandEncoder(),y=b.beginComputePass();y.setPipeline(this.#cd),y.setBindGroup(0,this.#hd);const T=Math.ceil(this.#sd/64);y.dispatchWorkgroups(T),y.end(),m.queue.submit([b.finish()])}#Md(){const{resourceManager:i,gpuDevice:m}=this.#l,g={code:this.#xd(this.geometry,this.material)},_=i.createGPUShaderModule(`${_a}_${this.#od}_${this.uuid}`,g),b=i.getGPUBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_Instancing);this.gpuRenderInfo.vertexShaderModule=_,this.gpuRenderInfo.pipeline=createBasePipeline(this,_,b),this.gpuRenderInfo.shadowPipeline=createBasePipeline(this,_,b,Tr),this.gpuRenderInfo.vertexUniformBindGroup=m.createBindGroup(this.#Ed()),this.#to.length=0,this.LODManager.LODList.forEach((g,_)=>{const y={code:this.#xd(g.geometry,g.material)},T=i.createGPUShaderModule(`${_a}_${this.#od}_LOD${_}_${this.uuid}`,y);this.#to[_]={pipeline:createBasePipeline({vertexStateBuffers:g.geometry.gpuRenderInfo.buffers,primitiveState:this.primitiveState,depthStencilState:this.depthStencilState,geometry:g.geometry,material:g.material||this.material,redGPUContext:this.#l,gpuRenderInfo:this.gpuRenderInfo},T,b),vertexUniformBindGroup:m.createBindGroup(this.#Ed(_+1))}})}#Ed(i=0){const{resourceManager:m}=this.#l,{vertexUniformBuffer:g}=this.gpuRenderInfo,{material:_}=this,{basicSampler:b,emptyBitmapTextureView:y}=m,{gpuSampler:T}=b,w=m.getGPUBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_Instancing),P=this.#md,H=P*i,$=P;if(H+$>this.#dd.size)throw new Error("Binding range exceeds visibility buffer size.");return{layout:w,label:"VERTEX_BIND_GROUP_DESCRIPTOR_INSTANCING",entries:[{binding:0,resource:{buffer:g.gpuBuffer,offset:0,size:g.size}},{binding:1,resource:_?.displacementTextureSampler?.gpuSampler||T},{binding:2,resource:m.getGPUResourceBitmapTextureView(_?.displacementTexture)||y},{binding:3,resource:{buffer:this.#dd.gpuBuffer,offset:H,size:$}}]}}#vd(){const i=4*this.#sd;this.#md=256*Math.ceil(i/256),this.#pd=this.#md/4}#_d(){const i=this.gpuRenderInfo.vertexUniformInfo,m=new ArrayBuffer(i.arrayBufferByteLength),g=new StorageBuffer(this.#l,m,`InstanceBuffer_${this.uuid}`),_=this.gpuRenderInfo.vertexUniformBuffer;_?.gpuBuffer&&(g.dataViewF32.set(_.dataViewF32,0),g.dataViewU32.set([_.dataViewU32[0]],0),g.dataViewU32.set([_.dataViewU32[1]],4),_.destroy()),this.gpuRenderInfo.vertexUniformBuffer=g}#Dd(i,m="",g="",_="",b=""){return[m,g,_,i.replaceAll(/__INSTANCE_COUNT__/g,this.#od.toString()),b].join("\n")}#xd(i,m){const g=i.vertexBuffer.interleavedStruct.label,_=m instanceof PBRMaterial,b="PBR"===g&&_,y=b?"struct InputData { @builtin(instance_index) instanceIdx:u32, @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(3) uv1:vec2<f32>, @location(4) vertexColor_0:vec4<f32>, @location(5) vertexTangent:vec4<f32>,\n};\n":"struct InputData { @builtin(instance_index) instanceIdx:u32, @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>,\n};",T="PBR"!==g&&_||b?xa:"struct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(11) instanceOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(14) @interpolate(flat) receiveShadow:f32, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\n";return this.#Dd("#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include calcDisplacements;\nstruct InstanceUniforms { useDisplacementTexture:u32, displacementScale:f32, instanceGroupModelMatrix:mat4x4<f32>, instanceModelMatrixs:array<mat4x4<f32>,__INSTANCE_COUNT__>, instanceNormalModelMatrix:array<mat4x4<f32>,__INSTANCE_COUNT__>, instanceOpacity:array<f32,__INSTANCE_COUNT__>,\n};\n@group(1) @binding(0) var<storage,read> instanceUniforms:InstanceUniforms;\n@group(1) @binding(1) var displacementTextureSampler:sampler;\n@group(1) @binding(2) var displacementTexture:texture_2d<f32>;\n@group(1) @binding(3) var<storage,read> visibilityBuffer:array<u32>;\nconst maxDistance:f32=1000.0;\nconst maxMipLevel:f32=10.0;",b?"@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; let input_instanceIdx:u32=visibilityBuffer[inputData.instanceIdx]; let u_modelMatrix=instanceUniforms.instanceModelMatrixs[input_instanceIdx]; let u_normalModelMatrix=instanceUniforms.instanceNormalModelMatrix[input_instanceIdx]; let u_instanceGroupModelMatrix=instanceUniforms.instanceGroupModelMatrix; let u_useDisplacementTexture=instanceUniforms.useDisplacementTexture==1u; let u_displacementScale=instanceUniforms.displacementScale; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let input_position=inputData.position; let input_vertexNormal=inputData.vertexNormal; let input_uv=inputData.uv; var position:vec4<f32>=u_modelMatrix * vec4<f32>(input_position,1.0); let worldPosition=position.xyz; if (u_useDisplacementTexture) { let distance=distance(position.xyz,u_cameraPosition); let mipLevel=(distance/maxDistance) * maxMipLevel; let displacedPosition=calcDisplacementPosition( input_position, input_vertexNormal, displacementTexture, displacementTextureSampler, u_displacementScale, input_uv, mipLevel ); position=u_modelMatrix * vec4<f32>(displacedPosition,1.0); } output.position=u_projectionCameraMatrix * u_instanceGroupModelMatrix * position; output.vertexPosition=position.xyz; var normalPosition:vec3<f32>=(u_instanceGroupModelMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0)).xyz; output.vertexNormal=normalPosition; output.instanceOpacity=instanceUniforms.instanceOpacity[input_instanceIdx]; output.uv=inputData.uv; output.uv1=inputData.uv1; output.vertexColor_0=inputData.vertexColor_0; output.vertexTangent=u_normalModelMatrix * inputData.vertexTangent; return output;\n}\n":"@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; let input_instanceIdx:u32=visibilityBuffer[inputData.instanceIdx]; let u_modelMatrix=instanceUniforms.instanceModelMatrixs[input_instanceIdx]; let u_normalModelMatrix=instanceUniforms.instanceNormalModelMatrix[input_instanceIdx]; let u_instanceGroupModelMatrix=instanceUniforms.instanceGroupModelMatrix; let u_useDisplacementTexture=instanceUniforms.useDisplacementTexture==1u; let u_displacementScale=instanceUniforms.displacementScale; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let input_position=inputData.position; let input_vertexNormal=inputData.vertexNormal; let input_uv=inputData.uv; var position:vec4<f32>=u_modelMatrix * vec4<f32>(input_position,1.0); let worldPosition=position.xyz; if (u_useDisplacementTexture) { let distance=distance(position.xyz,u_cameraPosition); let mipLevel=(distance/maxDistance) * maxMipLevel; let displacedPosition=calcDisplacementPosition( input_position, input_vertexNormal, displacementTexture, displacementTextureSampler, u_displacementScale, input_uv, mipLevel ); position=u_modelMatrix * vec4<f32>(displacedPosition,1.0); } output.position=u_projectionCameraMatrix * u_instanceGroupModelMatrix * position; output.vertexPosition=position.xyz; var normalPosition:vec3<f32>=(u_instanceGroupModelMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0)).xyz; output.vertexNormal=normalPosition; output.uv=input_uv; output.instanceOpacity=instanceUniforms.instanceOpacity[input_instanceIdx]; return output;\n}\n",y,T,"\nstruct OutputShadowData { @builtin(position) position:vec4<f32>,\n};\n@vertex\nfn drawDirectionalShadowDepth(inputData:InputData) -> OutputShadowData { var output:OutputShadowData; let input_instanceIdx:u32=visibilityBuffer[inputData.instanceIdx]; let u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix; let u_modelMatrix=instanceUniforms.instanceModelMatrixs[input_instanceIdx]; let u_useDisplacementTexture=instanceUniforms.useDisplacementTexture==1u; let u_displacementScale=instanceUniforms.displacementScale; let input_position=inputData.position; let input_vertexNormal=inputData.vertexNormal; let input_uv=inputData.uv; var position:vec4<f32>=u_modelMatrix * vec4<f32>(input_position,1.0); if (u_useDisplacementTexture) { let distance=distance(position.xyz,u_directionalLightProjectionViewMatrix[3].xyz); let mipLevel=(distance/maxDistance) * maxMipLevel; let displacedPosition=calcDisplacementPosition( input_position, input_vertexNormal, displacementTexture, displacementTextureSampler, u_displacementScale, input_uv, mipLevel ); position=u_modelMatrix * vec4<f32>(displacedPosition,1.0); } output.position=u_directionalLightProjectionViewMatrix * position; return output;\n}\n")}#Bd(){return this.#Dd("struct InstanceUniforms { useDisplacementTexture:u32, displacementScale:f32, instanceGroupModelMatrix:mat4x4<f32>, instanceModelMatrixs:array<mat4x4<f32>,__INSTANCE_COUNT__>, instanceNormalModelMatrix:array<mat4x4<f32>,__INSTANCE_COUNT__>, instanceOpacity:array<f32,__INSTANCE_COUNT__>,\n};\nstruct CullingUniforms { instanceCount:u32, stride:u32, lodNum:u32, padding:f32, cameraPosition:vec3<f32>, frustumPlanes:array<vec4<f32>,6>, lodDistanceList:array<f32,7>,\n};\nstruct IndirectDrawArgs { vertexCount:u32, instanceCount:atomic<u32>, firstVertex:u32, baseVertex:u32, firstInstance:u32,\n};\n@group(0) @binding(0) var<storage,read> instanceUniforms:InstanceUniforms;\n@group(0) @binding(1) var<storage,read> cullingUniforms:CullingUniforms;\n@group(0) @binding(2) var<storage,read_write> visibilityBuffer:array<u32>;\n@group(0) @binding(3) var<storage,read_write> indirectDrawBuffer:array<IndirectDrawArgs>;\nconst BOUNDING_RADIUS:f32=1.0;\nfn distanceToPlane(position:vec3<f32>,plane:vec4<f32>) -> f32 { return dot(vec4<f32>(position,1.0),plane);\n}\nfn isInsideFrustum(position:vec3<f32>,radius:f32) -> bool { for (var i:u32=0u;i < 6u;i=i + 1u) { let plane=cullingUniforms.frustumPlanes[i]; let distance=distanceToPlane(position,plane); if (distance < -radius) { return false; } } return true;\n}\nfn calculateLODLevel(distanceToCamera:f32) -> u32 { if (cullingUniforms.lodNum==0u) { return 0u; } for (var i:u32=0u;i < cullingUniforms.lodNum;i=i + 1u) { if (distanceToCamera < cullingUniforms.lodDistanceList[i]) { return i; } } return cullingUniforms.lodNum;\n}\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) globalId:vec3<u32>) { let instanceIdx=globalId.x; if (instanceIdx >=(cullingUniforms.instanceCount)) { return; } let u_instanceGroupModelMatrix=instanceUniforms.instanceGroupModelMatrix; let modelMatrix=u_instanceGroupModelMatrix * instanceUniforms.instanceModelMatrixs[instanceIdx]; let worldPosition=vec3<f32>( modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2] ); let scaleX=length(vec3<f32>(modelMatrix[0][0],modelMatrix[0][1],modelMatrix[0][2])); let scaleY=length(vec3<f32>(modelMatrix[1][0],modelMatrix[1][1],modelMatrix[1][2])); let scaleZ=length(vec3<f32>(modelMatrix[2][0],modelMatrix[2][1],modelMatrix[2][2])); let maxScale=max(max(scaleX,scaleY),scaleZ); let scaledRadius=BOUNDING_RADIUS * maxScale; let isVisible=isInsideFrustum(worldPosition,scaledRadius); if (isVisible) { let distanceToCamera=distance(worldPosition,cullingUniforms.cameraPosition); let lodLevel=calculateLODLevel(distanceToCamera); let visibilityStride=cullingUniforms.stride; let aliveIndex=atomicAdd(&indirectDrawBuffer[lodLevel].instanceCount,1u); visibilityBuffer[visibilityStride * lodLevel + aliveIndex]=instanceIdx; }\n}\n")}}Object.defineProperty(InstancingMesh.prototype,"meshType",{value:Qn.INSTANCED_MESH,writable:!1});var va=Object.freeze({__proto__:null,CoreGroup:Li,CoreInstancingMesh:ga,CoreMesh:Ii,CoreSkyBox:Pi,CoreSpriteSheet:Hi,CoreTextField:ia,CoreView:Ei,Group2D:Group2D,Group3D:Group3D,InstancingMesh:InstancingMesh,LINE_TYPE:Ji,Line2D:class extends Line3D{constructor(i,m=Ji.LINEAR,g="#fff"){super(i,m,g),this._material=new LineMaterial(i)}get geometry(){return this._geometry}set geometry(i){consoleAndThrowError("Line2D can not change geometry")}get material(){return this._material}set material(i){consoleAndThrowError("Line2D can not change material")}createCustomMeshVertexShaderModule=()=>this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_LINE_2D",na,ra,Qi);addPoint(i=0,m=0,g=this.baseColor,_=1,b=0,y=0,T=0,w=0){super.addPoint(i,m,0,g,_,b,y,0,T,w,0)}addPointAt(i,m=0,g=0,_=this.baseColor,b=1,y=0,T=0,w=0,P=0){super.addPointAt(i,m,g,0,_,b,y,T,0,w,P,0)}},Line3D:Line3D,Mesh:Mesh,PARTICLE_EASE:Ui,ParticleEmitter:ParticleEmitter,Scene:Scene,SkyBox:SkyBox,Sprite2D:Sprite2D,Sprite3D:Sprite3D,SpriteSheet2D:SpriteSheet2D,SpriteSheet3D:SpriteSheet3D,SpriteSheetInfo:SpriteSheetInfo,TextField2D:TextField2D,TextField3D:TextField3D,View2D:View2D,View3D:View3D}),ba=Object.freeze({__proto__:null,ABaseLight:ABaseLight}),ya=Object.freeze({__proto__:null,AmbientLight:AmbientLight,Core:ba,DirectionalLight:DirectionalLight,LightManager:LightManager,PointLight:PointLight,SpotLight:SpotLight}),Sa=Object.freeze({__proto__:null,GeometryGPURenderInfo:GeometryGPURenderInfo,Primitive:Primitive,createPrimitiveGeometry:createPrimitiveGeometry});function calculatePositionOnCurve(i,m,g,_,b){const y=Math.cos(i),T=Math.sin(i),w=g/m*i,P=Math.cos(w);b[0]=_*(2+P)*.5*y,b[1]=_*(2+P)*T*.5,b[2]=_*Math.sin(w)*.5}var Ta=Object.freeze({__proto__:null,Box:Box,Circle:class extends Primitive{#di=function(){return function(i,m,g,_,b,y){const T=[],w=[];T.push(0,0,0,0,0,1,.5,.5);for(let i=0;i<=_;i++){const m=b+i/_*y,w=Math.cos(m),P=Math.sin(m),H=g*w,$=g*P,W=0,q=(w+1)/2,ye=(P+1)/2;T.push(H,$,W,0,0,1,q,ye)}for(let i=1;i<=_;i++)w.push(0,i,i+1);return createPrimitiveGeometry(m,T,w,i)}}();constructor(i,m=1,g=32,_=0,b=2*Math.PI){if(super(i),g<3)throw new Error("segments must be 3 or greater");if(m<=0)throw new Error("radius must be greater than 0");if(b<=0)throw new Error("thetaLength must be greater than 0");const y=`PRIMITIVE_CIRCLE_R${m}_S${g}_TS${_}_TL${b}`,T=i.resourceManager.cachedBufferState;let w=T[y];w||(w=T[y]=this.#di(y,i,m,g,_,b)),this._setData(w)}},Core:Sa,Cylinder:Cylinder,Ground:class extends Primitive{#di=function(){const i=[],m=[];return function(g,_,b,y,T,w,P,H){const $=b/2,W=y/2,q=Math.floor(T)||1,ye=Math.floor(w)||1,Ge=q+1,Ke=ye+1,je=b/q,Xe=y/ye;i.length=0,m.length=0;for(let g=0;g<Ke;g++){const _=g*Xe-W,b=H?(1-g/ye)*P:g/ye*P;for(let y=0;y<Ge;y++){const T=y*je-$,w=y/q*P;if(i.push(T,0,_,0,1,0,w,b),g<ye&&y<q){const i=y+Ge*g,_=y+Ge*(g+1),b=y+1+Ge*(g+1),T=y+1+Ge*g;m.push(i,_,T),m.push(_,b,T)}}}return createPrimitiveGeometry(_,i,m,g)}}();constructor(i,m=1,g=1,_=1,b=1,y=1,T=!1){super(i);const w=`PRIMITIVE_GROUND_W${m}_H${g}_WS${_}_HS${b}_UV${y}_FY${T}`,P=i.resourceManager.cachedBufferState;let H=P[w];H||(H=P[w]=this.#di(w,i,m,g,_,b,y,T)),this._setData(H)}},Plane:Plane,Sphere:Sphere,Torus:class extends Primitive{#di=function(){return function(i,m,g,_,b,y,T,w){T=T||0;const P=(w=w||2*Math.PI)-T,H=b+1,$=y+1,W=[],q=[];for(let i=0;i<$;++i){const m=i/y,w=m*Math.PI*2,$=Math.sin(w),q=g+$*_,ye=Math.cos(w),Ge=ye*_;for(let i=0;i<H;++i){const g=i/b,_=T+g*P,y=Math.sin(_),w=Math.cos(_),H=y*q,Ke=w*q,je=y*$,Xe=w*$;W.push(H,Ge,Ke,je,ye,Xe,g,1-m)}}for(let i=0;i<y;++i)for(let m=0;m<b;++m){const g=1+m,_=1+i;q.push(H*i+m,H*_+m,H*i+g),q.push(H*_+m,H*_+g,H*i+g)}return createPrimitiveGeometry(m,W,q,i)}}();constructor(i,m=1,g=.5,_=16,b=16,y=0,T=2*Math.PI){if(super(i),_<3)throw new Error("radialSubdivisions must be 3 or greater");if(b<3)throw new Error("verticalSubdivisions must be 3 or greater");const w=`PRIMITIVE_TORUS_R${m}_T${g}_RSD${_}_BSD${b}_SA${y}_EA${T}`,P=i.resourceManager.cachedBufferState;let H=P[w];H||(H=P[w]=this.#di(w,i,m,g,_,b,y,T)),this._setData(H)}},TorusKnot:class extends Primitive{#di=function(){return function(i,m,g,_,b,y,T,w){b=Math.floor(b),y=Math.floor(y);const P=[],H=[],$=[],W=[],q=[0,0,0],ye=[0,0,0],Ge=[0,0,0],Ke=[0,0,0],je=[0,0,0];for(let i=0;i<=b;++i){const m=i/b*T*Math.PI*2;calculatePositionOnCurve(m,T,w,g,q),calculatePositionOnCurve(m+.01,T,w,g,ye),Ke[0]=ye[0]-q[0],Ke[1]=ye[1]-q[1],Ke[2]=ye[2]-q[2],je[0]=ye[0]+q[0],je[1]=ye[1]+q[1],je[2]=ye[2]+q[2];{const i=Ke[0],m=Ke[1],g=Ke[2],_=je[0],b=je[1],y=je[2];Ge[0]=m*y-g*b,Ge[1]=g*_-i*y,Ge[2]=i*b-m*_}{const i=Ge[0],m=Ge[1],g=Ge[2],_=Ke[0],b=Ke[1],y=Ke[2];je[0]=m*y-g*b,je[1]=g*_-i*y,je[2]=i*b-m*_}{let i=Ge[0],m=Ge[1],g=Ge[2],_=i*i+m*m+g*g;_>0&&(_=1/Math.sqrt(_||1)),Ge[0]=Ge[0]*_,Ge[1]=Ge[1]*_,Ge[2]=Ge[2]*_}{let i=je[0],m=je[1],g=je[2],_=i*i+m*m+g*g;_>0&&(_=1/Math.sqrt(_)),je[0]=je[0]*_,je[1]=je[1]*_,je[2]=je[2]*_}for(let m=0;m<=y;++m){const g=m/y*Math.PI*2,T=-_*Math.cos(g),w=_*Math.sin(g);$[0]=q[0]+(T*je[0]+w*Ge[0]),$[1]=q[1]+(T*je[1]+w*Ge[1]),$[2]=q[2]+(T*je[2]+w*Ge[2]),P.push($[0],$[1],$[2]);{W[0]=$[0]-q[0],W[1]=$[1]-q[1],W[2]=$[2]-q[2];let i=W[0],m=W[1],g=W[2],_=i*i+m*m+g*g;_>0&&(_=1/Math.sqrt(_)),W[0]=W[0]*_,W[1]=W[1]*_,W[2]=W[2]*_}P.push(W[0],W[1],W[2],i/b,m/y)}}for(let i=1;i<=b;i++)for(let m=1;m<=y;m++){const g=(y+1)*(i-1)+(m-1),_=(y+1)*i+(m-1),b=(y+1)*i+m,T=(y+1)*(i-1)+m;H.push(g,_,T),H.push(_,b,T)}return createPrimitiveGeometry(m,P,H,i)}}();constructor(i,m=1,g=.4,_=64,b=8,y=2,T=3){super(i);const w=`PRIMITIVE_TORUS_NUT_R${m}_T${g}_TS${_}_RS${b}_P${y}_Q${T}`,P=i.resourceManager.cachedBufferState;let H=P[w];H||(H=P[w]=this.#di(w,i,m,g,_,b,y,T)),this._setData(H)}}});const Ma=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include calcTintBlendMode;\n#redgpu_include calcDirectionalShadowVisibility;\n#redgpu_include normalFunctions;\n#redgpu_include drawPicking;\n#redgpu_include FragmentOutput;\n#redgpu_include calculateMotionVector;\nstruct Uniforms { color:vec3<f32>, emissiveColor:vec3<f32>, emissiveStrength:f32, specularColor:vec3<f32>, specularStrength:f32, shininess:f32, aoStrength:f32, normalScale:f32, opacity:f32, useTint:u32, tint:vec4<f32>, tintBlendMode:u32, useSSR:u32, metallic:f32, roughness:f32,\n};\nstruct InputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(14) @interpolate(flat) receiveShadow:f32, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n}\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\n@group(2) @binding(1) var diffuseTextureSampler:sampler;\n@group(2) @binding(2) var diffuseTexture:texture_2d<f32>;\n@group(2) @binding(3) var alphaTextureSampler:sampler;\n@group(2) @binding(4) var alphaTexture:texture_2d<f32>;\n@group(2) @binding(5) var specularTextureSampler:sampler;\n@group(2) @binding(6) var specularTexture:texture_2d<f32>;\n@group(2) @binding(7) var emissiveTextureSampler:sampler;\n@group(2) @binding(8) var emissiveTexture:texture_2d<f32>;\n@group(2) @binding(9) var aoTextureSampler:sampler;\n@group(2) @binding(10) var aoTexture:texture_2d<f32>;\n@group(2) @binding(11) var normalTextureSampler:sampler;\n@group(2) @binding(12) var normalTexture:texture_2d<f32>;\n@fragment\nfn main(inputData:InputData) -> FragmentOutput { var output:FragmentOutput; let u_ambientLight=systemUniforms.ambientLight; let u_ambientLightColor=u_ambientLight.color; let u_ambientLightIntensity=u_ambientLight.intensity; let u_directionalLightCount=systemUniforms.directionalLightCount; let u_directionalLights=systemUniforms.directionalLights; let u_shadowDepthTextureSize=systemUniforms.shadowDepthTextureSize; let u_bias=systemUniforms.bias; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_color=uniforms.color; let u_aoStrength=uniforms.aoStrength; let u_emissiveColor=uniforms.emissiveColor; let u_emissiveStrength=uniforms.emissiveStrength; let u_normalScale=uniforms.normalScale; let u_specularColor=uniforms.specularColor; let u_specularStrength=uniforms.specularStrength; let u_shininess=uniforms.shininess; let u_opacity=uniforms.opacity; let E=normalize(u_cameraPosition - inputData.vertexPosition); let receiveShadowYn=inputData.receiveShadow !=.0; var N=normalize(inputData.vertexNormal); #redgpu_if normalTexture let normalSamplerColor=textureSample(normalTexture,normalTextureSampler,inputData.uv).rgb; N=perturb_normal( N,inputData.vertexPosition,inputData.uv,normalSamplerColor,u_normalScale ); #redgpu_endIf var finalColor:vec4<f32>; var resultAlpha:f32=u_opacity * inputData.combinedOpacity; var diffuseColor:vec3<f32>=u_color; #redgpu_if diffuseTexture let diffuseSampleColor=textureSample(diffuseTexture,diffuseTextureSampler,inputData.uv); diffuseColor=diffuseSampleColor.rgb; resultAlpha=resultAlpha * diffuseSampleColor.a; #redgpu_endIf var specularSamplerValue:f32=1; #redgpu_if specularTexture specularSamplerValue=textureSample(specularTexture,specularTextureSampler,inputData.uv).r; #redgpu_endIf var mixColor:vec3<f32>; let ambientContribution=u_ambientLightColor * u_ambientLightIntensity; let ambientDiffuse=diffuseColor * ambientContribution; mixColor +=ambientDiffuse; var visibility:f32=1.0; visibility=calcDirectionalShadowVisibility( directionalShadowMap, directionalShadowMapSampler, u_shadowDepthTextureSize, u_bias, inputData.shadowPos, ); if(!receiveShadowYn){ visibility=1.0; } for (var i=0u;i < u_directionalLightCount;i=i + 1) { let u_directionalLightDirection=u_directionalLights[i].direction; let u_directionalLightColor=u_directionalLights[i].color; let u_directionalLightIntensity=u_directionalLights[i].intensity; let L=normalize(u_directionalLightDirection); let R=reflect(L,N); let lambertTerm=max(dot(N,-L),0.0); let specular=pow(max(dot(R,E),0.0),u_shininess) * specularSamplerValue; let lightContribution=u_directionalLightColor * u_directionalLightIntensity * visibility; let ld=diffuseColor * lightContribution * lambertTerm; let ls=u_specularColor * u_specularStrength * lightContribution * specular; mixColor +=ld + ls; } let clusterIndex=getClusterLightClusterIndex(inputData.position); let lightOffset=clusterLightGroup.lights[clusterIndex].offset; let lightCount:u32=clusterLightGroup.lights[clusterIndex].count; for (var lightIndex=0u;lightIndex < lightCount;lightIndex=lightIndex + 1u) { let i=clusterLightGroup.indices[lightOffset + lightIndex]; let u_clusterLightPosition=clusterLightList.lights[i].position; let u_clusterLightColor=clusterLightList.lights[i].color; let u_clusterLightIntensity=clusterLightList.lights[i].intensity; let u_clusterLightRadius=clusterLightList.lights[i].radius; let u_isSpotLight=clusterLightList.lights[i].isSpotLight; let lightDir=u_clusterLightPosition - inputData.vertexPosition; let lightDistance=length(lightDir); if (lightDistance > u_clusterLightRadius) { continue; } let L=normalize(lightDir); let dist2=max(dot(lightDir,lightDir),0.0001); let d=sqrt(dist2); let rangePart=pow(clamp(1.0 - d/u_clusterLightRadius,0.0,1.0),2.0); let invSquare=(u_clusterLightRadius * u_clusterLightRadius)/dist2; let attenuation=rangePart * invSquare; var finalAttenuation=attenuation; if (u_isSpotLight > 0.0) { let u_clusterLightDirection=normalize(vec3<f32>( clusterLightList.lights[i].directionX, clusterLightList.lights[i].directionY, clusterLightList.lights[i].directionZ )); let u_clusterLightInnerAngle=clusterLightList.lights[i].innerCutoff; let u_clusterLightOuterCutoff=clusterLightList.lights[i].outerCutoff; let lightToVertex=normalize(-lightDir); let cosTheta=dot(lightToVertex,u_clusterLightDirection); let cosOuter=cos(radians(u_clusterLightOuterCutoff)); let cosInner=cos(radians(u_clusterLightInnerAngle)); if (cosTheta < cosOuter) { continue; } let epsilon=cosInner - cosOuter; let spotIntensity=clamp((cosTheta - cosOuter)/epsilon,0.0,1.0); finalAttenuation *=spotIntensity; } let R=reflect(-L,N); let diffuse=diffuseColor * max(dot(N,L),0.0); let specular=pow(max(dot(R,E),0.0),u_shininess) * specularSamplerValue; let diffuseAttenuation=finalAttenuation; let specularAttenuation=finalAttenuation * finalAttenuation; let ld=u_clusterLightColor * diffuse * diffuseAttenuation * u_clusterLightIntensity; let ls=u_specularColor * u_specularStrength * specular * specularAttenuation * u_clusterLightIntensity; mixColor +=ld + ls; } #redgpu_if alphaTexture let alphaMapValue:f32=textureSample(alphaTexture,alphaTextureSampler,inputData.uv).r; resultAlpha=alphaMapValue * resultAlpha; if(resultAlpha==0){ discard;} #redgpu_endIf var emissiveColor=u_emissiveColor * u_emissiveStrength; #redgpu_if emissiveTexture emissiveColor=textureSample(emissiveTexture,emissiveTextureSampler,inputData.uv).rgb * u_emissiveStrength; #redgpu_endIf #redgpu_if aoTexture mixColor=mixColor * textureSample(aoTexture,aoTextureSampler,inputData.uv).rgb * u_aoStrength; #redgpu_endIf finalColor=vec4<f32>(mixColor + emissiveColor,resultAlpha); #redgpu_if useTint finalColor=calcTintBlendMode(finalColor,uniforms.tintBlendMode,uniforms.tint); #redgpu_endIf if (systemUniforms.isView3D==1 && finalColor.a==0.0) { discard; } output.color=finalColor; { let metallic=uniforms.metallic; let roughness=uniforms.roughness; let smoothness=1.0 - roughness; let smoothnessCurved=smoothness * smoothness * (3.0 - 2.0 * smoothness); let metallicWeight=metallic * metallic; let baseReflection=0.04 + 0.96 * metallicWeight; let baseReflectionStrength=smoothnessCurved * baseReflection; output.gBufferNormal=vec4<f32>(N * 0.5 + 0.5,baseReflectionStrength); } output.gBufferMotionVector=vec4<f32>(calculateMotionVector(inputData.currentClipPos,inputData.prevClipPos),0.0,1.0 ); return output;\n}\n");class PhongMaterial extends ABitmapBaseMaterial{#Ld;#Qs=1;constructor(i,m="#fff",g){super(i,"PHONG_MATERIAL",Ma,2),g&&(this.name=g),this.initGPURenderInfos(),this.color.setColorByHEX(m),this.emissiveColor.setColorByHEX(this.emissiveColor.hex),this.specularColor.setColorByHEX(this.specularColor.hex)}get displacementScale(){return this.#Qs}set displacementScale(i){this.#Qs=i}get displacementTexture(){return this.#Ld}set displacementTexture(i){const m=this.#Ld;this.#Ld=i,this.updateTexture(m,i),this.dirtyPipeline=!0}}In.defineByPreset(PhongMaterial,[In.PRESET_COLOR_RGB.COLOR,In.PRESET_TEXTURE.ALPHA_TEXTURE,In.PRESET_SAMPLER.ALPHA_TEXTURE_SAMPLER,In.PRESET_TEXTURE.AO_TEXTURE,In.PRESET_SAMPLER.AO_TEXTURE_SAMPLER,In.PRESET_POSITIVE_NUMBER.AO_STRENGTH,In.PRESET_TEXTURE.DIFFUSE_TEXTURE,In.PRESET_SAMPLER.DIFFUSE_TEXTURE_SAMPLER,In.PRESET_TEXTURE.EMISSIVE_TEXTURE,In.PRESET_SAMPLER.EMISSIVE_TEXTURE_SAMPLER,In.PRESET_POSITIVE_NUMBER.EMISSIVE_STRENGTH,[In.PRESET_COLOR_RGB.EMISSIVE_COLOR,"#000000"],In.PRESET_TEXTURE.NORMAL_TEXTURE,In.PRESET_SAMPLER.NORMAL_TEXTURE_SAMPLER,In.PRESET_POSITIVE_NUMBER.NORMAL_SCALE,In.PRESET_TEXTURE.SPECULAR_TEXTURE,In.PRESET_SAMPLER.SPECULAR_TEXTURE_SAMPLER,In.PRESET_POSITIVE_NUMBER.SPECULAR_STRENGTH,[In.PRESET_COLOR_RGB.SPECULAR_COLOR,"#ffffff"],[In.PRESET_POSITIVE_NUMBER.SHININESS,32]]),In.defineBoolean(PhongMaterial,[["useSSR",!1]]),In.definePositiveNumber(PhongMaterial,[["metallic",0,0,1],["roughness",0,0,1]]),Object.freeze(PhongMaterial);var wa=Object.freeze({__proto__:null,BLEND_MODE:Bi,BitmapMaterial:BitmapMaterial,COMPOSITE_MODE:{ADDITIVE:"additive",SOURCE_OVER:"source-over",SOURCE_IN:"source-in",SOURCE_OUT:"source-out",SOURCE_ATOP:"source-atop",DESTINATION_OVER:"destination-over",DESTINATION_IN:"destination-in",DESTINATION_OUT:"destination-out",DESTINATION_ATOP:"destination-atop"},ColorMaterial:ColorMaterial,Core:zn,PBRMaterial:PBRMaterial,PhongMaterial:PhongMaterial,TINT_BLEND_MODE:Nn}),Ca=Object.freeze({__proto__:null,ManagementResourceBase:ManagementResourceBase,ResourceBase:ResourceBase,ResourceManager:ResourceManager,ResourceStatusInfo:ResourceStatusInfo});var Ra=Object.freeze({__proto__:null,ABaseBuffer:ABaseBuffer,AUniformBaseBuffer:AUniformBaseBuffer,getUniformOffsetByRoundUp:(i,m)=>((i+m-1)/m|0)*m}),Pa=Object.freeze({__proto__:null,VertexInterleavedStructElement:VertexInterleavedStructElement});class ResourceStateHDRTexture{texture;src;cacheKey;useNum=0;uuid;constructor(i){this.texture=i,this.src=i.src,this.cacheKey=i.cacheKey,this.useNum=0,this.uuid=i.uuid}}class HDRLoader{#Ud=!0;constructor(i=!0){this.#Ud=i}get enableDebugLogs(){return this.#Ud}set enableDebugLogs(i){this.#Ud=i}async loadHDRFile(i){this.#Ud&&gt(`HDR 파일 로딩 시작:${i}`);const m=await fetch(i);if(!m.ok)throw new Error(`HTTP ${m.status}:${m.statusText}`);const g=await m.arrayBuffer(),_=new Uint8Array(g),b=this.#Ad(_,i);return gt({...b}),{...b}}#Ad(i,m){const g=this.#Od(i);if(this.#Ud&&gt(`파일 형식:${g.format}`),!g.isValid)throw new Error(g.error||"지원되지 않는 파일 형식입니다");if(m.split("?")[0].toLowerCase().endsWith(".hdr")){this.#Ud&&this.#kd(i.slice(0,200));const m=this.#Gd(i);return this.#Ud&&this.#Fd(m),m}throw m.split("?")[0].toLowerCase().endsWith(".exr")?new Error("EXR format not supported yet"):new Error(`Unsupported HDR format:${m}`)}#Gd(i){let m=0,g="";const _={};for(;m<i.length;){const _=String.fromCharCode(i[m++]);if("\n"===_)break;g+=_}if(!g.startsWith("#?RADIANCE")&&!g.startsWith("#?RGBE"))throw new Error("Invalid HDR file header");for(;m<i.length;){for(g="";m<i.length;){const _=String.fromCharCode(i[m++]);if("\n"===_)break;g+=_}if(""===g.trim())break;const b=g.indexOf("=");if(b>0){const i=g.substring(0,b).trim(),m=g.substring(b+1).trim();_[i]=m}}for(g="";m<i.length;){const _=String.fromCharCode(i[m++]);if("\n"===_)break;g+=_}const b=g.match(/-Y\s+(\d+)\s+\+X\s+(\d+)/);if(!b)throw new Error("Invalid resolution format in HDR file");const y=parseInt(b[1]),T=parseInt(b[2]);let w;_.EXPOSURE&&(w=parseFloat(_.EXPOSURE),this.#Ud&&gt(`파일 노출값:${w.toFixed(3)}`));const P=new Float32Array(T*y*4);let H=0;for(let g=0;g<y;g++){const g=this.#Nd(i,m,T);m=g.nextOffset;for(let i=0;i<T;i++){const m=4*i,_=g.data[m],b=g.data[m+1],y=g.data[m+2],T=g.data[m+3];if(0===T)P[H++]=0,P[H++]=0,P[H++]=0,P[H++]=1;else{const i=Math.pow(2,T-128-8);P[H++]=_*i,P[H++]=b*i,P[H++]=y*i,P[H++]=1}}}return{data:P,width:T,height:y}}#Od(i){if(i.length<50)return{isValid:!1,format:"unknown",error:"파일이 너무 작습니다"};const m=new TextDecoder("ascii",{fatal:!1}).decode(i.slice(0,50));return m.startsWith("#?RADIANCE")||m.startsWith("#?RGBE")?{isValid:!0,format:"RGBE/Radiance"}:m.includes("RADIANCE")||m.includes("RGBE")?{isValid:!0,format:"RGBE/Radiance (variant)"}:{isValid:!1,format:"unknown",error:"지원되지 않는 HDR 형식입니다"}}#Nd(i,m,g){const _=new Uint8Array(4*g);if(2===i[m]&&2===i[m+1]&&i[m+2]===(g>>8&255)&&i[m+3]===(255&g)){m+=4;for(let b=0;b<4;b++){let y=b;for(;y<4*g;){const b=i[m++];if(b>128){const T=b-128,w=i[m++];for(let i=0;i<T&&y<4*g;i++)_[y]=w,y+=4}else{const T=b;for(let b=0;b<T&&y<4*g;b++)_[y]=i[m++],y+=4}}}}else for(let b=0;b<4*g;b++)_[b]=i[m++];return{data:_,nextOffset:m}}#Fd(i){if(this.#Ud){gt("HDR 정보:"),gt(`크기:${i.width} x ${i.height}`),gt(`데이터 길이:${i.data.length}`),gt("예상 픽셀 수:"+i.width*i.height*4);for(let m=0;m<Math.min(16,i.data.length);m+=4)i.data[m],i.data[m+1],i.data[m+2],i.data[m+3]}}#kd(i){if(this.#Ud)for(let m=0;m<i.length;m+=16)Array.from(i.slice(m,m+16)).map(i=>i.toString(16).padStart(2,"0")).join(" "),Array.from(i.slice(m,m+16)).map(i=>i>=32&&i<=126?String.fromCharCode(i):".").join("")}}async function float32ToFloat16Linear(i,m,g){const _=performance.now(),{gpuDevice:b}=i,{width:y,height:T,workgroupSize:w=[8,8],maxValue:P=1e3}=g,H=m.length/4,$=function(i){return` struct Constants { width:u32, height:u32, }\n @group(0) @binding(0) var<storage,read> inputData:array<f32>; @group(0) @binding(1) var<storage,read_write> outputData:array<u32>; @group(0) @binding(2) var<uniform> constants:Constants;\n fn floatToHalf(value:f32) -> u32 { let bits=bitcast<u32>(value); let sign=(bits >> 16u) & 0x8000u; var exp=(bits >> 23u) & 0xFFu; var mantissa=bits & 0x7FFFFFu;\n if (exp==0u) { return sign; }\n if (exp==255u) { return sign | 0x7C00u | select(0u,1u,mantissa !=0u); }\n let newExp=i32(exp) - 127 + 15; if (newExp <=0) { return sign; } if (newExp >=31) { return sign | 0x7C00u; }\n return sign | (u32(newExp) << 10u) | (mantissa >> 13u); }\n @compute @workgroup_size(${i[0]},${i[1]}) fn main(@builtin(global_invocation_id) global_id:vec3<u32>) { let x=global_id.x; let y=global_id.y;\n if (x >=constants.width || y >=constants.height) { return; }\n let pixelIndex=y * constants.width + x; let baseIndex=pixelIndex * 4u;\n let r=inputData[baseIndex]; let g=inputData[baseIndex + 1u]; let b=inputData[baseIndex + 2u]; let a=inputData[baseIndex + 3u];\n let r16=floatToHalf(r); let g16=floatToHalf(g); let b16=floatToHalf(b); let a16=floatToHalf(a);\n let outputIndex=pixelIndex * 2u; outputData[outputIndex]=(g16 << 16u) | r16; outputData[outputIndex + 1u]=(a16 << 16u) | b16; } `}(w);try{const i=b.createShaderModule({code:$,label:"float16_linear_conversion_shader"}),g=function(i,m,g){const _=i.createBuffer({size:m.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,label:"float16_input_buffer"}),b=i.createBuffer({size:8*g,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC,label:"float16_output_buffer"}),y=i.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"float16_constants_buffer"}),T=i.createBuffer({size:8*g,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:"float16_read_buffer"});return i.queue.writeBuffer(_,0,m),{inputBuffer:_,outputBuffer:b,constantsBuffer:y,readBuffer:T}}(b,m,H);!function(i,m,g,_,b){const y=new ArrayBuffer(16),T=new DataView(y);T.setUint32(0,g,!0),T.setUint32(4,_,!0),T.setFloat32(8,b,!0),i.queue.writeBuffer(m,0,y)}(b,g.constantsBuffer,y,T,P);const{computePipeline:W,bindGroup:q}=function(i,m,g){const _=i.createComputePipeline({layout:"auto",compute:{module:m,entryPoint:"main"},label:"float16_conversion_pipeline"}),b=i.createBindGroup({layout:_.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:g.inputBuffer}},{binding:1,resource:{buffer:g.outputBuffer}},{binding:2,resource:{buffer:g.constantsBuffer}}],label:"float16_conversion_bindgroup"});return{computePipeline:_,bindGroup:b}}(b,i,g),ye=await async function(i,m,g,_,b,y,T,w,P){const H=Math.ceil(y/w[0]),$=Math.ceil(T/w[1]);if(H>65535||$>65535)throw new Error(`이미지 크기 초과:${H} × ${$}`);const W=i.createCommandEncoder(),q=W.beginComputePass();q.setPipeline(m),q.setBindGroup(0,g),q.dispatchWorkgroups(H,$),q.end(),W.copyBufferToBuffer(_,0,b,0,8*P),i.queue.submit([W.finish()]),await b.mapAsync(GPUMapMode.READ);const ye=new Uint32Array(b.getMappedRange()),Ge=new Uint16Array(ye.buffer.slice(ye.byteOffset,ye.byteOffset+ye.byteLength));return b.unmap(),Ge}(b,W,q,g.outputBuffer,g.readBuffer,y,T,w,H);!function(i){i.inputBuffer.destroy(),i.outputBuffer.destroy(),i.constantsBuffer.destroy(),i.readBuffer.destroy()}(g);return{data:ye,processedPixels:H,executionTime:performance.now()-_}}catch(i){throw console.error("Float16 변환 실패:",i),i}}class HDRTexture extends ManagementResourceBase{#U;#A;#O;#k;#Vd;#F=0;#zd=1024;#Hd=new HDRLoader;#V;#z;#H;#$d=!1;#Kd=null;constructor(i,m,g,_,b=1024,y=!0){if(super(i,"managedHDRTextureState"),this.#z=g,this.#H=_,this.#V="rgba16float",this.#zd=b,this.#k=y,this.#O=this.#k?getMipLevelCount(this.#zd,this.#zd):1,m){const i=this.#$(m);this.#Wd(i),this.#A=i,this.cacheKey=this.#K(m);const{table:g}=this.targetResourceManagedState;let _=g.get(this.cacheKey);if(_){const i=_.texture;return this.#z?.(i),i}this.src=m,this.#W()}}get videoMemorySize(){return this.#F}get gpuTexture(){return this.#U}get mipLevelCount(){return this.#O}get src(){return this.#A}set src(i){const m=this.#$(i);this.#Wd(m),this.#A=m,this.cacheKey=this.#K(i),this.#$d=!1,this.#A&&this.#jd(this.#A)}get useMipmap(){return this.#k}set useMipmap(i){this.#k!==i&&(this.#k=i,this.#O=this.#k?getMipLevelCount(this.#zd,this.#zd):1,this.#$d=!1,this.#X())}get viewDescriptor(){return{...CubeTexture.defaultViewDescriptor,mipLevelCount:this.#O}}static isSupportedFormat(i){return!(!i||"string"!=typeof i)&&i.toLowerCase().endsWith(".hdr")}static getSupportedFormats(){return[".hdr"]}destroy(){const i=this.#U;this.#q(null),this.#Kd&&(this.#Kd.destroy(),this.#Kd=null),this.#$d=!1,this.__fireListenerList(!0),this.#Y(),this.#A=null,this.cacheKey=null,i&&i.destroy()}#K(i){let m;return i||(m=this.uuid),m="string"==typeof i?getAbsoluteURL(window.location.href,i):i.cacheKey||getAbsoluteURL(window.location.href,i.src),`HDRTexture_${m}`}#$(i){return"string"==typeof i?i:i.src}#Wd(i){if(!i||"string"!=typeof i)throw new Error("HDR 파일 경로가 필요합니다");if(!i.split("?")[0].split("#")[0].toLowerCase().endsWith(".hdr"))throw new Error(`지원되지 않는 형식입니다. .hdr 형식만 지원됩니다. 입력된 파일:${i}`)}async#jd(i){try{const m=await this.#Hd.loadHDRFile(i);this.#Vd=m,await this.#X(),this.#z?.(this)}catch(i){console.error("HDR loading error (.hdr 형식):",i),this.#H?.(i)}}#q(i){this.#U=i,i||(this.#Vd=null,this.#$d=!1),this.__fireListenerList()}#W(){this.redGPUContext.resourceManager.registerManagementResource(this,new ResourceStateHDRTexture(this))}#Y(){this.redGPUContext.resourceManager.unregisterManagementResource(this)}async#X(){const{gpuDevice:i,resourceManager:m}=this.redGPUContext;if(this.#$d&&this.#U)return void await this.#Xd();await i.queue.onSubmittedWorkDone();const g=this.#U;this.#U=null;const _={size:[this.#zd,this.#zd,6],format:this.#V,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,mipLevelCount:this.#O,dimension:"2d",label:`${this.#A}_cubemap`},b=m.createManagedTexture(_);this.#q(b),this.#O=_.mipLevelCount||1,await this.#Xd(),this.#$d=!0,g&&(await i.queue.onSubmittedWorkDone(),g.destroy())}async#Xd(i=!1){const{gpuDevice:m,resourceManager:g}=this.redGPUContext;if(this.#U&&this.#Vd){if(!i||!this.#Kd){this.#Kd&&this.#Kd.destroy();const{width:i,height:_}=this.#Vd,b={size:[i,_],format:this.#V,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,label:`${this.#A}_temp_source`};this.#Kd=await this.#qd(m,g,this.#Vd,b)}for(let i=0;i<this.#O;i++){const m=i/(this.#O-1);await this.#Yd(this.#Kd,i,m*m)}this.targetResourceManagedState.videoMemory-=this.#F,this.#F=calculateTextureByteSize(this.#U),this.targetResourceManagedState.videoMemory+=this.#F}}async#Yd(i,m=0,g=0){const{gpuDevice:_}=this.redGPUContext,b=_.createShaderModule({code:"struct VertexOutput { @builtin(position) position:vec4<f32>, @location(0) texCoord:vec2<f32>,\n}\n@vertex fn vs_main(@builtin(vertex_index) vertexIndex:u32) -> VertexOutput { var pos=array<vec2<f32>,6>( vec2<f32>(-1.0,-1.0),vec2<f32>( 1.0,-1.0),vec2<f32>(-1.0,1.0), vec2<f32>(-1.0,1.0),vec2<f32>( 1.0,-1.0),vec2<f32>( 1.0,1.0) ); var texCoord=array<vec2<f32>,6>( vec2<f32>(0.0,1.0),vec2<f32>(1.0,1.0),vec2<f32>(0.0,0.0), vec2<f32>(0.0,0.0),vec2<f32>(1.0,1.0),vec2<f32>(1.0,0.0) ); var output:VertexOutput; output.position=vec4<f32>(pos[vertexIndex],0.0,1.0); output.texCoord=texCoord[vertexIndex]; return output;\n}\nstruct SceneUniforms { faceMatrix:mat4x4<f32>, roughness:f32,\n}\nconst PI:f32=3.14159265359;\nfn radicalInverse_VdC(bits_in:u32) -> f32 { var bits=bits_in; bits=(bits << 16u) | (bits >> 16u); bits=((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u); bits=((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u); bits=((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u); bits=((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u); return f32(bits) * 2.3283064365386963e-10;\n}\nfn hammersley(i:u32,n:u32) -> vec2<f32> { return vec2<f32>(f32(i)/f32(n),radicalInverse_VdC(i));\n}\nfn importanceSampleGGX(xi:vec2<f32>,N:vec3<f32>,roughness:f32) -> vec3<f32> { let a=roughness * roughness; let phi=2.0 * PI * xi.x; let cosTheta=sqrt((1.0 - xi.y)/(1.0 + (a * a - 1.0) * xi.y)); let sinTheta=sqrt(1.0 - cosTheta * cosTheta); let H=vec3<f32>(cos(phi) * sinTheta,sin(phi) * sinTheta,cosTheta); let up=select(vec3<f32>(1.0,0.0,0.0),vec3<f32>(0.0,0.0,1.0),abs(N.z) < 0.999); let tangent=normalize(cross(up,N)); let bitangent=cross(N,tangent); return normalize(tangent * H.x + bitangent * H.y + N * H.z);\n}\n@group(0) @binding(0) var equirectangularTexture:texture_2d<f32>;\n@group(0) @binding(1) var textureSampler:sampler;\n@group(0) @binding(2) var<uniform> uniforms:SceneUniforms;\n@fragment fn fs_main(input:VertexOutput) -> @location(0) vec4<f32> { let x=input.texCoord.x * 2.0 - 1.0; let y=input.texCoord.y * 2.0 - 1.0; let localPos=vec4<f32>(x,y,1.0,1.0); let N=normalize((uniforms.faceMatrix * localPos).xyz); let R=N; let V=R; let roughness=uniforms.roughness; if (roughness==0.0) { let theta=atan2(N.x,N.z); let phi=acos(clamp(N.y,-1.0,1.0)); return textureSampleLevel(equirectangularTexture,textureSampler,vec2<f32>(0.5 - theta/(2.0 * PI),phi/PI),0.0); } var prefilteredColor=vec3<f32>(0.0); var totalWeight=0.0; let numSamples=1024u; for (var i=0u;i < numSamples;i++) { let xi=hammersley(i,numSamples); let H=importanceSampleGGX(xi,N,roughness); let L=normalize(2.0 * dot(V,H) * H - V); let NdotL=max(dot(N,L),0.0); if (NdotL > 0.0) { let theta=atan2(L.x,L.z); let phi=acos(clamp(L.y,-1.0,1.0)); prefilteredColor +=textureSampleLevel(equirectangularTexture,textureSampler,vec2<f32>(0.5 - theta/(2.0 * PI),phi/PI),0.0).rgb * NdotL; totalWeight +=NdotL; } } return vec4<f32>(prefilteredColor/totalWeight,1.0);\n}"}),y=_.createRenderPipeline({layout:"auto",vertex:{module:b,entryPoint:"vs_main"},fragment:{module:b,entryPoint:"fs_main",targets:[{format:this.#V}]}}),T=new Sampler(this.redGPUContext,{magFilter:bt.LINEAR,minFilter:bt.LINEAR,addressModeU:vt.CLAMP_TO_EDGE,addressModeV:vt.CLAMP_TO_EDGE}),w=this.#Zd();for(let _=0;_<6;_++)await this.#Jd(y,T,_,w[_],i,m,g)}async#Qd(i){return(await float32ToFloat16Linear(this.redGPUContext,i,{width:this.#Vd.width,height:this.#Vd.height,workgroupSize:[8,8]})).data}async#qd(i,m,g,_){const b=i.createTexture(_);let y,T;if("rgba16float"!==this.#V)throw new Error(`지원되지 않는 텍스처 포맷:${this.#V}`);y=8;T=(await this.#Qd(g.data)).buffer;return i.queue.writeTexture({texture:b},T,{bytesPerRow:g.width*y,rowsPerImage:g.height},{width:g.width,height:g.height}),b}#Zd(){return[new Float32Array([0,0,-1,0,0,-1,0,0,1,0,0,0,0,0,0,1]),new Float32Array([0,0,1,0,0,-1,0,0,-1,0,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,0,-1,0,0,-1,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,1]),new Float32Array([-1,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,1])]}async#Jd(i,m,g,_,b,y=0,T=0){const{gpuDevice:w}=this.redGPUContext,P=new Float32Array(32);P.set(_,0),P[16]=T;const H=w.createBuffer({size:P.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});w.queue.writeBuffer(H,0,P);const $=w.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:b.createView()},{binding:1,resource:m.gpuSampler},{binding:2,resource:{buffer:H}}]}),W=w.createCommandEncoder(),q=W.beginRenderPass({colorAttachments:[{view:this.#U.createView({dimension:"2d",baseMipLevel:y,mipLevelCount:1,baseArrayLayer:g,arrayLayerCount:1}),clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}]});q.setPipeline(i),q.setBindGroup(0,$),q.draw(6,1,0,0),q.end(),w.queue.submit([W.finish()]),H.destroy()}}Object.freeze(HDRTexture);class IBLCubeTexture extends ManagementResourceBase{#U;#O;#k=!0;#F=0;#V;constructor(i,m,g){super(i,"managedCubeTextureState"),this.cacheKey=m;const{table:_}=this.targetResourceManagedState;if(m){let i=_.get(m);if(i)return i.texture;g&&this.#q(g),this.#W()}}get viewDescriptor(){return{...CubeTexture.defaultViewDescriptor,mipLevelCount:this.#O}}get format(){return this.#V}get videoMemorySize(){return this.#F}get gpuTexture(){return this.#U}set gpuTexture(i){this.#q(i)}get mipLevelCount(){return this.#O}get useMipmap(){return this.#k}destroy(){const i=this.#U;this.#q(null),this.__fireListenerList(!0),this.#Y(),this.cacheKey=null,i&&i.destroy()}#q(i){this.targetResourceManagedState.videoMemory-=this.#F,this.#U=i,i&&(this.#O=i.mipLevelCount,this.#k=i.mipLevelCount>1,this.#V=i.format,this.#F=calculateTextureByteSize(i)),this.targetResourceManagedState.videoMemory+=this.#F,this.__fireListenerList()}#W(){this.redGPUContext.resourceManager.registerManagementResource(this,new ResourceStateCubeTexture(this))}#Y(){this.redGPUContext.resourceManager.unregisterManagementResource(this)}}Object.freeze(IBLCubeTexture);class IBL{#l;#em;#tm;#nm;#rm;#u=createUUID();#V="rgba16float";#im;#am;#sm;constructor(i,m,g=1024,_=512){const b=`${m}?key=${g}_${_}`;this.#sm=_,this.#am=g,this.#l=i,this.#tm=new IBLCubeTexture(i,`IBL_ENV_${b}`),this.#rm=new IBLCubeTexture(i,`IBL_${b}`),this.#nm=new IBLCubeTexture(i,`IBL_IRRADIANCE_${b}`),this.#im="string"==typeof m?new HDRTexture(i,b,i=>{this.#em=i.gpuTexture,this.#ft()},void 0,g,!0):new CubeTexture(i,m,!0,i=>{this.#em=i.gpuTexture,this.#ft()})}get envCubeSize(){return this.#am}get iblCubeSize(){return this.#sm}get irradianceTexture(){return this.#nm}get environmentTexture(){return this.#tm}get iblTexture(){return this.#rm}async#ft(){const{downSampleCubeMapGenerator:i}=this.#l.resourceManager;if(this.#em){if(!this.#rm.gpuTexture){const m=await i.downsampleCubemap(this.#em,this.#sm);this.#rm.gpuTexture=m}if(this.#tm.gpuTexture||(this.#tm.gpuTexture=this.#em),!this.#nm.gpuTexture){const i=await this.#om(this.#em);this.#nm.gpuTexture=i}}}async#om(i){const{gpuDevice:m,resourceManager:g}=this.#l,_=g.createManagedTexture({size:[32,32,6],format:this.#V,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,dimension:"2d",mipLevelCount:1,label:`IBL_${this.#u}_irradianceTexture`}),b=m.createShaderModule({code:"struct VertexOutput { @builtin(position) position:vec4<f32>, @location(0) texCoord:vec2<f32>,\n}\n@vertex fn vs_main(@builtin(vertex_index) vertexIndex:u32) -> VertexOutput { var pos=array<vec2<f32>,6>( vec2<f32>(-1.0,-1.0),vec2<f32>( 1.0,-1.0),vec2<f32>(-1.0,1.0), vec2<f32>(-1.0,1.0),vec2<f32>( 1.0,-1.0),vec2<f32>( 1.0,1.0) ); var texCoord=array<vec2<f32>,6>( vec2<f32>(0.0,1.0),vec2<f32>(1.0,1.0),vec2<f32>(0.0,0.0), vec2<f32>(0.0,0.0),vec2<f32>(1.0,1.0),vec2<f32>(1.0,0.0) ); var output:VertexOutput; output.position=vec4<f32>(pos[vertexIndex],0.0,1.0); output.texCoord=texCoord[vertexIndex]; return output;\n}\n@group(0) @binding(0) var environmentTexture:texture_cube<f32>;\n@group(0) @binding(1) var environmentSampler:sampler;\n@group(0) @binding(2) var<uniform> faceMatrix:mat4x4<f32>;\nconst PI=3.14159265359;\nfn radicalInverse_VdC(bits_in:u32) -> f32 { var bits=bits_in; bits=(bits << 16u) | (bits >> 16u); bits=((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u); bits=((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u); bits=((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u); bits=((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u); return f32(bits) * 2.3283064365386963e-10;\n}\nfn hammersley(i:u32,n:u32) -> vec2<f32> { return vec2<f32>(f32(i)/f32(n),radicalInverse_VdC(i));\n}\n@fragment fn fs_main(input:VertexOutput) -> @location(0) vec4<f32> { let x=input.texCoord.x * 2.0 - 1.0; let y=input.texCoord.y * 2.0 - 1.0; let localPos=vec4<f32>(x,y,1.0,1.0); let normal=normalize((faceMatrix * localPos).xyz); let s=select(1.0,-1.0,normal.z < 0.0); let a=-1.0/(s + normal.z); let b=normal.x * normal.y * a; let tangent=vec3<f32>(1.0 + s * normal.x * normal.x * a,s * b,-s * normal.x); let bitangent=vec3<f32>(b,s + normal.y * normal.y * a,-normal.y); var irradiance=vec3<f32>(0.0); var totalWeight=0.0; let totalSamples=1024u; let envSize=f32(textureDimensions(environmentTexture).x); let saTexel=4.0 * PI/(6.0 * envSize * envSize); for (var i=0u;i < totalSamples;i++) { let xi=hammersley(i,totalSamples); let phi=2.0 * PI * xi.x; let cosTheta=sqrt(1.0 - xi.y); let sinTheta=sqrt(xi.y); let sampleVec=vec3<f32>(sinTheta * cos(phi),sinTheta * sin(phi),cosTheta); let worldSample=normalize(tangent * sampleVec.x + bitangent * sampleVec.y + normal * sampleVec.z); let pdf=max(cosTheta,0.001)/PI; let saSample=1.0/(f32(totalSamples) * pdf + 0.0001); let mipLevel=select(0.5 * log2(saSample/saTexel),0.0,saSample <=0.0); let sampleColor=textureSampleLevel(environmentTexture,environmentSampler,worldSample,mipLevel); irradiance +=sampleColor.rgb; totalWeight +=1.0; } irradiance=irradiance/totalWeight; return vec4<f32>(irradiance,1.0);\n}"}),y=m.createRenderPipeline({layout:"auto",vertex:{module:b,entryPoint:"vs_main"},fragment:{module:b,entryPoint:"fs_main",targets:[{format:this.#V}]}}),T=new Sampler(this.#l,{magFilter:bt.LINEAR,minFilter:bt.LINEAR,mipmapFilter:yt.LINEAR,addressModeU:vt.CLAMP_TO_EDGE,addressModeV:vt.CLAMP_TO_EDGE,addressModeW:vt.CLAMP_TO_EDGE}),w=this.#Zd();for(let m=0;m<6;m++)await this.#um(y,T,m,w[m],i,_);return _}async#um(i,m,g,_,b,y){const{gpuDevice:T}=this.#l,w=T.createBuffer({size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:`irradiance_face_${g}_uniform`});T.queue.writeBuffer(w,0,_);const P=T.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:b.createView({dimension:"cube"})},{binding:1,resource:m.gpuSampler},{binding:2,resource:{buffer:w}}]}),H=T.createCommandEncoder({label:`ibl_irradiance_face_${g}_encoder`}),$=H.beginRenderPass({colorAttachments:[{view:y.createView({dimension:"2d",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:g,arrayLayerCount:1}),clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}],label:`irradiance_face_${g}_renderpass`});$.setPipeline(i),$.setBindGroup(0,P),$.draw(6,1,0,0),$.end(),T.queue.submit([H.finish()]),w.destroy()}#Zd(){return[new Float32Array([0,0,-1,0,0,-1,0,0,1,0,0,0,0,0,0,1]),new Float32Array([0,0,1,0,0,-1,0,0,-1,0,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,0,-1,0,0,-1,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,1]),new Float32Array([-1,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,1])]}}Object.freeze(IBL);const Ba={MODE_1D:1,MODE_2D:2,MODE_3D:3};Object.freeze(Ba);const Ia="managedBitmapTextureState",Ea={animationSpeed:1,animationX:.1,animationY:.1};class ANoiseTexture extends ManagementResourceBase{mipLevelCount;useMipmap;src;#U;#ie=8;#ae=8;#yr=1;#Sr;#Tr;#Mr;#wr;#Bn;#lm;#pt;#gt;#cm;#hm=0;#fm=1;#dm=Ea.animationX;#mm=Ea.animationY;#F=0;constructor(i,m=1024,g=1024,_){super(i,Ia),validateUintRange(m,2,2048),validateUintRange(g,2,2048),this.#pt=m,this.#gt=g,this.#cm=_,this.#ft(i),this.cacheKey=`NoiseTexture_${m}x${g}_${Date.now()}`,this.#U=this.#Kr(i,m,g),this.#F=calculateTextureByteSize(this.#U),this.#jr(),this.#W()}get videoMemorySize(){return this.#F}get resourceManagerKey(){return Ia}get animationSpeed(){return this.#fm}set animationSpeed(i){validatePositiveNumberRange(i),this.#fm=i,this.updateUniform("animationSpeed",i)}get animationX(){return this.#dm}set animationX(i){validateNumber(i),this.#dm=i,this.updateUniform("animationX",i)}get animationY(){return this.#mm}set animationY(i){validateNumber(i),this.#mm=i,this.updateUniform("animationY",i)}get uniformInfo(){return this.#lm}get gpuTexture(){return this.#U}get time(){return this.#hm}set time(i){validatePositiveNumberRange(i),this.#hm=i,this.updateUniform("time",i/1e3)}updateUniform(i,m){this.#lm.members[i]&&(this.#Bn.writeOnlyBuffer(this.#lm.members[i],m),this.#cm[i]=m),this.#jr()}updateUniforms(i){Object.entries(i).forEach(([i,m])=>{this.#lm.members[i]&&(this.#Bn.writeOnlyBuffer(this.#lm.members[i],m),this.#cm[i]=m)}),this.#jr()}render(i){this.updateUniform("time",i),this.#jr()}destroy(){const i=this.#U;this.__fireListenerList(!0),this.#Y(),i&&i.destroy(),this.src=null,this.cacheKey=null,this.#U=null}#ft(i){const{gpuDevice:m}=i,g=this.#pm();this.cacheKey=this.uuid,this.#Sr=m.createShaderModule({code:g}),this.#Mr=this.#Hr(i),this.#wr=this.#$r(m,this.#Sr,this.#Mr);const _=parseWGSL(g);this.#lm=_.uniforms.uniforms;const b=new ArrayBuffer(this.#lm.arrayBufferByteLength);this.#Bn=new UniformBuffer(i,b,`${this.constructor.name}_UniformBuffer`),this.#cm.uniformDefaults&&this.updateUniforms({...Ea,...this.#cm.uniformDefaults})}#pm(){return` ${` struct Uniforms { time:f32, animationSpeed:f32, animationX:f32, animationY:f32, ${this.#cm.uniformStruct||""} }; `} @group(0) @binding(0) var<uniform> uniforms:Uniforms; @group(0) @binding(1) var outputTexture:texture_storage_2d<rgba8unorm,write>;  ${this.#cm.helperFunctions||""} @compute @workgroup_size(${this.#ie},${this.#ae},${this.#yr}) fn main ( @builtin(global_invocation_id) global_id:vec3<u32>, ){ let index=vec2<u32>(global_id.xy); let dimensions:vec2<u32>=textureDimensions(outputTexture);  if (index.x >=dimensions.x || index.y >=dimensions.y) { return; }  let dimW=f32(dimensions.x); let dimH=f32(dimensions.y); let base_uv=vec2<f32>((f32(index.x) + 0.5)/dimW,(f32(index.y) + 0.5)/dimH); ${this.#cm.mainLogic}  textureStore(outputTexture,index,finalColor); } `}#jr(){if(!this.#Tr)return;const i=this.redGPUContext.gpuDevice.createCommandEncoder(),m=i.beginComputePass();m.setPipeline(this.#wr),m.setBindGroup(0,this.#Tr),m.dispatchWorkgroups(Math.ceil(this.#pt/this.#ie),Math.ceil(this.#gt/this.#ae)),m.end(),this.redGPUContext.gpuDevice.queue.submit([i.finish()])}#Hr(i){return i.resourceManager.createBindGroupLayout("NoiseTextureBindGroupLayout",{entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm"}}]})}#Kr(i,m,g){const _=i.gpuDevice.createTexture({size:{width:m,height:g},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING,label:this.cacheKey}),b=_.createView();return this.#Tr=this.#Wr(i,this.#Mr,b),_}#Wr(i,m,g){return i.gpuDevice.createBindGroup({layout:m,entries:[{binding:0,resource:{buffer:this.#Bn.gpuBuffer,offset:0,size:this.#Bn.gpuBuffer.size}},{binding:1,resource:g}]})}#$r(i,m,g){return i.createComputePipeline({layout:i.createPipelineLayout({bindGroupLayouts:[g]}),compute:{module:m,entryPoint:"main"}})}#W(){this.redGPUContext.resourceManager.registerManagementResource(this,new ResourceStateBitmapTexture(this))}#Y(){this.redGPUContext.resourceManager.unregisterManagementResource(this)}}const mergerNoiseUniformStruct=(i,m)=>[i,m].filter(Boolean).join("\n"),mergerNoiseUniformDefault=(i,m)=>({...i,...m||{}}),mergerNoiseHelperFunctions=(i,m)=>[i,m].filter(Boolean).join("\n");const Da=Object.values(Ba),La={frequency:8,amplitude:1,octaves:1,persistence:.5,lacunarity:2,seed:0,noiseDimension:Ba.MODE_2D};const Ua={EUCLIDEAN:0,MANHATTAN:1,CHEBYSHEV:2};Object.freeze(Ua);const Aa={F1:0,F2:1,F2_MINUS_F1:2,F1_PLUS_F2:3,CELL_ID:4,CELL_ID_COLOR:5};Object.freeze(Aa);const Oa=Object.values(Ua),ka=Object.values(Aa),Ga={frequency:8,distanceScale:1,octaves:1,persistence:.5,lacunarity:2,seed:0,distanceType:Ua.EUCLIDEAN,outputType:Aa.F1,jitter:1,cellIdColorIntensity:1};var Fa=Object.freeze({__proto__:null,ANoiseTexture:ANoiseTexture,mergerNoiseHelperFunctions:mergerNoiseHelperFunctions,mergerNoiseUniformDefault:mergerNoiseUniformDefault,mergerNoiseUniformStruct:mergerNoiseUniformStruct}),Na=Object.freeze({__proto__:null,ShaderVariantGenerator:ShaderVariantGenerator,WGSLUniformTypes:WGSLUniformTypes,ensureVertexIndexBuiltin:ensureVertexIndexBuiltin,preprocessWGSL:preprocessWGSL}),Va=Object.freeze({__proto__:null,BitmapTexture:BitmapTexture,Core:Ca,CoreBuffer:Ra,CoreNoiseTexture:Fa,CoreVertexBuffer:Pa,CoreWGSLParser:Na,CubeTexture:CubeTexture,HDRTexture:HDRTexture,IBL:IBL,IndexBuffer:IndexBuffer,NOISE_DIMENSION:Ba,PackedTexture:PackedTexture,Sampler:Sampler,SimplexTexture:class extends ANoiseTexture{#gm=La.frequency;#xm=La.amplitude;#_m=La.octaves;#vm=La.persistence;#bm=La.lacunarity;#ym=La.seed;#Sm=La.noiseDimension;constructor(i,m=1024,g=1024,_){super(i,m,g,{..._,mainLogic:_?.mainLogic||" let uv=vec2<f32>( (base_uv.x + uniforms.time * ( uniforms.animationX * uniforms.animationSpeed )), (base_uv.y + uniforms.time * ( uniforms.animationY * uniforms.animationSpeed ))  ); let noise=getSimplexNoiseByDimension( uv,uniforms );  let finalColor=vec4<f32>(noise,noise,noise,1.0); ",uniformStruct:mergerNoiseUniformStruct(" noiseDimension:f32, frequency:f32, amplitude:f32, octaves:i32, persistence:f32, lacunarity:f32, seed:f32, ",_?.uniformStruct),uniformDefaults:mergerNoiseUniformDefault(La,_?.uniformDefaults),helperFunctions:mergerNoiseHelperFunctions("\nfn mod289_vec3(x:vec3<f32>) -> vec3<f32> { return x - floor(x * (1.0/289.0)) * 289.0;\n}\nfn mod289_vec2(x:vec2<f32>) -> vec2<f32> { return x - floor(x * (1.0/289.0)) * 289.0;\n}\nfn mod289_vec4(x:vec4<f32>) -> vec4<f32> { return x - floor(x * (1.0/289.0)) * 289.0;\n}\nfn mod289_f32(x:f32) -> f32 { return x - floor(x * (1.0/289.0)) * 289.0;\n}\nfn permute(x:vec3<f32>) -> vec3<f32> { return mod289_vec3(((x * 34.0) + 1.0) * x);\n}\nfn permute4(x:vec4<f32>) -> vec4<f32> { return mod289_vec4(((x * 34.0) + 1.0) * x);\n}\nfn permute_f32(x:f32) -> f32 { return mod289_f32(((x * 34.0) + 1.0) * x);\n}\nfn taylorInvSqrt4(r:vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r;\n}\nfn simplex1D(x:f32) -> f32 { var i=floor(x); let f=fract(x); let g0=select(-1.0,1.0,(permute_f32(i) * 0.024390243902439) >=0.5); let g1=select(-1.0,1.0,(permute_f32(i + 1.0) * 0.024390243902439) >=0.5); let d0=f; let d1=f - 1.0; let t=f * f * f * (f * (f * 6.0 - 15.0) + 10.0); let n0=g0 * d0; let n1=g1 * d1; return mix(n0,n1,t) * 0.395;\n}\nfn simplex2D(v:vec2<f32>) -> f32 { let C=vec4<f32>(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439); var i=floor(v + dot(v,C.yy)); let x0=v - i + dot(i,C.xx); let i1=select(vec2<f32>(0.0,1.0),vec2<f32>(1.0,0.0),x0.x > x0.y); var x12=x0.xyxy + C.xxzz; x12.x=x12.x - i1.x; x12.y=x12.y - i1.y; i=mod289_vec2(i); let p=permute(permute(i.y + vec3<f32>(0.0,i1.y,1.0)) + i.x + vec3<f32>(0.0,i1.x,1.0)); var m=max(0.5 - vec3<f32>(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),vec3<f32>(0.0)); m=m * m; m=m * m; let x=2.0 * fract(p * C.www) - 1.0; let h=abs(x) - 0.5; let ox=floor(x + 0.5); let a0=x - ox; m=m * (1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h)); let g=vec3<f32>(a0.x * x0.x + h.x * x0.y,a0.y * x12.x + h.y * x12.y,a0.z * x12.z + h.z * x12.w); return 130.0 * dot(m,g);\n}\nfn simplex3D(v:vec3<f32>) -> f32 { let C=vec2<f32>(1.0/6.0,1.0/3.0); let D=vec4<f32>(0.0,0.5,1.0,2.0); var i=floor(v + dot(v,C.yyy)); let x0=v - i + dot(i,C.xxx); let g=step(x0.yzx,x0.xyz); let l=1.0 - g; let i1=min(g.xyz,l.zxy); let i2=max(g.xyz,l.zxy); let x1=x0 - i1 + C.xxx; let x2=x0 - i2 + C.yyy; let x3=x0 - D.yyy; i=mod289_vec3(i); let p=permute4(permute4(permute4( i.z + vec4<f32>(0.0,i1.z,i2.z,1.0 )) + i.y + vec4<f32>(0.0,i1.y,i2.y,1.0 )) + i.x + vec4<f32>(0.0,i1.x,i2.x,1.0 )); let n_=0.142857142857; let ns=n_ * D.wyz - D.xzx; let j=p - 49.0 * floor(p * ns.z * ns.z); let x_=floor(j * ns.z); let y_=floor(j - 7.0 * x_ ); let x=x_ *ns.x + ns.yyyy; let y=y_ *ns.x + ns.yyyy; let h=1.0 - abs(x) - abs(y); let b0=vec4<f32>( x.xy,y.xy ); let b1=vec4<f32>( x.zw,y.zw ); let s0=floor(b0)*2.0 + 1.0; let s1=floor(b1)*2.0 + 1.0; let sh=-step(h,vec4<f32>(0.0)); let a0=b0.xzyw + s0.xzyw*sh.xxyy; let a1=b1.xzyw + s1.xzyw*sh.zzww; var p0=vec3<f32>(a0.xy,h.x); var p1=vec3<f32>(a0.zw,h.y); var p2=vec3<f32>(a1.xy,h.z); var p3=vec3<f32>(a1.zw,h.w); let norm=taylorInvSqrt4(vec4<f32>(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3))); p0 *=norm.x; p1 *=norm.y; p2 *=norm.z; p3 *=norm.w; var m=max(0.6 - vec4<f32>(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),vec4<f32>(0.0)); m=m * m; return 42.0 * dot( m*m,vec4<f32>( dot(p0,x0),dot(p1,x1), dot(p2,x2),dot(p3,x3) ) );\n}\nfn fbm1D(pos:f32,octaves:i32) -> f32 { var value=0.0; var amplitude=0.5; var frequency=1.0; var max_value=0.0; for (var i=0;i < octaves;i++) { if (i >=octaves) { break;} value +=simplex1D(pos * frequency) * amplitude; max_value +=amplitude; amplitude *=0.5; frequency *=2.0; } return value/max_value;\n}\nfn fbm(pos:vec2<f32>,octaves:i32) -> f32 { var value=0.0; var amplitude=0.5; var frequency=1.0; var max_value=0.0; for (var i=0;i < octaves;i++) { if (i >=octaves) { break;} value +=simplex2D(pos * frequency) * amplitude; max_value +=amplitude; amplitude *=0.5; frequency *=2.0; } return value/max_value;\n}\nfn fbm3D(pos:vec3<f32>,octaves:i32) -> f32 { var value=0.0; var amplitude=0.5; var frequency=1.0; var max_value=0.0; for (var i=0;i < octaves;i++) { if (i >=octaves) { break;} value +=simplex3D(pos * frequency) * amplitude; max_value +=amplitude; amplitude *=0.5; frequency *=2.0; } return value/max_value;\n}\nfn getSimplexNoise1D(pos:f32,uniforms:Uniforms) -> f32 { var total_amplitude:f32=0.0; var noise_value:f32=0.0; var current_amplitude:f32=1.0; var current_frequency:f32=uniforms.frequency; for (var i:i32=0;i < uniforms.octaves;i++) { let noise_pos=(pos + uniforms.seed) * current_frequency; let octave_noise=simplex1D(noise_pos); noise_value +=octave_noise * current_amplitude; total_amplitude +=current_amplitude; current_amplitude *=uniforms.persistence; current_frequency *=uniforms.lacunarity; } noise_value/=total_amplitude; noise_value *=uniforms.amplitude; let normalized_noise=(noise_value + 1.0) * 0.5; return normalized_noise;\n}\nfn getSimplexNoise2D(uv:vec2<f32>,uniforms:Uniforms) -> f32 { var total_amplitude:f32=0.0; var noise_value:f32=0.0; var current_amplitude:f32=1.0; var current_frequency:f32=uniforms.frequency; for (var i:i32=0;i < uniforms.octaves;i++) { let noise_pos=(uv + uniforms.seed) * current_frequency; let octave_noise=simplex2D(noise_pos); noise_value +=octave_noise * current_amplitude; total_amplitude +=current_amplitude; current_amplitude *=uniforms.persistence; current_frequency *=uniforms.lacunarity; } noise_value/=total_amplitude; noise_value *=uniforms.amplitude; let normalized_noise=(noise_value + 1.0) * 0.5; return normalized_noise;\n}\nfn getSimplexNoise3D(pos:vec3<f32>,uniforms:Uniforms) -> f32 { var total_amplitude:f32=0.0; var noise_value:f32=0.0; var current_amplitude:f32=1.0; var current_frequency:f32=uniforms.frequency; for (var i:i32=0;i < uniforms.octaves;i++) { let noise_pos=(pos + vec3<f32>(uniforms.seed)) * current_frequency; let octave_noise=simplex3D(noise_pos); noise_value +=octave_noise * current_amplitude; total_amplitude +=current_amplitude; current_amplitude *=uniforms.persistence; current_frequency *=uniforms.lacunarity; } noise_value/=total_amplitude; noise_value *=uniforms.amplitude; let normalized_noise=(noise_value + 1.0) * 0.5; return normalized_noise;\n}\nfn getSimplexNoiseByDimension(uv:vec2<f32>,uniforms:Uniforms) -> f32 { if (uniforms.noiseDimension < 1.1) { return getSimplexNoise1D(uv.x,uniforms); } else if (uniforms.noiseDimension < 2.1) { return getSimplexNoise2D(uv,uniforms); } else if (uniforms.noiseDimension < 3.1) { return getSimplexNoise3D(vec3<f32>(uv.x,uv.y,uniforms.seed * 0.1),uniforms); } else { return getSimplexNoise2D(uv,uniforms); }\n}\n",_?.helperFunctions)})}get noiseDimension(){return this.#Sm}set noiseDimension(i){Da.includes(i)?(this.#Sm=i,this.updateUniform("noiseDimension",i)):consoleAndThrowError(`Invalid value for noiseDimension. Received ${i}. Expected one of:${Da.join(",")}`)}get frequency(){return this.#gm}set frequency(i){validatePositiveNumberRange(i),this.#gm=i,this.updateUniform("frequency",i)}get amplitude(){return this.#xm}set amplitude(i){validatePositiveNumberRange(i),this.#xm=i,this.updateUniform("amplitude",i)}get octaves(){return this.#_m}set octaves(i){validateUintRange(i,1,8),this.#_m=i,this.updateUniform("octaves",i)}get persistence(){return this.#vm}set persistence(i){validatePositiveNumberRange(i,0,1),this.#vm=i,this.updateUniform("persistence",i)}get lacunarity(){return this.#bm}set lacunarity(i){validatePositiveNumberRange(i),this.#bm=i,this.updateUniform("lacunarity",i)}get seed(){return this.#ym}set seed(i){this.#ym=i,this.updateUniform("seed",i)}randomizeSeed(){this.seed=1e3*Math.random()}getSettings(){return{frequency:this.#gm,amplitude:this.#xm,octaves:this.#_m,persistence:this.#vm,lacunarity:this.#bm,seed:this.#ym}}applySettings(i){void 0!==i.frequency&&(this.frequency=i.frequency),void 0!==i.amplitude&&(this.amplitude=i.amplitude),void 0!==i.octaves&&(this.octaves=i.octaves),void 0!==i.persistence&&(this.persistence=i.persistence),void 0!==i.lacunarity&&(this.lacunarity=i.lacunarity),void 0!==i.seed&&(this.seed=i.seed)}},StorageBuffer:StorageBuffer,UniformBuffer:UniformBuffer,VORONOI_DISTANCE_TYPE:Ua,VORONOI_OUTPUT_TYPE:Aa,VertexBuffer:VertexBuffer,VertexInterleaveType:VertexInterleaveType,VertexInterleavedStruct:VertexInterleavedStruct,VoronoiTexture:class extends ANoiseTexture{#gm=Ga.frequency;#Tm=Ga.distanceScale;#_m=Ga.octaves;#vm=Ga.persistence;#bm=Ga.lacunarity;#ym=Ga.seed;#Mm=Ga.distanceType;#wm=Ga.outputType;#Cm=Ga.jitter;#Rm=Ga.cellIdColorIntensity;constructor(i,m=1024,g=1024,_){super(i,m,g,{..._,mainLogic:_?.mainLogic||" let uv=vec2<f32>( (base_uv.x + uniforms.time * (uniforms.animationX * uniforms.animationSpeed)), (base_uv.y + uniforms.time * (uniforms.animationY * uniforms.animationSpeed)) ); var finalColor:vec4<f32>; if (uniforms.outputType==5) { let colorNoise=getVoronoiColorNoise(uv,uniforms); finalColor=vec4<f32>(colorNoise,1.0); } else { let noise=getVoronoiNoise(uv,uniforms); finalColor=vec4<f32>(noise,noise,noise,1.0); } ",uniformStruct:mergerNoiseUniformStruct(" frequency:f32, distanceScale:f32, octaves:i32, persistence:f32, lacunarity:f32, seed:f32, distanceType:i32, outputType:i32, jitter:f32, cellIdColorIntensity:f32, ",_?.uniformStruct),uniformDefaults:mergerNoiseUniformDefault(Ga,_?.uniformDefaults),helperFunctions:mergerNoiseHelperFunctions("fn hash22(p:vec2<f32>) -> vec2<f32> { var p3=fract(vec3<f32>(p.xyx) * vec3<f32>(0.1031,0.1030,0.0973)); p3 +=dot(p3,p3.yzx + 33.33); return fract((p3.xx + p3.yz) * p3.zy);\n}\nfn hash12(p:vec2<f32>) -> f32 { var p3=fract(vec3<f32>(p.xyx) * 0.1031); p3 +=dot(p3,p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z);\n}\nfn euclideanDistance(a:vec2<f32>,b:vec2<f32>) -> f32 { let d=a - b; return sqrt(d.x * d.x + d.y * d.y);\n}\nfn manhattanDistance(a:vec2<f32>,b:vec2<f32>) -> f32 { let d=abs(a - b); return d.x + d.y;\n}\nfn chebyshevDistance(a:vec2<f32>,b:vec2<f32>) -> f32 { let d=abs(a - b); return max(d.x,d.y);\n}\nfn calculateDistance(a:vec2<f32>,b:vec2<f32>,distanceType:i32) -> f32 { switch (distanceType) { case 0:{ return euclideanDistance(a,b);} case 1:{ return manhattanDistance(a,b);} case 2:{ return chebyshevDistance(a,b);} default:{ return euclideanDistance(a,b);} }\n}\nfn cellIdToColor(cellId:f32,intensity:f32) -> vec3<f32> { let h=cellId * 6.28318; let s=0.7 + 0.3 * fract(cellId * 7.0); let v=0.6 + 0.4 * fract(cellId * 13.0); let c=v * s; let x=c * (1.0 - abs(((h/1.047198) % 2.0) - 1.0)); let m=v - c; var rgb:vec3<f32>; let sector=i32(h/1.047198) % 6; switch (sector) { case 0:{ rgb=vec3<f32>(c,x,0.0);} case 1:{ rgb=vec3<f32>(x,c,0.0);} case 2:{ rgb=vec3<f32>(0.0,c,x);} case 3:{ rgb=vec3<f32>(0.0,x,c);} case 4:{ rgb=vec3<f32>(x,0.0,c);} default:{ rgb=vec3<f32>(c,0.0,x);} } return (rgb + m) * intensity;\n}\nstruct VoronoiResult { f1:f32, f2:f32, cellId:f32,\n}\nfn voronoiSingle(pos:vec2<f32>,frequency:f32,seed:f32,jitter:f32,distanceType:i32) -> VoronoiResult { let scaledPos=pos * frequency; let gridPos=floor(scaledPos); let localPos=fract(scaledPos); var minDist1=999.0; var minDist2=999.0; var closestCellId=0.0; for (var y=-1;y <=1;y++) { for (var x=-1;x <=1;x++) { let neighborGrid=gridPos + vec2<f32>(f32(x),f32(y)); let randomOffset=hash22(neighborGrid + seed); let jitteredOffset=mix(vec2<f32>(0.5),randomOffset,jitter); let cellPoint=vec2<f32>(f32(x),f32(y)) + jitteredOffset; let dist=calculateDistance(localPos,cellPoint,distanceType); if (dist < minDist1) { minDist2=minDist1; minDist1=dist; closestCellId=hash12(neighborGrid + seed); } else if (dist < minDist2) { minDist2=dist; } } } return VoronoiResult(minDist1,minDist2,closestCellId);\n}\nfn getVoronoiNoise(uv:vec2<f32>,uniforms:Uniforms) -> f32 { var total=0.0; var frequency=uniforms.frequency; var amplitude=1.0; var maxValue=0.0; for (var i=0;i < uniforms.octaves;i++) { let voronoiResult=voronoiSingle( uv, frequency, uniforms.seed + f32(i) * 100.0, uniforms.jitter, uniforms.distanceType ); let F1=voronoiResult.f1 * uniforms.distanceScale; let F2=voronoiResult.f2 * uniforms.distanceScale; let cellId=voronoiResult.cellId; var octaveValue:f32; switch (uniforms.outputType) { case 0:{ octaveValue=F1;} case 1:{ octaveValue=F2;} case 2:{ octaveValue=F2 - F1;} case 3:{ octaveValue=(F1 + F2) * 0.5;} case 4:{ octaveValue=cellId;}  case 5:{ let colorRGB=cellIdToColor(cellId,uniforms.cellIdColorIntensity); octaveValue=(colorRGB.r + colorRGB.g + colorRGB.b)/3.0; } default:{ octaveValue=F1;} } total +=octaveValue * amplitude; maxValue +=amplitude; frequency *=uniforms.lacunarity; amplitude *=uniforms.persistence; } return clamp(total/maxValue,0.0,1.0);\n}\nfn getVoronoiColorNoise(uv:vec2<f32>,uniforms:Uniforms) -> vec3<f32> { if (uniforms.outputType==5) {  let voronoiResult=voronoiSingle( uv, uniforms.frequency, uniforms.seed, uniforms.jitter, uniforms.distanceType ); return cellIdToColor(voronoiResult.cellId,uniforms.cellIdColorIntensity); } else { let grayValue=getVoronoiNoise(uv,uniforms); return vec3<f32>(grayValue,grayValue,grayValue); }\n}\n",_?.helperFunctions)})}get frequency(){return this.#gm}set frequency(i){validatePositiveNumberRange(i),this.#gm=i,this.updateUniform("frequency",i)}get distanceScale(){return this.#Tm}set distanceScale(i){validatePositiveNumberRange(i),this.#Tm=i,this.updateUniform("distanceScale",i)}get octaves(){return this.#_m}set octaves(i){validateUintRange(i,1,8),this.#_m=i,this.updateUniform("octaves",i)}get persistence(){return this.#vm}set persistence(i){validatePositiveNumberRange(i,0,1),this.#vm=i,this.updateUniform("persistence",i)}get lacunarity(){return this.#bm}set lacunarity(i){validatePositiveNumberRange(i),this.#bm=i,this.updateUniform("lacunarity",i)}get seed(){return this.#ym}set seed(i){this.#ym=i,this.updateUniform("seed",i)}get distanceType(){return this.#Mm}set distanceType(i){Oa.includes(i)?(this.#Mm=i,this.updateUniform("distanceType",i)):consoleAndThrowError(`Invalid value for distanceType. Received ${i}. Expected one of:${Oa.join(",")}`)}get outputType(){return this.#wm}set outputType(i){ka.includes(i)?(this.#wm=i,this.updateUniform("outputType",i)):consoleAndThrowError(`Invalid value for outputType. Received ${i}. Expected one of:${ka.join(",")}`)}get jitter(){return this.#Cm}set jitter(i){validatePositiveNumberRange(i,0,1),this.#Cm=i,this.updateUniform("jitter",i)}get cellIdColorIntensity(){return this.#Rm}set cellIdColorIntensity(i){validatePositiveNumberRange(i),this.#Rm=i,this.updateUniform("cellIdColorIntensity",i)}randomizeSeed(){this.seed=1e3*Math.random()}setEuclideanDistance(){this.distanceType=Ua.EUCLIDEAN}setManhattanDistance(){this.distanceType=Ua.MANHATTAN}setChebyshevDistance(){this.distanceType=Ua.CHEBYSHEV}setF1Output(){this.outputType=Aa.F1}setF2Output(){this.outputType=Aa.F2}setCrackPattern(){this.outputType=Aa.F2_MINUS_F1}setSmoothBlend(){this.outputType=Aa.F1_PLUS_F2}setCellIdOutput(){this.outputType=Aa.CELL_ID}setCellIdColorOutput(){this.outputType=Aa.CELL_ID_COLOR}setCellularPattern(){this.outputType=Aa.F1,this.distanceType=Ua.EUCLIDEAN,this.jitter=1}setStonePattern(){this.outputType=Aa.F2_MINUS_F1,this.distanceType=Ua.EUCLIDEAN,this.jitter=.8}setOrganicPattern(){this.distanceType=Ua.MANHATTAN,this.jitter=.6}setGridPattern(){this.jitter=0,this.distanceType=Ua.EUCLIDEAN}setCrystalPattern(){this.outputType=Aa.F2_MINUS_F1,this.distanceType=Ua.CHEBYSHEV,this.jitter=.9}setStainedGlassPattern(){this.outputType=Aa.CELL_ID_COLOR,this.distanceType=Ua.EUCLIDEAN,this.jitter=.7,this.cellIdColorIntensity=.8}setMosaicPattern(){this.outputType=Aa.CELL_ID_COLOR,this.distanceType=Ua.MANHATTAN,this.jitter=.3,this.cellIdColorIntensity=1}setBiomeMapPattern(){this.outputType=Aa.CELL_ID,this.distanceType=Ua.EUCLIDEAN,this.jitter=.8,this.frequency=4}getSettings(){return{frequency:this.#gm,distanceScale:this.#Tm,octaves:this.#_m,persistence:this.#vm,lacunarity:this.#bm,seed:this.#ym,distanceType:this.#Mm,outputType:this.#wm,jitter:this.#Cm,cellIdColorIntensity:this.#Rm}}applySettings(i){void 0!==i.frequency&&(this.frequency=i.frequency),void 0!==i.distanceScale&&(this.distanceScale=i.distanceScale),void 0!==i.octaves&&(this.octaves=i.octaves),void 0!==i.persistence&&(this.persistence=i.persistence),void 0!==i.lacunarity&&(this.lacunarity=i.lacunarity),void 0!==i.seed&&(this.seed=i.seed),void 0!==i.distanceType&&(this.distanceType=i.distanceType),void 0!==i.outputType&&(this.outputType=i.outputType),void 0!==i.jitter&&(this.jitter=i.jitter),void 0!==i.cellIdColorIntensity&&(this.cellIdColorIntensity=i.cellIdColorIntensity)}getDistanceTypeName(){return{[Ua.EUCLIDEAN]:"Euclidean",[Ua.MANHATTAN]:"Manhattan",[Ua.CHEBYSHEV]:"Chebyshev"}[this.#Mm]||"Unknown"}getOutputTypeName(){return{[Aa.F1]:"F1",[Aa.F2]:"F2",[Aa.F2_MINUS_F1]:"F2-F1 (Crack)",[Aa.F1_PLUS_F2]:"F1+F2 (Blend)",[Aa.CELL_ID]:"Cell ID",[Aa.CELL_ID_COLOR]:"Cell ID Color"}[this.#wm]||"Unknown"}},parseWGSL:parseWGSL});class GltfAnimationLooperManager{#Pm=60;#Bm=1e3/this.#Pm;#Di=0;#Im=0;render=(i,g,_,b)=>{const y=g;this.#Di;this.#Bm,this.#Di=y,this.#Im++;const T=m,w=180/Math.PI;let P,H,$,W,q,ye,Ge,Ke,je,Xe,Ye,Ze,Je,Qe,et,at,ht,ft,gt,xt,vt,bt,yt,St,Tt,Mt,wt,Ct,Rt,Pt,Bt,It,Et,Dt,Lt,Ut,At,Ot,kt,Gt,Ft,Nt,Vt,zt,Ht,$t,Kt,Wt,jt,Xt,qt,Yt,Zt,Jt,Qt,en,tn,nn,rn,an,sn,on,un,ln,cn,hn,fn,dn,mn=b.length;for(;mn--;){sn=b[mn],an=sn.targetGLTFParsedSingleClip,rn=an.length;const m=an.maxTime;for(;rn--;){on=an[rn],un=on.cacheTable;const{animationTargetMesh:b,timeAnimationInfo:y,aniDataAnimationInfo:mn,weightMeshes:pn}=on;b.dirtyTransform=!0,Qt=(g-sn.startTime)%(1e3*m)/1e3,hn=y.dataList,fn=mn.dataList,dn=hn.length;const gn=on.lastPrevIdx||0;if(gn<dn-1)if(hn[gn]<=Qt&&Qt<hn[gn+1])cn=gn,ln=gn+1;else if(gn+1<dn-1&&hn[gn+1]<=Qt&&Qt<hn[gn+2])cn=gn+1,ln=gn+2;else if(Qt<=hn[0])cn=dn-1,ln=0;else if(Qt>=hn[dn-1])cn=dn-1,ln=0;else{let i=0,m=dn-1;for(;i<m-1;){const g=i+m>>1;hn[g]<=Qt?i=g:m=g}cn=i,ln=m}else if(Qt<=hn[0])cn=dn-1,ln=0;else if(Qt>=hn[dn-1])cn=dn-1,ln=0;else{let i=0,m=dn-1;for(;i<m-1;){const g=i+m>>1;hn[g]<=Qt?i=g:m=g}cn=i,ln=m}let xn,_n,vn,bn,yn,Sn,Tn;on.lastPrevIdx=cn,en=hn[cn],tn=hn[ln];const Mn=on.interpolation;if("CUBICSPLINE"==Mn){const i=tn-en;nn=i==i?i:0;const m=(Qt-en)/nn;xn=m==m?m:0,_n=xn*xn,vn=_n*xn,Sn=-2*vn+3*_n,Tn=vn-_n,bn=1-Sn,yn=Tn-_n+xn}else if("STEP"==Mn)nn=0;else{const i=(Qt-en)/(tn-en);nn=i==i?i:0}switch(on.key){case"rotation":if(cn!==dn-1){if("CUBICSPLINE"===Mn){let i,m,g,_,b,y,T,w;kt=12*cn,Gt=12*ln,P=fn[kt+4],H=fn[kt+5],$=fn[kt+6],W=fn[kt+7],q=P*P+H*H+$*$+W*W,q>0?(ye=1/Math.sqrt(q),Ge=P*ye,Ke=H*ye,je=$*ye,Xe=W*ye):(Ge=Ke=je=0,Xe=1),P=fn[kt+8],H=fn[kt+9],$=fn[kt+10],W=fn[kt+11],q=P*P+H*H+$*$+W*W,q>0?(ye=1/Math.sqrt(q),i=P*ye,m=H*ye,g=$*ye,_=W*ye):(i=m=g=0,_=1),P=fn[Gt],H=fn[Gt+1],$=fn[Gt+2],W=fn[Gt+3],q=P*P+H*H+$*$+W*W,q>0?(ye=1/Math.sqrt(q),b=P*ye,y=H*ye,T=$*ye,w=W*ye):(b=y=T=0,w=1),P=fn[Gt+4],H=fn[Gt+5],$=fn[Gt+6],W=fn[Gt+7],q=P*P+H*H+$*$+W*W,q>0?(ye=1/Math.sqrt(q),Ye=P*ye,Ze=H*ye,Je=$*ye,Qe=W*ye):(Ye=Ze=Je=0,Qe=1),P=bn*Ge+yn*i*nn+Sn*Ye+Tn*b*nn,H=bn*Ke+yn*m*nn+Sn*Ze+Tn*y*nn,$=bn*je+yn*g*nn+Sn*Je+Tn*T*nn,W=bn*Xe+yn*_*nn+Sn*Qe+Tn*w*nn}else{kt=cn<<2,Gt=ln<<2;const i=kt<<16|Gt;let m=un[i];m?(et=m[0],Ge=m[1],Ke=m[2],je=m[3],Xe=m[4],Ye=m[5],Ze=m[6],Je=m[7],Qe=m[8]):(P=fn[kt],H=fn[kt+1],$=fn[kt+2],W=fn[kt+3],q=P*P+H*H+$*$+W*W,q>0?(ye=1/Math.sqrt(q),Ge=P*ye,Ke=H*ye,je=$*ye,Xe=W*ye):(Ge=Ke=je=0,Xe=1),P=fn[Gt],H=fn[Gt+1],$=fn[Gt+2],W=fn[Gt+3],q=P*P+H*H+$*$+W*W,q>0?(ye=1/Math.sqrt(q),Ye=P*ye,Ze=H*ye,Je=$*ye,Qe=W*ye):(Ye=Ze=Je=0,Qe=1),et=Ge*Ye+Ke*Ze+je*Je+Xe*Qe,et<0&&(et=-et,Ye=-Ye,Ze=-Ze,Je=-Je,Qe=-Qe),m=new Float32Array(9),m[0]=et,m[1]=Ge,m[2]=Ke,m[3]=je,m[4]=Xe,m[5]=Ye,m[6]=Ze,m[7]=Je,m[8]=Qe,un[i]=m),1-et>T?(at=Math.acos(et),ht=Math.sin(at),ft=Math.sin((1-nn)*at)/ht,gt=Math.sin(nn*at)/ht):(ft=1-nn,gt=nn),P=ft*Ge+gt*Ye,H=ft*Ke+gt*Ze,$=ft*je+gt*Je,W=ft*Xe+gt*Qe}xt=P+P,vt=H+H,bt=$+$,yt=P*xt,St=P*vt,Tt=P*bt,Mt=H*vt,wt=H*bt,Ct=$*bt,Rt=W*xt,Pt=W*vt,Bt=W*bt,Dt=Tt+Pt,It=1-(Mt+Ct),Et=St-Bt,Ut=wt-Rt,Ot=1-(yt+Mt),At=wt+Rt,Lt=1-(yt+Ct),H=Math.asin(Math.max(-1,Math.min(1,Dt))),Math.abs(Dt)<.99999?(P=Math.atan2(-Ut,Ot),$=Math.atan2(-Et,It)):(P=Math.atan2(At,Lt),$=0),b.rotationX=P*w,b.rotationY=H*w,b.rotationZ=$*w}break;case"translation":"CUBICSPLINE"===Mn?cn!==dn-1&&(kt=9*cn,Ft=fn[kt+3],Nt=fn[kt+4],Vt=fn[kt+5],Xt=fn[kt+6],qt=fn[kt+7],Yt=fn[kt+8],Gt=9*ln,Kt=fn[Gt],Wt=fn[Gt+1],jt=fn[Gt+2],zt=fn[Gt+3],Ht=fn[Gt+4],$t=fn[Gt+5],Zt=Xt*nn,Jt=Kt*nn,b.x=bn*zt+yn*Zt+Sn*Ft+Tn*Jt,Zt=qt*nn,Jt=Wt*nn,b.y=bn*Ht+yn*Zt+Sn*Nt+Tn*Jt,Zt=Yt*nn,Jt=jt*nn,b.z=bn*$t+yn*Zt+Sn*Vt+Tn*Jt):(kt=3*ln,Ft=fn[kt],Nt=fn[kt+1],Vt=fn[kt+2],Gt=3*cn,zt=fn[Gt],Ht=fn[Gt+1],$t=fn[Gt+2],b.x=zt+nn*(Ft-zt),b.y=Ht+nn*(Nt-Ht),b.z=$t+nn*(Vt-$t));break;case"scale":"CUBICSPLINE"===Mn?cn!==dn-1&&(kt=9*cn,Ft=fn[kt+3],Nt=fn[kt+4],Vt=fn[kt+5],Xt=fn[kt+6],qt=fn[kt+7],Yt=fn[kt+8],Gt=9*ln,Kt=fn[Gt],Wt=fn[Gt+1],jt=fn[Gt+2],zt=fn[Gt+3],Ht=fn[Gt+4],$t=fn[Gt+5],Zt=Xt*nn,Jt=Kt*nn,b.scaleX=bn*zt+yn*Zt+Sn*Ft+Tn*Jt,Zt=qt*nn,Jt=Wt*nn,b.scaleY=bn*Ht+yn*Zt+Sn*Nt+Tn*Jt,Zt=Yt*nn,Jt=jt*nn,b.scaleZ=bn*$t+yn*Zt+Sn*Vt+Tn*Jt):(kt=3*ln,Ft=fn[kt],Nt=fn[kt+1],Vt=fn[kt+2],Gt=3*cn,zt=fn[Gt],Ht=fn[Gt+1],$t=fn[Gt+2],b.scaleX=zt+nn*(Ft-zt),b.scaleY=Ht+nn*(Nt-Ht),b.scaleZ=$t+nn*(Vt-$t));break;case"weights":{let m=pn.length;for(;m--;)on.renderWeight(i,_,pn[m],nn,cn,ln);break}}}}}}!function(i,m){void 0===m&&(m={});var g=m.insertAt;if("undefined"!=typeof document){var _=document.head||document.getElementsByTagName("head")[0],b=document.createElement("style");b.type="text/css","top"===g&&_.firstChild?_.insertBefore(b,_.firstChild):_.appendChild(b),b.styleSheet?b.styleSheet.cssText=i:b.appendChild(document.createTextNode(i))}}(".RedGPUDebugPanel{background:rgba(0,0,0,.9);bottom:0;color:#fff;font-size:11px;left:0;line-height:1;max-height:100%;min-width:250px;overflow-y:auto;position:fixed;transform:translateZ(0);width:330px;will-change:transform;z-index:2}.RedGPUDebugPanel::-webkit-scrollbar{width:6px}.RedGPUDebugPanel::-webkit-scrollbar-track{background:#000}.RedGPUDebugPanel::-webkit-scrollbar-thumb{background:#333}.RedGPUDebugPanel::-webkit-scrollbar-thumb:hover{background:#444}.debug-group{line-height:1.4;padding:10px;b{color:#fdb48d;font-weight:700}}.debug-sub-group{background:linear-gradient(90deg,hsla(0,0%,100%,.1),rgba(0,0,0,.01));border:1px solid hsla(0,0%,100%,.16);border-radius:6px;box-shadow:0 0 10px rgba(0,0,0,.16);line-height:1.4;margin:8px 0;padding:6px 10px;b{color:#fdb48d;font-weight:700}}.debug-sub-group-title{color:#e3b096}.debug-item{align-items:center;color:#ccc;display:flex;font-weight:400;gap:10px;justify-content:space-between;transform:translateZ(0);width:100%;will-change:transform;b{color:#fdb48d;font-weight:700}}.boolean-true{background:green}.boolean-false,.boolean-true{border-radius:4px;color:#fff;line-height:1;margin:2px 0;padding:2px 4px}.boolean-false{background:red}.debug-folder{background:rgba(0,0,0,.5);border-bottom:1px solid hsla(0,0%,100%,.05);display:flex;flex-direction:column;width:100%}.debug-folder-title{color:#fdb48d;font-size:15px;b{color:#fdb48d;font-size:11px;font-weight:700}}.debug-folder-small-title,.debug-folder-title{align-items:center;background:linear-gradient(0deg,rgba(0,0,0,.95),hsla(0,0%,100%,.055));cursor:pointer;display:flex;justify-content:space-between;line-height:1;padding:10px 8px;width:100%}.debug-folder-small-title{color:#fff;font-size:12px;b{color:#fdb48d;font-size:11px;font-weight:700}}.debug-folder-title .onoff{font-size:11px}.debug-item-title{color:#888;max-width:240px}.debug-item-cache-key,.debug-item-title{font-weight:500;overflow:hidden;text-overflow:ellipsis;text-shadow:1px 1px 0 rgba(0,0,0,.3)}.debug-item-cache-key{color:#fff;max-width:250px;white-space:nowrap}.div-line{background:hsla(0,0%,100%,.06);border-bottom:1px solid transparent;height:1px;margin:10px 0;width:100%}.root-padding{padding:6px;width:100%}.color-box{border:1px solid hsla(0,0%,100%,.2);border-radius:4px;margin:2px;padding:3px}");const createDebugTitle=i=>`<div>${i}</div>`,makeColorDebug=(i,m)=>`\n<div class='debug-item'>\n\x3c!--\t<span class='debug-item-title'>${i}</span> --\x3e\n\t<span class='debug-item-title'></span> \n\t<div style="border:1px solid rgba(255,255,255,0.2);border-radius:4px;background:rgba(${m.rgba});padding:3px;margin:2px"> ${m.rgba}\n\t</div>\n</div>\n`,makeBooleanDebug=(i,m)=>`<span class="${m?"boolean-true":"boolean-false"}">${m?"TRUE":"FALSE"}</span>`,getDebugFormatValue=i=>"boolean"==typeof i?i.toString():"number"==typeof i?i.toLocaleString():i,updateDebugItemValue=(i,m,g,_,b="")=>{const y=i.querySelector(`.${m}`);if(!y)return;const T=`${getDebugFormatValue(g)}${b}`;y.innerHTML!==T&&(y.innerHTML=T,_&&(y.style.background=g?"green":"rgba(255,255,255,0.1)"))};let za=class{dom;#Em;#Dm=!1;constructor(i){this.#Em=i,this.dom=document.createElement("div"),this.dom.innerHTML=` <div class="debug-folder">\t <div class="debug-folder-small-title" style="display:flex;align-items:center;justify-content:space-between;cursor:pointer;"> ${createDebugTitle(`${i} Num:<span class="totalCount"></span> (<b class="targetVideoMemorySize"></b>)`)}\n\x3c!-- <div class="onoff">${this.#Dm?"close":"open"}</div>--\x3e </div> <div class="item-container" style="display:none"></div> </div>\n`}get openYn(){return this.#Dm}set openYn(i){this.#Dm=i,this.dom.querySelector(".onoff").innerHTML=this.openYn?"close":"open"}update(i,m){const{resourceManager:g}=m;if("Buffer"===this.#Em){const m=g.resources.get("GPUBuffer"),{videoMemory:_}=m;i.totalUsedVideoMemory+=_,updateDebugItemValue(this.dom,"totalCount",m.size),updateDebugItemValue(this.dom,"targetVideoMemorySize",formatBytes(_))}else{const m=g[`managed${this.#Em}State`],{table:_,videoMemory:b}=m;i.totalUsedVideoMemory+=b,updateDebugItemValue(this.dom,"totalCount",_.size),updateDebugItemValue(this.dom,"targetVideoMemorySize",formatBytes(b)),this.#Em}}#Lm(i){let m=i;(i.startsWith("Vertex_")||i.startsWith("Index_"))&&(m=i.substring(i.indexOf("_")+1));try{const i=new URL(m),g=i.pathname.split("/").pop()||m;return{host:i.host,filename:g}}catch{return{host:null,filename:m}}}#Um(i){const m=this.dom.querySelector(".item-container"),g=new Set,_=this.#Em,b=new Map;m.querySelectorAll(".debug-group").forEach(i=>{const m=i.className.split(" ")[1].replace(`${_}_`,"");g.add(m),b.set(m,i)});let y=0;i.forEach((i,T)=>{const w=T,P=i.size||0,H=`${_}_${w}`;let $=b.get(w);$?g.delete(w):($=document.createElement("div"),$.className=`debug-group ${H}`,$.innerHTML=` <div class='debug-item'> <div> <div class='debug-item-title'><span style="white-space:nowrap"> <span class="host"></span> <div class="name"></div> </span></div> <div style="font-size:10px">${w}</div> </div> <div style="display:flex;flex-direction:column;align-items:center;gap:4px;width:50px"> <span style="white-space:nowrap"><b class="videoMemorySize"></b></span> </div> </div> `,m.appendChild($));const{host:W,filename:q}=this.#Lm(T);W?(updateDebugItemValue($,"host",`${y} ${W}`),updateDebugItemValue($,"name",q)):updateDebugItemValue($,"host",`${y} ${T}`),updateDebugItemValue($,"videoMemorySize",formatBytes(P)),y++});for(let i of g)b.get(i).remove()}#Am(i){const m=this.dom.querySelector(".item-container"),g=new Set,_=this.#Em,b=new Map;m.querySelectorAll(".debug-group").forEach(i=>{const m=i.className.split(" ")[1].replace(`${_}_`,"");g.add(m),b.set(m,i)});let y=0;const T="UniformBuffer"===this.#Em||"StorageBuffer"===this.#Em;i.forEach(i=>{const{useNum:w,buffer:P}=i,{uuid:H,size:$,name:W,gpuBuffer:q}=P,{label:ye}=q,Ge=`${_}_${H}`;let Ke=b.get(H);Ke?g.delete(H):(Ke=document.createElement("div"),Ke.className=`debug-group ${Ge}`,Ke.innerHTML=` <div class='debug-item'> <div style="display:flex;flex-direction:column;width:100%"> <div class='debug-item-title'><span style="white-space:nowrap"> <span class="host"></span> <div class="name"></div> </span></div> <div style="font-size:10px">${H}</div> </div> <div style="display:flex;flex-direction:column;align-items:center;gap:4px;width:50px;min-width:50px"> <span class='useNum' style="display:${T?"none":"block"};padding:2px 4px;border-radius:4px;width:100%;text-align:center"></span> <span style="white-space:nowrap"><b class="videoMemorySize"></b></span> </div> </div> `,m.appendChild(Ke));const{host:je,filename:Xe}=this.#Lm(W);je?(updateDebugItemValue(Ke,"host",`${y} ${je}`),updateDebugItemValue(Ke,"name",Xe)):updateDebugItemValue(Ke,"host",`${y} ${ye}`),T||updateDebugItemValue(Ke,"useNum",w,!0),updateDebugItemValue(Ke,"videoMemorySize",formatBytes($)),y++});for(let i of g)b.get(i).remove()}};class DebugBufferList{debugStatisticsDomService;constructor(i){this.debugStatisticsDomService=new za(i)}get dom(){return this.debugStatisticsDomService.dom}update(i,m){this.debugStatisticsDomService.update(i,m)}}class ADebugItem{debugStatisticsDomService;constructor(){}get dom(){return this.debugStatisticsDomService.dom}update(i,m,g){this.debugStatisticsDomService.update(i,m)}}class ADebugStatisticsDomService{dom;#Dm=!1;constructor(){}get openYn(){return this.#Dm}set openYn(i){this.#Dm=i,this.dom.querySelector(".onoff").innerHTML=this.openYn?"close":"open"}init(i,m=!1,g=!1){this.#Dm=m,this.dom=document.createElement("div"),this.dom.innerHTML=` <div class="debug-folder">\t <div class="${g?"debug-folder-small-title":"debug-folder-title"}"> ${i}\n\x3c!-- <div class="onoff">${this.openYn?"close":"open"}</div>--\x3e </div> <div class="item-container" style="display:${m?"":"none"}"></div> </div>\n`}update(i,m){}}const Ha=["useMSAA","useFXAA","useTAA","alphaMode","renderScale"];let $a=class extends ADebugStatisticsDomService{constructor(){super(),this.init(`${createDebugTitle("RedGPUContext")}`,!0),this.#Am()}update(i,m){Ha.forEach(i=>this.#Om(m,i)),this.#km(m)}#Am(){const i=this.dom.querySelector(".item-container"),m=['<div class="debug-group">',...Ha.map(i=>this.#Gm(i)),this.#Gm("width_height"),this.#Gm("pixelRectArray"),this.#Gm("backgroundColor"),"</div>"];i.innerHTML=m.join("")}#Gm(i){return` <div class='debug-item'> ${i} <span class='debug-item-title redGPUContext_${i}'/> </div> `}#Om(i,m){const g=["useMSAA","useFXAA","useTAA"].includes(m),_=g?i.antialiasingManager[m]:i[m];updateDebugItemValue(this.dom,`redGPUContext_${m}`,g?makeBooleanDebug(0,_):getDebugFormatValue(_))}#km(i){const{sizeManager:m,width:g,height:_,backgroundColor:b}=i,{pixelRectArray:y}=m;updateDebugItemValue(this.dom,"redGPUContext_width_height",`${g},${_}`),updateDebugItemValue(this.dom,"redGPUContext_pixelRectArray",y),updateDebugItemValue(this.dom,"redGPUContext_backgroundColor",makeColorDebug("backgroundColor",b))}};class DebugRedGPUContext extends ADebugItem{constructor(){super(),this.debugStatisticsDomService=new $a}}let Ka=class extends ADebugStatisticsDomService{#Fm;constructor(i){super(),this.#Fm=i,this.init(`${createDebugTitle(`${i}Texture Num:<span class="totalCount"></span> (<b class="targetVideoMemorySize"></b>)`)}`,!1,!0)}update(i,m){if("Packed"===this.#Fm)this.#Nm(i,m);else{const{resourceManager:g}=m,{managedBitmapTextureState:_,managedCubeTextureState:b,managedHDRTextureState:y}=g,{table:T,videoMemory:w}="Bitmap"===this.#Fm?_:"Cube"===this.#Fm?b:y;i.totalUsedVideoMemory+=w,updateDebugItemValue(this.dom,"totalCount",T.size),updateDebugItemValue(this.dom,"targetVideoMemorySize",formatBytes(w))}}getTargetSrc(i){if("Packed"===this.#Fm)return i.src||"packed texture";if(i instanceof ResourceStateCubeTexture){const{cacheKey:m}=i;return`${m}...`}{const{src:m}=i;return m?m.startsWith("data:")?"base64 texture":m:"null"}}getUpdatedTdom(i,m,g,_,b,y){return i||((i=document.createElement("div")).className=`debug-group ${g}`,i.innerHTML=` <div class='debug-item'> \t<div style="display:flex;flex-direction:column;width:100%"> <div class='debug-item-title'>${_} <span class="targetSrc" style="white-space:nowrap">${b||""}</span></div>  <div class='debug-item-cache-key'><span class="host">Place holder for host</span></div> <div class='debug-item-cache-key'><span class="fileName">Place holder for fileName</span></div> <div>mipLevelCount:<span class="mipLevelCount"></span>/useMipmap:<span class="useMipmap"></span></div> <div>width:<span class="width"></span>/height:<span class="height"></span></div> </div> <div style="display:flex;flex-direction:column;align-items:center;gap:4px;width:50px;min-width:50px"> <span class='useNum' style="display:${"HDR"===this.#Fm?"none":"block"}padding:2px 4px;border-radius:4px;width:100%;text-align:center"></span> <span><b class="videoMemorySize"></b></span> </div> </div> <div style="font-size:10px">${y}</div> `,m.appendChild(i)),i}updateDebugItems(i,m,g,_,b,y,T,w,P){updateDebugItemValue(i,"mipLevelCount",m),updateDebugItemValue(i,"useMipmap",g),updateDebugItemValue(i,"width",_),updateDebugItemValue(i,"height",b),"HDR"!==this.#Fm&&updateDebugItemValue(i,"useNum",y,!0);const{host:H,filename:$}=this.#Lm(T);H?(updateDebugItemValue(i,"host",H),updateDebugItemValue(i,"fileName",$)):updateDebugItemValue(i,"fileName",T),updateDebugItemValue(i,"targetSrc","null"===w?"":w),updateDebugItemValue(i,"videoMemorySize",formatBytes(P))}#Nm(i,m){const g=PackedTexture.getCacheMap(),_=this.#Vm(g);let b=0;_.forEach(i=>{b+=i.texture.videoMemorySize}),i.totalUsedVideoMemory+=b,updateDebugItemValue(this.dom,"totalCount",_.size),updateDebugItemValue(this.dom,"targetVideoMemorySize",formatBytes(b))}#Vm(i){const m=new Map;return i.forEach((i,g)=>{const _={gpuTexture:i.gpuTexture,uuid:i.uuid,mipLevelCount:i.gpuTexture.mipLevelCount||1,useMipmap:(i.gpuTexture.mipLevelCount||1)>1,videoMemorySize:this.#zm(i.gpuTexture)},b={useNum:i.useNum,cacheKey:g,texture:_,src:`packed:${g.substring(0,50)}${g.length>50?"...":""}`,mappingKey:i.mappingKey};m.set(g,b)}),m}#zm(i){const m=i.label?.match(/(\d+)x(\d+)/);if(m){const g=parseInt(m[1]),_=parseInt(m[2]),b=i.mipLevelCount||1;let y=0;for(let i=0;i<b;i++){y+=Math.max(1,g>>i)*Math.max(1,_>>i)*4}return y}return 4194304}#Lm(i){if("Packed"===this.#Fm){try{const m=i.split("}_");if(m.length>=2){const i=m[0]+"}";m[1];return{host:"packed",filename:`${i.substring(0,20)}...`}}}catch{}return{host:"packed",filename:i.length>30?i.substring(0,30)+"...":i}}try{const m=new URL(i),g=m.pathname.split("/").pop()||i;return{host:m.host,filename:g}}catch{const m=i.split("_");return{host:m[0],filename:m.pop()||i}}}#Am(i){const m=this.dom.querySelector(".item-container"),g=new Set,_="Bitmap"===this.#Fm?"cube_texture":"Cube"===this.#Fm?"bitmap_texture":"HDR"===this.#Fm?"hdr_texture":"packed_texture";m.querySelectorAll(".debug-group").forEach(i=>{const m=i.className.split(" ")[1].replace(`${_}_`,"");g.add(m)});let b=0;for(const y of i.values()){const{useNum:i,cacheKey:T,texture:w}=y;let P=this.getTargetSrc(y);const{mipLevelCount:H,useMipmap:$,gpuTexture:W,uuid:q,videoMemorySize:ye}=w,{width:Ge,height:Ke}=W||{},je=`${_}_${w.uuid}`;let Xe=m.querySelector(`.${je}`);Xe=this.getUpdatedTdom(Xe,m,je,b,P,q),g.delete(w.uuid),this.updateDebugItems(Xe,H,$,Ge,Ke,i,T,P,ye),b++}for(let i of g)m.querySelector(`.${_}_${i}`)?.remove()}};class DebugTextureList extends ADebugItem{constructor(i="Bitmap"){super(),this.debugStatisticsDomService=new Ka(i)}}const Wa=["totalNum3DGroups","totalNum3DObjects","totalNumInstances","totalNumDrawCalls","totalNumTriangles","totalNumPoints","totalUsedVideoMemory"];let ja=class{dom;constructor(){this.dom=document.createElement("div"),this.#Hm()}update(i){Wa.forEach(m=>{const g=i[m],_="totalUsedVideoMemory"===m?`<b>${formatBytes(g)}</b>`:g;updateDebugItemValue(this.dom,m,_)})}#Hm(){const i=this.#Am();this.dom.innerHTML=` <div class="debug-group"> ${createDebugTitle("Total State")} <div>${i}</div>  </div> `}#Am(){return Wa.map(i=>"totalUsedVideoMemory"===i?`<div class='debug-item'>${i}<span class='debug-item-title'/><b class="${i}"></b></div>`:`<div class='debug-item'>${i}<span class='debug-item-title ${i}'/></div>`).join("")}};class DebugTotalState extends ADebugItem{constructor(){super(),this.debugStatisticsDomService=new ja}}const Xa=["usedVideoMemory","viewRenderTime","num3DGroups","num3DObjects","numInstances","numDrawCalls","numTriangles","numPoints"],qa={viewRenderTime:"ms"},Ya={camera:"camera.name",scene:"scene.name",useBackgroundColor:"scene.useBackgroundColor",backgroundColor:"scene.backgroundColor",x_y:"x,y",width_height:"width,height"};let Za=class extends ADebugStatisticsDomService{#$m=0;constructor(){super(),this.init(`${createDebugTitle("ViewList")}`,!0)}update(i,m){const{viewList:g,numViews:_}=m;this.#$m!==_&&(this.#Km(g),this.#$m=_),g.forEach((m,g)=>{Xa.forEach(_=>this.#Om(m,g,_,i)),this.#km(m,g)})}#Gm(i,m){return` <div class='debug-item'> ${Ya[m]||m} <span class='debug-item-title view${i}_${m}'/> </div> `}#Km(i){const m=this.dom.querySelector(".item-container"),g=i.map((i,m)=>{const{name:g}=i,_=Xa.map(i=>this.#Gm(m,i));return _.push('<div class="debug-sub-group">',this.#Gm(m,"x_y"),this.#Gm(m,"width_height"),this.#Gm(m,"pixelRectArray"),this.#Gm(m,"camera"),this.#Gm(m,"scene"),this.#Gm(m,"useBackgroundColor"),this.#Gm(m,"backgroundColor"),"</div>"),`${createDebugTitle(`<div class="debug-sub-group-title">${g}</div>`)}${_.join("")}`});return m.innerHTML=` <div class="debug-group"> ${g.join('<div class="div-line"></div>')} </div> `}#Om(i,m,g,_){const{renderViewStateData:b}=i,y=`total${g.charAt(0).toUpperCase()}${g.substring(1)}`,T=b[g],w="usedVideoMemory"===g?`<b>${formatBytes(T)}</b>`:T,P=qa[g];_[y]+=T,updateDebugItemValue(this.dom,`view${m}_${g}`,w,!1,P)}#km(i,m){const{renderViewStateData:g,rawCamera:_,scene:b}=i,{backgroundColor:y,useBackgroundColor:T}=b,{viewportSize:w}=g,{pixelRectArray:P,x:H,y:$,width:W,height:q}=w;updateDebugItemValue(this.dom,`view${m}_x_y`,`${formatNumber(H)},${formatNumber($)}`),updateDebugItemValue(this.dom,`view${m}_width_height`,`${W},${q}`),updateDebugItemValue(this.dom,`view${m}_pixelRectArray`,P),updateDebugItemValue(this.dom,`view${m}_useBackgroundColor`,makeBooleanDebug(0,T)),updateDebugItemValue(this.dom,`view${m}_backgroundColor`,makeColorDebug("backgroundColor",y)),updateDebugItemValue(this.dom,`view${m}_camera`,_.name),updateDebugItemValue(this.dom,`view${m}_scene`,b.name)}};class DebugViewList extends ADebugItem{constructor(){super(),this.debugStatisticsDomService=new Za}}const formatNumber=i=>{const m=String(i);if(m.includes("%")){const i=parseFloat(m);return isNaN(i)?m:`${i.toFixed(2)}%`}if(m.includes("px")){const i=parseFloat(m);return isNaN(i)?m:`${i.toFixed(2)}px`}const g=parseFloat(m);return isNaN(g)?m:g.toFixed(2)};class DebugStatisticsDomService{dom;constructor(i){this.dom=document.createElement("div"),this.dom.style.cssText="z-index:1;position:sticky;top:0;background:#000;border-bottom:1px solid rgba(255,255,255,0.06);box-shadow:0 10px 10px rgba(0,0,0,0.5)",this.#Hm(i)}update(i,m,g,_,b){const y={fps:i,avg:m,low1:g,low01:_,frameTime:b};Object.entries(y).forEach(([i,m])=>this.#Wm(i,m))}#Hm(i){this.dom.innerHTML=' <div class="debug-group"> <div class=\'debug-item\'> <span class=\'debug-item-title\' style="font-size:14px;font-weight:500;color:#fff">Performance<br/>Monitor</span> <div style="display:flex;align-items:center;justify-content:flex-end;gap:12px;"> <div style="display:flex;flex-direction:column;align-items:flex-end;gap:2px"> <div class="fps" style="color:#0f0;font-size:18px;font-weight:bold;white-space:nowrap">60 FPS</div> <div class="frameTime" style="color:#888;font-size:11px;">16.67ms</div> </div> <div style="width:1px;height:36px;background:rgba(255,255,255,0.15)"></div> <div style="display:flex;flex-direction:column;align-items:flex-end;gap:0px"> <div class="avg" style="color:#4af;font-size:11px;">Avg:60</div> <div class="low1" style="color:#fa0;font-size:11px;">1%:60</div> <div class="low01" style="color:#f50;font-size:11px;">0.1%:60</div> </div> <div class="panel_close" style="cursor:pointer;border-radius:4px;display:flex;align-items:center;justify-content:center;color:#fff;width:50px;height:48px;background:#c00;margin-left:8px;font-size:10px;font-weight:bold;transition:background 0.2s;" onmouseover="this.style.background=\'#e00\'" onmouseout="this.style.background=\'#c00\'">CLOSE</div> </div> </div> </div> '}#Wm(i,m){const g=this.dom.querySelector(`.${i}`);g&&g.innerHTML!==m&&(g.innerHTML=m)}}class Fps extends ADebugItem{#jm=0;#Im=0;#Xm=!1;#qm=[];#Ym=1200;#Zm=[];#Jm=10;#Qm=0;#ep=60;#tp=0;#np=0;#rp=0;#ip=60;constructor(i){super(),this.debugStatisticsDomService=new DebugStatisticsDomService(i)}update(i,m,g){if(0===this.#Im)return this.#jm=g,void this.#Im++;const _=g-this.#jm;if(this.#jm=g,this.#Im++,!this.#Xm){const i=document.querySelector(".panel_close");i&&(i.addEventListener("click",()=>{m.useDebugPanel=!1}),this.#Xm=!0)}const b=this.#ap(_);this.#Im>this.#ip&&(this.#qm.push(b),this.#qm.length>this.#Ym&&this.#qm.shift()),this.#Zm.push(b),this.#Zm.length>this.#Jm&&this.#Zm.shift();const y=this.#sp();this.#Qm++,this.#Qm>=this.#ep&&(this.#op(),this.#Qm=0),this.debugStatisticsDomService.update(`${y} FPS`,`Avg:${this.#tp}`,`1%:${this.#np}`,`0.1%:${this.#rp}`,`${b.toFixed(2)}ms`)}#ap(i){return Math.min(Math.max(i,.1),1e3)}#sp(){if(0===this.#Zm.length)return 0;const i=this.#Zm.reduce((i,m)=>i+m,0)/this.#Zm.length;return Math.round(1e3/i)}#op(){if(this.#qm.length<100)return this.#tp=0,this.#np=0,void(this.#rp=0);const i=this.#up();this.#tp=i.avgFps,this.#np=i.low1Fps,this.#rp=i.low01Fps}#up(){const i=this.#qm.reduce((i,m)=>i+m,0),m=i/this.#qm.length,g=Math.round(1e3/m),_=[...this.#qm].sort((i,m)=>m-i),b=_.length,y=Math.max(1,Math.ceil(.01*b)),T=_.slice(0,y),w=T.reduce((i,m)=>i+m,0)/T.length,P=Math.round(1e3/w),H=Math.max(1,Math.ceil(.001*b)),$=_.slice(0,H),W=$.reduce((i,m)=>i+m,0)/$.length;return{avgFps:g,low1Fps:P,low01Fps:Math.round(1e3/W)}}}class DebugRender{fps;debugTotalState;debugViewList;debugRedGPUContext;debugBitmapTextureList;debugCubeTextureList;debugHDRTextureList;debugPackedTextureList;debugIndexBufferList;debugVertexBufferList;debugUniformBufferList;debugStorageBufferList;debugBufferList;totalNum3DGroups;totalNum3DObjects;totalNumDrawCalls;totalNumInstances;totalNumTriangles;totalNumPoints;totalUsedVideoMemory;#lp;constructor(i){this.fps=new Fps(i),this.debugTotalState=new DebugTotalState,this.debugRedGPUContext=new DebugRedGPUContext,this.debugViewList=new DebugViewList,this.debugBitmapTextureList=new DebugTextureList,this.debugCubeTextureList=new DebugTextureList("Cube"),this.debugHDRTextureList=new DebugTextureList("HDR"),this.debugPackedTextureList=new DebugTextureList("Packed"),this.debugIndexBufferList=new DebugBufferList("IndexBuffer"),this.debugVertexBufferList=new DebugBufferList("VertexBuffer"),this.debugUniformBufferList=new DebugBufferList("UniformBuffer"),this.debugStorageBufferList=new DebugBufferList("StorageBuffer"),this.debugBufferList=new DebugBufferList("Buffer"),this.#cp()}render(i,m){i.useDebugPanel?(this.#hp(),this.fps.update(this,i,m),this.debugRedGPUContext.update(this,i,m),this.debugViewList.update(this,i,m),this.debugBitmapTextureList.update(this,i,m),this.debugCubeTextureList.update(this,i,m),this.debugHDRTextureList.update(this,i,m),this.debugPackedTextureList.update(this,i,m),this.debugIndexBufferList.update(this,i),this.debugVertexBufferList.update(this,i),this.debugUniformBufferList.update(this,i),this.debugStorageBufferList.update(this,i),this.debugBufferList.update(this,i),this.debugTotalState.update(this,i,m)):this.#fp(),this.#cp()}#cp(){this.totalNum3DGroups=0,this.totalNum3DObjects=0,this.totalNumInstances=0,this.totalNumDrawCalls=0,this.totalNumTriangles=0,this.totalNumPoints=0,this.totalUsedVideoMemory=0}#hp(){this.#lp||(this.#lp=document.createElement("div"),this.#lp.className="RedGPUDebugPanel",document.body.appendChild(this.#lp),[this.fps.debugStatisticsDomService,this.debugTotalState.debugStatisticsDomService,this.debugRedGPUContext.debugStatisticsDomService,this.debugViewList.debugStatisticsDomService,this.debugBufferList.debugStatisticsDomService,this.debugVertexBufferList.debugStatisticsDomService,this.debugIndexBufferList.debugStatisticsDomService,this.debugUniformBufferList.debugStatisticsDomService,this.debugStorageBufferList.debugStatisticsDomService,this.debugBitmapTextureList.debugStatisticsDomService,this.debugPackedTextureList.debugStatisticsDomService,this.debugCubeTextureList.debugStatisticsDomService,this.debugHDRTextureList.debugStatisticsDomService].forEach(i=>this.#lp.appendChild(i.dom)))}#fp(){this.#lp&&(this.#lp.remove(),this.#lp=null)}}Object.freeze(DebugRender);var Ja="struct Uniforms{ backgroundColor:vec4<f32>\n}\n@group(1) @binding(0)\nvar _sampler:sampler;\n@group(1) @binding(1)\nvar _texture:texture_2d<f32>;\n@group(1) @binding(2)\nvar<uniform> uniforms:Uniforms;\n@fragment\nfn main(@location(0) fragUV:vec2<f32>) -> @location(0) vec4<f32> { var viewColor:vec4<f32>=textureSample(_texture,_sampler,fragUV); let backgroundColor=uniforms.backgroundColor; let blendedColor=vec4<f32>( viewColor.rgb + backgroundColor.rgb * (1.0 - viewColor.a), viewColor.a + backgroundColor.a * (1.0 - viewColor.a) ); return blendedColor;\n}\n",Qa="\nstruct VertexUniforms { modelMatrix:mat4x4<f32>,\n};\n@group(0) @binding(0)\nvar<uniform> vertexUniforms:VertexUniforms;\nstruct VertexOutput { @builtin(position) Position:vec4<f32>, @location(0) fragUV:vec2<f32>,\n};\n@vertex\nfn main(@builtin(vertex_index) VertexIndex:u32) -> VertexOutput { var pos=array<vec2<f32>,6>( vec2( 1.0,1.0), vec2( 1.0,-1.0), vec2(-1.0,-1.0), vec2( 1.0,1.0), vec2(-1.0,-1.0), vec2(-1.0,1.0), ); var uv=array<vec2<f32>,6>( vec2(1.0,0.0), vec2(1.0,1.0), vec2(0.0,1.0), vec2(1.0,0.0), vec2(0.0,1.0), vec2(0.0,0.0), ); var output:VertexOutput; output.Position=vertexUniforms.modelMatrix * vec4<f32>(pos[VertexIndex],0.0,1.0); output.fragUV=uv[VertexIndex]; return output;\n}\n";const es=parseWGSL(Qa),ts=parseWGSL(Ja),ns=es.uniforms.vertexUniforms;class FinalRender{#dp=[];#mp=[];#pp;#gp;#xp;#_p;#vp;#bp=[];#Bu;#yp=[];#Sp=[];#pe;#Tp=[];#Mp=[];constructor(){}render(i,m){const{sizeManager:g,gpuDevice:_,antialiasingManager:b}=i,{changedMSAA:y,useMSAA:T}=b,{pixelRectObject:w}=g,{width:P,height:H}=w;if(0===P||0===H)return;const $=this.#wp(i),W=_.createCommandEncoder(),q=W.beginRenderPass($);q.setViewport(0,0,P,H,0,1),q.setScissorRect(0,0,P,H),this.#pp&&!y||this.#Cp(i),this.#Rp(i,q,m.map(i=>{const m=i.colorAttachments[0];return m.postEffectView||m.pickingView||m.resolveTarget||m.view}),P,H,T),q.end(),_.queue.submit([W.finish()])}#Pp(i,m){{const{scene:g,redGPUContext:_}=i,{gpuDevice:b}=_,{backgroundColor:y,useBackgroundColor:T}=g,w=T?y.rgbaNormal:[0,0,0,0],P=_.backgroundColor.rgbaNormal;let H;const $=[w[0]*w[3],w[1]*w[3],w[2]*w[3],w[3]],W=[P[0]*P[3],P[1]*P[3],P[2]*P[3],P[3]];H=[$[0]+W[0]*(1-w[3]),$[1]+W[1]*(1-w[3]),$[2]+W[2]*(1-w[3]),w[3]+P[3]*(1-w[3])],this.#Mp[m][0]=H[0],this.#Mp[m][1]=H[1],this.#Mp[m][2]=H[2],this.#Mp[m][3]=H[3],b.queue.writeBuffer(this.#Tp[m],0,this.#Mp[m])}}#Rp(i,m,g,_,b,y){const{gpuDevice:T}=i;g.forEach((g,y)=>{const P=i.viewList[y],{x:H,y:$,width:W,height:q}=P.pixelRectObject,ye=create$2();w(ye,0,1,0,1,-1e3,1e3),scale(ye,ye,[1/_,1/b,1]),translate(ye,ye,[W/2+H,b-q/2-$,0]),scale(ye,ye,[W/2,q/2,1]),this.#Bp(i,y);const Ge=this.#dp[y],Ke=this.#mp[y];T.queue.writeBuffer(Ge.gpuBuffer,ns.members.modelMatrix.uniformOffset,ye);if(i.antialiasingManager.changedMSAA||!this.#yp[y]||this.#yp[y].width!==W||this.#yp[y].height!==q||this.#Sp[y]!==g){this.#Tp[y]||(this.#Tp[y]=i.gpuDevice.createBuffer({label:`FINAL_RENDER_FRAGMENT_BUFFER_${y}`,size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.#Mp[y]=new Float32Array([1,0,0,1]));const m={layout:this.#_p,label:"FRAGMENT_BIND_GROUP_DESCRIPTOR_FINAL_RENDER",entries:[{binding:0,resource:this.#pe.gpuSampler},{binding:1,resource:g},{binding:2,resource:{buffer:this.#Tp[y],offset:0,size:this.#Tp[y].size}}]};this.#bp[y]=T.createBindGroup(m),this.#yp[y]={width:W||1,height:q||1},this.#Sp[y]=g}this.#Pp(P,y),m.setPipeline(this.#Ip(i)),m.setBindGroup(0,Ke),m.setBindGroup(1,this.#bp[y]),m.draw(6,1,0,0)})}#Cp(i){const{resourceManager:m}=i;this.#pp=m.createBindGroupLayout("FINAL_RENDER_VERTEX_BIND_GROUP_LAYOUT",getVertexBindGroupLayoutDescriptorFromShaderInfo(es,0)),this.#gp=m.createGPUShaderModule("VERTEX_MODULE_FINAL_RENDER",{code:Qa}),this.#xp={module:this.#gp,entryPoint:"main"},this.#vp=m.createGPUShaderModule("FRAGMENT_MODULE_FINAL_RENDER",{code:Ja}),this.#_p=m.createBindGroupLayout("FINAL_RENDER_BIND_GROUP_LAYOUT",getFragmentBindGroupLayoutDescriptorFromShaderInfo(ts,1)),this.#pe=new Sampler(i,{minFilter:"linear"})}#Bp(i,m){const{gpuDevice:g}=i;if(!this.#dp[m]){const _=new ArrayBuffer(ns.arrayBufferByteLength),b=this.#dp[m]=new UniformBuffer(i,_,`FinalRender_View(${m})_VertexUniform`),y={layout:this.#pp,label:"VERTEX_BIND_GROUP_DESCRIPTOR_FINAL_RENDER",entries:[{binding:0,resource:{buffer:b.gpuBuffer,offset:0,size:b.size}}]};this.#mp[m]=g.createBindGroup(y)}}#wp(i){const{backgroundColor:m,gpuContext:g}=i;return{colorAttachments:[{view:g.getCurrentTexture().createView({label:"FINAL_RENDER"}),clearValue:{r:0,g:0,b:0,a:0},loadOp:Ct.CLEAR,storeOp:Rt.STORE}]}}#Ip(i){if(!this.#Bu||i.antialiasingManager.changedMSAA){const{gpuDevice:m}=i,g={label:"PIPELINE_DESCRIPTOR_FINAL_RENDER",layout:m.createPipelineLayout({label:"FINAL_RENDER_PIPELINE_LAYOUT",bindGroupLayouts:[this.#pp,this.#_p]}),vertex:this.#xp,fragment:{module:this.#vp,entryPoint:"main",targets:[{format:navigator.gpu.getPreferredCanvasFormat(),blend:{color:{srcFactor:En.SRC_ALPHA,dstFactor:En.ONE_MINUS_SRC_ALPHA,operation:Dn.ADD},alpha:{srcFactor:En.SRC_ALPHA,dstFactor:En.ONE_MINUS_SRC_ALPHA,operation:Dn.ADD}}}]}};this.#Bu=m.createRenderPipeline(g)}return this.#Bu}}const renderListForLayer=(i,m,g="pipeline")=>{let _=0;const b=i.length,{currentRenderPassEncoder:y}=m;for(y.setBindGroup(0,m.view.systemUniform_Vertex_UniformBindGroup);_<b;_++){const b=i[_];if(b.passFrustumCulling&&b.gpuRenderInfo){const i=b._geometry,_=b._material;i?m.num3DObjects++:m.num3DGroups++;const{gpuRenderInfo:T}=b,{vertexUniformBindGroup:w}=T;if(T[g]||("shadowPipeline"===g?T.shadowPipeline=b.gpuRenderInfo.vertexStructInfo.vertexEntries.includes("drawDirectionalShadowDepth")?createBasePipeline(b,b.gpuRenderInfo.vertexShaderModule,b.gpuRenderInfo.vertexBindGroupLayout,Tr):null:"pickingPipeline"===g&&(T.pickingPipeline=b.gpuRenderInfo.vertexStructInfo.vertexEntries.includes("picking")?createBasePipeline(b,b.gpuRenderInfo.vertexShaderModule,b.gpuRenderInfo.vertexBindGroupLayout,Mr):null)),i&&T[g]){y.setPipeline(T[g]);const{gpuBuffer:b}=i.vertexBuffer,{fragmentUniformBindGroup:P}=_.gpuRenderInfo;if(m.prevVertexGpuBuffer!==b&&(y.setVertexBuffer(0,b),m.prevVertexGpuBuffer=b),y.setBindGroup(1,w),m.prevFragmentUniformBindGroup!==P&&(y.setBindGroup(2,P),m.prevFragmentUniformBindGroup=P),m.numDrawCalls++,i.indexBuffer){const{indexBuffer:g}=i,{indexCount:_,triangleCount:b,gpuBuffer:T,format:w}=g;y.setIndexBuffer(T,w),y.drawIndexed(_,1,0,0,0),m.numTriangles+=b,m.numPoints+=_}else{const{vertexBuffer:g}=i,{vertexCount:_,triangleCount:b}=g;y.draw(_,1,0,0),m.numTriangles+=b,m.numPoints+=_}}}}m.prevVertexGpuBuffer=null,m.prevFragmentUniformBindGroup=null,m.prevVertexGpuBuffer=null};class Renderer{#Ep;#Dp;#Lp;#Up=new GltfAnimationLooperManager;constructor(){}start(i,m){cancelAnimationFrame(i.currentRequestAnimationFrame);const HD_render=g=>{m?.(g),i.currentTime=g,this.renderFrame(i,g),this.#Lp.render(i,g),i.currentRequestAnimationFrame=requestAnimationFrame(HD_render)};i.currentRequestAnimationFrame=requestAnimationFrame(HD_render)}stop(i){cancelAnimationFrame(i.currentRequestAnimationFrame),i.currentRequestAnimationFrame=null}renderFrame(i,m){this.#Dp||(this.#Dp=new FinalRender),this.#Lp||(this.#Lp=new DebugRender(i));const g=[];{let _=0;const b=i.viewList.length;for(;_<b;_++){const b=i.viewList[_];g.push(this.renderView(b,m))}}this.#Dp.render(i,g),i.antialiasingManager.changedMSAA=!1}renderView(i,m){const{redGPUContext:g,camera:_,pickingManager:b,pixelRectObject:y,renderViewStateData:T}=i,{colorAttachment:w,depthStencilAttachment:P,gBufferNormalTextureAttachment:H,gBufferMotionVectorTextureAttachment:$}=this.#Ap(i),W=g.gpuDevice.createCommandEncoder({label:"ViewRender_MainCommandEncoder"}),q={label:`${i.name} Basic Render Pass`,colorAttachments:[w,H,$],depthStencilAttachment:P};if(i.renderViewStateData.reset(null,m),y.width&&y.height){{const{scene:m}=i,{shadowManager:_}=m;_.update(g)}DrawBufferManager.getInstance(g).flushAllCommands(T);{const{timestamp:g,prevTimestamp:b}=T,y=g-b,w=1e3/60;y>=w&&(T.prevTimestamp=g-y%w,_.update?.(i,m))}this.#Op(i),this.#kp(i,W),_.targetMesh?.render(i.renderViewStateData),this.#Gp(i,W,q),this.#Fp(i,W,q,P),this.#Np(i,W)}return q.colorAttachments[0].postEffectView=i.postEffectManager.render().textureView,g.gpuDevice.queue.submit([W.finish(),this.#Vp(g,T)]),i.renderViewStateData.viewRenderTime=performance.now()-i.renderViewStateData.startTime,b?.checkEvents(i,m),q}#kp(i,m){const{scene:g}=i,{shadowManager:_}=g,{directionalShadowManager:b}=_,y={label:`${i.name} Shadow Render Pass`,colorAttachments:[],depthStencilAttachment:{view:b.shadowDepthTextureView,depthClearValue:1,depthLoadOp:Ct.CLEAR,depthStoreOp:Rt.STORE}},T=m.beginRenderPass(y);this.#zp(i,T,!0),this.#Hp(i,T,!0,!1),b.castingList.length&&((i,m)=>{const{renderViewStateData:g,scene:_}=i;g.currentRenderPassEncoder=m;const{shadowManager:b}=_,{directionalShadowManager:y}=b,{castingList:T}=y;renderListForLayer(T,g,"shadowPipeline")})(i,T),T.end(),b.resetCastingList()}#Gp(i,m,g){const{renderViewStateData:_,skybox:b,grid:y,axis:T}=i,w=m.beginRenderPass(g);{const m=i.viewRenderTextureManager.renderPath1ResultTextureView;this.#zp(i,w),this.#Hp(i,w,!1,!0,m)}_.currentRenderPassEncoder=w,w.setBindGroup(0,i.systemUniform_Vertex_UniformBindGroup),b&&b.render(_),T&&T.render(_),((i,m)=>{const{renderViewStateData:g,scene:_}=i;g.currentRenderPassEncoder=m;const{children:b}=_;let y=0;const T=b.length;for(;y<T;y++)b[y].render(g);g.prevVertexGpuBuffer=null,g.prevFragmentUniformBindGroup=null,g.prevVertexGpuBuffer=null,m.executeBundles(g.bundleListBasicList)})(i,w),y&&y.render(_),((i,m)=>{const{renderViewStateData:g,rawCamera:_}=i;g.currentRenderPassEncoder=m;const{bundleListAlphaLayer:b,bundleListTransparentLayer:y,bundleListParticleLayer:T}=g;b.length&&m.executeBundles(b);const{x:w,y:P,z:H}=_;y.length&&m.executeBundles(sortTransparentObjects({x:w,y:P,z:H},y)),T.length&&m.executeBundles(T)})(i,w),w.end()}#Fp(i,m,g,_){const{redGPUContext:b,renderViewStateData:y}=i,{antialiasingManager:T}=b,{useMSAA:w}=T;if(i.renderViewStateData.bundleListRender2PathLayer.length){const{mipmapGenerator:T}=b.resourceManager;let P=i.viewRenderTextureManager.renderPath1ResultTexture,H=w?i.viewRenderTextureManager.gBufferColorResolveTexture:i.viewRenderTextureManager.gBufferColorTexture;H||(w?console.error("MSAA가 활성화되어 있지만 gBufferColorResolveTexture가 정의되지 않았습니다"):console.error("gBufferColorTexture가 정의되지 않았습니다")),P||console.error("renderPath1ResultTexture가 정의되지 않았습니다"),m.copyTextureToTexture({texture:H},{texture:P},{width:i.pixelRectObject.width,height:i.pixelRectObject.height,depthOrArrayLayers:1}),T.generateMipmap(P,i.viewRenderTextureManager.renderPath1ResultTextureDescriptor,!0);const $=m.beginRenderPass({label:`${i.name} 2Path Render Pass`,colorAttachments:[...g.colorAttachments].map(i=>({...i,loadOp:Ct.LOAD})),depthStencilAttachment:{..._,depthLoadOp:Ct.LOAD}});$.executeBundles(y.bundleListRender2PathLayer),$.end()}}#Np(i,m){const{pickingManager:g}=i;if(g&&g.castingList.length){g.checkTexture(i);const _={label:`${i.name} Picking Render Pass`,colorAttachments:[{view:g.pickingGPUTextureView,clearValue:{r:0,g:0,b:0,a:0},loadOp:Ct.CLEAR,storeOp:Rt.STORE}],depthStencilAttachment:{view:g.pickingDepthGPUTextureView,depthClearValue:1,depthLoadOp:Ct.CLEAR,depthStoreOp:Rt.STORE}},b=m.beginRenderPass(_);this.#zp(i,b),this.#Hp(i,b,!1,!1),((i,m)=>{const{renderViewStateData:g,pickingManager:_}=i;g.currentRenderPassEncoder=m;const{castingList:b}=_;renderListForLayer(b,g,"pickingPipeline")})(i,b),b.end()}}#Op(i){const{taa:m}=i,g=m.frameIndex||0,_=m.jitterStrength,b=g%16,y=this.#$p(b+1,2),T=this.#$p(b+1,3),w=window.devicePixelRatio||1,P=(y-.5)/w*_,H=(T-.5)/w*_;i.setJitterOffset(P,H)}#$p(i,m){let g=0,_=1,b=i;for(;b>0;)_/=m,g+=_*(b%m),b=Math.floor(b/m);return g}#Vp(i,m){const{animationList:g,skinList:_}=m,b=_.length,y=g.length,{gpuDevice:T}=i,w=T.createCommandEncoder({label:"BatchUpdateSkinMatrices_CommandEncoder"}),P=w.beginComputePass();y&&this.#Up.render(i,m.timestamp,P,g.flat());for(let m=0;m<b;m++){const g=_[m],b=g.animationInfo.skinInfo;b.usedJoints||(b.usedJoints=b.getUsedJointIndices(g));const y=16*(1+b.usedJoints.length);b.jointData&&b.jointData.length===y||(b.jointData=new Float32Array(y),b.computeShader=null),b.invertNodeGlobalTransform=b.invertNodeGlobalTransform||new Float32Array(g.modelMatrix.length);{const i=g.modelMatrix,m=b.invertNodeGlobalTransform,_=i[0],y=i[1],T=i[2],w=i[3],P=i[4],H=i[5],$=i[6],W=i[7],q=i[8],ye=i[9],Ge=i[10],Ke=i[11],je=i[12],Xe=i[13],Ye=i[14],Ze=i[15],Je=H*(Ge*Ze-Ke*Ye)-$*(ye*Ze-Ke*Xe)+W*(ye*Ye-Ge*Xe),Qe=-(P*(Ge*Ze-Ke*Ye)-$*(q*Ze-Ke*je)+W*(q*Ye-Ge*je)),et=P*(ye*Ze-Ke*Xe)-H*(q*Ze-Ke*je)+W*(q*Xe-ye*je),at=-(P*(ye*Ye-Ge*Xe)-H*(q*Ye-Ge*je)+$*(q*Xe-ye*je)),ht=-(y*(Ge*Ze-Ke*Ye)-T*(ye*Ze-Ke*Xe)+w*(ye*Ye-Ge*Xe)),ft=_*(Ge*Ze-Ke*Ye)-T*(q*Ze-Ke*je)+w*(q*Ye-Ge*je),gt=-(_*(ye*Ze-Ke*Xe)-y*(q*Ze-Ke*je)+w*(q*Xe-ye*je)),xt=_*(ye*Ye-Ge*Xe)-y*(q*Ye-Ge*je)+T*(q*Xe-ye*je),vt=y*($*Ze-W*Ye)-T*(H*Ze-W*Xe)+w*(H*Ye-$*Xe),bt=-(_*($*Ze-W*Ye)-T*(P*Ze-W*je)+w*(P*Ye-$*je)),yt=_*(H*Ze-W*Xe)-y*(P*Ze-W*je)+w*(P*Xe-H*je),St=-(_*(H*Ye-$*Xe)-y*(P*Ye-$*je)+T*(P*Xe-H*je)),Tt=-(y*($*Ke-W*Ge)-T*(H*Ke-W*ye)+w*(H*Ge-$*ye)),Mt=_*($*Ke-W*Ge)-T*(P*Ke-W*q)+w*(P*Ge-$*q),wt=-(_*(H*Ke-W*ye)-y*(P*Ke-W*q)+w*(P*ye-H*q)),Ct=_*(H*Ge-$*ye)-y*(P*Ge-$*q)+T*(P*ye-H*q),Rt=_*Je+y*Qe+T*et+w*at;if(Math.abs(Rt)<1e-10)console.error("Matrix is not invertible (determinant is zero or near zero)"),m[0]=1,m[1]=0,m[2]=0,m[3]=0,m[4]=0,m[5]=1,m[6]=0,m[7]=0,m[8]=0,m[9]=0,m[10]=1,m[11]=0,m[12]=0,m[13]=0,m[14]=0,m[15]=1;else{const i=1/Rt;m[0]=Je*i,m[1]=ht*i,m[2]=vt*i,m[3]=Tt*i,m[4]=Qe*i,m[5]=ft*i,m[6]=bt*i,m[7]=Mt*i,m[8]=et*i,m[9]=gt*i,m[10]=yt*i,m[11]=wt*i,m[12]=at*i,m[13]=xt*i,m[14]=St*i,m[15]=Ct*i}}b.computeShader||b.createCompute(i,T,g.geometry.vertexBuffer,g.animationInfo.weightBuffer,g.animationInfo.jointBuffer);{const i=b.usedJoints;let m=i.length;const g=b.jointData;for(;m--;)g.set(b.joints[i[m]].modelMatrix,16*(m+1));g.set(b.invertNodeGlobalTransform,0),T.queue.writeBuffer(b.uniformBuffer,0,g)}P.setPipeline(b.computePipeline),P.setBindGroup(0,b.bindGroup),P.dispatchWorkgroups(Math.ceil(g.geometry.vertexBuffer.vertexCount/b.WORK_SIZE))}return P.end(),w.finish()}#Ap(i){const{scene:m,redGPUContext:g,viewRenderTextureManager:_}=i,{depthTextureView:b,gBufferColorTextureView:y,gBufferColorResolveTextureView:T,gBufferNormalTextureView:w,gBufferNormalResolveTextureView:P,gBufferMotionVectorTextureView:H,gBufferMotionVectorResolveTextureView:$}=_,{antialiasingManager:W}=g,{useMSAA:q}=W,ye={view:y,clearValue:{r:0,g:0,b:0,a:0},loadOp:Ct.CLEAR,storeOp:Rt.STORE},Ge={view:b,depthClearValue:1,depthLoadOp:Ct.CLEAR,depthStoreOp:Rt.STORE},Ke={view:w,clearValue:{r:0,g:0,b:0,a:0},loadOp:Ct.CLEAR,storeOp:Rt.STORE},je={view:H,clearValue:{r:0,g:0,b:0,a:0},loadOp:Ct.CLEAR,storeOp:Rt.STORE};return q&&(ye.resolveTarget=T,Ke.resolveTarget=P,je.resolveTarget=$),{colorAttachment:ye,depthStencilAttachment:Ge,gBufferNormalTextureAttachment:Ke,gBufferMotionVectorTextureAttachment:je}}#zp(i,m,g=!1){const{scene:_,pixelRectObject:b}=i,{shadowManager:y}=_,{directionalShadowManager:T}=y;if(g){const i=T.shadowDepthTextureSize,g=T.shadowDepthTextureSize;m.setViewport(0,0,i,g,0,1),m.setScissorRect(0,0,i,g)}else{const{width:i,height:g}=b;this.#Ep&&this.#Ep.width===i&&this.#Ep.height===g||(m.setViewport(0,0,i,g,0,1),m.setScissorRect(0,0,i,g),this.#Ep={width:i,height:g})}}#Hp(i,m,g=!1,_=!0,b=null){i.update(g,_,b),m.setBindGroup(0,i.systemUniform_Vertex_UniformBindGroup)}}create$2();var rs=Object.freeze({__proto__:null,isHexColor:isHexColor,isUint:isUint,validateNumber:validateNumber,validateNumberRange:validateNumberRange,validatePositiveNumberRange:validatePositiveNumberRange,validateRedGPUContext:validateRedGPUContext,validateUintRange:validateUintRange});class BrightnessContrast extends ASinglePassPostEffect{#Ul=0;#ar=0;constructor(i){super(i),this.init(i,"POST_EFFECT_BRIGHTNESS_CONTRAST",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy );\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nvar color:vec4<f32>=textureLoad( sourceTexture,index,);\nlet brightness_value:f32=uniforms.brightness/255.0;\nlet contrast_value:f32=uniforms.contrast/255.0;\nvar tempColor:vec3<f32>;\nif ( contrast_value > 0.0 ) { tempColor=( color.rgb - 0.5 )/( 1.0 - contrast_value ) + 0.5;\n}else { tempColor=( color.rgb - 0.5 ) * ( 1.0 + contrast_value ) + 0.5;\n}\ncolor=vec4<f32>(tempColor + brightness_value,color.a);\ntextureStore(outputTexture,index,color );\n","struct Uniforms { brightness:f32, contrast:f32\n};\n"))}get brightness(){return this.#Ul}set brightness(i){validateNumberRange(i,-150,150),this.#Ul=i,this.updateUniform("brightness",i)}get contrast(){return this.#ar}set contrast(i){validateNumberRange(i,-50,100),this.#ar=i,this.updateUniform("contrast",i)}}Object.freeze(BrightnessContrast);class ColorBalance extends ASinglePassPostEffect{#Kp=0;#Wp=0;#jp=0;#Xp=0;#qp=0;#Yp=0;#Zp=0;#Jp=0;#Qp=0;#eg=!0;constructor(i){super(i),this.init(i,"POST_EFFECT_COLOR_BALANCE",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy );\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nvar color:vec4<f32>=textureLoad( sourceTexture,index,);\nlet original_luminance=0.299 * color.r + 0.587 * color.g + 0.114 * color.b;\nlet shadow_weight=1.0 - smoothstep(0.0,0.5,original_luminance);\nlet highlight_weight=smoothstep(0.5,1.0,original_luminance);\nlet midtone_weight=1.0 - shadow_weight - highlight_weight;\nlet cyan_red=shadow_weight * uniforms.shadowCyanRed +\nmidtone_weight * uniforms.midtoneCyanRed +\nhighlight_weight * uniforms.highlightCyanRed;\nlet magenta_green=shadow_weight * uniforms.shadowMagentaGreen +\nmidtone_weight * uniforms.midtoneMagentaGreen +\nhighlight_weight * uniforms.highlightMagentaGreen;\nlet yellow_blue=shadow_weight * uniforms.shadowYellowBlue +\nmidtone_weight * uniforms.midtoneYellowBlue +\nhighlight_weight * uniforms.highlightYellowBlue;\ncolor.r +=cyan_red * 0.01;\ncolor.g +=magenta_green * 0.01;\ncolor.b +=yellow_blue * 0.01;\nlet adjusted_luminance=0.299 * color.r + 0.587 * color.g + 0.114 * color.b;\nif (uniforms.preserveLuminosity==1 && adjusted_luminance > 0.0) { let ratio=original_luminance/adjusted_luminance; color=color * ratio;\n}\ntextureStore(outputTexture,index,color );\n","struct Uniforms { shadowCyanRed:f32, shadowMagentaGreen:f32, shadowYellowBlue:f32, midtoneCyanRed:f32, midtoneMagentaGreen:f32, midtoneYellowBlue:f32, highlightCyanRed:f32, highlightMagentaGreen:f32, highlightYellowBlue:f32, preserveLuminosity:u32\n};\n"))}get shadowCyanRed(){return this.#Kp}set shadowCyanRed(i){validateNumberRange(i,-100,100),this.#Kp=i,this.updateUniform("shadowCyanRed",i)}get shadowMagentaGreen(){return this.#Wp}set shadowMagentaGreen(i){validateNumberRange(i,-100,100),this.#Wp=i,this.updateUniform("shadowMagentaGreen",i)}get shadowYellowBlue(){return this.#jp}set shadowYellowBlue(i){validateNumberRange(i,-100,100),this.#jp=i,this.updateUniform("shadowYellowBlue",i)}get midtoneCyanRed(){return this.#Xp}set midtoneCyanRed(i){validateNumberRange(i,-100,100),this.#Xp=i,this.updateUniform("midtoneCyanRed",i)}get midtoneMagentaGreen(){return this.#qp}set midtoneMagentaGreen(i){validateNumberRange(i,-100,100),this.#qp=i,this.updateUniform("midtoneMagentaGreen",i)}get midtoneYellowBlue(){return this.#Yp}set midtoneYellowBlue(i){validateNumberRange(i,-100,100),this.#Yp=i,this.updateUniform("midtoneYellowBlue",i)}get highlightCyanRed(){return this.#Zp}set highlightCyanRed(i){validateNumberRange(i,-100,100),this.#Zp=i,this.updateUniform("highlightCyanRed",i)}get highlightMagentaGreen(){return this.#Jp}set highlightMagentaGreen(i){validateNumberRange(i,-100,100),this.#Jp=i,this.updateUniform("highlightMagentaGreen",i)}get highlightYellowBlue(){return this.#Qp}set highlightYellowBlue(i){validateNumberRange(i,-100,100),this.#Qp=i,this.updateUniform("highlightYellowBlue",i)}get preserveLuminosity(){return this.#eg}set preserveLuminosity(i){this.#eg=i,this.updateUniform("preserveLuminosity",i)}}Object.freeze(ColorBalance);class ColorTemperatureTint extends ASinglePassPostEffect{#tg=6500;#ng=0;#rg=100;constructor(i){super(i),this.init(i,"POST_EFFECT_COLOR_TEMPERATURE_TINT",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy);\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nvar color:vec4<f32>=textureLoad(sourceTexture,index);\nlet temp=uniforms.temperature;\nvar tempRGB:vec3<f32>;\nif (temp <=6600.0) { tempRGB.r=1.0;\n} else { let t=temp - 6600.0; tempRGB.r=clamp(1.292936 * pow(t,-0.1332047),0.0,1.0);\n}\nif (temp <=6600.0) { let t=temp; tempRGB.g=clamp(0.39008157 * log(t) - 0.63184144,0.0,1.0);\n} else { let t=temp - 6600.0; tempRGB.g=clamp(1.292936 * pow(t,-0.1332047),0.0,1.0);\n}\nif (temp >=6600.0) { tempRGB.b=1.0;\n} else if (temp <=1900.0) { tempRGB.b=0.0;\n} else { let t=temp - 1000.0; tempRGB.b=clamp(0.543206789 * log(t) - 1.19625408,0.0,1.0);\n}\nlet neutralTemp:vec3<f32>=vec3<f32>(1.0,1.0,1.0);\nlet tempAdjust:vec3<f32>=tempRGB/neutralTemp;\nlet tintValue=uniforms.tint * 0.01;\nvar tintRGB:vec3<f32>;\nif (tintValue >=0.0) { tintRGB=vec3<f32>(1.0 - tintValue * 0.2,1.0,1.0 - tintValue * 0.2);\n} else { let mag=-tintValue; tintRGB=vec3<f32>(1.0,1.0 - mag * 0.2,1.0);\n}\nlet colorAdjust=tempAdjust * tintRGB;\nlet strength=uniforms.strength * 0.01;\nlet finalAdjust=mix(vec3<f32>(1.0,1.0,1.0),colorAdjust,strength);\ncolor=vec4<f32>(color.rgb * finalAdjust,color.a);\ncolor=vec4<f32>(clamp(color.rgb,vec3<f32>(0.0),vec3<f32>(1.0)),color.a);\ntextureStore(outputTexture,index,color);\n","struct Uniforms { temperature:f32, tint:f32, strength:f32\n};\n")),this.strength=this.#rg,this.tint=this.#ng,this.temperature=this.#tg}get temperature(){return this.#tg}set temperature(i){validateNumberRange(i,1e3,2e4),this.#tg=i,this.updateUniform("temperature",i)}get tint(){return this.#ng}set tint(i){validateNumberRange(i,-100,100),this.#ng=i,this.updateUniform("tint",i)}get strength(){return this.#rg}set strength(i){validateNumberRange(i,0,100),this.#rg=i,this.updateUniform("strength",i)}setWarmTone(){this.temperature=3200,this.tint=-10}setCoolTone(){this.temperature=8e3,this.tint=10}setNeutral(){this.temperature=6500,this.tint=0}setCandleLight(){this.temperature=1900,this.tint=-5}setDaylight(){this.temperature=5600,this.tint=0}setCloudyDay(){this.temperature=7500,this.tint=5}setNeonLight(){this.temperature=9e3,this.tint=15}}Object.freeze(ColorTemperatureTint);class Grayscale extends ASinglePassPostEffect{constructor(i){super(i);this.init(i,"POST_EFFECT_GRAYSCALE",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy );\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nvar color:vec4<f32>=textureLoad( sourceTexture,index );\nlet gray=(color.r + color.g + color.b)/3.0;\ntextureStore(outputTexture,index,vec4<f32>( gray,gray,gray,color.a) );\n",""))}}Object.freeze(Grayscale);class HueSaturation extends ASinglePassPostEffect{#ig=0;#ag=0;constructor(i){super(i),this.init(i,"POST_EFFECT_HUE_SATURATION",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy );\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nvar color:vec4<f32>=textureLoad( sourceTexture,index,);\nlet hue_value:f32=uniforms.hue/180.0;\nlet saturation_value:f32=uniforms.saturation/100.0;\nlet angle:f32=hue_value * 3.1415926535897932384626433832795;\nlet s:f32=sin(angle);\nlet c:f32=cos(angle);\nvar weights:vec3<f32>=(vec3<f32>(2.0 * c,-sqrt(3.0) * s - c,sqrt(3.0) * s - c) + 1.0)/3.0;\nlet len:f32=length(color.rgb);\ncolor=vec4<f32>( vec3<f32>( dot(color.rgb,weights.xyz), dot(color.rgb,weights.zxy), dot(color.rgb,weights.yzx) ), color.a\n);\nlet average:f32=(color.r + color.g + color.b)/3.0;\nif (saturation_value > 0.0) { color=vec4<f32>( color.rgb + (average - color.rgb) * (1.0 - 1.0/(1.001 - saturation_value)), color.a );\n} else { color=vec4<f32>( color.rgb + (average - color.rgb) * (-saturation_value), color.a );\n}\ntextureStore(outputTexture,index,color );\n","struct Uniforms { hue:f32, saturation:f32\n};\n"))}get hue(){return this.#ig}set hue(i){validateNumberRange(i,-180,180),this.#ig=i,this.updateUniform("hue",i)}get saturation(){return this.#ag}set saturation(i){validateNumberRange(i,-100,100),this.#ag=i,this.updateUniform("saturation",i)}}Object.freeze(HueSaturation);class Invert extends ASinglePassPostEffect{constructor(i){super(i);this.init(i,"POST_EFFECT_INVERT",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy );\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nvar color:vec4<f32>=textureLoad( sourceTexture,index,);\ncolor.r=1.0 - color.r;\ncolor.g=1.0 - color.g;\ncolor.b=1.0 - color.b;\ntextureStore(outputTexture,index,color );\n",""))}}Object.freeze(Invert);class Threshold extends ASinglePassPostEffect{#sg=128;constructor(i){super(i),this.init(i,"POST_EFFECT_THRESHOLD",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy );\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nvar color:vec4<f32>=textureLoad( sourceTexture,index,);\nlet threshold_value:f32=uniforms.threshold/255.0;\nvar v=0.0;\nif( 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b >=threshold_value) { v=1.0;\n}\ncolor=vec4<f32>(v,v,v,color.a);\ntextureStore(outputTexture,index,color );\n","struct Uniforms { threshold:f32\n};\n")),this.threshold=this.#sg}get threshold(){return this.#sg}set threshold(i){validateNumberRange(i,1,255),this.#sg=i,this.updateUniform("threshold",i)}}Object.freeze(Threshold);class Vibrance extends ASinglePassPostEffect{#og=0;#ag=0;constructor(i){super(i),this.init(i,"POST_EFFECT_VIBRANCE",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy);\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nvar color:vec4<f32>=textureLoad(sourceTexture,index);\nlet originalColor=color;\nlet luminance=0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\nif (uniforms.saturation !=0.0) { let saturationFactor=1.0 + uniforms.saturation * 0.01; color=vec4<f32>( mix(luminance,color.r,saturationFactor), mix(luminance,color.g,saturationFactor), mix(luminance,color.b,saturationFactor), color.a );\n}\nif (uniforms.vibrance !=0.0) { let maxComponent=max(max(color.r,color.g),color.b); let minComponent=min(min(color.r,color.g),color.b); let currentSaturation=maxComponent - minComponent; let protectionFactor=1.0/(1.0 + exp(6.0 * (currentSaturation - 0.6))); var skinToneProtection=1.0; if (color.r > color.g && color.g > color.b) { let skinToneAmount=(color.r - color.b)/max(color.r,0.001); skinToneProtection=1.0 - smoothstep(0.3,0.8,skinToneAmount) * 0.7; } let finalProtection=protectionFactor * skinToneProtection; let vibranceStrength=uniforms.vibrance * 0.01 * finalProtection; let vibranceFactor=1.0 + vibranceStrength; color=vec4<f32>( mix(luminance,color.r,vibranceFactor), mix(luminance,color.g,vibranceFactor), mix(luminance,color.b,vibranceFactor), color.a );\n}\ncolor=clamp(color,vec4<f32>(0.0),vec4<f32>(1.0));\ntextureStore(outputTexture,index,color);\n","struct Uniforms { vibrance:f32, saturation:f32\n};\n"))}get vibrance(){return this.#og}set vibrance(i){validateNumberRange(i,-100,100),this.#og=i,this.updateUniform("vibrance",i)}get saturation(){return this.#ag}set saturation(i){validateNumberRange(i,-100,100),this.#ag=i,this.updateUniform("saturation",i)}}Object.freeze(Vibrance);const is=[0,0,0,0,0,1,0,0,0,0,0,0],as=[0,-1,0,0,-1,5,-1,0,0,-1,0,0],ss=[1,1,1,0,1,1,1,0,1,1,1,0],os=[0,1,0,0,1,-4,1,0,0,1,0,0],us=[-2,-1,0,0,-1,1,1,0,0,1,2,0];class Convolution extends ASinglePassPostEffect{static NORMAL=is;static SHARPEN=as;static BLUR=ss;static EDGE=os;static EMBOSE=us;#ug=ss;constructor(i){super(i),this.init(i,"POST_EFFECT_CONVOLUTION",createBasicPostEffectCode(this,"let index=vec2<i32>(global_id.xy );\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet perPX=vec2<f32>(1.0/dimW,1.0/dimH);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nvar color:vec4<f32>=vec4<f32>(0.0);\nlet kernelWeight_value:f32=uniforms.kernelWeight;\nlet kernel_value:mat3x3<f32>=uniforms.kernel;\ncolor +=textureLoad(sourceTexture,index + vec2<i32>(-1,-1)) * kernel_value[0][0];\ncolor +=textureLoad(sourceTexture,index + vec2<i32>(0,-1)) * kernel_value[0][1];\ncolor +=textureLoad(sourceTexture,index + vec2<i32>(1,-1)) * kernel_value[0][2];\ncolor +=textureLoad(sourceTexture,index + vec2<i32>(-1,0)) * kernel_value[1][0];\ncolor +=textureLoad(sourceTexture,index + vec2<i32>(0,0)) * kernel_value[1][1];\ncolor +=textureLoad(sourceTexture,index + vec2<i32>(1,0)) * kernel_value[1][2];\ncolor +=textureLoad(sourceTexture,index + vec2<i32>(-1,1)) * kernel_value[2][0];\ncolor +=textureLoad(sourceTexture,index + vec2<i32>(0,1)) * kernel_value[2][1];\ncolor +=textureLoad(sourceTexture,index + vec2<i32>(1,1)) * kernel_value[2][2];\ntextureStore(outputTexture,index,color/kernelWeight_value );\n","struct Uniforms { kernelWeight:f32, kernel:mat3x3<f32>\n};\n")),this.kernel=this.#ug}get kernel(){return this.#ug}set kernel(i){this.#ug=i;let m=0;for(const i in this.#ug)m+=this.#ug[i];this.updateUniform("kernelWeight",m),this.updateUniform("kernel",i)}}Object.freeze(Convolution);class Blur extends AMultiPassPostEffect{#lg;constructor(i){super(i,[new Convolution(i)]),this.#lg=this.passList[0],this.#lg.kernel=Convolution.BLUR}render(i,m,g,_){return this.#lg.render(i,m,g,_)}}Object.freeze(Blur);class DirectionalBlur extends ASinglePassPostEffect{#cg=15;#hg=0;constructor(i){super(i),this.init(i,"POST_EFFECT_DIRECTIONAL_BLUR",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet direction=vec2<f32>(uniforms.directionX,uniforms.directionY);\nlet dirLength=length(direction);\nlet normalizedDir=select(vec2<f32>(0.0),direction/dirLength,dirLength > 0.0);\nlet dir=normalizedDir * uniforms.amount;\nconst loopSize=30.0;\nlet offset=random(global_id,0.0);\nlet global_id_vec=vec2<f32>(f32(global_id.x),f32(global_id.y));\nvar sum=vec4<f32>(0.0,0.0,0.0,0.0);\nvar total=0.0;\nfor (var t=-loopSize;t <=loopSize;t=t + 1.0) { var percent=1.0 - (t + offset - 0.5)/loopSize; var weight=3.0 * (percent - percent * percent); let deltaPercent=dir * percent; let delta=vec2<i32>( i32(clamp(global_id_vec.x + deltaPercent.x,0.0,dimW - 1.0)), i32(clamp(global_id_vec.y + deltaPercent.y,0.0,dimH - 1.0)) ); sum +=textureLoad(sourceTexture,delta).xyzw * weight; total +=weight;\n}\ntextureStore(outputTexture,vec2<i32>(global_id.xy),sum/total);\n","struct Uniforms { amount:f32, directionX:f32, directionY:f32\n};\nfn random(id:vec3<u32>,delta:f32) -> f32 { let seed:u32=((id.x << 16) | (id.y & 0xFFFF)) ^ (id.z * 0x63641362); let t:vec3<f32>=vec3<f32>(f32(seed & 0xFF),f32((seed >> 8) & 0xFF),f32(seed >> 16)); return delta + fract(sin(dot(t,vec3<f32>(12.9898,78.233,12.9898))) * 43758.5453);\n}\n")),this.amount=this.#cg,this.angle=this.#hg}get angle(){return this.#hg}set angle(i){validateNumber(i),this.#hg=i%360,this.#fg()}get amount(){return this.#cg}set amount(i){validateNumberRange(i,0),this.#cg=i,this.updateUniform("amount",i)}#fg(){const i=this.#hg*Math.PI/180,m=Math.cos(i),g=Math.sin(i);this.updateUniform("directionX",m),this.updateUniform("directionY",g)}}Object.freeze(DirectionalBlur);class RadialBlur extends ASinglePassPostEffect{#cg=50;#xh=0;#_h=0;#dg=16;constructor(i){super(i),this.init(i,"POST_EFFECT_RADIAL_BLUR",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet center=vec2<f32>(dimW * 0.5 + uniforms.centerX,dimH * 0.5 + uniforms.centerY);\nlet global_id_vec=vec2<f32>(f32(global_id.x),f32(global_id.y));\nlet toPixel=global_id_vec - center;\nlet distance=length(toPixel);\nlet angle=atan2(toPixel.y,toPixel.x);\nlet maxDist=min(dimW,dimH) * 0.5;\nlet normalizedDistance=distance/maxDist;\nlet rotationAngle=uniforms.amount * normalizedDistance * 0.001;\nlet sampleCount=i32(uniforms.sampleCount);\nvar sum=vec4<f32>(0.0,0.0,0.0,0.0);\nvar totalWeight=0.0;\nfor (var i=0;i < sampleCount;i=i + 1) { let t=f32(i)/f32(sampleCount - 1); let sampleAngle=angle + (t - 0.5) * rotationAngle; let samplePos=center + vec2<f32>( cos(sampleAngle) * distance, sin(sampleAngle) * distance ); var weight=1.0 - abs(t - 0.5) * 1.5; weight=max(weight,0.1); let sampleCoord=vec2<i32>( i32(clamp(samplePos.x,0.0,dimW - 1.0)), i32(clamp(samplePos.y,0.0,dimH - 1.0)) ); sum +=textureLoad(sourceTexture,sampleCoord).xyzw * weight; totalWeight +=weight;\n}\nlet centerFalloff=smoothstep(0.0,maxDist * 0.2,distance);\nlet originalColor=textureLoad(sourceTexture,vec2<i32>(global_id.xy)).xyzw;\nlet blurredColor=sum/totalWeight;\nlet finalColor=mix(originalColor,blurredColor,centerFalloff);\ntextureStore(outputTexture,vec2<i32>(global_id.xy),finalColor);\n","struct Uniforms { amount:f32, centerX:f32, centerY:f32, sampleCount:f32\n};\n")),this.amount=this.#cg,this.sampleCount=this.#dg}get centerX(){return this.#xh}set centerX(i){validateNumber(i),this.#xh=i,this.updateUniform("centerX",i)}get centerY(){return this.#_h}set centerY(i){validateNumber(i),this.#_h=i,this.updateUniform("centerY",i)}get amount(){return this.#cg}set amount(i){validateNumberRange(i,0),this.#cg=i,this.updateUniform("amount",i)}get sampleCount(){return this.#dg}set sampleCount(i){validateNumberRange(i,4),this.#dg=i,this.updateUniform("sampleCount",i)}}Object.freeze(RadialBlur);class ZoomBlur extends ASinglePassPostEffect{#cg=64;#xh=0;#_h=0;constructor(i){super(i),this.init(i,"POST_EFFECT_ZOOM_BLUR",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet dimensionsVec=vec2<f32>(dimW,dimH);\nlet amount=uniforms.amount/min(dimW,dimH);\nconst loopSize=30.0;\nlet offset=random(global_id,0.0);\nlet center=vec2<f32>(dimW * 0.5 + uniforms.centerX,dimH * 0.5 + uniforms.centerY);\nlet global_id_vec=vec2<f32>(f32(global_id.x),f32(global_id.y));\nlet dir=(center - global_id_vec) * amount;\nvar sum=vec4<f32>(0.0,0.0,0.0,0.0);\nvar total=0.0;\nfor (var t=-loopSize;t <=loopSize;t=t + 1.0) { var percent=1.0 - (t + offset - 0.5)/loopSize; var weight=3.0 * (percent - percent * percent); let deltaPercent=dir * percent; let delta=vec2<i32>( i32(clamp(global_id_vec.x + deltaPercent.x,0.0,dimW - 1.0)), i32(clamp(global_id_vec.y + deltaPercent.y,0.0,dimH - 1.0)) ); sum +=textureLoad(sourceTexture,delta).xyzw * weight; total +=weight;\n}\ntextureStore(outputTexture,vec2<i32>(global_id.xy),sum/total);\n","struct Uniforms { amount:f32, centerX:f32, centerY:f32\n};\nfn random(id:vec3<u32>,delta:f32) -> f32 { let seed:u32=((id.x << 16) | (id.y & 0xFFFF)) ^ (id.z * 0x63641362); let t:vec3<f32>=vec3<f32>(f32(seed & 0xFF),f32((seed >> 8) & 0xFF),f32(seed >> 16)); return delta + fract(sin(dot(t,vec3<f32>(12.9898,78.233,12.9898))) * 43758.5453);\n}\n")),this.amount=this.#cg}get centerX(){return this.#xh}set centerX(i){validateNumber(i),this.#xh=i,this.updateUniform("centerX",i)}get centerY(){return this.#_h}set centerY(i){validateNumber(i),this.#_h=i,this.updateUniform("centerY",i)}get amount(){return this.#cg}set amount(i){validateNumberRange(i,0),this.#cg=i,this.updateUniform("amount",i)}}Object.freeze(ZoomBlur);const ls={filmGrainIntensity:.02,filmGrainResponse:.9,filmGrainScale:2.5,coloredGrain:.3,grainSaturation:.4},cs={filmGrainIntensity:.05,filmGrainResponse:.8,filmGrainScale:3,coloredGrain:.5,grainSaturation:.6},hs={filmGrainIntensity:.12,filmGrainResponse:.6,filmGrainScale:4,coloredGrain:.7,grainSaturation:.8},fs={filmGrainIntensity:.08,filmGrainResponse:.7,filmGrainScale:5,coloredGrain:.9,grainSaturation:1};class FilmGrain extends ASinglePassPostEffect{static SUBTLE=ls;static MEDIUM=cs;static HEAVY=hs;static VINTAGE=fs;#mg=hs.filmGrainIntensity;#pg=hs.filmGrainResponse;#gg=hs.filmGrainScale;#xg=hs.coloredGrain;#_g=hs.grainSaturation;#hm=0;#vg=1;constructor(i){super(i),this.#vg=window?.devicePixelRatio||1,this.init(i,"POST_EFFECT_FILM_GRAIN",createBasicPostEffectCode(this,"let index=vec2<i32>(global_id.xy);\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nlet originalColor=textureLoad(sourceTexture,index);\nlet filmGrainIntensity_value:f32=uniforms.filmGrainIntensity;\nlet filmGrainResponse_value:f32=uniforms.filmGrainResponse;\nlet filmGrainScale_value:f32=uniforms.filmGrainScale;\nlet coloredGrain_value:f32=uniforms.coloredGrain;\nlet grainSaturation_value:f32=uniforms.grainSaturation;\nlet time_value:f32=uniforms.time;\nlet devicePixelRatio_value:f32=uniforms.devicePixelRatio;\nif (filmGrainIntensity_value <=0.0) { textureStore(outputTexture,index,originalColor); return;\n}\nlet baseScale=max(filmGrainScale_value,0.1);\nlet scaledUV=uv * vec2<f32>(dimW,dimH) * devicePixelRatio_value/baseScale;\nlet timeOffset=vec2<f32>( fract(time_value * 0.0317) * 100.0, fract(time_value * 0.0271) * 100.0\n);\nlet grainCoord=scaledUV + timeOffset;\nlet sampleOffset=1.0/baseScale;\nlet noiseR=(filmGrainNoise(grainCoord) + filmGrainNoise(grainCoord + vec2<f32>(sampleOffset,0.0)) + filmGrainNoise(grainCoord + vec2<f32>(0.0,sampleOffset)))/3.0;\nlet noiseG=filmGrainNoise(grainCoord + vec2<f32>(127.1,311.7));\nlet noiseB=filmGrainNoise(grainCoord + vec2<f32>(269.5,183.3));\nlet monoGrain=(noiseR + noiseG + noiseB)/3.0;\nlet colorGrain=vec3<f32>(noiseR,noiseG,noiseB);\nvar grainColor=mix(vec3<f32>(monoGrain),colorGrain,coloredGrain_value);\nlet grainLuminance=dot(grainColor,vec3<f32>(0.299,0.587,0.114));\ngrainColor=mix(vec3<f32>(grainLuminance),grainColor,grainSaturation_value);\nlet luminance=dot(originalColor.rgb,vec3<f32>(0.299,0.587,0.114));\nlet luminanceWeight=pow(max(luminance,0.01),filmGrainResponse_value);\nlet grainIntensity=filmGrainIntensity_value * luminanceWeight;\nlet grain=grainColor * grainIntensity;\nlet finalColor=originalColor.rgb + grain;\nlet outputColor=vec4<f32>(clamp(finalColor,vec3<f32>(0.0),vec3<f32>(1.0)),originalColor.a);\ntextureStore(outputTexture,index,outputColor);\n","struct Uniforms { filmGrainIntensity:f32, filmGrainResponse:f32, filmGrainScale:f32, coloredGrain:f32, grainSaturation:f32, time:f32, devicePixelRatio:f32\n};\nfn filmGrainNoise(coord:vec2<f32>) -> f32 { let p=floor(coord); let f=fract(coord); let u=f * f * f * (f * (f * 6.0 - 15.0) + 10.0); let a=hash(p); let b=hash(p + vec2<f32>(1.0,0.0)); let c=hash(p + vec2<f32>(0.0,1.0)); let d=hash(p + vec2<f32>(1.0,1.0)); let noise=mix(mix(a,b,u.x),mix(c,d,u.x),u.y); return (noise - 0.5) * 2.0;\n}\nfn hash(p:vec2<f32>) -> f32 { var p3=fract(vec3<f32>(p.xyx) * 0.1031); p3 +=dot(p3,p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z);\n}\n")),this.#bg()}get filmGrainIntensity(){return this.#mg}set filmGrainIntensity(i){this.#mg=Math.max(0,Math.min(1,i)),this.updateUniform("filmGrainIntensity",this.#mg)}get filmGrainResponse(){return this.#pg}set filmGrainResponse(i){this.#pg=Math.max(0,Math.min(2,i)),this.updateUniform("filmGrainResponse",this.#pg)}get filmGrainScale(){return this.#gg}set filmGrainScale(i){this.#gg=Math.max(.1,Math.min(20,i)),this.updateUniform("filmGrainScale",this.#gg)}get coloredGrain(){return this.#xg}set coloredGrain(i){this.#xg=Math.max(0,Math.min(1,i)),this.updateUniform("coloredGrain",this.#xg)}get grainSaturation(){return this.#_g}set grainSaturation(i){this.#_g=Math.max(0,Math.min(2,i)),this.updateUniform("grainSaturation",this.#_g)}applyPreset(i){this.#mg=i.filmGrainIntensity,this.#pg=i.filmGrainResponse,this.#gg=i.filmGrainScale,this.#xg=i.coloredGrain,this.#_g=i.grainSaturation,this.#bg()}update(i){this.#hm+=i,this.updateUniform("time",this.#hm)}#bg(){this.updateUniform("filmGrainIntensity",this.#mg),this.updateUniform("filmGrainResponse",this.#pg),this.updateUniform("filmGrainScale",this.#gg),this.updateUniform("coloredGrain",this.#xg),this.updateUniform("grainSaturation",this.#_g),this.updateUniform("time",this.#hm),this.updateUniform("devicePixelRatio",this.#vg)}}Object.freeze(FilmGrain);class Fog extends ASinglePassPostEffect{static EXPONENTIAL=0;static EXPONENTIAL_SQUARED=1;#yg=Fog.EXPONENTIAL;#Sg=.05;#Tg=4.5;#Mg=50;#wg;constructor(i){super(i),this.useDepthTexture=!0,this.init(i,"POST_EFFECT_FOG",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy);\nlet coord=vec2<i32>(global_id.xy);\nvar sceneColor:vec4<f32>=textureLoad(sourceTexture,coord);\nlet depth=textureLoad(depthTexture,coord,0);\nlet linearDepth=linearizeDepth(depth,systemUniforms.camera.nearClipping,systemUniforms.camera.farClipping);\nlet fogFactor=calculateFogFactor(linearDepth,systemUniforms.camera.farClipping);\nlet finalColor=mix(uniforms.fogColor.rgb,sceneColor.rgb,fogFactor);\ntextureStore(outputTexture,coord,vec4<f32>(finalColor,sceneColor.a));\n","struct Uniforms { fogType:u32, density:f32, nearDistance:f32, farDistance:f32, fogColor:vec3<f32>, padding1:f32,\n};\nfn linearizeDepth(depth:f32,cameraNear:f32,cameraFar:f32) -> f32 { let z=depth * 2.0 - 1.0; return (2.0 * cameraNear * cameraFar)/ (cameraFar + cameraNear - z * (cameraFar - cameraNear));\n}\nfn calculateFogFactor(linearDepth:f32,cameraFar:f32) -> f32 { let u_density=uniforms.density; let u_fogType=uniforms.fogType; let u_nearDistance=uniforms.nearDistance; let u_farDistance=uniforms.farDistance; let isBackground=linearDepth >=(cameraFar * 0.99); if (isBackground) { return 1.0 - u_density; } let distance=max(0.0,linearDepth - u_nearDistance); let maxDistance=u_farDistance - u_nearDistance; let normalizedDistance=clamp(distance/max(0.1,maxDistance),0.0,1.0); var fogFactor:f32; if (u_fogType==0u) { fogFactor=exp(-u_density * normalizedDistance * 10.0); } else { let expValue=u_density * normalizedDistance * 5.0; fogFactor=exp(-(expValue * expValue)); } return clamp(fogFactor,0.0,1.0);\n}\n")),this.#wg=new ColorRGB(178,178,204,()=>{this.updateUniform("fogColor",this.#wg.rgbNormalLinear)}),this.fogType=this.#yg,this.density=this.#Sg,this.nearDistance=this.#Tg,this.farDistance=this.#Mg}get fogType(){return this.#yg}set fogType(i){validateNumberRange(i,0,1),this.#yg=Math.floor(i),this.updateUniform("fogType",this.#yg)}get density(){return this.#Sg}set density(i){validateNumberRange(i,0,1),this.#Sg=Math.max(0,Math.min(1,i)),this.updateUniform("density",this.#Sg)}get nearDistance(){return this.#Tg}set nearDistance(i){validateNumberRange(i,0),this.#Tg=Math.max(.1,i),this.#Mg<=this.#Tg&&(this.#Mg=this.#Tg+.1,this.updateUniform("farDistance",this.#Mg)),this.updateUniform("nearDistance",this.#Tg)}get farDistance(){return this.#Mg}set farDistance(i){validateNumberRange(i,0),this.#Mg=Math.max(this.#Tg+.1,i),this.updateUniform("farDistance",this.#Mg)}get fogColor(){return this.#wg}render(i,m,g,_){return super.render(i,m,g,_)}}Object.freeze(Fog);class HeightFog extends ASinglePassPostEffect{static EXPONENTIAL=0;static EXPONENTIAL_SQUARED=1;#yg=HeightFog.EXPONENTIAL;#Sg=1;#wg;#Cg=0;#Rg=100;#Pg=.1;constructor(i){super(i),this.useDepthTexture=!0,this.init(i,"POST_EFFECT_HEIGHT_FOG",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet global_id_vec=vec2<f32>(f32(global_id.x),f32(global_id.y));\nlet screenCoord=vec2<f32>( global_id_vec.x/dimW,global_id_vec.y/dimH );\nvar depth:f32=1.0;\nif (dimensions.x > u32(global_id.x) && dimensions.y > u32(global_id.y)) { depth=textureLoad(depthTexture,vec2<i32>(global_id.xy),0);\n}\nlet fogFactor=calculateHeightFogFactor(screenCoord,depth);\nlet originalColor=textureLoad(sourceTexture,vec2<i32>(global_id.xy)).rgb;\nlet foggedColor=mix(uniforms.fogColor,originalColor,fogFactor);\ntextureStore(outputTexture,vec2<i32>(global_id.xy),vec4<f32>(foggedColor,1.0));\n","struct Uniforms { fogType:u32, density:f32, baseHeight:f32, falloff:f32, maxHeight:f32, fogColor:vec3<f32>, padding1:f32, padding2:f32,\n};\nfn isFiniteValue(value:f32) -> bool { return value==value;\n}\nfn isFiniteVec3(v:vec3<f32>) -> bool { return isFiniteValue(v.x) && isFiniteValue(v.y) && isFiniteValue(v.z);\n}\nfn reconstructWorldPositionUltraPrecise(screenCoord:vec2<f32>,depth:f32) -> vec3<f32> { let ndcX=fma(screenCoord.x,2.0,-1.0); let ndcY=fma(-screenCoord.y,2.0,1.0); let safeDepth=clamp(depth,1e-7,1.0 - 1e-7); let ndc=vec3<f32>(ndcX,ndcY,safeDepth); let clipPos=vec4<f32>(ndc,1.0); let worldPos4=systemUniforms.inverseProjectionCameraMatrix * clipPos; let epsilon=1e-6; let w=select(worldPos4.w,epsilon,abs(worldPos4.w) < epsilon); let worldPos=worldPos4.xyz/w; let maxCoord=1e6; let stabilizedX=clamp(worldPos.x,-maxCoord,maxCoord); let stabilizedY=clamp(worldPos.y,-maxCoord,maxCoord); let stabilizedZ=clamp(worldPos.z,-maxCoord,maxCoord); let finalPos=vec3<f32>(stabilizedX,stabilizedY,stabilizedZ); return select(vec3<f32>(0.0,0.0,0.0),finalPos,isFiniteVec3(finalPos));\n}\nfn calculateHeightFogFactor(screenCoord:vec2<f32>,depth:f32) -> f32 { let backgroundThreshold=1.0 - 1e-5; let isBackground=depth >=backgroundThreshold; var pixelWorldHeight:f32; if (isBackground) { let rayDirection=getRayDirectionMaxPrecision(screenCoord); pixelWorldHeight=getSkyboxHeightMaxPrecision(rayDirection); } else { let worldPos=reconstructWorldPositionUltraPrecise(screenCoord,depth); pixelWorldHeight=worldPos.y; } return calculateAbsoluteHeightFogMaxPrecision(pixelWorldHeight);\n}\nfn getSkyboxHeightMaxPrecision(rayDirection:vec3<f32>) -> f32 { let u_baseHeight=uniforms.baseHeight; let u_maxHeight=uniforms.maxHeight; let rayY=clamp(rayDirection.y,-0.999,0.999); let upThreshold=0.08; let downThreshold=-0.015; let transitionRange=upThreshold - downThreshold; let safeTransitionRange=max(transitionRange,1e-6); if (rayY > upThreshold) { return u_maxHeight + 25.0; } else if (rayY < downThreshold) { return fma(u_maxHeight - u_baseHeight,0.03,u_baseHeight); } else { let normalizedT=(rayY - downThreshold)/safeTransitionRange; let smoothT=smoothstep(0.0,1.0,normalizedT); let lowValue=fma(u_maxHeight - u_baseHeight,0.03,u_baseHeight); let highValue=u_maxHeight + 25.0; return fma(smoothT,highValue - lowValue,lowValue); }\n}\nfn calculateAbsoluteHeightFogMaxPrecision(worldHeight:f32) -> f32 { let u_baseHeight=uniforms.baseHeight; let u_maxHeight=uniforms.maxHeight; let u_density=uniforms.density; let u_falloff=uniforms.falloff; let u_fogType=uniforms.fogType; if (!isFiniteValue(worldHeight)) { return 1.0; } let heightRange=u_maxHeight - u_baseHeight; let safeHeightRange=max(heightRange,1e-3); let margin=fma(safeHeightRange,0.18,1.2); let extendedBaseHeight=u_baseHeight - margin; let extendedMaxHeight=u_maxHeight + margin; let extendedRange=extendedMaxHeight - extendedBaseHeight; if (worldHeight <=extendedBaseHeight || worldHeight >=extendedMaxHeight) { return 1.0; } let safeExtendedRange=max(extendedRange,1e-3); if (safeExtendedRange <=0.3) { return 1.0; } let normalizedHeight=clamp( (worldHeight - extendedBaseHeight)/safeExtendedRange, 0.0, 1.0 ); let centerOffset=normalizedHeight - 0.5; let edgeFactor=fma(-abs(centerOffset),0.25,1.0); let heightFactor=1.0 - normalizedHeight; let safeHeightFactor=max(heightFactor,1e-4); let safeFalloff=clamp(u_falloff,0.05,1.8); let expPower=fma(safeFalloff,0.73,1.05); var fogDensity:f32; if (u_fogType==0u) { fogDensity=pow(safeHeightFactor,expPower); fogDensity=smoothstep(0.0,1.0,fogDensity); } else { let expResult=pow(safeHeightFactor,expPower); fogDensity=expResult * expResult; fogDensity=smoothstep(0.0,1.0,fogDensity); } let densityWithEdge=fogDensity * edgeFactor; let safeDensity=clamp(u_density,0.0,4.0); let finalFogAmount=fma(densityWithEdge,safeDensity,0.0) * 0.42; let result=clamp(1.0 - finalFogAmount,0.0,1.0); return select(1.0,result,isFiniteValue(result));\n}\nfn getRayDirectionMaxPrecision(screenCoord:vec2<f32>) -> vec3<f32> { let centeredX=fma(screenCoord.x,1.0,-0.5); let centeredY=fma(screenCoord.y,1.0,-0.5); let ndcX=centeredX * 2.0; let ndcY=-(centeredY * 2.0); let ndc=vec3<f32>(ndcX,ndcY,1.0); let clipPos=vec4<f32>(ndc,1.0); let worldPos4=systemUniforms.inverseProjectionCameraMatrix * clipPos; let epsilon=1e-6; let w=select(worldPos4.w,epsilon,abs(worldPos4.w) < epsilon); let worldPos=worldPos4.xyz/w; let cameraPos=systemUniforms.camera.cameraPosition; let rayDir=worldPos - cameraPos; let rayLength=length(rayDir); let minLength=1e-6; if (rayLength < minLength) { return vec3<f32>(0.0,0.0,1.0); } let normalizedRay=rayDir/rayLength; let safeRayX=clamp(normalizedRay.x,-0.999,0.999); let safeRayY=clamp(normalizedRay.y,-0.999,0.999); let safeRayZ=clamp(normalizedRay.z,-0.999,0.999); let safeRay=vec3<f32>(safeRayX,safeRayY,safeRayZ); let finalRayLength=length(safeRay); let isValidRay=finalRayLength > 1e-6 && isFiniteValue(finalRayLength); if (isValidRay) { let finalRay=safeRay/finalRayLength; return select(vec3<f32>(0.0,0.0,1.0),finalRay,isFiniteVec3(finalRay)); } return vec3<f32>(0.0,0.0,1.0);\n}\n")),this.#wg=new ColorRGB(178,178,204,()=>{this.updateUniform("fogColor",this.#wg.rgbNormal)}),this.fogType=this.#yg,this.density=this.#Sg,this.baseHeight=this.#Cg,this.thickness=this.#Rg,this.falloff=this.#Pg}get fogType(){return this.#yg}set fogType(i){validateNumberRange(i,0,1),this.#yg=Math.floor(i),this.updateUniform("fogType",this.#yg)}get density(){return this.#Sg}set density(i){validateNumberRange(i,0,5),this.#Sg=Math.max(0,Math.min(5,i)),this.updateUniform("density",this.#Sg)}get fogColor(){return this.#wg}get baseHeight(){return this.#Cg}set baseHeight(i){validateNumberRange(i),this.#Cg=i,this.updateUniform("baseHeight",this.#Cg),this.updateUniform("maxHeight",this.maxHeight)}get maxHeight(){return this.#Cg+this.#Rg}get thickness(){return this.#Rg}set thickness(i){validateNumberRange(i,.1),this.#Rg=Math.max(.1,i),this.updateUniform("maxHeight",this.#Cg+this.#Rg)}get falloff(){return this.#Pg}set falloff(i){validateNumberRange(i,0,2),this.#Pg=Math.max(.001,Math.min(2,i)),this.updateUniform("falloff",this.#Pg)}render(i,m,g,_){return super.render(i,m,g,_)}}Object.freeze(HeightFog);class ChromaticAberration extends ASinglePassPostEffect{#rg=.015;#xh=.5;#_h=.5;#Pg=1;constructor(i){super(i),this.init(i,"POST_EFFECT_CHROMATIC_ABERRATION",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet uv=vec2<f32>(f32(global_id.x),f32(global_id.y))/vec2<f32>(dimW,dimH);\nlet center=vec2<f32>(uniforms.centerX,uniforms.centerY);\nlet offset=uv - center;\nlet distance=length(offset);\nlet distortion=uniforms.strength * pow(distance,uniforms.falloff);\nlet redOffset=uv + offset * distortion * vec2<f32>(-1.0,-1.0);\nlet greenOffset=uv;\nlet blueOffset=uv + offset * distortion * vec2<f32>(1.0,1.0);\nvar finalColor=vec3<f32>(0.0);\nif (redOffset.x >=0.0 && redOffset.x <=1.0 && redOffset.y >=0.0 && redOffset.y <=1.0) { let redCoord=vec2<i32>( i32(clamp(redOffset.x * dimW,0.0,dimW - 1.0)), i32(clamp(redOffset.y * dimH,0.0,dimH - 1.0)) ); finalColor.r=textureLoad(sourceTexture,redCoord).r;\n}\nlet greenCoord=vec2<i32>( i32(clamp(greenOffset.x * dimW,0.0,dimW - 1.0)), i32(clamp(greenOffset.y * dimH,0.0,dimH - 1.0))\n);\nfinalColor.g=textureLoad(sourceTexture,greenCoord).g;\nif (blueOffset.x >=0.0 && blueOffset.x <=1.0 && blueOffset.y >=0.0 && blueOffset.y <=1.0) { let blueCoord=vec2<i32>( i32(clamp(blueOffset.x * dimW,0.0,dimW - 1.0)), i32(clamp(blueOffset.y * dimH,0.0,dimH - 1.0)) ); finalColor.b=textureLoad(sourceTexture,blueCoord).b;\n}\nlet originalAlpha=textureLoad(sourceTexture,vec2<i32>(global_id.xy)).a;\ntextureStore(outputTexture,vec2<i32>(global_id.xy),vec4<f32>(finalColor,originalAlpha));\n","struct Uniforms { strength:f32, centerX:f32, centerY:f32, falloff:f32\n};\n")),this.strength=this.#rg,this.centerX=this.#xh,this.centerY=this.#_h,this.falloff=this.#Pg}get strength(){return this.#rg}set strength(i){validateNumberRange(i,0),this.#rg=i,this.updateUniform("strength",i)}get centerX(){return this.#xh}set centerX(i){validateNumberRange(i,0,1),this.#xh=i,this.updateUniform("centerX",i)}get centerY(){return this.#_h}set centerY(i){validateNumberRange(i,0,1),this.#_h=i,this.updateUniform("centerY",i)}get falloff(){return this.#Pg}set falloff(i){validateNumberRange(i,0,5),this.#Pg=i,this.updateUniform("falloff",i)}}Object.freeze(ChromaticAberration);class DOFCoC extends ASinglePassPostEffect{#Bg=15;#Ig=1.4;#Eg=32;#Dg=.1;#Lg=1e3;constructor(i){super(i),this.useDepthTexture=!0,this.init(i,"POST_EFFECT_DOF_COC",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy);\nlet coord=vec2<i32>(global_id.xy);\nlet originalColor=textureLoad(sourceTexture,coord).xyzw;\nlet depth=textureLoad(depthTexture,coord,0);\nlet linearDepth=linearizeDepth(depth);\nlet coc=calculateCoC(linearDepth);\nlet encodedCoC=encodeCoC(coc);\ntextureStore(outputTexture,coord,vec4<f32>(originalColor.rgb,encodedCoC));\n","struct Uniforms { focusDistance:f32, aperture:f32, maxCoC:f32, nearPlane:f32, farPlane:f32,\n};\nfn linearizeDepth(depth:f32) -> f32 { let z=depth * 2.0 - 1.0; return (2.0 * uniforms.nearPlane * uniforms.farPlane)/ (uniforms.farPlane + uniforms.nearPlane - z * (uniforms.farPlane - uniforms.nearPlane));\n}\nfn encodeCoC(coc:f32) -> f32 { return (coc + 1.0) * 0.5;\n}\nfn calculateCoC(linearDepth:f32) -> f32 { let subjectDistance=linearDepth; let focalLength=50.0; let focusRange=uniforms.focusDistance * 0.15; let transitionRange=uniforms.focusDistance * 0.35; let distanceFromFocus=abs(subjectDistance - uniforms.focusDistance); if (distanceFromFocus < focusRange) { let focusFactor=smoothstep(0.0,focusRange,distanceFromFocus); return mix(0.0,0.02,focusFactor); } var rawCoC:f32; var signedCoC:f32; if (subjectDistance < uniforms.focusDistance) { let nearDistance=uniforms.focusDistance - subjectDistance; let nearFactor=nearDistance/uniforms.focusDistance; rawCoC=(uniforms.aperture * focalLength * nearDistance)/ (subjectDistance * (uniforms.focusDistance - focalLength)); rawCoC=rawCoC * (1.0 + nearFactor * 1.5); signedCoC=-(rawCoC/uniforms.maxCoC); let absCoC=abs(signedCoC); if (absCoC > 0.05) { signedCoC=-min(1.0,absCoC * smoothstep(0.05,0.3,absCoC) * 1.5); } if (distanceFromFocus < transitionRange) { let transitionFactor=smoothstep(focusRange,transitionRange,distanceFromFocus); signedCoC=mix(0.0,signedCoC,transitionFactor); } return clamp(signedCoC,-1.0,0.0); } else { let farDistance=subjectDistance - uniforms.focusDistance; rawCoC=(uniforms.aperture * focalLength * farDistance)/ (subjectDistance * (uniforms.focusDistance + focalLength)); rawCoC=rawCoC * (1.0 + farDistance * 0.08); signedCoC=rawCoC/uniforms.maxCoC; let absCoC=abs(signedCoC); if (absCoC > 0.1) { signedCoC=min(1.0,absCoC * smoothstep(0.1,0.5,absCoC) * 1.2); } if (distanceFromFocus < transitionRange) { let transitionFactor=smoothstep(focusRange,transitionRange,distanceFromFocus); signedCoC=mix(0.0,signedCoC,transitionFactor); } return clamp(signedCoC,0.0,1.0); }\n}\n")),this.focusDistance=this.#Bg,this.aperture=this.#Ig,this.maxCoC=this.#Eg,this.nearPlane=this.#Dg,this.farPlane=this.#Lg}get focusDistance(){return this.#Bg}set focusDistance(i){validateNumberRange(i),this.#Bg=i,this.updateUniform("focusDistance",i)}get aperture(){return this.#Ig}set aperture(i){validateNumberRange(i),this.#Ig=i,this.updateUniform("aperture",i)}get maxCoC(){return this.#Eg}set maxCoC(i){validateNumberRange(i),this.#Eg=i,this.updateUniform("maxCoC",i)}get nearPlane(){return this.#Dg}set nearPlane(i){validateNumberRange(i),this.#Dg=i,this.updateUniform("nearPlane",i)}get farPlane(){return this.#Lg}set farPlane(i){validateNumberRange(i),this.#Lg=i,this.updateUniform("farPlane",i)}}Object.freeze(DOFCoC);class DOFUnified extends ASinglePassPostEffect{#Ug=16;#Ag=24;#Og=1;#kg=1;constructor(i){super(i);const{WORK_SIZE_X:m,WORK_SIZE_Y:g,WORK_SIZE_Z:_}=this,b=` struct Uniforms { nearBlurSize:f32, farBlurSize:f32, nearStrength:f32, farStrength:f32, };  @group(0) @binding(0) var sourceTexture:texture_storage_2d<rgba16float,read>; @group(0) @binding(1) var cocTexture:texture_storage_2d<rgba16float,read>; @group(1) @binding(0) var outputTexture:texture_storage_2d<rgba16float,write>; @group(1) @binding(1) var<uniform> uniforms:Uniforms;  /* CoC 디코딩 함수 */ fn decodeCoC(encoded:f32) -> f32 { /* 0~1 범위를 -1~1 범위로 복원 */ return encoded * 2.0 - 1.0; }  @compute @workgroup_size(${m},${g},${_}) fn main (@builtin(global_invocation_id) global_id:vec3<u32>) { let index=vec2<u32>(global_id.xy); let dimensions:vec2<u32>=textureDimensions(sourceTexture);  if (index.x >=dimensions.x || index.y >=dimensions.y) { return; }  let originalSample=textureLoad(sourceTexture,index); let originalColor=originalSample.rgb; let originalAlpha=originalSample.a; let encodedCoC=textureLoad(cocTexture,index).a;  /* CoC 값 디코딩 */ let cocValue=decodeCoC(encodedCoC);  /* CoC 임계값 체크 */ if (abs(cocValue) < 0.005) { textureStore(outputTexture,index,vec4<f32>(originalColor,originalAlpha)); return; }  var finalColor=originalColor; var finalAlpha=originalAlpha;  /* Near blur 처리 (CoC < 0) */ if (cocValue < 0.0) { let blurResult=calculateBlur(index,abs(cocValue),uniforms.nearBlurSize,true); let nearBlur=blurResult.rgb; let nearBlurAlpha=blurResult.a; /* Near strength 블렌딩 개선 - 더 강한 효과 */ let nearBlend=saturate(pow(abs(cocValue) * uniforms.nearStrength,0.7)); finalColor=mix(originalColor,nearBlur,nearBlend); finalAlpha=mix(originalAlpha,nearBlurAlpha,nearBlend); } /* Far blur 처리 (CoC > 0) */ else if (cocValue > 0.0) { let blurResult=calculateBlur(index,cocValue,uniforms.farBlurSize,false); let farBlur=blurResult.rgb; let farBlurAlpha=blurResult.a; let rawBlend=cocValue * uniforms.farStrength; let farBlend=saturate(smoothstep(0.0,0.8,rawBlend)); finalColor=mix(originalColor,farBlur,farBlend); finalAlpha=mix(originalAlpha,farBlurAlpha,farBlend); }  textureStore(outputTexture,index,vec4<f32>(finalColor,finalAlpha)); }  fn calculateBlur(center:vec2<u32>,intensity:f32,maxBlurSize:f32,isNear:bool) -> vec4<f32> { let dimensions:vec2<u32>=textureDimensions(sourceTexture); let blurRadius=intensity * maxBlurSize;  /* 최소 블러 반경 조정 */ if (blurRadius < 0.3) { return textureLoad(sourceTexture,center); }  var sum:vec3<f32>=vec3<f32>(0.0); var sumAlpha:f32=0.0; var totalWeight=0.0;  let maxRadius=min(blurRadius,maxBlurSize); /* Near blur에 더 많은 샘플 적용 */ let samples=select(8,16,isNear);/* near=16,far=8 */ let angleStep=6.28318530718/f32(samples);  let originalSample=textureLoad(sourceTexture,center); let originalColor=originalSample.rgb; let originalAlpha=originalSample.a; /* Near blur에 더 강한 중앙 가중치 */ let centerWeight=select(0.4,0.2,isNear);/* near=0.2,far=0.4 */ sum +=originalColor * centerWeight; sumAlpha +=originalAlpha * centerWeight; totalWeight +=centerWeight;  /* 방사형 샘플링 */ for (var i=0;i < samples;i=i + 1) { for (var r=1.0;r <=maxRadius;r=r + 1.0) { let angle=f32(i) * angleStep; let offset=vec2<f32>(cos(angle) * r,sin(angle) * r);  let samplePos=vec2<i32>( clamp(i32(f32(center.x) + offset.x),0,i32(dimensions.x) - 1), clamp(i32(f32(center.y) + offset.y),0,i32(dimensions.y) - 1) );  let sampleData=textureLoad(sourceTexture,vec2<u32>(samplePos)); let sampleColor=sampleData.rgb; let sampleAlpha=sampleData.a; let sampleEncodedCoC=textureLoad(cocTexture,vec2<u32>(samplePos)).a; let sampleCoC=decodeCoC(sampleEncodedCoC);/* 디코딩 추가 */  /* 가우시안 가중치 */ var weight=exp(-r * r/(maxRadius * maxRadius * 0.5));  /* CoC 기반 가중치 조정 */ if (isNear) { /* Near blur:더 강한 조건으로 가중치 증가 */ if (sampleCoC < 0.0 && abs(sampleCoC) >=intensity * 0.5) { weight *=1.5; } } else { /* Far blur:기존 조건 유지 */ if (sampleCoC > 0.0 && sampleCoC >=intensity * 0.7) { weight *=1.2; } }  sum +=sampleColor * weight; sumAlpha +=sampleAlpha * weight; totalWeight +=weight; } }  /* 추가 근거리 샘플링 (near blur만) */ if (isNear && maxRadius > 2.0) { let additionalSamples=8; let innerRadius=maxRadius * 0.3; let innerAngleStep=6.28318530718/f32(additionalSamples);  for (var i=0;i < additionalSamples;i=i + 1) { let angle=f32(i) * innerAngleStep + 0.5;/* 약간의 오프셋 */ let offset=vec2<f32>(cos(angle) * innerRadius,sin(angle) * innerRadius);  let samplePos=vec2<i32>( clamp(i32(f32(center.x) + offset.x),0,i32(dimensions.x) - 1), clamp(i32(f32(center.y) + offset.y),0,i32(dimensions.y) - 1) );  let sampleData=textureLoad(sourceTexture,vec2<u32>(samplePos)); let sampleColor=sampleData.rgb; let sampleAlpha=sampleData.a; let weight=0.8;  sum +=sampleColor * weight; sumAlpha +=sampleAlpha * weight; totalWeight +=weight; } }  if (totalWeight > 0.0) { return vec4<f32>(sum/totalWeight,sumAlpha/totalWeight); } else { return vec4<f32>(originalColor,originalAlpha); } } `;this.init(i,"POST_EFFECT_DOF_UNIFIED",{msaa:b,nonMsaa:b}),this.nearBlurSize=this.#Ug,this.farBlurSize=this.#Ag,this.nearStrength=this.#Og,this.farStrength=this.#kg}get nearBlurSize(){return this.#Ug}set nearBlurSize(i){validateNumberRange(i),this.#Ug=i,this.updateUniform("nearBlurSize",i)}get farBlurSize(){return this.#Ag}set farBlurSize(i){validateNumberRange(i),this.#Ag=i,this.updateUniform("farBlurSize",i)}get nearStrength(){return this.#Og}set nearStrength(i){validateNumberRange(i),this.#Og=i,this.updateUniform("nearStrength",i)}get farStrength(){return this.#kg}set farStrength(i){validateNumberRange(i),this.#kg=i,this.updateUniform("farStrength",i)}render(i,m,g,_,b){return super.render(i,m,g,_,b)}}Object.freeze(DOFUnified);class DOF extends AMultiPassPostEffect{#Gg;#Fg;#Bg=15;#Ig=2.8;#Eg=25;#Dg=.1;#Lg=1e3;#Ug=15;#Ag=15;#Og=1;#kg=1;constructor(i){super(i,[new DOFCoC(i),new DOFUnified(i)]),this.#Gg=this.passList[0],this.#Fg=this.passList[1],this.#Gg.focusDistance=this.#Bg,this.#Gg.aperture=this.#Ig,this.#Gg.maxCoC=this.#Eg,this.#Gg.nearPlane=this.#Dg,this.#Gg.farPlane=this.#Lg,this.#Fg.nearBlurSize=this.#Ug,this.#Fg.farBlurSize=this.#Ag,this.#Fg.nearStrength=this.#Og,this.#Fg.farStrength=this.#kg}get focusDistance(){return this.#Bg}set focusDistance(i){this.#Bg=i,this.#Gg.focusDistance=i}get aperture(){return this.#Ig}set aperture(i){this.#Ig=i,this.#Gg.aperture=i}get maxCoC(){return this.#Eg}set maxCoC(i){this.#Eg=i,this.#Gg.maxCoC=i}get nearPlane(){return this.#Dg}set nearPlane(i){this.#Dg=i,this.#Gg.nearPlane=i}get farPlane(){return this.#Lg}set farPlane(i){this.#Lg=i,this.#Gg.farPlane=i}get nearBlurSize(){return this.#Ug}set nearBlurSize(i){this.#Ug=i,this.#Fg.nearBlurSize=i}get farBlurSize(){return this.#Ag}set farBlurSize(i){this.#Ag=i,this.#Fg.farBlurSize=i}get nearStrength(){return this.#Og}set nearStrength(i){this.#Og=i,this.#Fg.nearStrength=i}get farStrength(){return this.#kg}set farStrength(i){this.#kg=i,this.#Fg.farStrength=i}setGameDefault(){this.focusDistance=15,this.aperture=2.8,this.maxCoC=25,this.nearBlurSize=15,this.farBlurSize=15,this.nearStrength=1,this.farStrength=1}setCinematic(){this.focusDistance=20,this.aperture=1.4,this.maxCoC=40,this.nearBlurSize=25,this.farBlurSize=30,this.nearStrength=1.2,this.farStrength=1.3}setPortrait(){this.focusDistance=8,this.aperture=1.8,this.maxCoC=35,this.nearBlurSize=12,this.farBlurSize=25,this.nearStrength=.8,this.farStrength=1.4}setLandscape(){this.focusDistance=50,this.aperture=8,this.maxCoC=20,this.nearBlurSize=20,this.farBlurSize=10,this.nearStrength=1.1,this.farStrength=.6}setMacro(){this.focusDistance=2,this.aperture=1,this.maxCoC=50,this.nearBlurSize=30,this.farBlurSize=35,this.nearStrength=1.5,this.farStrength=1.6}setSports(){this.focusDistance=25,this.aperture=4,this.maxCoC=18,this.nearBlurSize=10,this.farBlurSize=12,this.nearStrength=.8,this.farStrength=.9}setNightMode(){this.focusDistance=12,this.aperture=2,this.maxCoC=30,this.nearBlurSize=18,this.farBlurSize=20,this.nearStrength=1.1,this.farStrength=1.2}render(i,m,g,_){const b=this.#Gg.render(i,m,g,_);return this.#Fg.render(i,m,g,_,b)}}Object.freeze(DOF);class LensDistortion extends ASinglePassPostEffect{#Ng=.1;#Vg=0;#xh=0;#_h=0;constructor(i){super(i),this.init(i,"POST_EFFECT_LENS_DISTORTION",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet center=vec2<f32>(dimW * 0.5 + uniforms.centerX,dimH * 0.5 + uniforms.centerY);\nlet global_id_vec=vec2<f32>(f32(global_id.x),f32(global_id.y));\nlet uv=global_id_vec/vec2<f32>(dimW,dimH);\nlet uvCenter=center/vec2<f32>(dimW,dimH);\nlet offset=uv - uvCenter;\nlet distance=length(offset);\nlet barrelFactor=1.0 + uniforms.barrelStrength * distance * distance;\nlet pincushionFactor=1.0 - uniforms.pincushionStrength * distance * distance;\nlet distortionFactor=barrelFactor * pincushionFactor;\nlet distortedUV=uvCenter + offset * distortionFactor;\nif (distortedUV.x < 0.0 || distortedUV.x > 1.0 || distortedUV.y < 0.0 || distortedUV.y > 1.0) { textureStore(outputTexture,vec2<i32>(global_id.xy),vec4<f32>(0.0,0.0,0.0,1.0));\n} else { let sampleCoord=vec2<i32>( i32(clamp(distortedUV.x * dimW,0.0,dimW - 1.0)), i32(clamp(distortedUV.y * dimH,0.0,dimH - 1.0)) ); let sampledColor=textureLoad(sourceTexture,sampleCoord).xyzw; textureStore(outputTexture,vec2<i32>(global_id.xy),sampledColor);\n}\n","struct Uniforms { barrelStrength:f32, pincushionStrength:f32, centerX:f32, centerY:f32\n};\n")),this.barrelStrength=this.#Ng,this.pincushionStrength=this.#Vg,this.centerX=this.#xh,this.centerY=this.#_h}get barrelStrength(){return this.#Ng}set barrelStrength(i){validateNumberRange(i,0),this.#Ng=i,this.updateUniform("barrelStrength",i)}get pincushionStrength(){return this.#Vg}set pincushionStrength(i){validateNumberRange(i,0),this.#Vg=i,this.updateUniform("pincushionStrength",i)}get centerX(){return this.#xh}set centerX(i){validateNumber(i),this.#xh=i,this.updateUniform("centerX",i)}get centerY(){return this.#_h}set centerY(i){validateNumber(i),this.#_h=i,this.updateUniform("centerY",i)}}Object.freeze(LensDistortion);class Vignetting extends ASinglePassPostEffect{#zg=.2;#Ft=.5;constructor(i){super(i),this.init(i,"POST_EFFECT_VIGNETTING",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet index=vec2<u32>(global_id.xy);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nlet smoothness=uniforms.smoothness;\nlet size=uniforms.size;\nvar color:vec4<f32>=textureLoad(sourceTexture,index);\nvar diff=size - distance(uv,vec2<f32>(0.5));\nlet vignette=smoothstep(-smoothness,smoothness,diff);\ncolor.r *=vignette;\ncolor.g *=vignette;\ncolor.b *=vignette;\ntextureStore(outputTexture,index,color);\n","struct Uniforms { smoothness:f32, size:f32,\n};\n")),this.smoothness=this.#zg,this.size=this.#Ft}get size(){return this.#Ft}set size(i){validateNumberRange(i,0),this.#Ft=i,this.updateUniform("size",i)}get smoothness(){return this.#zg}set smoothness(i){validateNumberRange(i,0,1),this.#zg=i,this.updateUniform("smoothness",i)}}Object.freeze(Vignetting);class OldBloomBlend extends ASinglePassPostEffect{#Hg=1;#Ll=1;constructor(i){super(i);const{WORK_SIZE_X:m,WORK_SIZE_Y:g,WORK_SIZE_Z:_}=this,b=` struct Uniforms { bloomStrength:f32, exposure:f32 }; @group(0) @binding(0) var sourceTexture0:texture_storage_2d<rgba16float,read>; @group(0) @binding(1) var sourceTexture1:texture_storage_2d<rgba16float,read>; @group(1) @binding(0) var outputTexture:texture_storage_2d<rgba16float,write>; @group(1) @binding(1) var<uniform> uniforms:Uniforms; @compute @workgroup_size(${m},${g},${_}) fn main ( @builtin(global_invocation_id) global_id:vec3<u32>, ){ let index=vec2<u32>(global_id.xy ); let dimensions:vec2<u32>=textureDimensions(sourceTexture0); let dimW=f32(dimensions.x); let dimH=f32(dimensions.y); let uv=\tvec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH); var diffuse:vec4<f32>=textureLoad( sourceTexture0, index, ); var blur:vec4<f32>=textureLoad( sourceTexture1, index, );  let finalColor=vec4<f32>((diffuse.rgb + blur.rgb * uniforms.bloomStrength ) * uniforms.exposure,diffuse.a); textureStore(outputTexture,index,finalColor ); }; `;this.init(i,"POST_EFFECT_OLD_BLOOM",{msaa:b,nonMsaa:b}),this.exposure=this.#Ll,this.bloomStrength=this.#Hg}get bloomStrength(){return this.#Hg}set bloomStrength(i){this.#Hg=i,this.updateUniform("bloomStrength",i)}get exposure(){return this.#Ll}set exposure(i){this.#Ll=i,this.updateUniform("exposure",i)}render(i,m,g,_,b){return super.render(i,m,g,_,b)}}Object.freeze(OldBloomBlend);class OldBloom extends AMultiPassPostEffect{#$g;#Kg;#Wg;#sg=156;#jg=32;#Ll=1;#Hg=1.2;constructor(i){super(i,[new Threshold(i),new GaussianBlur(i),new OldBloomBlend(i)]),this.#$g=this.passList[0],this.#Kg=this.passList[1],this.#Wg=this.passList[2],this.#$g.threshold=this.#sg,this.#Kg.size=this.#jg,this.#Wg.exposure=this.#Ll,this.#Wg.bloomStrength=this.#Hg}get threshold(){return this.#sg}set threshold(i){this.#sg=i,this.#$g.threshold=i}get gaussianBlurSize(){return this.#jg}set gaussianBlurSize(i){this.#jg=i,this.#Kg.size=i}get exposure(){return this.#Ll}set exposure(i){this.#Ll=i,this.#Wg.exposure=i}get bloomStrength(){return this.#Hg}set bloomStrength(i){this.#Hg=i,this.#Wg.bloomStrength=i}render(i,m,g,_){const b=this.#$g.render(i,m,g,_),y=this.#Kg.render(i,m,g,b);return this.#Wg.render(i,m,g,_,y)}}Object.freeze(OldBloom);class Sharpen extends AMultiPassPostEffect{#lg;constructor(i){super(i,[new Convolution(i)]),this.#lg=this.passList[0],this.#lg.kernel=Convolution.SHARPEN}render(i,m,g,_){return this.#lg.render(i,m,g,_)}}Object.freeze(Sharpen);var ds=Object.freeze({__proto__:null,AMultiPassPostEffect:AMultiPassPostEffect,ASinglePassPostEffect:ASinglePassPostEffect,createBasicPostEffectCode:createBasicPostEffectCode}),ms=Object.freeze({__proto__:null,Blur:Blur,BlurX:BlurX,BlurY:BlurY,BrightnessContrast:BrightnessContrast,ChromaticAberration:ChromaticAberration,ColorBalance:ColorBalance,ColorTemperatureTint:ColorTemperatureTint,Convolution:Convolution,Core:ds,DOF:DOF,DirectionalBlur:DirectionalBlur,FilmGrain:FilmGrain,Fog:Fog,GaussianBlur:GaussianBlur,Grayscale:Grayscale,HeightFog:HeightFog,HueSaturation:HueSaturation,Invert:Invert,LensDistortion:LensDistortion,OldBloom:OldBloom,PostEffectManager:PostEffectManager,RadialBlur:RadialBlur,Sharpen:Sharpen,Threshold:Threshold,Vibrance:Vibrance,Vignetting:Vignetting,ZoomBlur:ZoomBlur}),ps=Object.freeze({__proto__:null,PICKING_EVENT_TYPE:i,PickingEvent:PickingEvent}),gs=Object.freeze({__proto__:null,BlendState:BlendState,DepthStencilState:DepthStencilState,PrimitiveState:PrimitiveState}),xs=Object.freeze({__proto__:null,TONE_MAPPING_MODE:Yr,ToneMappingManager:ToneMappingManager}),_s=Object.freeze({__proto__:null,DirectionalShadowManager:DirectionalShadowManager,ShadowManager:ShadowManager}),vs=Object.freeze({__proto__:null,AntialiasingManager:AntialiasingManager,FXAA:FXAA,TAA:TAA,TAASharpen:TAASharpen});export{vs as Antialiasing,li as Bound,bi as Camera,Ti as Color,Si as Context,In as DefineForFragment,Xn as DefineForVertex,va as Display,GLTFLoader,vt as GPU_ADDRESS_MODE,En as GPU_BLEND_FACTOR,Dn as GPU_BLEND_OPERATION,Ft as GPU_COMPARE_FUNCTION,xr as GPU_CULL_MODE,bt as GPU_FILTER_MODE,_r as GPU_FRONT_FACE,qn as GPU_INDEX_FORMAT,Ct as GPU_LOAD_OP,yt as GPU_MIPMAP_FILTER_MODE,Zn as GPU_PRIMITIVE_TOPOLOGY,Rt as GPU_STORE_OP,Geometry,ya as Light,wa as Material,ps as Picking,ms as PostEffect,Ta as Primitive,gs as RenderState,Renderer,Va as Resource,rs as RuntimeChecker,_s as Shadow,Et as SystemCode,xs as ToneMapping,xt as Util,init,y as mat3,$ as mat4};