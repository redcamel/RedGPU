const consoleAndThrowError=(...i)=>{const g=Array.prototype.slice.call(i).join(" ");throw new Error(g)},validatePositiveNumberRange=(i,g=0,x=Number.MAX_VALUE)=>("number"!=typeof i&&consoleAndThrowError("Only numbers allowed."),"number"!=typeof g&&consoleAndThrowError("Only numbers allowed."),"number"!=typeof x&&consoleAndThrowError("Only numbers allowed."),(g<0||i<0||i<g||i>x)&&consoleAndThrowError(`Only numbers within the range of [${g},${x}] are allowed.`),!0),isUint=i=>Number.isInteger(i)&&i>=0,validateUintRange=(i,g=0,x=4503599627370496)=>{const _=isUint(i),v=isUint(g),b=isUint(x),y="is not Uint!/value:",S=`(check range:${g}u ~ ${x}u)`;return _||consoleAndThrowError(`value ${y}${i}/${S}`),v||consoleAndThrowError(`min ${y}${g}/${S}`),b||consoleAndThrowError(`max ${y}${x}/${S}`),g>=x&&consoleAndThrowError(`maximum value is bigger than minimum value./${S}`),g>i&&consoleAndThrowError(`value is smaller than minimum value./value:${i}/${S}`),x<i&&consoleAndThrowError(`value is bigger than maximum value./value:${i}/${S}`),!0},isHexColor=i=>{const g=/^([A-Fa-f0-9]{3}){1,2}$/;return i.startsWith("#")?g.test(i.substring(1)):!!i.startsWith("0x")&&g.test(i.substring(2))},convertHexToRgb=(i,g=!1)=>{if("number"==typeof i&&(i=`#${i.toString(16)}`),isHexColor(i)){"#"===i.charAt(0)&&(i=i.substring(1)),3===i.length&&(i=i.charAt(0)+i.charAt(0)+i.charAt(1)+i.charAt(1)+i.charAt(2)+i.charAt(2));const x=parseInt("0x"+i),_=x>>16&255,v=x>>8&255,b=255&x;return g?[_,v,b]:{r:_,g:v,b:b}}throw Error(`from ${convertHexToRgb.constructor.name}:input value - ${i}/Only hex string allowed`)},convertRgbToHex=(i,g,x)=>{validateUintRange(i,0,255),validateUintRange(g,0,255),validateUintRange(x,0,255);return`#${i.toString(16).padStart(2,"0").toUpperCase()}${g.toString(16).padStart(2,"0").toUpperCase()}${x.toString(16).padStart(2,"0").toUpperCase()}`};class ColorRGB{#e;#t;#n;#r;constructor(i=255,g=255,x=255,_=void 0){this.#i(i,g,x),this.#a(i,g,x),_&&(this.#r=_)}get r(){return this.#e}set r(i){validateUintRange(i,0,255),this.#e=i,this.#r?.()}get g(){return this.#t}set g(i){validateUintRange(i,0,255),this.#t=i,this.#r?.()}get b(){return this.#n}set b(i){validateUintRange(i,0,255),this.#n=i,this.#r?.()}get rgb(){return[this.#e,this.#t,this.#n]}get rgbNormal(){return[this.#e/255,this.#t/255,this.#n/255]}get rgbNormalLinear(){return[Math.pow(this.#e/255,2.2),Math.pow(this.#t/255,2.2),Math.pow(this.#n/255,2.2)]}get hex(){return convertRgbToHex(this.#e,this.#t,this.#n)}setColorByRGB(i,g,x){this.#i(i,g,x),this.#a(i,g,x)}setColorByHEX(i){const{r:g,g:x,b:_}=convertHexToRgb(i);this.#a(g,x,_)}setColorByRGBString(i){const g=/rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(i);g||consoleAndThrowError(`유효하지 않은 rgb 색상 값입니다:${i}`);const[,x,_,v]=g.map(Number);this.#i(x,_,v),this.#a(x,_,v)}#a(i,g,x){this.#e=i,this.#t=g,this.#n=x,this.#r?.()}#i(i,g,x){validateUintRange(i,0,255),validateUintRange(g,0,255),validateUintRange(x,0,255)}}Object.freeze(ColorRGB);class ColorRGBA extends ColorRGB{#s;#r;constructor(i=255,g=255,x=255,_=1,v=void 0){super(i,g,x,v),validatePositiveNumberRange(_,0,1),this.#s=_,v&&(this.#r=v)}get a(){return this.#s}set a(i){validatePositiveNumberRange(i,0,1),this.#s=i,this.#r?.()}get rgba(){return[this.r,this.g,this.b,this.#s]}get rgbaNormal(){return[this.r/255,this.g/255,this.b/255,this.#s]}get rgbaNormalLinear(){return[Math.pow(this.r/255,2.2),Math.pow(this.g/255,2.2),Math.pow(this.b/255,2.2),this.#s]}setColorByRGBA(i,g,x,_){this.#o(i,g,x,_),this.r=i,this.g=g,this.b=x,this.#s=_,this.#r?.()}setColorByRGBAString(i){const g=/rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d*(?:\.\d+)?)\s*\)/.exec(i);if(!g)throw new Error(`유효하지 않은 rgba 색상 값입니다:${i}`);const[,x,_,v,b]=g.map(Number);this.#o(x,_,v,b),this.r=x,this.g=_,this.b=v,this.#s=b,this.#r?.()}#o(i,g,x,_){validateUintRange(i,0,255),validateUintRange(g,0,255),validateUintRange(x,0,255),validatePositiveNumberRange(_,0,1)}}const i={MOVE:"move",DOWN:"down",UP:"up",OVER:"over",OUT:"out",CLICK:"click"},copyGPUBuffer=(i,g,x)=>{const _=i.createCommandEncoder({label:"copyGPUBuffer_CommandEncoder"});_.copyBufferToBuffer(g,0,x,0,Math.min(g.size,x.size));const v=_.finish();i.queue.submit([v])},formatBytes=(i,g=2)=>{if(("number"!=typeof i||i<0||Number.isNaN(i)||!Number.isInteger(i))&&consoleAndThrowError("Invalid input:'bytes' must be a uint"),0===i)return"0 Bytes";const x=g<0?0:g,_=Math.floor(Math.log(i)/Math.log(1024));return parseFloat((i/Math.pow(1024,_)).toFixed(x))+" "+["Bytes","KB","MB","GB"][_]};function getAbsoluteURL(i,g){try{return new URL(g,i).href}catch(i){return g}}const getFileExtension=i=>{if(!i||0===i.trim().length)throw new Error("URL must not be empty or undefined");const g=i.split("/"),x=g[g.length-1],_=x.lastIndexOf(".");return-1===_?"":x.substring(_+1).toLowerCase()},getFileName=(i,g=!0)=>{const x=i.substring(i.lastIndexOf("/")+1);return g?x:x.split(".").slice(0,-1).join(".")},getFilePath=i=>{if(!i||0===i.trim().length)throw new Error("URL must not be empty or undefined");return i.substring(0,i.lastIndexOf("/")+1)};function calculateTextureByteSize(i){const g={size:[i.width,i.height,i.depthOrArrayLayers],format:i.format,sampleCount:i.sampleCount,usage:i.usage};return function(i){switch(i){case"r8unorm":case"r8snorm":case"r8uint":case"r8sint":return 1;case"r16uint":case"r16sint":case"r16float":case"rg8unorm":case"rg8snorm":case"rg8uint":case"rg8sint":case"depth16unorm":return 2;case"r32uint":case"r32sint":case"r32float":case"rg16uint":case"rg16sint":case"rg16float":case"rgba8unorm":case"rgba8unorm-srgb":case"rgba8snorm":case"rgba8uint":case"rgba8sint":case"bgra8unorm":case"bgra8unorm-srgb":case"depth24plus":case"depth32float":return 4;case"rg32uint":case"rg32sint":case"rg32float":case"rgba16uint":case"rgba16sint":case"rgba16float":return 8;case"rgba32uint":case"rgba32sint":case"rgba32float":return 16;default:throw new Error(`Unrecognized texture format:${i}`)}}(g.format)*(g.size[0]*g.size[1]*(g.size[2]||1))*(g.sampleCount?g.sampleCount:1)}const getMipLevelCount=(i,g)=>Math.floor(Math.log2(Math.max(i,g)))+1,imageBitmapToGPUTexture=(i,g,x,_=!0)=>{const v=i.createTexture(x);for(let b=0;b<g.length;b++){const y=g[b],S={source:y},w={texture:v,origin:[0,0,b],premultipliedAlpha:_};x.format.includes("srgb")&&(w.colorSpace="srgb");const L=[y.width,y.height];i.queue.copyExternalImageToTexture(S,w,L)}return v};async function loadAndCreateBitmapImage(i,g="none",x="premultiply"){const _=await fetch(i),v=await _.blob();return createImageBitmap(v,{colorSpaceConversion:g,premultiplyAlpha:x})}const createUUID=()=>{const i="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");let g,x=0,_=new Array(36);for(_[8]=_[13]=_[18]=_[23]="-",_[14]="4";x<36;)_[x]||(g=16*Math.random()|0,_[x]=i[19===x?3&g|8:15&g]),x++;return _.join("")};class InstanceIdGenerator{static idMaps=new Map;static getNextId(i){let g=this.idMaps.get(i)||0;return this.idMaps.set(i,g+1),g}}Object.freeze(InstanceIdGenerator);const uuidToUint=i=>{const g=i.replace(/-/g,"").substring(0,8);return parseInt(g,16)},g=console.log.bind(console);var x=Object.freeze({__proto__:null,InstanceIdGenerator:InstanceIdGenerator,calculateTextureByteSize:calculateTextureByteSize,copyGPUBuffer:copyGPUBuffer,copyToTextureArray:function(i,g,x,_){const v=i.createCommandEncoder({label:"COPY_TO_TEXTURE_ARRAY"});v.copyTextureToTexture({texture:g},{texture:x,origin:[0,0,_]},[g.width,g.height,1]),i.queue.submit([v.finish()])},createUUID:createUUID,formatBytes:formatBytes,getAbsoluteURL:getAbsoluteURL,getFileExtension:getFileExtension,getFileName:getFileName,getFilePath:getFilePath,getMipLevelCount:getMipLevelCount,imageBitmapToGPUTexture:imageBitmapToGPUTexture,keepLog:g,loadAndCreateBitmapImage:loadAndCreateBitmapImage,uuidToUint:uuidToUint});const _={CLAMP_TO_EDGE:"clamp-to-edge",REPEAT:"repeat",MIRRORED_REPEAT:"mirror-repeat"};Object.freeze(_);const v={NEAREST:"nearest",LINEAR:"linear"};Object.freeze(v);const b={NEAREST:"nearest",LINEAR:"linear"};Object.freeze(b);const validateRedGPUContext=i=>{if("RedGPUContext"!==i?.constructor?.name){return consoleAndThrowError(`from ${i?.constructor?.name}:requires a RedGPUContext instance,but received:${i}`),!1}return!0};class ResourceBase{#u=createUUID();#l;#c;#h="";#f;#d;#m=[];#p;constructor(i,g){validateRedGPUContext(i),this.#p=g,this.#l=i,this.#c=i.gpuDevice}get cacheKey(){return this.#d}set cacheKey(i){this.#d=i}get resourceManagerKey(){return this.#p}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get uuid(){return this.#u}get gpuDevice(){return this.#c}get redGPUContext(){return this.#l}__addDirtyPipelineListener(i){this.#g(!0),this.#m.push(i)}__removeDirtyPipelineListener(i){const g=this.#m.indexOf(i);g>-1&&(this.#m.splice(g,1),this.#g(!1))}__fireListenerList(i=!1){for(const i of this.#m)i(this);i&&(this.#m.length=0)}#g(i){const{resourceManager:g}=this.#l;if("Sampler"!==this.constructor.name&&g){const x=g[this.#p];x||consoleAndThrowError("need managedStateKey",this.constructor.name);const _=x?.table.get(this.cacheKey);_&&(i?_.useNum++:_.useNum--)}}}const y=new Map,S=Object.values(v),w=Object.values(_),L=Object.values(b);class Sampler extends ResourceBase{#x;#_=v.LINEAR;#v=v.LINEAR;#b=b.LINEAR;#y=_.CLAMP_TO_EDGE;#S=_.CLAMP_TO_EDGE;#T=_.REPEAT;#M;#w;#C;#P=1;constructor(i,g){super(i),this.#R(g)}get addressModeU(){return this.#y}set addressModeU(i){this.#B(i,"addressModeU")}get addressModeV(){return this.#S}set addressModeV(i){this.#B(i,"addressModeV")}get addressModeW(){return this.#T}set addressModeW(i){this.#B(i,"addressModeW")}get mipmapFilter(){return this.#b}set mipmapFilter(i){this.#I(i,L,"mipmapFilter")}get gpuSampler(){return this.#x}get magFilter(){return this.#_}set magFilter(i){this.#I(i,S,"magFilter")}get minFilter(){return this.#v}set minFilter(i){this.#I(i,S,"minFilter")}get maxAnisotropy(){return this.#P}set maxAnisotropy(i){validateUintRange(i,1,16),this.#P=i,this.#R()}get isAnisotropyValid(){return!this.#P||"linear"===this.#_&&"linear"===this.#v&&"linear"===this.#b}#E(){this.__fireListenerList()}#B(i,g){if(w.includes(i)){switch(g){case"addressModeU":this.#y=i;break;case"addressModeV":this.#S=i;break;case"addressModeW":this.#T=i}this.#R()}else consoleAndThrowError(`Invalid ${g} value. Must be one of ${w.join(",")},but received:${i}.`)}#I(i,g,x){if(g.includes(i)||null===i){switch(x){case"mipmapFilter":this.#b=i;break;case"magFilter":this.#_=i;break;case"minFilter":this.#v=i}this.#R()}else consoleAndThrowError(`Invalid ${x} value. Must be one of ${g.join(",")},but received:${i}.`)}#D(){return`${this.#_}:${this.#v}:${this.#b}:${this.#y}:${this.#S}:${this.#T}:${this.#M}:${this.#w}:${this.#C}:${this.#P}`}#R(i){i&&(i.magFilter&&(this.#_=i.magFilter),i.minFilter&&(this.#v=i.minFilter),i.mipmapFilter&&(this.#b=i.mipmapFilter),i.addressModeU&&(this.#y=i.addressModeU),i.addressModeV&&(this.#S=i.addressModeV),i.addressModeW&&(this.#T=i.addressModeW),void 0!==i.lodMinClamp&&(this.#M=i.lodMinClamp),void 0!==i.lodMaxClamp&&(this.#w=i.lodMaxClamp),i.compare&&(this.#C=i.compare),i.maxAnisotropy&&(this.#P=i.maxAnisotropy)),this.isAnisotropyValid||1===this.#P||(console.warn(`Invalid maxAnisotropy setting (${this.#P}) detected:magFilter(${this.#_}),minFilter(${this.#v}),mipmapFilter(${this.#b}) must all be set to 'linear' for anisotropic filtering to work. Falling back to default (1).`),this.#P=1);const g=this.#D();if(!y.has(g)){let i={};this.#_&&(i.magFilter=this.#_),this.#v&&(i.minFilter=this.#v),this.#b&&(i.mipmapFilter=this.#b),this.#y&&(i.addressModeU=this.#y),this.#S&&(i.addressModeV=this.#S),this.#T&&(i.addressModeW=this.#T),void 0!==this.#M&&(i.lodMinClamp=this.#M),void 0!==this.#w&&(i.lodMaxClamp=this.#w),this.#C&&(i.compare=this.#C),this.#P&&(i.maxAnisotropy=this.#P),y.set(g,this.redGPUContext.gpuDevice.createSampler(i))}this.#x=y.get(g),this.#E()}}Object.freeze(Sampler);class ManagementResourceBase extends ResourceBase{#U;constructor(i,g){super(i,g),g||consoleAndThrowError("need managedStateKey",this.constructor.name),this.#U=i.resourceManager[g],this.#U||consoleAndThrowError(g,"is not exist in RedGPUContext.resourceManager",this.constructor.name)}get targetResourceManagedState(){return this.#U}}class ResourceStateBitmapTexture{texture;src;cacheKey;useNum=0;uuid;constructor(i){this.texture=i,this.src=i.src,this.cacheKey=i.cacheKey,this.useNum=0,this.uuid=i.uuid}}class BitmapTexture extends ManagementResourceBase{#L;#A;#G;#k;#O;#N=0;#V=!0;#F;#z;#H;constructor(i,g,x=!0,_,v,b,y=!1){if(super(i,"managedBitmapTextureState"),this.#z=_,this.#H=v,this.#V=y,this.#k=x,this.#F=b||`${navigator.gpu.getPreferredCanvasFormat()}-srgb`,g){this.#A=this.#$(g),this.cacheKey=this.#K(g);const{table:i}=this.targetResourceManagedState;let x=i.get(this.cacheKey);if(x){const i=x.texture;return this.#z?.(i),i}this.src=g,this.#X()}}get width(){return this.#O?.width||0}get height(){return this.#O?.height||0}get usePremultiplyAlpha(){return this.#V}get videoMemorySize(){return this.#N}get gpuTexture(){return this.#L}get mipLevelCount(){return this.#G}get src(){return this.#A}set src(i){this.#A=this.#$(i),this.cacheKey=this.#K(i),this.#A&&this.#j(this.#A)}get useMipmap(){return this.#k}set useMipmap(i){this.#k=i,this.#Y()}destroy(){const i=this.#L;this.#q(null),this.__fireListenerList(!0),this.#W(),this.cacheKey=null,this.#A=null,i&&i.destroy()}#K(i){return i?"string"==typeof i?getAbsoluteURL(window.location.href,i):i.cacheKey||getAbsoluteURL(window.location.href,i.src):this.uuid}#$(i){return"string"==typeof i?i:i.src}#q(i){this.#L=i,i||(this.#O=null),this.__fireListenerList()}#X(){this.redGPUContext.resourceManager.registerManagementResource(this,new ResourceStateBitmapTexture(this))}#W(){this.redGPUContext.resourceManager.unregisterManagementResource(this)}#Y(){const{gpuDevice:i,resourceManager:g}=this.redGPUContext,{mipmapGenerator:x}=g;this.#L&&(this.#L.destroy(),this.#L=null),this.targetResourceManagedState.videoMemory-=this.#N,this.#N=0;const{width:_,height:v}=this.#O;this.#G=1;const b={size:[_,v],format:this.#F,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,label:this.#A};this.#k&&(this.#G=getMipLevelCount(_,v),b.mipLevelCount=this.#G,b.usage|=GPUTextureUsage.RENDER_ATTACHMENT);const y=imageBitmapToGPUTexture(i,[this.#O],b,this.#V);this.#N=calculateTextureByteSize(y),this.targetResourceManagedState.videoMemory+=this.#N,this.#k&&x.generateMipmap(y,b),this.#q(y)}async#Z(i){return new Promise((g,x)=>{const _=new Image;_.src=i,_.onload=()=>{const i=document.createElement("canvas");i.width=_.width||512,i.height=_.height||512;const v=i.getContext("2d");v?(v.fillStyle="rgba(0,0,0,0)",v.fillRect(0,0,i.width,i.height),v.drawImage(_,0,0,i.width,i.height),createImageBitmap(i,{colorSpaceConversion:"none",premultiplyAlpha:this.#V?"premultiply":"none"}).then(g).catch(x)):x(new Error("Canvas context could not be created."))},_.onerror=i=>{x(new Error(`Failed to load SVG:${i}`))}})}async#j(i){try{i.endsWith(".svg")?this.#O=await this.#Z(i):this.#O=await loadAndCreateBitmapImage(i,"none",this.#V?"premultiply":"none"),this.#Y(),this.#z?.(this)}catch(i){console.error(i),this.#H?.(i)}}}Object.freeze(BitmapTexture);class BRDFGenerator{#l;#J;#Q;#ee;constructor(i){this.#l=i}get brdfLUTTexture(){return this.#ee||this.#te(),this.#ee}async#te(){const{gpuDevice:i,resourceManager:g}=this.#l,x="rg16float";this.#ee=g.createManagedTexture({size:[128,128],format:x,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,label:"BRDF_LUT_Texture"}),this.#J||(this.#J=g.createGPUShaderModule("BRDF_GENERATOR_SHADER_MODULE",{code:"\nconst PI=3.14159265359;\nfn radicalInverse_VdC(bits:u32) -> f32 { var b=bits; b=(b << 16u) | (b >> 16u); b=((b & 0x55555555u) << 1u) | ((b & 0xAAAAAAAAu) >> 1u); b=((b & 0x33333333u) << 2u) | ((b & 0xCCCCCCCCu) >> 2u); b=((b & 0x0F0F0F0Fu) << 4u) | ((b & 0xF0F0F0F0u) >> 4u); b=((b & 0x00FF00FFu) << 8u) | ((b & 0xFF00FF00u) >> 8u); return f32(b) * 2.3283064365386963e-10;\n}\nfn hammersley(i:u32,N:u32) -> vec2<f32> { return vec2<f32>(f32(i)/f32(N),radicalInverse_VdC(i));\n}\nfn importanceSampleGGX(Xi:vec2<f32>,N:vec3<f32>,roughness:f32) -> vec3<f32> { let a=roughness * roughness; let phi=2.0 * PI * Xi.x; let cosTheta=sqrt((1.0 - Xi.y)/(1.0 + (a * a - 1.0) * Xi.y)); let sinTheta=sqrt(1.0 - cosTheta * cosTheta); let H=vec3<f32>(cos(phi) * sinTheta,sin(phi) * sinTheta,cosTheta); let up=select(vec3<f32>(1.0,0.0,0.0),vec3<f32>(0.0,0.0,1.0),abs(N.z) < 0.999); let tangent=normalize(cross(up,N)); let bitangent=cross(N,tangent); return normalize(tangent * H.x + bitangent * H.y + N * H.z);\n}\nfn geometrySchlickGGX(NdotV:f32,roughness:f32) -> f32 { let a=roughness; let k=(a * a)/2.0; let nom=NdotV; let denom=NdotV * (1.0 - k) + k; return nom/denom;\n}\nfn geometrySmith(N:vec3<f32>,V:vec3<f32>,L:vec3<f32>,roughness:f32) -> f32 { let NdotV=max(dot(N,V),0.0); let NdotL=max(dot(N,L),0.0); let ggx2=geometrySchlickGGX(NdotV,roughness); let ggx1=geometrySchlickGGX(NdotL,roughness); return ggx1 * ggx2;\n}\nfn integrateBRDF(in_NdotV:f32,roughness:f32) -> vec2<f32> { let NdotV=max(in_NdotV,0.001); var V:vec3<f32>; V.x=sqrt(1.0 - NdotV * NdotV); V.y=0.0; V.z=NdotV; var A=0.0; var B=0.0; let N=vec3<f32>(0.0,0.0,1.0); let sampleCount=1024u; for (var i=0u;i < sampleCount;i=i + 1u) { let Xi=hammersley(i,sampleCount); let H=importanceSampleGGX(Xi,N,roughness); let L=normalize(2.0 * dot(V,H) * H - V); let NdotL=max(L.z,0.0); let NdotH=max(H.z,0.0); let VdotH=max(dot(V,H),0.0); if (NdotL > 0.0) { let G=geometrySmith(N,V,L,roughness); let G_Vis=(G * VdotH)/(max(NdotH * NdotV,0.001)); let Fc=pow(1.0 - VdotH,5.0); A=A + (1.0 - Fc) * G_Vis; B=B + Fc * G_Vis; } } return vec2<f32>(A,B)/f32(sampleCount);\n}\nstruct VertexOutput { @builtin(position) position:vec4<f32>, @location(0) uv:vec2<f32>,\n};\n@vertex\nfn vs_main(@builtin(vertex_index) vertexIndex:u32) -> VertexOutput { var pos=array<vec2<f32>,3>( vec2<f32>(-1.0,-1.0), vec2<f32>(3.0,-1.0), vec2<f32>(-1.0,3.0) ); var output:VertexOutput; output.position=vec4<f32>(pos[vertexIndex],0.0,1.0); output.uv=pos[vertexIndex] * 0.5 + 0.5; return output;\n}\n@fragment\nfn fs_main(@location(0) uv:vec2<f32>) -> @location(0) vec4<f32> { let integratedBRDF=integrateBRDF(uv.x,1.0 - uv.y); return vec4<f32>(integratedBRDF,0.0,1.0);\n}"})),this.#Q||(this.#Q=i.createRenderPipeline({label:"BRDF_GENERATOR_PIPELINE",layout:"auto",vertex:{module:this.#J,entryPoint:"vs_main"},fragment:{module:this.#J,entryPoint:"fs_main",targets:[{format:x}]},primitive:{topology:"triangle-list"}}));const _=i.createCommandEncoder({label:"BRDF_GENERATOR_COMMAND_ENCODER"}),v=_.beginRenderPass({label:"BRDF_GENERATOR_RENDER_PASS",colorAttachments:[{view:this.#ee.createView(),loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"}]});v.setPipeline(this.#Q),v.draw(3),v.end(),i.queue.submit([_.finish()]),await i.queue.onSubmittedWorkDone()}}Object.freeze(BRDFGenerator);class BRDFLUTTexture extends ManagementResourceBase{#L;constructor(i){super(i,"managedBitmapTextureState"),this.#ne()}#ne(){this.#L=this.redGPUContext.resourceManager.brdfGenerator.brdfLUTTexture,this.__fireListenerList()}get gpuTexture(){return this.#L}get videoMemorySize(){return 65536}}Object.freeze(BRDFLUTTexture);class CubeTexture extends ManagementResourceBase{static defaultViewDescriptor={dimension:"cube",aspect:"all",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:0,arrayLayerCount:6};#L;#re;#G;#k;#ie;#N=0;#F;#z;#H;constructor(i,g,x=!0,_,v,b){super(i,"managedCubeTextureState"),this.#z=_,this.#H=v,this.#k=x,this.#F=b||`${navigator.gpu.getPreferredCanvasFormat()}-srgb`,this.#re=this.#$(g),this.cacheKey=this.#K(g);const{table:y}=this.targetResourceManagedState;if(g){let i=y.get(this.cacheKey);if(i){const g=i.texture;return this.#z?.(g),g}this.srcList=g,this.#X()}}get viewDescriptor(){return{...CubeTexture.defaultViewDescriptor,mipLevelCount:this.#G}}get videoMemorySize(){return this.#N}get gpuTexture(){return this.#L}get mipLevelCount(){return this.#G}get srcList(){return this.#re}set srcList(i){this.#re=this.#$(i),this.cacheKey=this.#K(i),this.#re?.length&&this.#j(this.#re)}get useMipmap(){return this.#k}set useMipmap(i){this.#k=i,this.#Y()}destroy(){const i=this.#L;this.#q(null),this.__fireListenerList(!0),this.#W(),this.#re=null,this.cacheKey=null,i&&i.destroy()}setGPUTextureDirectly(i,g,x=!0){this.#L&&(this.#L.destroy(),this.targetResourceManagedState.videoMemory-=this.#N),this.#L=i,this.#k=x,this.#G=i.mipLevelCount,this.cacheKey=g||`direct_${this.uuid}`,this.#N=calculateTextureByteSize(i),this.targetResourceManagedState.videoMemory+=this.#N,this.__fireListenerList()}#K(i){return i?i instanceof Array?i.length?i.toString():this.uuid:i.cacheKey||i.srcList.toString():this.uuid}#$(i){return i instanceof Array?i:i?.srcList}#q(i){this.#L=i,i||(this.#ie=null),this.__fireListenerList()}#X(){this.redGPUContext.resourceManager.registerManagementResource(this,new ResourceStateCubeTexture(this))}#W(){this.redGPUContext.resourceManager.unregisterManagementResource(this)}#Y(){const{gpuDevice:i,resourceManager:g}=this.redGPUContext,{mipmapGenerator:x}=g;this.#L&&(this.#L.destroy(),this.#L=null),this.#G=1;{const g=this.#ie,_=g[0],{width:v,height:b}=_,y={size:[v,b,6],format:this.#F,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,label:`cubeTexture_${this.#re?.toString()||this.uuid}`};this.#k&&(this.#G=getMipLevelCount(v,b),y.mipLevelCount=this.#G,y.usage|=GPUTextureUsage.RENDER_ATTACHMENT);const S=imageBitmapToGPUTexture(i,g,y);this.targetResourceManagedState.videoMemory-=this.#N,this.#N=calculateTextureByteSize(S),this.targetResourceManagedState.videoMemory+=this.#N,this.#k&&x.generateMipmap(S,y),this.#q(S)}}async#j(i){this.#ie=await async function(i){const g=i.map(i=>loadAndCreateBitmapImage(i));return await Promise.all(g)}(i);try{this.#Y(),this.#z?.(this)}catch(i){console.error(i),this.#H?.(i)}}}Object.freeze(CubeTexture);class ResourceStateCubeTexture{texture;srcList;cacheKey;useNum=0;uuid;constructor(i){this.texture=i,this.srcList=i instanceof CubeTexture?i.srcList:void 0,this.cacheKey=i.cacheKey,this.useNum=0,this.uuid=i.uuid}}class IBLCubeTexture extends ManagementResourceBase{#L;#G;#k=!0;#N=0;#F;constructor(i,g,x){super(i,"managedCubeTextureState"),this.cacheKey=g;const{table:_}=this.targetResourceManagedState;if(g){let i=_.get(g);if(i)return i.texture;x&&this.#q(x),this.#X()}}get viewDescriptor(){return{...CubeTexture.defaultViewDescriptor,mipLevelCount:this.#G}}get format(){return this.#F}get videoMemorySize(){return this.#N}get gpuTexture(){return this.#L}set gpuTexture(i){this.#q(i)}get mipLevelCount(){return this.#G}get useMipmap(){return this.#k}destroy(){const i=this.#L;this.#q(null),this.__fireListenerList(!0),this.#W(),this.cacheKey=null,i&&i.destroy()}#q(i){this.targetResourceManagedState.videoMemory-=this.#N,this.#L=i,i&&(this.#G=i.mipLevelCount,this.#k=i.mipLevelCount>1,this.#F=i.format,this.#N=calculateTextureByteSize(i)),this.targetResourceManagedState.videoMemory+=this.#N,this.__fireListenerList()}#X(){this.redGPUContext.resourceManager.registerManagementResource(this,new ResourceStateCubeTexture(this))}#W(){this.redGPUContext.resourceManager.unregisterManagementResource(this)}}Object.freeze(IBLCubeTexture);class IrradianceGenerator{#l;#ae;#Q;#se;constructor(i){this.#l=i,this.#ae=new Sampler(this.#l,{magFilter:v.LINEAR,minFilter:v.LINEAR,mipmapFilter:b.LINEAR,addressModeU:_.CLAMP_TO_EDGE,addressModeV:_.CLAMP_TO_EDGE,addressModeW:_.CLAMP_TO_EDGE})}async generate(i,g=32){const{gpuDevice:x,resourceManager:_}=this.#l,v=_.createManagedTexture({size:[g,g,6],format:"rgba16float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,dimension:"2d",mipLevelCount:1,label:`Irradiance_Map_Texture_${createUUID()}`});this.#se||(this.#se=_.createGPUShaderModule("IRRADIANCE_GENERATOR_SHADER_MODULE",{code:"\n@group(0) @binding(0) var environmentTexture:texture_cube<f32>;\n@group(0) @binding(1) var environmentSampler:sampler;\n@group(0) @binding(2) var outTexture:texture_storage_2d_array<rgba16float,write>;\n@group(0) @binding(3) var<uniform> faceMatrices:array<mat4x4<f32>,6>;\nconst PI=3.14159265359;\nfn radicalInverse_VdC(bits_in:u32) -> f32 { var bits=bits_in; bits=(bits << 16u) | (bits >> 16u); bits=((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u); bits=((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u); bits=((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u); bits=((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u); return f32(bits) * 2.3283064365386963e-10;\n}\nfn hammersley(i:u32,n:u32) -> vec2<f32> { return vec2<f32>(f32(i)/f32(n),radicalInverse_VdC(i));\n}\n@compute @workgroup_size(8,8,1)\nfn cs_main(@builtin(global_invocation_id) global_id:vec3<u32>) { let size_u=textureDimensions(outTexture); let size=vec2<f32>(size_u); if (global_id.x >=size_u.x || global_id.y >=size_u.y || global_id.z >=6u) { return; } let face=global_id.z; let uv=(vec2<f32>(global_id.xy) + 0.5)/size; let x=uv.x * 2.0 - 1.0; let y=uv.y * 2.0 - 1.0; let localPos=vec4<f32>(x,y,1.0,1.0); let normal=normalize((faceMatrices[face] * localPos).xyz); let s=select(1.0,-1.0,normal.z < 0.0); let a=-1.0/(s + normal.z); let b=normal.x * normal.y * a; let tangent=vec3<f32>(1.0 + s * normal.x * normal.x * a,s * b,-s * normal.x); let bitangent=vec3<f32>(b,s + normal.y * normal.y * a,-normal.y); var irradiance=vec3<f32>(0.0); var totalWeight=0.0; let totalSamples=1024u; let envSize=f32(textureDimensions(environmentTexture).x); let saTexel=4.0 * PI/(6.0 * envSize * envSize); for (var i=0u;i < totalSamples;i++) { let xi=hammersley(i,totalSamples); let phi=2.0 * PI * xi.x; let cosTheta=sqrt(1.0 - xi.y); let sinTheta=sqrt(xi.y); let sampleVec=vec3<f32>(sinTheta * cos(phi),sinTheta * sin(phi),cosTheta); let worldSample=normalize(tangent * sampleVec.x + bitangent * sampleVec.y + normal * sampleVec.z); let pdf=max(cosTheta,0.001)/PI; let saSample=1.0/(f32(totalSamples) * pdf + 0.0001); let mipLevel=max(0.5 * log2(saSample/saTexel),0.0); let sampleColor=textureSampleLevel(environmentTexture,environmentSampler,worldSample,mipLevel); irradiance +=sampleColor.rgb; totalWeight +=1.0; } irradiance=irradiance/totalWeight; textureStore(outTexture,global_id.xy,face,vec4<f32>(irradiance,1.0));\n}"})),this.#Q||(this.#Q=x.createComputePipeline({label:"IRRADIANCE_GENERATOR_PIPELINE",layout:"auto",compute:{module:this.#se,entryPoint:"cs_main"}}));const b=x.createCommandEncoder({label:"Irradiance_Generator_Command_Encoder"}),y=this.#oe(),S=x.createBuffer({size:384,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"Irradiance_face_matrices_uniform"}),w=new Float32Array(96);y.forEach((i,g)=>w.set(i,16*g)),x.queue.writeBuffer(S,0,w);const L=x.createBindGroup({layout:this.#Q.getBindGroupLayout(0),entries:[{binding:0,resource:i.createView({dimension:"cube"})},{binding:1,resource:this.#ae.gpuSampler},{binding:2,resource:v.createView({dimension:"2d-array"})},{binding:3,resource:{buffer:S}}]}),k=b.beginComputePass({label:"Irradiance_Generator_Compute_Pass"});return k.setPipeline(this.#Q),k.setBindGroup(0,L),k.dispatchWorkgroups(Math.ceil(g/8),Math.ceil(g/8),6),k.end(),x.queue.submit([b.finish()]),await x.queue.onSubmittedWorkDone(),S.destroy(),new IBLCubeTexture(this.#l,`Irradiance_Map_${createUUID()}`,v)}#oe(){return[new Float32Array([0,0,-1,0,0,-1,0,0,1,0,0,0,0,0,0,1]),new Float32Array([0,0,1,0,0,-1,0,0,-1,0,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,0,-1,0,0,-1,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,1]),new Float32Array([-1,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,1])]}}Object.freeze(IrradianceGenerator);class PrefilterGenerator{#l;#ae;#Q;#se;constructor(i){this.#l=i,this.#ae=new Sampler(this.#l,{magFilter:v.LINEAR,minFilter:v.LINEAR,addressModeU:_.CLAMP_TO_EDGE,addressModeV:_.CLAMP_TO_EDGE,addressModeW:_.CLAMP_TO_EDGE})}async generate(i,g=512){const{gpuDevice:x,resourceManager:_}=this.#l,v=getMipLevelCount(g,g),b=_.createManagedTexture({size:[g,g,6],format:"rgba16float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,dimension:"2d",mipLevelCount:v,label:`Prefilter_Map_Texture_${createUUID()}`});this.#se||(this.#se=_.createGPUShaderModule("PREFILTER_GENERATOR_SHADER_MODULE",{code:"\n@group(0) @binding(0) var environmentTexture:texture_cube<f32>;\n@group(0) @binding(1) var textureSampler:sampler;\n@group(0) @binding(2) var outTexture:texture_storage_2d_array<rgba16float,write>;\nstruct PrefilterUniforms { faceMatrices:array<mat4x4<f32>,6>, roughness:f32,\n}\n@group(0) @binding(3) var<uniform> uniforms:PrefilterUniforms;\nconst PI:f32=3.14159265359;\nfn radicalInverse_VdC(bits_in:u32) -> f32 { var bits=bits_in; bits=(bits << 16u) | (bits >> 16u); bits=((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u); bits=((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u); bits=((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u); bits=((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u); return f32(bits) * 2.3283064365386963e-10;\n}\nfn hammersley(i:u32,n:u32) -> vec2<f32> { return vec2<f32>(f32(i)/f32(n),radicalInverse_VdC(i));\n}\nfn distribution_ggx(NdotH:f32,roughness:f32) -> f32 { let a=roughness * roughness; let a2=a * a; let NdotH2=NdotH * NdotH; let denom=(NdotH2 * (a2 - 1.0) + 1.0); return a2/(PI * denom * denom);\n}\nfn importanceSampleGGX(xi:vec2<f32>,N:vec3<f32>,roughness:f32) -> vec3<f32> { let a=roughness * roughness; let phi=2.0 * PI * xi.x; let cosTheta=sqrt((1.0 - xi.y)/(1.0 + (a * a - 1.0) * xi.y)); let sinTheta=sqrt(max(0.0,1.0 - cosTheta * cosTheta)); let H=vec3<f32>(cos(phi) * sinTheta,sin(phi) * sinTheta,cosTheta); let up=select(vec3<f32>(1.0,0.0,0.0),vec3<f32>(0.0,0.0,1.0),abs(N.z) < 0.999); let tangent=normalize(cross(up,N)); let bitangent=cross(N,tangent); return normalize(tangent * H.x + bitangent * H.y + N * H.z);\n}\n@compute @workgroup_size(8,8,1)\nfn cs_main(@builtin(global_invocation_id) global_id:vec3<u32>) { let size_u=textureDimensions(outTexture); let size=vec2<f32>(size_u); if (global_id.x >=size_u.x || global_id.y >=size_u.y || global_id.z >=6u) { return; } let face=global_id.z; let roughness=uniforms.roughness; let uv=(vec2<f32>(global_id.xy) + 0.5)/size; let x=uv.x * 2.0 - 1.0; let y=uv.y * 2.0 - 1.0; let localPos=vec4<f32>(x,y,1.0,1.0); let N=normalize((uniforms.faceMatrices[face] * localPos).xyz); if (roughness <=0.0) { textureStore(outTexture,global_id.xy,face,textureSampleLevel(environmentTexture,textureSampler,N,0.0)); return; } let R=N; let V=R; var prefilteredColor=vec3<f32>(0.0); var totalWeight=0.0; let numSamples=1024u; let envSize=f32(textureDimensions(environmentTexture).x); let saTexel=4.0 * PI/(6.0 * envSize * envSize); for (var i=0u;i < numSamples;i++) { let xi=hammersley(i,numSamples); let H=importanceSampleGGX(xi,N,roughness); let L=normalize(2.0 * dot(V,H) * H - V); let NdotL=max(dot(N,L),0.0); if (NdotL > 0.0) { let NdotH=max(dot(N,H),0.001); let VdotH=max(dot(V,H),0.001); let D=distribution_ggx(NdotH,roughness); let pdf=(D * NdotH/(4.0 * VdotH)) + 0.0001; let saSample=1.0/(f32(numSamples) * pdf + 0.0001); let mipLevel=max(0.25 * log2(saSample/saTexel),0.0); prefilteredColor +=textureSampleLevel(environmentTexture,textureSampler,L,mipLevel).rgb * NdotL; totalWeight +=NdotL; } } if (totalWeight > 0.0) { textureStore(outTexture,global_id.xy,face,vec4<f32>(prefilteredColor/totalWeight,1.0)); } else { textureStore(outTexture,global_id.xy,face,textureSampleLevel(environmentTexture,textureSampler,N,0.0)); }\n}"})),this.#Q||(this.#Q=x.createComputePipeline({label:"PREFILTER_GENERATOR_PIPELINE",layout:"auto",compute:{module:this.#se,entryPoint:"cs_main"}}));const y=x.createCommandEncoder({label:"Prefilter_Generator_Command_Encoder"}),S=this.#oe(),w=[];for(let _=0;_<v;_++){const L=Math.max(1,g>>_),k=_/(v-1),z=new Float32Array(100);S.forEach((i,g)=>z.set(i,16*g)),z[96]=k;const H=x.createBuffer({size:z.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});x.queue.writeBuffer(H,0,z),w.push(H);const q=x.createBindGroup({layout:this.#Q.getBindGroupLayout(0),entries:[{binding:0,resource:i.createView({dimension:"cube"})},{binding:1,resource:this.#ae.gpuSampler},{binding:2,resource:b.createView({dimension:"2d-array",baseMipLevel:_,mipLevelCount:1})},{binding:3,resource:{buffer:H}}]}),W=y.beginComputePass({label:`Prefilter_mip_${_}_compute_pass`});W.setPipeline(this.#Q),W.setBindGroup(0,q),W.dispatchWorkgroups(Math.ceil(L/8),Math.ceil(L/8),6),W.end()}return x.queue.submit([y.finish()]),await x.queue.onSubmittedWorkDone(),w.forEach(i=>i.destroy()),new IBLCubeTexture(this.#l,`Prefilter_Map_${createUUID()}`,b)}#oe(){return[new Float32Array([0,0,-1,0,0,-1,0,0,1,0,0,0,0,0,0,1]),new Float32Array([0,0,1,0,0,-1,0,0,-1,0,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,0,-1,0,0,-1,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,1]),new Float32Array([-1,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,1])]}}Object.freeze(PrefilterGenerator);class EquirectangularToCubeGenerator{#l;#se;#Q;#ae;constructor(i){this.#l=i,this.#ae=new Sampler(this.#l,{magFilter:v.LINEAR,minFilter:v.LINEAR,addressModeU:_.CLAMP_TO_EDGE,addressModeV:_.CLAMP_TO_EDGE})}async generate(i,g=512){const{gpuDevice:x,resourceManager:_}=this.#l,v=getMipLevelCount(g,g),b={size:[g,g,6],format:"rgba16float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,dimension:"2d",mipLevelCount:v,label:`EquirectangularToCube_Texture_${createUUID()}`},y=_.createManagedTexture(b);this.#se||(this.#se=_.createGPUShaderModule("EQUIRECTANGULAR_TO_CUBE_GENERATOR_SHADER_MODULE",{code:"\n@group(0) @binding(0) var equirectangularTexture:texture_2d<f32>;\n@group(0) @binding(1) var textureSampler:sampler;\n@group(0) @binding(2) var outTexture:texture_storage_2d_array<rgba16float,write>;\n@group(0) @binding(3) var<uniform> faceMatrices:array<mat4x4<f32>,6>;\nconst PI:f32=3.14159265359;\nfn directionToSphericalUV(dir:vec3<f32>) -> vec2<f32> { let normalizedDir=normalize(dir); let theta=atan2(normalizedDir.x,normalizedDir.z); let phi=acos(clamp(normalizedDir.y,-1.0,1.0)); return vec2<f32>(0.5 - theta/(2.0 * PI),phi/PI);\n}\n@compute @workgroup_size(8,8,1)\nfn cs_main(@builtin(global_invocation_id) global_id:vec3<u32>) { let size=textureDimensions(outTexture); if (global_id.x >=size.x || global_id.y >=size.y || global_id.z >=6u) { return; } let face=global_id.z; let uv=(vec2<f32>(global_id.xy) + 0.5)/vec2<f32>(size); let x=uv.x * 2.0 - 1.0; let y=uv.y * 2.0 - 1.0; let localPos=vec4<f32>(x,y,1.0,1.0); let direction=(faceMatrices[face] * localPos).xyz; let sphericalUV=directionToSphericalUV(direction); let color=textureSampleLevel(equirectangularTexture,textureSampler,sphericalUV,0.0); textureStore(outTexture,global_id.xy,face,color);\n}\n"})),this.#Q||(this.#Q=x.createComputePipeline({label:"EQUIRECTANGULAR_TO_CUBE_GENERATOR_PIPELINE",layout:"auto",compute:{module:this.#se,entryPoint:"cs_main"}}));const S=x.createCommandEncoder({label:"EquirectangularToCube_Generator_Command_Encoder"}),w=this.#oe(),L=x.createBuffer({size:384,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"EquirectangularToCube_face_matrices_uniform"}),k=new Float32Array(96);w.forEach((i,g)=>k.set(i,16*g)),x.queue.writeBuffer(L,0,k);const z=x.createBindGroup({layout:this.#Q.getBindGroupLayout(0),entries:[{binding:0,resource:i.createView()},{binding:1,resource:this.#ae.gpuSampler},{binding:2,resource:y.createView({dimension:"2d-array",baseMipLevel:0,mipLevelCount:1})},{binding:3,resource:{buffer:L}}]}),H=S.beginComputePass({label:"EquirectangularToCube_Generator_Compute_Pass"});return H.setPipeline(this.#Q),H.setBindGroup(0,z),H.dispatchWorkgroups(Math.ceil(g/8),Math.ceil(g/8),6),H.end(),x.queue.submit([S.finish()]),_.mipmapGenerator.generateMipmap(y,b),await x.queue.onSubmittedWorkDone(),L.destroy(),new IBLCubeTexture(this.#l,`CubeMap_From_Equirect_${createUUID()}`,y)}#oe(){return[new Float32Array([0,0,-1,0,0,-1,0,0,1,0,0,0,0,0,0,1]),new Float32Array([0,0,1,0,0,-1,0,0,-1,0,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,0,-1,0,0,-1,0,0,0,0,0,1]),new Float32Array([1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,1]),new Float32Array([-1,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,1])]}}Object.freeze(EquirectangularToCubeGenerator);var k=Object.freeze({__proto__:null,BRDFGenerator:BRDFGenerator,BRDFLUTTexture:BRDFLUTTexture,EquirectangularToCubeGenerator:EquirectangularToCubeGenerator,IBLCubeTexture:IBLCubeTexture,IrradianceGenerator:IrradianceGenerator,PrefilterGenerator:PrefilterGenerator});class DownSampleCubeMapGenerator{#l;#ue=new Map;#le=new Map;#ce=null;#he=null;#fe=null;#de=null;#me=8;#pe=8;#ge=new Map;#xe=new Map;constructor(i){this.#l=i}createSourceTextureView(i,g){const x=`DOWN_SAMPLE_CUBE_GENERATOR_SOURCE_VIEW_${i.label}_${g}`;if(!this.#ge.has(x)){const _=i.createView({label:x,dimension:"cube",baseMipLevel:g,mipLevelCount:1});this.#ge.set(x,_)}return this.#ge.get(x)}createTargetTextureView(i,g){const x=`DOWN_SAMPLE_CUBE_GENERATOR_TARGET_VIEW_${i.label}_${g}`;if(!this.#ge.has(x)){const _=i.createView({label:x,dimension:"2d-array",baseMipLevel:g,mipLevelCount:1,arrayLayerCount:6});this.#ge.set(x,_)}return this.#ge.get(x)}createBindGroup(i,g,x){const _=`DOWN_SAMPLE_CUBE_GENERATOR_BIND_GROUP_${g.label}_${x.label}`;if(!this.#xe.has(_)){const{gpuDevice:v}=this.#l,b=v.createBindGroup({label:_,layout:i,entries:[{binding:0,resource:g},{binding:1,resource:x},{binding:2,resource:this.#de},{binding:3,resource:{buffer:this.#he}}]});this.#xe.set(_,b)}return this.#xe.get(_)}async downsampleCubemap(i,g=256,x="rgba16float"){try{this.#_e(),this.#ve();const{gpuDevice:_,resourceManager:v}=this.#l;if(!i)throw new Error("Invalid source cubemap texture");if(g<=0||!Number.isInteger(g))throw new Error("Target size must be a positive integer");const b=i.mipLevelCount,y=getMipLevelCount(g,g),S=v.createManagedTexture({size:[g,g,6],format:x,usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,dimension:"2d",mipLevelCount:y,label:`DOWN_SAMPLE_CUBE_GENERATOR_TEXTURE_${g}x${g}_${y}mips_${Date.now()}`});for(let _=0;_<y;_++){const v=Math.max(1,g>>_),y=this.#be(i.width,g,_,b);await this.#ye(i,S,y,_,v,x)}return this.#_e(),S}catch(i){throw console.error("큐브맵 다운샘플링 실패:",i),this.#_e(),i}}destroy(){this.#_e(),this.#he&&(this.#he.destroy(),this.#he=null),this.#ue.clear(),this.#le.clear(),this.#ce=null,this.#de=null}#_e(){this.#ge.clear(),this.#xe.clear()}#ve(){if(this.#ce)return;const{gpuDevice:i,resourceManager:g}=this.#l;this.#de=new Sampler(this.#l,{minFilter:"linear",magFilter:"linear",mipmapFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge"}).gpuSampler,this.#ce=g.createGPUShaderModule("DOWN_SAMPLE_CUBE_GENERATOR_COMPUTE_SHADER",{code:"\nstruct Uniforms { targetSize:f32, sourceMipLevel:f32, targetMipLevel:f32, padding:f32,\n};\n@group(0) @binding(0) var sourceCubemap:texture_cube<f32>;\n@group(0) @binding(1) var targetCubemap:texture_storage_2d_array<rgba16float,write>;\n@group(0) @binding(2) var cubemapSampler:sampler;\n@group(0) @binding(3) var<uniform> uniforms:Uniforms;\nfn cubemapUVToDirection(uv:vec2<f32>,face:u32) -> vec3<f32> { let u=uv.x * 2.0 - 1.0; let v=uv.y * 2.0 - 1.0; switch face { case 0u:{ return vec3<f32>(1.0,-v,-u); } case 1u:{ return vec3<f32>(-1.0,-v,u); } case 2u:{ return vec3<f32>(u,1.0,v); } case 3u:{ return vec3<f32>(u,-1.0,-v); } case 4u:{ return vec3<f32>(u,-v,1.0); } case 5u:{ return vec3<f32>(-u,-v,-1.0); } default:{ return vec3<f32>(0.0,0.0,1.0); } }\n}\nfn gaussianWeight(x:f32,y:f32,sigma:f32) -> f32 { let sigmaSq=sigma * sigma; return exp(-(x * x + y * y)/(2.0 * sigmaSq))/(2.0 * 3.14159265359 * sigmaSq);\n}\nfn clampCubemapUV(uv:vec2<f32>) -> vec2<f32> { return clamp(uv,vec2<f32>(0.0),vec2<f32>(1.0));\n}\n@compute @workgroup_size(8,8,1)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>) { let face=global_id.z; let coord=vec2<u32>(global_id.xy); let targetSize=u32(uniforms.targetSize); if (coord.x >=targetSize || coord.y >=targetSize || face >=6u) { return; } let uv=(vec2<f32>(coord) + 0.5)/f32(targetSize); let direction=normalize(cubemapUVToDirection(uv,face)); let sourceMipLevel=uniforms.sourceMipLevel; let targetMipLevel=uniforms.targetMipLevel; var color=vec4<f32>(0.0); if (sourceMipLevel==0.0 && targetSize > 64u) { let sampleCount=16u; let sampleRadius=1.0/f32(targetSize); var totalWeight=0.0; for (var i=0u;i < sampleCount;i++) { let angle=2.0 * 3.14159265359 * f32(i)/f32(sampleCount); let radius=sampleRadius * (0.5 + 0.5 * f32(i % 4u)/4.0); let offsetUV=clampCubemapUV(uv + vec2<f32>( cos(angle) * radius, sin(angle) * radius )); let sampleDir=normalize(cubemapUVToDirection(offsetUV,face)); let sampleColor=textureSampleLevel(sourceCubemap,cubemapSampler,sampleDir,sourceMipLevel); let weight=gaussianWeight( cos(angle) * radius * f32(targetSize), sin(angle) * radius * f32(targetSize), 0.8 ); color +=sampleColor * weight; totalWeight +=weight; } if (totalWeight > 0.0) { color=color/totalWeight; } } else if (sourceMipLevel==0.0 && targetSize > 16u) { let sampleCount=4u; let invSampleCount=1.0/f32(sampleCount * sampleCount); let sampleOffset=0.5/f32(targetSize); for (var x=0u;x < sampleCount;x++) { for (var y=0u;y < sampleCount;y++) { let offset=vec2<f32>( (f32(x) - 1.5) * sampleOffset, (f32(y) - 1.5) * sampleOffset ); let offsetUV=clampCubemapUV(uv + offset); let sampleDir=normalize(cubemapUVToDirection(offsetUV,face)); color +=textureSampleLevel(sourceCubemap,cubemapSampler,sampleDir,sourceMipLevel); } } color *=invSampleCount; } else if (targetSize > 4u) { let sampleCount=2u; let invSampleCount=1.0/f32(sampleCount * sampleCount); let sampleOffset=0.25/f32(targetSize); for (var x=0u;x < sampleCount;x++) { for (var y=0u;y < sampleCount;y++) { let offset=vec2<f32>( (f32(x) - 0.5) * sampleOffset, (f32(y) - 0.5) * sampleOffset ); let offsetUV=clampCubemapUV(uv + offset); let sampleDir=normalize(cubemapUVToDirection(offsetUV,face)); color +=textureSampleLevel(sourceCubemap,cubemapSampler,sampleDir,sourceMipLevel); } } color *=invSampleCount; } else { color=textureSampleLevel(sourceCubemap,cubemapSampler,direction,sourceMipLevel); } if (targetMipLevel > 0.0) { let luminance=dot(color.rgb,vec3<f32>(0.299,0.587,0.114)); let saturation=0.9 + 0.1/(1.0 + targetMipLevel * 0.1); color=vec4<f32>(mix(vec3<f32>(luminance),color.rgb,saturation),color.a); } textureStore(targetCubemap,vec2<i32>(coord),i32(face),color);\n}\n"}),this.#Se()}#Te(i){if(!this.#ue.has(i)){const{gpuDevice:g,resourceManager:x}=this.#l,_=x.createBindGroupLayout(`DOWN_SAMPLE_CUBE_GENERATOR_BIND_GROUP_LAYOUT_${i}`,{entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{viewDimension:"cube",sampleType:"float"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:i,viewDimension:"2d-array"}},{binding:2,visibility:GPUShaderStage.COMPUTE,sampler:{type:"filtering"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),v=g.createComputePipeline({label:`DOWN_SAMPLE_CUBE_GENERATOR_COMPUTE_PIPELINE_${i}`,layout:g.createPipelineLayout({label:`DOWN_SAMPLE_CUBE_GENERATOR_PIPELINE_LAYOUT_${i}`,bindGroupLayouts:[_]}),compute:{module:this.#ce,entryPoint:"main"}});this.#le.set(i,_),this.#ue.set(i,v)}return this.#ue.get(i)}#Se(){const{gpuDevice:i,resourceManager:g}=this.#l;this.#fe={arrayBufferByteLength:16,properties:{targetSize:{byteOffset:0,size:4},sourceMipLevel:{byteOffset:4,size:4},targetMipLevel:{byteOffset:8,size:4},padding:{byteOffset:12,size:4}}},this.#he=i.createBuffer({size:this.#fe.arrayBufferByteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"DOWN_SAMPLE_CUBE_GENERATOR_UNIFORM_BUFFER"})}#be(i,g,x,_){const v=i/Math.max(1,g>>x),b=Math.max(0,Math.floor(Math.log2(v)));return Math.min(b,_-1)}async#ye(i,g,x,_,v,b){const{gpuDevice:y}=this.#l,S=this.#Te(b),w=this.#le.get(b),L=this.createSourceTextureView(i,x),k=this.createTargetTextureView(g,_),z=this.createBindGroup(w,L,k);this.#Me(x,_,v);const H=y.createCommandEncoder({label:`DOWN_SAMPLE_CUBE_GENERATOR_COMMAND_ENCODER_MIP${_}`}),q=H.beginComputePass({label:`DOWN_SAMPLE_CUBE_GENERATOR_COMPUTE_PASS_MIP${_}`});q.setPipeline(S),q.setBindGroup(0,z),q.dispatchWorkgroups(Math.ceil(v/this.#me),Math.ceil(v/this.#pe),6),q.end();const W=H.finish();y.queue.submit([W]),await y.queue.onSubmittedWorkDone()}#Me(i,g,x){const{gpuDevice:_}=this.#l,v=new Float32Array([x,i,g,0]);_.queue.writeBuffer(this.#he,0,v)}}Object.freeze(DownSampleCubeMapGenerator);const z={LOAD:"load",CLEAR:"clear"};Object.freeze(z);const H={STORE:"store",DISCARD:"discard"};Object.freeze(H);class MipmapGenerator{#l;#ae;#we;#Ce;#Pe;#Re;#ge=new Map;#xe=new Map;#Be=new WeakMap;#Ie=new WeakMap;constructor(i){this.#l=i,this.#ae=new Sampler(i,{minFilter:"linear"}).gpuSampler,this.#Ce={}}createTextureView(i,g,x,_=!1){const v=`${g}_${x}`;if(_){let _=this.#Ie.get(i);if(_||(_=new Map,this.#Ie.set(i,_)),_.has(v))return _.get(v);const b=i.createView({baseMipLevel:g,mipLevelCount:1,dimension:"2d",baseArrayLayer:x,arrayLayerCount:1,label:`MIPMAP_GENERATOR_CACHED_${i.label}_${v}`});return _.set(v,b),b}{const _=`MIPMAP_GENERATOR_${i.label}_${g}_${x}`;if(!this.#ge.has(_)){const v=i.createView({baseMipLevel:g,mipLevelCount:1,dimension:"2d",baseArrayLayer:x,arrayLayerCount:1,label:_});this.#ge.set(_,v)}return this.#ge.get(_)}}createBindGroup(i,g,x=!1){const{gpuDevice:_}=this.#l;if(x){let x=this.#Be.get(i);x||(x=new Map,this.#Be.set(i,x));const v=g.label||"unlabeled";if(x.has(v))return x.get(v);const b=_.createBindGroup({label:`MIPMAP_GENERATOR_BIND_GROUP_CACHED_${i.label}_${v}`,layout:this.#Pe,entries:[{binding:0,resource:this.#ae},{binding:1,resource:g}]});return x.set(v,b),b}{const x=`${i.label}_${g.label}`;if(this.#xe.has(x))return this.#xe.get(x);const v=_.createBindGroup({label:`MIPMAP_GENERATOR_BIND_GROUP_TEMP_${x}`,layout:this.#Pe,entries:[{binding:0,resource:this.#ae},{binding:1,resource:g}]});return this.#xe.set(x,v),v}}getMipmapPipeline(i){const{gpuDevice:g,resourceManager:x}=this.#l;let _=this.#Ce[i];return _||(this.#Re||(this.#Re=x.createGPUShaderModule("MIPMAP_GENERATOR_SHADER_MODULE",{code:"\nvar<private> pos:array<vec2<f32>,3>=array<vec2<f32>,3>( vec2<f32>(-1.0,-1.0), vec2<f32>(-1.0,3.0), vec2<f32>(3.0,-1.0)\n);\nstruct VertexOutput { @builtin(position) position:vec4<f32>, @location(0) texCoord:vec2<f32>,\n};\n@vertex\nfn vertexMain(@builtin(vertex_index) vertexIndex:u32) -> VertexOutput { var output:VertexOutput; output.texCoord=pos[vertexIndex] * vec2<f32>(0.5,-0.5) + vec2<f32>(0.5); output.position=vec4<f32>(pos[vertexIndex],0.0,1.0); return output;\n}\n@group(0) @binding(0)\nvar imgSampler:sampler;\n@group(0) @binding(1)\nvar img:texture_2d<f32>;\n@fragment\nfn fragmentMain(@location(0) texCoord:vec2<f32>) -> @location(0) vec4<f32> { return textureSample(img,imgSampler,texCoord);\n}\n"}),this.#Pe=x.createBindGroupLayout("MIPMAP_GENERATOR_FRAGMENT_BIND_GROUP_LAYOUT",{entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}}]}),this.#we=x.createGPUPipelineLayout("MIPMAP_GENERATOR_PIPELINE_LAYOUT",{bindGroupLayouts:[this.#Pe]})),_=g.createRenderPipeline({label:`MIPMAP_GENERATOR_PIPELINE_${i}`,layout:this.#we,vertex:{module:this.#Re,entryPoint:"vertexMain"},fragment:{module:this.#Re,entryPoint:"fragmentMain",targets:[{format:i}]}}),this.#Ce[i]=_),_}generateMipmap(i,g,x=!1){x||this.#_e();const{gpuDevice:_,resourceManager:v}=this.#l,b=this.getMipmapPipeline(g.format);if("3d"==g.dimension||"1d"==g.dimension)throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");let y=i;const S=g.size[0],w=g.size[1],L=g.size[2]||1,k=g.usage&GPUTextureUsage.RENDER_ATTACHMENT;if(!k){const i={size:{width:Math.max(1,S>>>1),height:Math.max(1,w>>>1),depthOrArrayLayers:L},format:g.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:g.mipLevelCount-1};y=v.createManagedTexture(i)}const q=_.createCommandEncoder({});for(let _=0;_<L;++_){let v=this.createTextureView(i,0,_,x),S=k?1:0;for(let w=1;w<g.mipLevelCount;++w){const g=this.createTextureView(y,S++,_,x),w=q.beginRenderPass({colorAttachments:[{view:g,clearValue:{r:0,g:0,b:0,a:0},loadOp:z.CLEAR,storeOp:H.STORE}]}),L=this.createBindGroup(i,v,x);w.setPipeline(b),w.setBindGroup(0,L),w.draw(3,1,0,0),w.end(),v=g}}if(!k){const x={width:Math.max(1,S>>>1),height:Math.max(1,w>>>1),depthOrArrayLayers:L};for(let _=1;_<g.mipLevelCount;++_)q.copyTextureToTexture({texture:y,mipLevel:_-1},{texture:i,mipLevel:_},x),x.width=Math.max(1,x.width>>>1),x.height=Math.max(1,x.height>>>1)}return _.queue.submit([q.finish()]),k||y.destroy(),x||this.#_e(),i}destroy(){this.#_e()}#_e(){this.#ge.clear(),this.#xe.clear()}}Object.freeze(MipmapGenerator);const q={TILE_COUNT_X:32,TILE_COUNT_Y:32,TILE_COUNT_Z:48,WORKGROUP_SIZE_X:8,WORKGROUP_SIZE_Y:4,WORKGROUP_SIZE_Z:8,MAX_LIGHTS_PER_CLUSTER:100,MAX_CLUSTER_LIGHTS:1024,getTotalTileSize:()=>q.TILE_COUNT_X*q.TILE_COUNT_Y*q.TILE_COUNT_Z,getClusterLightsBufferSize:()=>{const i=q.getTotalTileSize();return 8*i+8*q.MAX_LIGHTS_PER_CLUSTER*i+4},getDispatchSize:()=>[Math.ceil(q.TILE_COUNT_X/q.WORKGROUP_SIZE_X),Math.ceil(q.TILE_COUNT_Y/q.WORKGROUP_SIZE_Y),Math.ceil(q.TILE_COUNT_Z/q.WORKGROUP_SIZE_Z)]};Object.freeze(q);const W=Object.freeze({calcTintBlendMode:"\nfn rgbToHsl(rgb:vec3<f32>) -> vec3<f32> { let maxVal:f32=max(max(rgb.r,rgb.g),rgb.b); let minVal:f32=min(min(rgb.r,rgb.g),rgb.b); let delta:f32=maxVal - minVal; let eps=1e-6; let lightness:f32=(maxVal + minVal) * 0.5; if (delta < eps) { return vec3<f32>(0.0,0.0,lightness); } var saturation:f32; if (lightness < 0.5) { saturation=delta/(maxVal + minVal + eps); } else { saturation=delta/(2.0 - maxVal - minVal + eps); } var hue:f32=0.0; if (abs(rgb.r - maxVal) < eps) { hue=(rgb.g - rgb.b)/delta; if (rgb.g < rgb.b) { hue +=6.0; } } else if (abs(rgb.g - maxVal) < eps) { hue=(rgb.b - rgb.r)/delta + 2.0; } else { hue=(rgb.r - rgb.g)/delta + 4.0; } hue=hue/6.0; return vec3<f32>(hue,saturation,lightness);\n}\nfn hslToRgb(hsl:vec3<f32>) -> vec3<f32> { let h=hsl.x; let s=hsl.y; let l=hsl.z; if (s==0.0) { return vec3<f32>(l,l,l); } var q:f32; if (l < 0.5) { q=l * (1.0 + s); } else { q=l + s - l * s; } let p=2.0 * l - q; var r:f32; var g:f32; var b:f32; for (var i:i32=0;i < 3;i=i + 1) { var t:f32; if (i==0) { t=h + 1.0/3.0; } else if (i==1) { t=h; } else { t=h - 1.0/3.0; } if (t < 0.0) { t=t + 1.0; } if (t > 1.0) { t=t - 1.0; } var color:f32; if (t < 1.0/6.0) { color=p + (q - p) * 6.0 * t; } else if (t < 1.0/2.0) { color=q; } else if (t < 2.0/3.0) { color=p + (q - p) * (2.0/3.0 - t) * 6.0; } else { color=p; } if (i==0) { r=color; } else if (i==1) { g=color; } else { b=color; } } return vec3<f32>(r,g,b);\n}\nfn calcTintBlendMode(baseColor:vec4<f32>,tintBlendMode:u32,tint:vec4<f32>) -> vec4<f32> { var tintedColor:vec3<f32>; let eps=1e-6; switch (tintBlendMode) { case 0u:{  tintedColor=mix(baseColor.rgb,tint.rgb,tint.a); } case 1u:{  tintedColor=baseColor.rgb * tint.rgb; } case 2u:{  tintedColor=max(baseColor.rgb,tint.rgb); } case 3u:{  tintedColor=1.0 - (1.0 - baseColor.rgb) * (1.0 - tint.rgb); } case 4u:{  tintedColor=clamp(baseColor.rgb + tint.rgb,vec3<f32>(0.0),vec3<f32>(1.0)); } case 5u:{  tintedColor=clamp(baseColor.rgb - tint.rgb,vec3<f32>(0.0),vec3<f32>(1.0)); } case 6u:{  tintedColor=min(baseColor.rgb,tint.rgb); } case 7u:{  tintedColor=mix( 2.0 * baseColor.rgb * tint.rgb, 1.0 - 2.0 * (1.0 - baseColor.rgb) * (1.0 - tint.rgb), step(vec3<f32>(0.5),baseColor.rgb) ); } case 8u:{  tintedColor=clamp(baseColor.rgb/(1.0 - tint.rgb + eps),vec3<f32>(0.0),vec3<f32>(1.0)); } case 9u:{  tintedColor=1.0 - clamp((1.0 - baseColor.rgb)/(tint.rgb + eps),vec3<f32>(0.0),vec3<f32>(1.0)); } case 10u:{  tintedColor=mix( 2.0 * baseColor.rgb * tint.rgb, 1.0 - 2.0 * (1.0 - baseColor.rgb) * (1.0 - tint.rgb), step(vec3<f32>(0.5),tint.rgb) ); } case 11u:{  tintedColor=mix( baseColor.rgb * (tint.rgb + tint.rgb - vec3<f32>(1.0)), baseColor.rgb + tint.rgb - baseColor.rgb * tint.rgb, step(vec3<f32>(0.5),tint.rgb) ); } case 12u:{  tintedColor=abs(baseColor.rgb - tint.rgb); } case 13u:{  tintedColor=baseColor.rgb + tint.rgb - 2.0 * baseColor.rgb * tint.rgb; } case 14u:{  tintedColor=clamp(baseColor.rgb/(tint.rgb + eps),vec3<f32>(0.0),vec3<f32>(1.0)); } case 15u:{  tintedColor=mix( clamp(baseColor.rgb/(1.0 - (tint.rgb - vec3<f32>(0.5)) * 2.0 + eps),vec3<f32>(0.0),vec3<f32>(1.0)), 1.0 - clamp((1.0 - baseColor.rgb)/(tint.rgb * 2.0 + eps),vec3<f32>(0.0),vec3<f32>(1.0)), step(vec3<f32>(0.5),tint.rgb) ); } case 16u:{  tintedColor=clamp(baseColor.rgb + tint.rgb - vec3<f32>(1.0),vec3<f32>(0.0),vec3<f32>(1.0)); } case 17u:{  tintedColor=mix( min(baseColor.rgb,2.0 * tint.rgb), max(baseColor.rgb,2.0 * tint.rgb - vec3<f32>(1.0)), step(vec3<f32>(0.5),tint.rgb) ); } case 18u:{  let baseHsl=rgbToHsl(baseColor.rgb); let tintHsl=rgbToHsl(tint.rgb); tintedColor=hslToRgb(vec3<f32>(baseHsl.x,tintHsl.y,baseHsl.z)); } case 19u:{  let baseHsl=rgbToHsl(baseColor.rgb); let tintHsl=rgbToHsl(tint.rgb); tintedColor=hslToRgb(vec3<f32>(tintHsl.x,baseHsl.y,baseHsl.z)); } case 20u:{  let baseHsl=rgbToHsl(baseColor.rgb); let tintHsl=rgbToHsl(tint.rgb); tintedColor=hslToRgb(vec3<f32>(baseHsl.x,baseHsl.y,tintHsl.z)); } case 21u:{  let baseHsl=rgbToHsl(baseColor.rgb); let tintHsl=rgbToHsl(tint.rgb); tintedColor=hslToRgb(vec3<f32>(tintHsl.x,tintHsl.y,baseHsl.z)); } case 22u:{  tintedColor=1.0 - abs(1.0 - baseColor.rgb - tint.rgb); } default:{ tintedColor=baseColor.rgb; } } return vec4<f32>(tintedColor,baseColor.a * tint.a);\n}\n",calcDirectionalShadowVisibility:"fn calcDirectionalShadowVisibility( directionalShadowMap:texture_depth_2d, directionalShadowMapSampler:sampler_comparison, shadowDepthTextureSize:u32, bias:f32, shadowPos:vec3<f32>\n) -> f32 { let oneOverShadowDepthTextureSize=1.0/f32(shadowDepthTextureSize); let shadowDepth=clamp(shadowPos.z,0.0,1.0); var visibility:f32=0.0; for (var y=-1;y <=1;y++) { for (var x=-1;x <=1;x++) { let offset=vec2f(vec2(x,y)) * oneOverShadowDepthTextureSize; let tUV=shadowPos.xy + offset; let sampleVisibility=textureSampleCompare( directionalShadowMap, directionalShadowMapSampler, tUV, shadowDepth - bias ); if (tUV.x < 0.0 || tUV.x > 1.0 || tUV.y < 0.0 || tUV.y > 1.0) { visibility +=1.0; } else { visibility +=sampleVisibility; } } } visibility/=9.0; let depthFactor=shadowDepth; let minVisibility=0.2 + depthFactor * 0.6; return max(visibility,minVisibility);\n}\n",drawDirectionalShadowDepth:"struct OutputShadowData { @builtin(position) position:vec4<f32>,\n};\n@vertex\nfn drawDirectionalShadowDepth(inputData:InputData) -> OutputShadowData { var output:OutputShadowData; let u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let input_position=inputData.position; let input_vertexNormal=inputData.vertexNormal; let input_uv=inputData.uv; var position:vec4<f32>; position=u_modelMatrix * vec4<f32>(input_position,1.0); #redgpu_if useDisplacementTexture { let distance=distance(position.xyz,u_cameraPosition); let mipLevel=(distance/maxDistance) * maxMipLevel; let displacedPosition=calcDisplacementPosition( input_position, input_vertexNormal, displacementTexture, displacementTextureSampler, vertexUniforms.displacementScale, input_uv, mipLevel ); position=u_modelMatrix * vec4<f32>(displacedPosition,1.0); } #redgpu_endIf output.position=u_directionalLightProjectionViewMatrix * position; return output;\n}\n",normalFunctions:"\nfn cotangent_frame( N:vec3<f32>,p:vec3<f32>,uv:vec2<f32>) -> mat3x3<f32>{ let dp1:vec3<f32>=dpdx( p ); let dp2:vec3<f32>=dpdy( p ); let duv1:vec2<f32>=dpdx( uv ); let duv2:vec2<f32>=dpdy( uv ); let dp2perp:vec3<f32>=cross( dp2,N ); let dp1perp:vec3<f32>=cross( N,dp1 ); let T:vec3<f32>=dp2perp * duv1.x + dp1perp * duv2.x; let B:vec3<f32>=dp2perp * duv1.y + dp1perp * duv2.y; return mat3x3<f32>( normalize(T),normalize(B),N );\n}\nfn perturb_normal( N:vec3<f32>,position:vec3<f32>,texcoord:vec2<f32>,normalColor:vec3<f32>,normalPower:f32 ) -> vec3<f32> { var map:vec3<f32>=normalColor; map=normalColor * 2.0 - 1.0; map=vec3<f32>(map.xy * -normalPower,map.z); let TBN:mat3x3<f32>=cotangent_frame(N,position,texcoord); return normalize(TBN * map);\n}\n",calcPrePathBackground:"fn calcPrePathBackground( u_useKHR_materials_volume:bool,thicknessParameter:f32,u_KHR_dispersion:f32,u_KHR_attenuationDistance:f32,u_KHR_attenuationColor:vec3<f32>, ior:f32,roughnessParameter:f32,albedo:vec3<f32>, projectionCameraMatrix:mat4x4<f32>,input_vertexPosition:vec3<f32>,input_ndcPosition:vec3<f32>, V:vec3<f32>,N:vec3<f32>, renderPath1ResultTexture:texture_2d<f32>,renderPath1ResultTextureSampler:sampler\n) -> vec3<f32> { var prePathBackground=vec3<f32>(0.0); let maxMipLevel=f32(textureNumLevels(renderPath1ResultTexture) - 1); let transmissionMipLevel=clamp(roughnessParameter * maxMipLevel,0.0,maxMipLevel); if(u_useKHR_materials_volume){ var iorR:f32=ior; var iorG:f32=ior; var iorB:f32=ior; if(u_KHR_dispersion > 0.0){ let halfSpread:f32=(ior - 1.0) * 0.025 * u_KHR_dispersion; iorR=ior + halfSpread; iorG=ior; iorB=ior - halfSpread; } iorR=max(iorR,1.0001); iorG=max(iorG,1.0001); iorB=max(iorB,1.0001); let refractedVecR:vec3<f32>=refract(-V,N,1.0/iorR); let refractedVecG:vec3<f32>=refract(-V,N,1.0/iorG); let refractedVecB:vec3<f32>=refract(-V,N,1.0/iorB); let validR=dot(refractedVecR,refractedVecR) > 0.0; let validG=dot(refractedVecG,refractedVecG) > 0.0; let validB=dot(refractedVecB,refractedVecB) > 0.0; let finalRefractR=select(reflect(-V,N),refractedVecR,validR); let finalRefractG=select(reflect(-V,N),refractedVecG,validG); let finalRefractB=select(reflect(-V,N),refractedVecB,validB); let safeThickness=clamp(thicknessParameter,0.0,100.0); let worldPosR:vec3<f32>=input_vertexPosition + finalRefractR * safeThickness; let worldPosG:vec3<f32>=input_vertexPosition + finalRefractG * safeThickness; let worldPosB:vec3<f32>=input_vertexPosition + finalRefractB * safeThickness; let clipPosR:vec4<f32>=projectionCameraMatrix * vec4<f32>(worldPosR,1.0); let clipPosG:vec4<f32>=projectionCameraMatrix * vec4<f32>(worldPosG,1.0); let clipPosB:vec4<f32>=projectionCameraMatrix * vec4<f32>(worldPosB,1.0); let wR=max(abs(clipPosR.w),0.0001); let wG=max(abs(clipPosG.w),0.0001); let wB=max(abs(clipPosB.w),0.0001); let ndcR:vec2<f32>=clipPosR.xy/wR * 0.5 + 0.5; let ndcG:vec2<f32>=clipPosG.xy/wG * 0.5 + 0.5; let ndcB:vec2<f32>=clipPosB.xy/wB * 0.5 + 0.5; let finalUV_R:vec2<f32>=clamp(vec2<f32>(ndcR.x,1.0 - ndcR.y),vec2<f32>(0.0),vec2<f32>(1.0)); let finalUV_G:vec2<f32>=clamp(vec2<f32>(ndcG.x,1.0 - ndcG.y),vec2<f32>(0.0),vec2<f32>(1.0)); let finalUV_B:vec2<f32>=clamp(vec2<f32>(ndcB.x,1.0 - ndcB.y),vec2<f32>(0.0),vec2<f32>(1.0)); let sampledR=textureSampleLevel(renderPath1ResultTexture,renderPath1ResultTextureSampler,finalUV_R,transmissionMipLevel).r; let sampledG=textureSampleLevel(renderPath1ResultTexture,renderPath1ResultTextureSampler,finalUV_G,transmissionMipLevel).g; let sampledB=textureSampleLevel(renderPath1ResultTexture,renderPath1ResultTextureSampler,finalUV_B,transmissionMipLevel).b; prePathBackground.r=select(0.0,sampledR,isFiniteScalar(sampledR)); prePathBackground.g=select(0.0,sampledG,isFiniteScalar(sampledG)); prePathBackground.b=select(0.0,sampledB,isFiniteScalar(sampledB)); } else { let safeIor=max(ior,1.0001); let refractedVec:vec3<f32>=refract(-V,N,1.0/safeIor); let valid=dot(refractedVec,refractedVec) > 0.0; let finalRefract=select(reflect(-V,N),refractedVec,valid); let safeThickness=clamp(thicknessParameter,0.0,100.0); let worldPos:vec3<f32>=input_vertexPosition + finalRefract * safeThickness; let clipPos:vec4<f32>=projectionCameraMatrix * vec4<f32>(worldPos,1.0); let w=max(abs(clipPos.w),0.0001); let ndc:vec2<f32>=clipPos.xy/w * 0.5 + 0.5; let finalUV:vec2<f32>=clamp(vec2<f32>(ndc.x,1.0 - ndc.y),vec2<f32>(0.0),vec2<f32>(1.0)); let sampled=textureSampleLevel(renderPath1ResultTexture,renderPath1ResultTextureSampler,finalUV,transmissionMipLevel).rgb; prePathBackground=select(vec3<f32>(0.0),sampled,all(isFiniteVec3(sampled))); } let safeAlbedo=clamp(albedo,vec3<f32>(0.0),vec3<f32>(1.0)); prePathBackground *=safeAlbedo; prePathBackground=select(vec3<f32>(0.0),prePathBackground,all(isFiniteVec3(prePathBackground))); return prePathBackground;\n}\nfn isFiniteScalar(x:f32) -> bool { return x==x && abs(x) < 1e30;\n}\nfn isFiniteVec3(v:vec3<f32>) -> vec3<bool> { return vec3<bool>( v.x==v.x && abs(v.x) < 1e30, v.y==v.y && abs(v.y) < 1e30, v.z==v.z && abs(v.z) < 1e30 );\n}",calculateMotionVector:"fn calculateMotionVector( currentClipPos:vec4<f32>, prevClipPos:vec4<f32>,\n) -> vec2<f32> { let currentNDC=currentClipPos.xy/max(currentClipPos.w,1e-6); let prevNDC=prevClipPos.xy/max(prevClipPos.w,1e-6); var motionVector=currentNDC - prevNDC; motionVector.y=-motionVector.y; let uvMotionVector=motionVector * 0.5; return uvMotionVector;\n}\n",FragmentOutput:"struct FragmentOutput { @location(0) color:vec4<f32>, @location(1) gBufferNormal:vec4<f32>, @location(2) gBufferMotionVector:vec4<f32>,\n}\n",picking:"@vertex\nfn picking(inputData:InputData) -> OutputData { var output:OutputData; let input_position=inputData.position; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; var position:vec4<f32>=u_modelMatrix * vec4<f32>(input_position,1.0); output.position=u_projectionCameraMatrix * position; output.pickingId=unpack4x8unorm(vertexUniforms.pickingId); return output;\n}\n",drawPicking:"\n@fragment\nfn picking(inputData:InputData) -> @location(0) vec4<f32> { var finalColor:vec4<f32>=inputData.pickingId; return finalColor;\n}\n"});Object.freeze(W);const be=Object.freeze({billboardPicking:"@vertex\nfn picking(inputData:InputData) -> OutputData { var output:OutputData; let u_resolution=systemUniforms.resolution; #redgpu_if disableJitter let u_projectionMatrix=systemUniforms.noneJitterProjectionMatrix; #redgpu_else let u_projectionMatrix=systemUniforms.projectionMatrix; #redgpu_endIf let u_cameraMatrix=systemUniforms.camera.cameraMatrix; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_useBillboard=vertexUniforms.useBillboard; let u_usePixelSize=vertexUniforms.usePixelSize; let u_pixelSize=vertexUniforms.pixelSize; let u_renderRatioX=vertexUniforms._renderRatioX; let u_renderRatioY=vertexUniforms._renderRatioY; var ratioScaleMatrix:mat4x4<f32>=mat4x4<f32>( u_renderRatioX,0,0,0, 0,u_renderRatioY,0,0, 0,0,1,0, 0,0,0,1 ); if (u_useBillboard==1) { let billboardMatrix=getBillboardMatrix(u_cameraMatrix,u_modelMatrix); if (u_usePixelSize==1) { let viewPositionCenter=billboardMatrix * vec4<f32>(0.0,0.0,0.0,1.0); let clipCenter=u_projectionMatrix * viewPositionCenter; let scaleX=(u_pixelSize/u_resolution.x) * 2.0 * u_renderRatioX; let scaleY=(u_pixelSize/u_resolution.y) * 2.0 * u_renderRatioY; output.position=vec4<f32>( clipCenter.xy + inputData.position.xy * vec2<f32>(scaleX,scaleY) * clipCenter.w, clipCenter.zw ); } else { output.position=u_projectionMatrix * billboardMatrix * ratioScaleMatrix * vec4<f32>(inputData.position,1.0); } } else { output.position=u_projectionMatrix * u_cameraMatrix * u_modelMatrix * ratioScaleMatrix * vec4<f32>(inputData.position,1.0); } output.pickingId=unpack4x8unorm(vertexUniforms.pickingId); return output;\n}",billboardShadow:"struct OutputShadowData { @builtin(position) position:vec4<f32>,\n};\n@vertex\nfn drawDirectionalShadowDepth(inputData:InputData) -> OutputShadowData { var output:OutputShadowData; return output;\n}",calcBillboard:"struct BillboardResult { position:vec4<f32>, vertexPosition:vec3<f32>, vertexNormal:vec3<f32>,\n}\nfn calcBillboard( input_position:vec3<f32>, input_normal:vec3<f32>, modelMatrix:mat4x4<f32>, cameraMatrix:mat4x4<f32>, projectionMatrix:mat4x4<f32>, resolution:vec2<f32>, useBillboard:u32, usePixelSize:u32, pixelSize:f32, renderRatioX:f32, renderRatioY:f32\n) -> BillboardResult { var result:BillboardResult; let ratioScaleMatrix=mat4x4<f32>( renderRatioX,0,0,0, 0,renderRatioY,0,0, 0,0,1,0, 0,0,0,1 ); var viewPos:vec4<f32>; var viewNormal:vec4<f32>; if (useBillboard==1u) { let billboardMatrix=getBillboardMatrix(cameraMatrix,modelMatrix); if (usePixelSize==1u) { let viewCenter=billboardMatrix * vec4<f32>(0.0,0.0,0.0,1.0); let clipCenter=projectionMatrix * viewCenter; let scaleX=(pixelSize/resolution.x) * 2.0 * renderRatioX; let scaleY=(pixelSize/resolution.y) * 2.0 * renderRatioY; result.position=vec4<f32>( clipCenter.xy + input_position.xy * vec2<f32>(scaleX,scaleY) * clipCenter.w, clipCenter.zw ); viewPos=viewCenter; viewNormal=vec4<f32>(0.0,0.0,1.0,0.0); } else { viewPos=billboardMatrix * ratioScaleMatrix * vec4<f32>(input_position,1.0); viewNormal=vec4<f32>(0.0,0.0,1.0,0.0); result.position=projectionMatrix * viewPos; } } else { viewPos=cameraMatrix * modelMatrix * ratioScaleMatrix * vec4<f32>(input_position,1.0); viewNormal=cameraMatrix * modelMatrix * ratioScaleMatrix * vec4<f32>(input_normal,0.0); result.position=projectionMatrix * viewPos; } result.vertexPosition=viewPos.xyz; result.vertexNormal=normalize(viewNormal.xyz); return result;\n}\n",calcDisplacements:"fn calcDisplacementPosition(input_position:vec3<f32>,input_vertexNormal:vec3<f32>,displacementTexture:texture_2d<f32>,displacementTextureSampler:sampler,displacementScale:f32,input_uv:vec2<f32>,mipLevel:f32) -> vec3<f32> { let displacementSample=textureSampleLevel(displacementTexture,displacementTextureSampler,input_uv,mipLevel).r; let scaledDisplacement=(displacementSample - 0.5) * displacementScale; let displacedPosition=input_position + input_vertexNormal * scaledDisplacement; return displacedPosition;\n}\nfn calcDisplacementNormal( input_vertexNormal:vec3<f32>, displacementTexture:texture_2d<f32>, displacementTextureSampler:sampler, displacementScale:f32, input_uv:vec2<f32>, mipLevel:f32\n) -> vec3<f32> { let textureDimensions=vec2<f32>(textureDimensions(displacementTexture,0)); let adaptiveOffset=vec2<f32>(1.0)/textureDimensions; let actualMipLevel=mipLevel; let center=textureSampleLevel(displacementTexture,displacementTextureSampler,input_uv,actualMipLevel).r; let left=textureSampleLevel(displacementTexture,displacementTextureSampler,input_uv - vec2<f32>(adaptiveOffset.x,0.0),actualMipLevel).r; let right=textureSampleLevel(displacementTexture,displacementTextureSampler,input_uv + vec2<f32>(adaptiveOffset.x,0.0),actualMipLevel).r; let down=textureSampleLevel(displacementTexture,displacementTextureSampler,input_uv - vec2<f32>(0.0,adaptiveOffset.y),actualMipLevel).r; let up=textureSampleLevel(displacementTexture,displacementTextureSampler,input_uv + vec2<f32>(0.0,adaptiveOffset.y),actualMipLevel).r; let ddx=((right - 0.5) - (left - 0.5)) * displacementScale/(2.0 * adaptiveOffset.x); let ddy=((up - 0.5) - (down - 0.5)) * displacementScale/(2.0 * adaptiveOffset.y); let tangentSpaceNormal=normalize(vec3<f32>(-ddx,-ddy,1.0)); let worldNormal=normalize(input_vertexNormal); let normalStrength=clamp(1.0 - mipLevel * 0.1,0.2,1.0); let blendedNormal=normalize(mix(worldNormal,tangentSpaceNormal,normalStrength * 0.3)); return blendedNormal;\n}\n",getBillboardMatrix:"fn getBillboardMatrix(cameraMatrix:mat4x4<f32>,modelMatrix:mat4x4<f32>) -> mat4x4<f32> { let scaleX=length(vec3<f32>(modelMatrix[0].xyz)); let scaleY=length(vec3<f32>(modelMatrix[1].xyz)); let scaleZ=length(vec3<f32>(modelMatrix[2].xyz)); let scaleMatrix=mat4x4<f32>( vec4<f32>(scaleX,0.0,0.0,0.0), vec4<f32>(0.0,scaleY,0.0,0.0), vec4<f32>(0.0,0.0,scaleZ,0.0), vec4<f32>(0.0,0.0,0.0,1.0) ); var resultMatrix=cameraMatrix * modelMatrix; resultMatrix[0][0]=1.0;resultMatrix[0][1]=0.0;resultMatrix[0][2]=0.0; resultMatrix[1][0]=0.0;resultMatrix[1][1]=1.0;resultMatrix[1][2]=0.0; resultMatrix[2][0]=0.0;resultMatrix[2][1]=0.0;resultMatrix[2][2]=1.0; return resultMatrix * scaleMatrix;\n}\nfn getBillboardMatrixNoScaleRatio( cameraMatrix:mat4x4<f32>,modelMatrix:mat4x4<f32>)-> mat4x4<f32>{ var resultMatrix=cameraMatrix * modelMatrix; resultMatrix[0][0]=modelMatrix[0][0];resultMatrix[0][1]=0.0;resultMatrix[0][2]=0.0; resultMatrix[1][0]=0.0;resultMatrix[1][1]=modelMatrix[1][1];resultMatrix[1][2]=0.0; resultMatrix[2][0]=0.0;resultMatrix[2][1]=0.0;resultMatrix[2][2]=modelMatrix[2][2]; return resultMatrix;\n}\n",extractScaleAndTranslation:"fn extractScaleAndTranslation(modelMatrix:mat4x4<f32>) -> mat4x4<f32> { let scaleX=length(vec3<f32>(modelMatrix[0].xyz)); let scaleY=length(vec3<f32>(modelMatrix[1].xyz)); let scaleZ=length(vec3<f32>(modelMatrix[2].xyz)); let scaleMatrix=mat4x4<f32>( vec4<f32>(scaleX,0.0,0.0,0.0), vec4<f32>(0.0,scaleY,0.0,0.0), vec4<f32>(0.0,0.0,scaleZ,0.0), vec4<f32>(0.0,0.0,0.0,1.0) ); return mat4x4<f32>( scaleMatrix[0], scaleMatrix[1], scaleMatrix[2], modelMatrix[3]  );\n}\n",meshVertexBasicUniform:"struct MatrixList{ localMatrix:mat4x4<f32>, modelMatrix:mat4x4<f32>, prevModelMatrix:mat4x4<f32>, normalModelMatrix:mat4x4<f32>,\n}\nstruct VertexUniforms { matrixList:MatrixList, pickingId:u32, receiveShadow:f32, combinedOpacity:f32, useDisplacementTexture:u32, displacementScale:f32, disableJitter:u32, uvTransform:vec4<f32>,\n};"});Object.freeze(be);const Ke=Object.freeze({SYSTEM_UNIFORM:"struct DirectionalLight { direction:vec3<f32>, color:vec3<f32>, intensity:f32,\n};\nstruct AmbientLight { color:vec3<f32>, intensity:f32\n};\nstruct Camera { cameraMatrix:mat4x4<f32>, cameraPosition:vec3<f32>, nearClipping:f32, farClipping:f32\n};\nstruct SystemUniform { projectionMatrix:mat4x4<f32>, projectionCameraMatrix:mat4x4<f32>, noneJitterProjectionMatrix:mat4x4<f32>, noneJitterProjectionCameraMatrix:mat4x4<f32>, inverseProjectionMatrix:mat4x4<f32>, prevNoneJitterProjectionCameraMatrix:mat4x4<f32>, resolution:vec2<f32>, camera:Camera, time:f32, usePrefilterTexture:u32, isView3D:u32, shadowDepthTextureSize:u32, bias:f32, directionalLightCount:u32, directionalLightProjectionViewMatrix:mat4x4<f32>, directionalLightProjectionMatrix:mat4x4<f32>, directionalLightViewMatrix:mat4x4<f32>, directionalLights:array<DirectionalLight,3>, ambientLight:AmbientLight,\n};\n@group(0) @binding(0) var<uniform> systemUniforms:SystemUniform;\n@group(0) @binding(1) var directionalShadowMapSampler:sampler_comparison;\n@group(0) @binding(2) var directionalShadowMap:texture_depth_2d;\n@group(0) @binding(3) var prefilterTextureSampler:sampler;\n@group(0) @binding(7) var renderPath1ResultTextureSampler:sampler;\n@group(0) @binding(8) var renderPath1ResultTexture:texture_2d<f32>;\n@group(0) @binding(9) var packedTextureSampler:sampler;\n@group(0) @binding(10) var ibl_environmentTexture:texture_cube<f32>;\n@group(0) @binding(11) var ibl_irradianceTexture:texture_cube<f32>;\n@group(0) @binding(12) var ibl_brdfLUTTexture:texture_2d<f32>;\nconst clusterLight_indicesLength:u32=u32(REDGPU_DEFINE_MAX_LIGHTS_PER_CLUSTERu * REDGPU_DEFINE_TOTAL_TILESu);\nconst clusterLight_tileCount=vec3<u32>(REDGPU_DEFINE_TILE_COUNT_Xu,REDGPU_DEFINE_TILE_COUNT_Yu,REDGPU_DEFINE_TILE_COUNT_Zu);\nstruct ClusterLights { offset:u32, count:u32\n};\nstruct ClusterLightsGroup { offset:atomic<u32>, lights:array<ClusterLights,REDGPU_DEFINE_TOTAL_TILES>, indices:array<u32,clusterLight_indicesLength>\n};\nstruct ClusterLight_ClusterCube { minAABB:vec4<f32>, maxAABB:vec4<f32> };\nstruct ClusterLight_Clusters { cubeList:array<ClusterLight_ClusterCube,REDGPU_DEFINE_TOTAL_TILES>\n};\nfn linearDepth(depthSample:f32) -> f32 { return systemUniforms.camera.farClipping*systemUniforms.camera.nearClipping/fma(depthSample,systemUniforms.camera.nearClipping-systemUniforms.camera.farClipping,systemUniforms.camera.farClipping);\n}\nfn getClusterLightClusterIndex(fragCoord:vec4<f32>) -> u32 { let tile=getClusterLightTile(fragCoord); return tile.x + tile.y * clusterLight_tileCount.x + tile.z * clusterLight_tileCount.x * clusterLight_tileCount.y;\n}\nfn getClusterLightTile(fragCoord:vec4<f32>) -> vec3<u32> { let sliceScale=f32(clusterLight_tileCount.z)/log2(systemUniforms.camera.farClipping/systemUniforms.camera.nearClipping); let sliceBias=-(f32(clusterLight_tileCount.z) * log2(systemUniforms.camera.nearClipping)/log2(systemUniforms.camera.farClipping/systemUniforms.camera.nearClipping)); let zTile=u32(max(log2(linearDepth(fragCoord.z)) * sliceScale + sliceBias,0.0)); return vec3<u32>(u32(fragCoord.x/(systemUniforms.resolution.x/f32(clusterLight_tileCount.x))), u32(fragCoord.y/(systemUniforms.resolution.y/f32(clusterLight_tileCount.y))), zTile);\n}\nstruct ClusterLight { position:vec3<f32>,radius:f32, color:vec3<f32>,intensity:f32, isSpotLight:f32,directionX:f32,directionY:f32,directionZ:f32, outerCutoff:f32,innerCutoff:f32,\n};\nstruct ClusterLightList { count:vec4<f32>, lights:array<ClusterLight>\n};\n@group(0) @binding(5) var<storage> clusterLightList:ClusterLightList;\n@group(0) @binding(6) var<storage,read_write> clusterLightGroup:ClusterLightsGroup;\n",...be,...W});Object.freeze(Ke);class ShaderVariantGenerator{#Ee=new Map;#De;#Ue;#Le=[];#Ae=[];#Ge=new Map;#ke=new Map;constructor(i,g){this.#De=i,this.#Ue=g}setBaseInfo(i,g){this.#Le=i,this.#Ae=g}addConditionalInfo(i,g,x){this.#Ge.set(i,g),this.#ke.set(i,x)}getVariantTextures(i){const g="none"===i?[]:i.split("+"),x=[...this.#Le];return g.forEach(i=>{const g=this.#Ge.get(i);g&&g.forEach(i=>{x.find(g=>g.name===i.name)||x.push(i)})}),x}getVariantSamplers(i){const g="none"===i?[]:i.split("+"),x=[...this.#Ae];return g.forEach(i=>{const g=this.#ke.get(i);g&&g.forEach(i=>{x.find(g=>g.name===i.name)||x.push(i)})}),x}getUnionTextures(){const i=[...this.#Le];return this.#Ge.forEach(g=>{g.forEach(g=>{i.find(i=>i.name===g.name)||i.push(g)})}),i}getUnionSamplers(){const i=[...this.#Ae];return this.#ke.forEach(g=>{g.forEach(g=>{i.find(i=>i.name===g.name)||i.push(g)})}),i}getVariant(i){if(this.#Ee.has(i))return this.#Ee.get(i);const g="none"===i?[]:i.split("+"),x=this.#Oe(g);return this.#Ee.set(i,x),x}getCachedVariants(){return Array.from(this.#Ee.keys())}#Oe(i){let g=this.#De;for(let x=this.#Ue.length-1;x>=0;x--){const _=this.#Ue[x];g=i.includes(_.uniformName)?g.replace(_.fullMatch,_.ifBlock):g.replace(_.fullMatch,_.elseBlock||"")}return g}}const Xe=Object.keys(Ke).join("|"),je=new RegExp(`#redgpu_include (${Xe})`,"g"),Ye=/REDGPU_DEFINE_(?:TILE_COUNT_[XYZ]|TOTAL_TILES|WORKGROUP_SIZE_[XYZ]|MAX_LIGHTS_PER_CLUSTER)/g,Ze={REDGPU_DEFINE_TILE_COUNT_X:q.TILE_COUNT_X.toString(),REDGPU_DEFINE_TILE_COUNT_Y:q.TILE_COUNT_Y.toString(),REDGPU_DEFINE_TILE_COUNT_Z:q.TILE_COUNT_Z.toString(),REDGPU_DEFINE_TOTAL_TILES:q.getTotalTileSize().toString(),REDGPU_DEFINE_WORKGROUP_SIZE_X:q.WORKGROUP_SIZE_X.toString(),REDGPU_DEFINE_WORKGROUP_SIZE_Y:q.WORKGROUP_SIZE_Y.toString(),REDGPU_DEFINE_WORKGROUP_SIZE_Z:q.WORKGROUP_SIZE_Z.toString(),REDGPU_DEFINE_MAX_LIGHTS_PER_CLUSTER:q.MAX_LIGHTS_PER_CLUSTER.toString()},Je=new Map,preprocessWGSL=i=>{const g=(i=>{let g=0;for(let x=0;x<i.length;x++)g=(g<<5)-g+i.charCodeAt(x),g&=g;return g.toString(36)})(i),x=Je.get(g);if(x)return x;const _=(i=>{let g=i,x=0;for(;x<10;){const i=g;if(g=g.replace(je,(i,g)=>Ke[g]||i),g===i)break;x++}return g})(i),v=(i=>i.replace(Ye,i=>Ze[i]||i))(_),b=(i=>{const g=[],x=/#redgpu_if\s+(\w+)\b|#redgpu_else|#redgpu_endIf/g,_=[];let v,b=0;for(;null!==(v=x.exec(i));){const x=v[0];if(x.startsWith("#redgpu_if"))_.push({uniformName:v[1],startIndex:v.index,headerLength:x.length});else if("#redgpu_else"===x){const i=_[_.length-1];if(!i)throw new Error(`[preprocessWGSL] Mismatched #redgpu_else at index ${v.index}`);void 0===i.elseIndex&&(i.elseIndex=v.index)}else if("#redgpu_endIf"===x){const y=_.pop();if(!y)throw new Error(`[preprocessWGSL] Mismatched #redgpu_endIf at index ${v.index}`);{const _=i.substring(y.startIndex,v.index+x.length);let S,w;void 0!==y.elseIndex?(S=i.substring(y.startIndex+y.headerLength,y.elseIndex),w=i.substring(y.elseIndex+12,v.index)):S=i.substring(y.startIndex+y.headerLength,v.index),g.push({uniformName:y.uniformName,ifBlock:S.trim(),elseBlock:w?.trim(),fullMatch:_,blockIndex:b++})}}}if(_.length>0)throw new Error(`[preprocessWGSL] Unclosed #redgpu_if for:${_.map(i=>i.uniformName).join(",")}`);return g})(v);(i=>{if(!i.length)return;const g=new Map;i.forEach(i=>{g.set(i.uniformName,(g.get(i.uniformName)||0)+1)}),Array.from(g.entries()).filter(([i,g])=>g>1).length})(b);const y=[...new Set(b.map(i=>i.uniformName))],S=new ShaderVariantGenerator(v,b),w={cacheKey:g,defaultSource:S.getVariant("none"),shaderSourceVariant:S,conditionalBlocks:y,conditionalBlockInfos:b};return Math.pow(2,y.length),Je.set(g,w),w};class ResourceStatusInfo{table=new Map;videoMemory=0;constructor(){}}var Qe;Object.freeze(ResourceStatusInfo),function(i){i.GPUShaderModule="GPUShaderModule",i.GPUBindGroupLayout="GPUBindGroupLayout",i.GPUPipelineLayout="GPUPipelineLayout",i.GPUBuffer="GPUBuffer"}(Qe||(Qe={}));class ResourceManager{static PRESET_GPUBindGroupLayout_System="PRESET_GPUBindGroupLayout_System";static PRESET_VERTEX_GPUBindGroupLayout_Instancing="PRESET_VERTEX_GPUBindGroupLayout_Instancing";static PRESET_VERTEX_GPUBindGroupLayout="PRESET_VERTEX_GPUBindGroupLayout";static PRESET_VERTEX_GPUBindGroupLayout_SKIN="PRESET_VERTEX_GPUBindGroupLayout_SKIN";#Ne=0;#Ve=new ImmutableKeyMap([[Qe.GPUShaderModule,new Map],[Qe.GPUBindGroupLayout,new Map],[Qe.GPUPipelineLayout,new Map],[Qe.GPUBuffer,new MemoryTrackingMap]]);#Fe=new ResourceStatusInfo;#ze=new ResourceStatusInfo;#He=new ResourceStatusInfo;#$e=new ResourceStatusInfo;#Ke=new ResourceStatusInfo;#Xe=new ResourceStatusInfo;#je=new ResourceStatusInfo;#Ye={};#qe;#We;#Ze;#Je;#Qe;#et;#tt;#nt;#rt;#it;#at=new WeakMap;#st=new WeakMap;#l;#c;constructor(i){this.#l=i,this.#c=i.gpuDevice,this.#Je=new MipmapGenerator(i),this.#Qe=new DownSampleCubeMapGenerator(i),this.#et=new BRDFGenerator(i),this.#tt=new IrradianceGenerator(i),this.#nt=new PrefilterGenerator(i),this.#rt=new EquirectangularToCubeGenerator(i),this.#ot()}get redGPUContext(){return this.#l}get gpuDevice(){return this.#c}get basicSampler(){return this.#it}get brdfGenerator(){return this.#et}get irradianceGenerator(){return this.#tt}get prefilterGenerator(){return this.#nt}get equirectangularToCubeGenerator(){return this.#rt}get mipmapGenerator(){return this.#Je}get downSampleCubeMapGenerator(){return this.#Qe}get cachedBufferState(){return this.#Ye}get emptyBitmapTextureView(){return this.#qe}get emptyCubeTextureView(){return this.#We}get emptyTexture3DView(){return this.#Ze}get managedBitmapTextureState(){return this.#Fe}get managedCubeTextureState(){return this.#ze}get managedHDRTextureState(){return this.#He}get managedUniformBufferState(){return this.#$e}get managedVertexBufferState(){return this.#Ke}get managedIndexBufferState(){return this.#Xe}get managedStorageBufferState(){return this.#je}get resources(){return this.#Ve}registerManagementResource(i,x){const{cacheKey:_,targetResourceManagedState:v}=i,{table:b}=v;b.get(_)?g(`Resource with cacheKey ${_} is already registered.`):(b.set(_,x),v.videoMemory+=i.videoMemorySize)}unregisterManagementResource(i){const{cacheKey:g,targetResourceManagedState:x}=i,{table:_}=x;_.get(g)&&(x.videoMemory-=i.videoMemorySize,_.delete(g))}createManagedTexture(i){const g=this.gpuDevice.createTexture(i),x=g.destroy.bind(g);return g.destroy=()=>{this.#ut(g,i),x()},g}getGPUResourceBitmapTextureView(i,g){const x=i instanceof GPUTexture?i:i?.gpuTexture;if(!x)return this.#qe;let _=this.#at.get(x);_||(_=new Map,this.#at.set(x,_));const v=this.#lt(g);let b=_.get(v);if(!b){const i=g?{...g,label:g.label||x.label}:{label:x.label};b=x.createView(i),_.set(v,b)}return b}getGPUResourceCubeTextureView(i,g){const x=i instanceof GPUTexture?i:i?.gpuTexture;if(!x)return this.#We;let _=this.#st.get(x);_||(_=new Map,this.#st.set(x,_)),i instanceof GPUTexture||g||(g=i.viewDescriptor);const v=g||CubeTexture.defaultViewDescriptor,b=this.#lt(v);let y=_.get(b);if(!y){const i={...v,label:x.label};y=x.createView(i),_.set(b,y)}return y}createGPUShaderModule(i,g){return this.#ct(i,g,g=>this.#ht(i,g),Qe.GPUShaderModule)}getGPUShaderModule(i){return this.#ft(i,Qe.GPUShaderModule)}deleteGPUShaderModule(i){this.#dt(i,Qe.GPUShaderModule)}createBindGroupLayout(i,g){return this.#ct(i,g,g=>(g.label||(g.label=i),this.redGPUContext.gpuDevice.createBindGroupLayout(g)),Qe.GPUBindGroupLayout)}getGPUBindGroupLayout(i){return this.#ft(i,Qe.GPUBindGroupLayout)}deleteGPUBindGroupLayout(i){this.#dt(i,Qe.GPUBindGroupLayout)}createGPUPipelineLayout(i,g){return this.#ct(i,g,g=>(g.label||(g.label=i),this.redGPUContext.gpuDevice.createPipelineLayout(g)),Qe.GPUPipelineLayout)}createGPUBuffer(i,g){return this.#ct(i,g,g=>(g.label||(g.label=i),this.gpuDevice.createBuffer(g)),Qe.GPUBuffer)}#ut(i,g){const x="3d"===g.dimension?this.#st:this.#at;x.get(i)?.clear(),x.delete(i)}#lt(i){return i?JSON.stringify(i):"default"}#ot(){const{gpuDevice:i}=this.redGPUContext;{const g=i.createTexture({size:{width:1,height:1,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING,label:"EMPTY_BITMAP_TEXTURE"});this.#qe=g.createView({label:g.label});const x=new Uint8Array([0,0,0,0]);i.queue.writeTexture({texture:g},x,{bytesPerRow:4,rowsPerImage:1},{width:1,height:1,depthOrArrayLayers:1});const _=i.createTexture({size:{width:1,height:1,depthOrArrayLayers:6},format:"rgba8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,label:"EMPTY_CUBE_TEXTURE"});this.#We=_.createView(CubeTexture.defaultViewDescriptor);const v=new Uint8Array([0,0,0,0]);for(let g=0;g<6;g++)i.queue.writeTexture({texture:_,origin:{x:0,y:0,z:g}},v,{bytesPerRow:4,rowsPerImage:1},{width:1,height:1,depthOrArrayLayers:1});const b=i.createTexture({size:{width:1,height:1,depthOrArrayLayers:1},dimension:"3d",format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,label:"EMPTY_TEXTURE_3D"});this.#Ze=b.createView({label:b.label,dimension:"3d"}),this.#it=new Sampler(this.redGPUContext)}this.createBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System,{entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{type:"comparison"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"depth"}},{binding:3,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:5,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:6,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:7,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:8,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:9,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:10,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube"}},{binding:11,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"cube"}},{binding:12,visibility:GPUShaderStage.FRAGMENT,texture:{}}]}),this.createBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout,{entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX,sampler:{type:"filtering"}},{binding:2,visibility:GPUShaderStage.VERTEX,texture:{}}]}),this.createBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_SKIN,{entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.VERTEX,sampler:{type:"filtering"}},{binding:2,visibility:GPUShaderStage.VERTEX,texture:{}},{binding:3,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}}]}),this.createBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_Instancing,{entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.VERTEX,sampler:{type:"filtering"}},{binding:2,visibility:GPUShaderStage.VERTEX,texture:{}},{binding:3,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}}]})}#mt(i){return this.#Ve.get(i)}#ht(i,g){const{code:x}=g,_=preprocessWGSL(x).defaultSource,v=this.redGPUContext.gpuDevice.createShaderModule({...g,code:_});return this.#mt(Qe.GPUShaderModule).set(i,v),v}#pt(i,g){if(!i)throw new Error("Name is required");return this.#mt(g)}#ct(i,g,x,_){const v=this.#pt(i,_);if(v.has(i))return v.get(i);g.label||(g.label=i);const b=x(g);return v.set(i,b),b}#ft(i,g){return this.#pt(i,g).get(i)}#dt(i,g){const x=this.#pt(i,g);if(!x.has(i))throw new Error(`${g} with name ${i} doesn't exist.`);x.delete(i)}}Object.freeze(BitmapTexture);class ImmutableKeyMap extends Map{constructor(i=[]){super(),i?.forEach(([i,g])=>super.set(i,g))}set(i,g){if(this.has(i))throw new Error("Cannot change the value of an existing key");return super.set(i,g)}}class MemoryTrackingMap extends Map{#gt=0;constructor(){super()}get videoMemory(){return this.#gt}set(i,g){const x=g&&"videoMemorySize"in g?"videoMemorySize":g&&"size"in g?"size":void 0;if(this.has(i)){const g=this.get(i);g&&g[x]&&(this.#gt-=g[x])}g&&g&&(this.#gt+=g[x]);return super.set(i,g)}delete(i){if(this.has(i)){const g=this.get(i),x=g&&"videoMemorySize"in g?"videoMemorySize":g&&"size"in g?"size":void 0;g&&g[x]&&(this.#gt-=g[x])}return super.delete(i)}clear(){this.#gt=0,super.clear()}}class AntialiasingManager{#l;#xt;#_t=!0;#vt=!1;#bt=!1;#yt=!0;constructor(i){this.#l=i,window.devicePixelRatio>1?this.useTAA=!0:this.useMSAA=!0}get useTAA(){return this.#bt}set useTAA(i){this.#bt!==i&&(this.#St(),this.#bt=i)}get useMSAA(){return this.#_t}set useMSAA(i){this.#_t!==i&&(this.#St(),this.#xt=createUUID(),this.#_t=i,this.#yt=!0)}get useFXAA(){return this.#vt}set useFXAA(i){this.#vt!==i&&(this.#St(),this.#vt=i)}get changedMSAA(){return this.#yt}set changedMSAA(i){this.#yt=i}get msaaID(){return this.#xt}#St(){this.#_t=!1,this.#vt=!1,this.#bt=!1}}Object.freeze(AntialiasingManager);class RedGPUContextDetector{#Tt;#Mt;#wt;#Ct;#Pt;constructor(i){this.#ne(i.gpuAdapter)}get adapterInfo(){return this.#Tt}get limits(){return this.#Mt}get isFallbackAdapter(){return this.#wt}get groupedLimits(){return this.#Ct}get userAgent(){return this.#Pt}get isMobile(){return/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Windows Phone|Kindle|Silk|PlayBook/i.test(navigator.userAgent)}#ne(i){this.#Pt=navigator.userAgent,this.#Rt(i),this.#Bt()}#Rt(i){if(i){const{limits:g,info:x}=i,{isFallbackAdapter:_}=x;this.#Tt=x,this.#wt=_,this.#Mt=g}}#Bt(){const i={TextureLimits:["maxTextureDimension1D","maxTextureDimension2D","maxTextureDimension3D","maxTextureArrayLayers","maxSampledTexturesPerShaderStage","maxSamplersPerShaderStage"],BufferLimits:["maxBindGroups","maxBindGroupsPlusVertexBuffers","maxBindingsPerBindGroup","maxDynamicUniformBuffersPerPipelineLayout","maxDynamicStorageBuffersPerPipelineLayout","maxStorageBuffersPerShaderStage","maxStorageTexturesPerShaderStage","maxUniformBuffersPerShaderStage","maxUniformBufferBindingSize","maxStorageBufferBindingSize","minUniformBufferOffsetAlignment","minStorageBufferOffsetAlignment","maxBufferSize"],PipelineAndShaderLimits:["maxVertexBuffers","maxVertexAttributes","maxVertexBufferArrayStride","maxInterStageShaderComponents","maxInterStageShaderVariables"],ComputeLimits:["maxComputeWorkgroupStorageSize","maxComputeInvocationsPerWorkgroup","maxComputeWorkgroupSizeX","maxComputeWorkgroupSizeY","maxComputeWorkgroupSizeZ","maxComputeWorkgroupsPerDimension"],ColorLimits:["maxColorAttachments","maxColorAttachmentBytesPerSample"]},g={TextureLimits:{},BufferLimits:{},PipelineAndShaderLimits:{},ComputeLimits:{},ColorLimits:{},EtcLimit:{}};for(const x in this.#Mt){let _=!1;for(const v in i)if(i[v].includes(x)){g[v][x]=this.#Mt[x],_=!0;break}_||(g.EtcLimit[x]=this.#Mt[x])}this.#Ct=g}}const validateNumber=i=>"number"==typeof i||(consoleAndThrowError("Only numbers allowed."),!1);class RedGPUContextSizeManager{#It;#Et;#l;#Dt=[0,0,0,0];#Ut;#Lt=1;constructor(i,g="100%",x="100%"){this.#l=i,this.#Ut=i.htmlCanvas,this.#Ut.style.boxSizing="border-box",this.#It=g,this.#Et=x}get renderScale(){return this.#Lt}set renderScale(i){validateNumber(i),i<=0&&(i=.01),this.#Lt=i,this.setSize()}get width(){return this.#It}set width(i){this.setSize(i,this.#Et)}get height(){return this.#Et}set height(i){this.setSize(this.#It,i)}get pixelRectArray(){return this.#Dt}get pixelRectObject(){return{x:this.#Dt[0],y:this.#Dt[1],width:this.#Dt[2],height:this.#Dt[3]}}get parentDomRect(){return(this.#Ut.parentNode||document.body).getBoundingClientRect()}get screenRectObject(){return{x:this.#Dt[0]/devicePixelRatio,y:this.#Dt[1]/devicePixelRatio,width:this.#Dt[2]/devicePixelRatio,height:this.#Dt[3]/devicePixelRatio}}static validateSizeValue=i=>{switch(typeof i){case"number":validatePositiveNumberRange(i);break;case"string":new RegExp(/^[+]?^[.]?(\d+)(\.\d+)?(?:px|%|$)/gm).test(i)||consoleAndThrowError(`allow positive number,%,px model/input:${i}`);break;default:consoleAndThrowError(`positive number,%,px model/input:${i}`)}};static validatePositionValue=i=>{switch(typeof i){case"number":validateNumber(i);break;case"string":new RegExp(/^-?\d+(\.\d+)?(px|%)?$/).test(i)||consoleAndThrowError(`allow number,%,px model /input:${i}`);break;default:consoleAndThrowError(`number,%,px model/input:${i}`)}};static getPixelDimension(i,g,x){return"number"==typeof x?x:RedGPUContextSizeManager.calculateSizeFromString(i,g,x)}static calculateSizeFromString(i,g,x){return x.includes("%")?Math.floor(i[g]*+x.replace("%","")/100):+x.replace("px","")}setSize(i=this.#It,g=this.#Et){RedGPUContextSizeManager.validateSizeValue(i),RedGPUContextSizeManager.validateSizeValue(g),this.#It=i,this.#Et=g;const x=RedGPUContextSizeManager.getPixelDimension(this.parentDomRect,"width",i),_=RedGPUContextSizeManager.getPixelDimension(this.parentDomRect,"height",g);this.#At(x,_),this.#Gt(x,_),this.#kt()}#Gt(i,g){this.#Dt[2]=Math.max(1,Math.floor(i*this.#Lt*window.devicePixelRatio)),this.#Dt[3]=Math.max(1,Math.floor(g*this.#Lt*window.devicePixelRatio))}#kt(){this.#l.onResize&&this.#l.onResize({target:this.#l,screenRectObject:this.screenRectObject,pixelRectObject:this.pixelRectObject}),this.#l.viewList.forEach(i=>{i.setSize(),i.setPosition()})}#At(i,g){const x=this.#Ut,{style:_}=x;x.width=Math.max(1,i*this.#Lt*window.devicePixelRatio),x.height=Math.max(1,g*this.#Lt*window.devicePixelRatio),_.width=`${i}px`,_.height=`${g}px`}}var et=1e-6,tt="undefined"!=typeof Float32Array?Float32Array:Array,it=Math.random;function round$3(i){return i>=0?Math.round(i):i%.5==0?Math.floor(i):Math.round(i)}function create$5(){var i=new tt(9);return tt!=Float32Array&&(i[1]=0,i[2]=0,i[3]=0,i[5]=0,i[6]=0,i[7]=0),i[0]=1,i[4]=1,i[8]=1,i}function multiply$5(i,g,x){var _=g[0],v=g[1],b=g[2],y=g[3],S=g[4],w=g[5],L=g[6],k=g[7],z=g[8],H=x[0],q=x[1],W=x[2],be=x[3],Ke=x[4],Xe=x[5],je=x[6],Ye=x[7],Ze=x[8];return i[0]=H*_+q*y+W*L,i[1]=H*v+q*S+W*k,i[2]=H*b+q*w+W*z,i[3]=be*_+Ke*y+Xe*L,i[4]=be*v+Ke*S+Xe*k,i[5]=be*b+Ke*w+Xe*z,i[6]=je*_+Ye*y+Ze*L,i[7]=je*v+Ye*S+Ze*k,i[8]=je*b+Ye*w+Ze*z,i}function subtract$4(i,g,x){return i[0]=g[0]-x[0],i[1]=g[1]-x[1],i[2]=g[2]-x[2],i[3]=g[3]-x[3],i[4]=g[4]-x[4],i[5]=g[5]-x[5],i[6]=g[6]-x[6],i[7]=g[7]-x[7],i[8]=g[8]-x[8],i}var ft=multiply$5,pt=subtract$4,xt=Object.freeze({__proto__:null,add:function(i,g,x){return i[0]=g[0]+x[0],i[1]=g[1]+x[1],i[2]=g[2]+x[2],i[3]=g[3]+x[3],i[4]=g[4]+x[4],i[5]=g[5]+x[5],i[6]=g[6]+x[6],i[7]=g[7]+x[7],i[8]=g[8]+x[8],i},adjoint:function(i,g){var x=g[0],_=g[1],v=g[2],b=g[3],y=g[4],S=g[5],w=g[6],L=g[7],k=g[8];return i[0]=y*k-S*L,i[1]=v*L-_*k,i[2]=_*S-v*y,i[3]=S*w-b*k,i[4]=x*k-v*w,i[5]=v*b-x*S,i[6]=b*L-y*w,i[7]=_*w-x*L,i[8]=x*y-_*b,i},clone:function(i){var g=new tt(9);return g[0]=i[0],g[1]=i[1],g[2]=i[2],g[3]=i[3],g[4]=i[4],g[5]=i[5],g[6]=i[6],g[7]=i[7],g[8]=i[8],g},copy:function(i,g){return i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7],i[8]=g[8],i},create:create$5,determinant:function(i){var g=i[0],x=i[1],_=i[2],v=i[3],b=i[4],y=i[5],S=i[6],w=i[7],L=i[8];return g*(L*b-y*w)+x*(-L*v+y*S)+_*(w*v-b*S)},equals:function(i,g){var x=i[0],_=i[1],v=i[2],b=i[3],y=i[4],S=i[5],w=i[6],L=i[7],k=i[8],z=g[0],H=g[1],q=g[2],W=g[3],be=g[4],Ke=g[5],Xe=g[6],je=g[7],Ye=g[8];return Math.abs(x-z)<=et*Math.max(1,Math.abs(x),Math.abs(z))&&Math.abs(_-H)<=et*Math.max(1,Math.abs(_),Math.abs(H))&&Math.abs(v-q)<=et*Math.max(1,Math.abs(v),Math.abs(q))&&Math.abs(b-W)<=et*Math.max(1,Math.abs(b),Math.abs(W))&&Math.abs(y-be)<=et*Math.max(1,Math.abs(y),Math.abs(be))&&Math.abs(S-Ke)<=et*Math.max(1,Math.abs(S),Math.abs(Ke))&&Math.abs(w-Xe)<=et*Math.max(1,Math.abs(w),Math.abs(Xe))&&Math.abs(L-je)<=et*Math.max(1,Math.abs(L),Math.abs(je))&&Math.abs(k-Ye)<=et*Math.max(1,Math.abs(k),Math.abs(Ye))},exactEquals:function(i,g){return i[0]===g[0]&&i[1]===g[1]&&i[2]===g[2]&&i[3]===g[3]&&i[4]===g[4]&&i[5]===g[5]&&i[6]===g[6]&&i[7]===g[7]&&i[8]===g[8]},frob:function(i){return Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]+i[3]*i[3]+i[4]*i[4]+i[5]*i[5]+i[6]*i[6]+i[7]*i[7]+i[8]*i[8])},fromMat2d:function(i,g){return i[0]=g[0],i[1]=g[1],i[2]=0,i[3]=g[2],i[4]=g[3],i[5]=0,i[6]=g[4],i[7]=g[5],i[8]=1,i},fromMat4:function(i,g){return i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[4],i[4]=g[5],i[5]=g[6],i[6]=g[8],i[7]=g[9],i[8]=g[10],i},fromQuat:function(i,g){var x=g[0],_=g[1],v=g[2],b=g[3],y=x+x,S=_+_,w=v+v,L=x*y,k=_*y,z=_*S,H=v*y,q=v*S,W=v*w,be=b*y,Ke=b*S,Xe=b*w;return i[0]=1-z-W,i[3]=k-Xe,i[6]=H+Ke,i[1]=k+Xe,i[4]=1-L-W,i[7]=q-be,i[2]=H-Ke,i[5]=q+be,i[8]=1-L-z,i},fromRotation:function(i,g){var x=Math.sin(g),_=Math.cos(g);return i[0]=_,i[1]=x,i[2]=0,i[3]=-x,i[4]=_,i[5]=0,i[6]=0,i[7]=0,i[8]=1,i},fromScaling:function(i,g){return i[0]=g[0],i[1]=0,i[2]=0,i[3]=0,i[4]=g[1],i[5]=0,i[6]=0,i[7]=0,i[8]=1,i},fromTranslation:function(i,g){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=1,i[5]=0,i[6]=g[0],i[7]=g[1],i[8]=1,i},fromValues:function(i,g,x,_,v,b,y,S,w){var L=new tt(9);return L[0]=i,L[1]=g,L[2]=x,L[3]=_,L[4]=v,L[5]=b,L[6]=y,L[7]=S,L[8]=w,L},identity:function(i){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=1,i[5]=0,i[6]=0,i[7]=0,i[8]=1,i},invert:function(i,g){var x=g[0],_=g[1],v=g[2],b=g[3],y=g[4],S=g[5],w=g[6],L=g[7],k=g[8],z=k*y-S*L,H=-k*b+S*w,q=L*b-y*w,W=x*z+_*H+v*q;return W?(W=1/W,i[0]=z*W,i[1]=(-k*_+v*L)*W,i[2]=(S*_-v*y)*W,i[3]=H*W,i[4]=(k*x-v*w)*W,i[5]=(-S*x+v*b)*W,i[6]=q*W,i[7]=(-L*x+_*w)*W,i[8]=(y*x-_*b)*W,i):null},mul:ft,multiply:multiply$5,multiplyScalar:function(i,g,x){return i[0]=g[0]*x,i[1]=g[1]*x,i[2]=g[2]*x,i[3]=g[3]*x,i[4]=g[4]*x,i[5]=g[5]*x,i[6]=g[6]*x,i[7]=g[7]*x,i[8]=g[8]*x,i},multiplyScalarAndAdd:function(i,g,x,_){return i[0]=g[0]+x[0]*_,i[1]=g[1]+x[1]*_,i[2]=g[2]+x[2]*_,i[3]=g[3]+x[3]*_,i[4]=g[4]+x[4]*_,i[5]=g[5]+x[5]*_,i[6]=g[6]+x[6]*_,i[7]=g[7]+x[7]*_,i[8]=g[8]+x[8]*_,i},normalFromMat4:function(i,g){var x=g[0],_=g[1],v=g[2],b=g[3],y=g[4],S=g[5],w=g[6],L=g[7],k=g[8],z=g[9],H=g[10],q=g[11],W=g[12],be=g[13],Ke=g[14],Xe=g[15],je=x*S-_*y,Ye=x*w-v*y,Ze=x*L-b*y,Je=_*w-v*S,Qe=_*L-b*S,et=v*L-b*w,tt=k*be-z*W,it=k*Ke-H*W,ft=k*Xe-q*W,pt=z*Ke-H*be,xt=z*Xe-q*be,vt=H*Xe-q*Ke,bt=je*vt-Ye*xt+Ze*pt+Je*ft-Qe*it+et*tt;return bt?(bt=1/bt,i[0]=(S*vt-w*xt+L*pt)*bt,i[1]=(w*ft-y*vt-L*it)*bt,i[2]=(y*xt-S*ft+L*tt)*bt,i[3]=(v*xt-_*vt-b*pt)*bt,i[4]=(x*vt-v*ft+b*it)*bt,i[5]=(_*ft-x*xt-b*tt)*bt,i[6]=(be*et-Ke*Qe+Xe*Je)*bt,i[7]=(Ke*Ze-W*et-Xe*Ye)*bt,i[8]=(W*Qe-be*Ze+Xe*je)*bt,i):null},projection:function(i,g,x){return i[0]=2/g,i[1]=0,i[2]=0,i[3]=0,i[4]=-2/x,i[5]=0,i[6]=-1,i[7]=1,i[8]=1,i},rotate:function(i,g,x){var _=g[0],v=g[1],b=g[2],y=g[3],S=g[4],w=g[5],L=g[6],k=g[7],z=g[8],H=Math.sin(x),q=Math.cos(x);return i[0]=q*_+H*y,i[1]=q*v+H*S,i[2]=q*b+H*w,i[3]=q*y-H*_,i[4]=q*S-H*v,i[5]=q*w-H*b,i[6]=L,i[7]=k,i[8]=z,i},scale:function(i,g,x){var _=x[0],v=x[1];return i[0]=_*g[0],i[1]=_*g[1],i[2]=_*g[2],i[3]=v*g[3],i[4]=v*g[4],i[5]=v*g[5],i[6]=g[6],i[7]=g[7],i[8]=g[8],i},set:function(i,g,x,_,v,b,y,S,w,L){return i[0]=g,i[1]=x,i[2]=_,i[3]=v,i[4]=b,i[5]=y,i[6]=S,i[7]=w,i[8]=L,i},str:function(i){return"mat3("+i[0]+","+i[1]+","+i[2]+","+i[3]+","+i[4]+","+i[5]+","+i[6]+","+i[7]+","+i[8]+")"},sub:pt,subtract:subtract$4,translate:function(i,g,x){var _=g[0],v=g[1],b=g[2],y=g[3],S=g[4],w=g[5],L=g[6],k=g[7],z=g[8],H=x[0],q=x[1];return i[0]=_,i[1]=v,i[2]=b,i[3]=y,i[4]=S,i[5]=w,i[6]=H*_+q*y+L,i[7]=H*v+q*S+k,i[8]=H*b+q*w+z,i},transpose:function(i,g){if(i===g){var x=g[1],_=g[2],v=g[5];i[1]=g[3],i[2]=g[6],i[3]=x,i[5]=g[7],i[6]=_,i[7]=v}else i[0]=g[0],i[1]=g[3],i[2]=g[6],i[3]=g[1],i[4]=g[4],i[5]=g[7],i[6]=g[2],i[7]=g[5],i[8]=g[8];return i}});function create$4(){var i=new tt(16);return tt!=Float32Array&&(i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[11]=0,i[12]=0,i[13]=0,i[14]=0),i[0]=1,i[5]=1,i[10]=1,i[15]=1,i}function clone$4(i){var g=new tt(16);return g[0]=i[0],g[1]=i[1],g[2]=i[2],g[3]=i[3],g[4]=i[4],g[5]=i[5],g[6]=i[6],g[7]=i[7],g[8]=i[8],g[9]=i[9],g[10]=i[10],g[11]=i[11],g[12]=i[12],g[13]=i[13],g[14]=i[14],g[15]=i[15],g}function copy$4(i,g){return i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7],i[8]=g[8],i[9]=g[9],i[10]=g[10],i[11]=g[11],i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15],i}function fromValues$4(i,g,x,_,v,b,y,S,w,L,k,z,H,q,W,be){var Ke=new tt(16);return Ke[0]=i,Ke[1]=g,Ke[2]=x,Ke[3]=_,Ke[4]=v,Ke[5]=b,Ke[6]=y,Ke[7]=S,Ke[8]=w,Ke[9]=L,Ke[10]=k,Ke[11]=z,Ke[12]=H,Ke[13]=q,Ke[14]=W,Ke[15]=be,Ke}function identity$1(i){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i}function invert$1(i,g){var x=g[0],_=g[1],v=g[2],b=g[3],y=g[4],S=g[5],w=g[6],L=g[7],k=g[8],z=g[9],H=g[10],q=g[11],W=g[12],be=g[13],Ke=g[14],Xe=g[15],je=x*S-_*y,Ye=x*w-v*y,Ze=x*L-b*y,Je=_*w-v*S,Qe=_*L-b*S,et=v*L-b*w,tt=k*be-z*W,it=k*Ke-H*W,ft=k*Xe-q*W,pt=z*Ke-H*be,xt=z*Xe-q*be,vt=H*Xe-q*Ke,bt=je*vt-Ye*xt+Ze*pt+Je*ft-Qe*it+et*tt;return bt?(bt=1/bt,i[0]=(S*vt-w*xt+L*pt)*bt,i[1]=(v*xt-_*vt-b*pt)*bt,i[2]=(be*et-Ke*Qe+Xe*Je)*bt,i[3]=(H*Qe-z*et-q*Je)*bt,i[4]=(w*ft-y*vt-L*it)*bt,i[5]=(x*vt-v*ft+b*it)*bt,i[6]=(Ke*Ze-W*et-Xe*Ye)*bt,i[7]=(k*et-H*Ze+q*Ye)*bt,i[8]=(y*xt-S*ft+L*tt)*bt,i[9]=(_*ft-x*xt-b*tt)*bt,i[10]=(W*Qe-be*Ze+Xe*je)*bt,i[11]=(z*Ze-k*Qe-q*je)*bt,i[12]=(S*it-y*pt-w*tt)*bt,i[13]=(x*pt-_*it+v*tt)*bt,i[14]=(be*Ye-W*Je-Ke*je)*bt,i[15]=(k*Je-z*Ye+H*je)*bt,i):null}function multiply$4(i,g,x){var _=g[0],v=g[1],b=g[2],y=g[3],S=g[4],w=g[5],L=g[6],k=g[7],z=g[8],H=g[9],q=g[10],W=g[11],be=g[12],Ke=g[13],Xe=g[14],je=g[15],Ye=x[0],Ze=x[1],Je=x[2],Qe=x[3];return i[0]=Ye*_+Ze*S+Je*z+Qe*be,i[1]=Ye*v+Ze*w+Je*H+Qe*Ke,i[2]=Ye*b+Ze*L+Je*q+Qe*Xe,i[3]=Ye*y+Ze*k+Je*W+Qe*je,Ye=x[4],Ze=x[5],Je=x[6],Qe=x[7],i[4]=Ye*_+Ze*S+Je*z+Qe*be,i[5]=Ye*v+Ze*w+Je*H+Qe*Ke,i[6]=Ye*b+Ze*L+Je*q+Qe*Xe,i[7]=Ye*y+Ze*k+Je*W+Qe*je,Ye=x[8],Ze=x[9],Je=x[10],Qe=x[11],i[8]=Ye*_+Ze*S+Je*z+Qe*be,i[9]=Ye*v+Ze*w+Je*H+Qe*Ke,i[10]=Ye*b+Ze*L+Je*q+Qe*Xe,i[11]=Ye*y+Ze*k+Je*W+Qe*je,Ye=x[12],Ze=x[13],Je=x[14],Qe=x[15],i[12]=Ye*_+Ze*S+Je*z+Qe*be,i[13]=Ye*v+Ze*w+Je*H+Qe*Ke,i[14]=Ye*b+Ze*L+Je*q+Qe*Xe,i[15]=Ye*y+Ze*k+Je*W+Qe*je,i}function translate(i,g,x){var _,v,b,y,S,w,L,k,z,H,q,W,be=x[0],Ke=x[1],Xe=x[2];return g===i?(i[12]=g[0]*be+g[4]*Ke+g[8]*Xe+g[12],i[13]=g[1]*be+g[5]*Ke+g[9]*Xe+g[13],i[14]=g[2]*be+g[6]*Ke+g[10]*Xe+g[14],i[15]=g[3]*be+g[7]*Ke+g[11]*Xe+g[15]):(_=g[0],v=g[1],b=g[2],y=g[3],S=g[4],w=g[5],L=g[6],k=g[7],z=g[8],H=g[9],q=g[10],W=g[11],i[0]=_,i[1]=v,i[2]=b,i[3]=y,i[4]=S,i[5]=w,i[6]=L,i[7]=k,i[8]=z,i[9]=H,i[10]=q,i[11]=W,i[12]=_*be+S*Ke+z*Xe+g[12],i[13]=v*be+w*Ke+H*Xe+g[13],i[14]=b*be+L*Ke+q*Xe+g[14],i[15]=y*be+k*Ke+W*Xe+g[15]),i}function scale$4(i,g,x){var _=x[0],v=x[1],b=x[2];return i[0]=g[0]*_,i[1]=g[1]*_,i[2]=g[2]*_,i[3]=g[3]*_,i[4]=g[4]*v,i[5]=g[5]*v,i[6]=g[6]*v,i[7]=g[7]*v,i[8]=g[8]*b,i[9]=g[9]*b,i[10]=g[10]*b,i[11]=g[11]*b,i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15],i}function rotateX$2(i,g,x){var _=Math.sin(x),v=Math.cos(x),b=g[4],y=g[5],S=g[6],w=g[7],L=g[8],k=g[9],z=g[10],H=g[11];return g!==i&&(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15]),i[4]=b*v+L*_,i[5]=y*v+k*_,i[6]=S*v+z*_,i[7]=w*v+H*_,i[8]=L*v-b*_,i[9]=k*v-y*_,i[10]=z*v-S*_,i[11]=H*v-w*_,i}function rotateY$2(i,g,x){var _=Math.sin(x),v=Math.cos(x),b=g[0],y=g[1],S=g[2],w=g[3],L=g[8],k=g[9],z=g[10],H=g[11];return g!==i&&(i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7],i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15]),i[0]=b*v-L*_,i[1]=y*v-k*_,i[2]=S*v-z*_,i[3]=w*v-H*_,i[8]=b*_+L*v,i[9]=y*_+k*v,i[10]=S*_+z*v,i[11]=w*_+H*v,i}function rotateZ$2(i,g,x){var _=Math.sin(x),v=Math.cos(x),b=g[0],y=g[1],S=g[2],w=g[3],L=g[4],k=g[5],z=g[6],H=g[7];return g!==i&&(i[8]=g[8],i[9]=g[9],i[10]=g[10],i[11]=g[11],i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15]),i[0]=b*v+L*_,i[1]=y*v+k*_,i[2]=S*v+z*_,i[3]=w*v+H*_,i[4]=L*v-b*_,i[5]=k*v-y*_,i[6]=z*v-S*_,i[7]=H*v-w*_,i}function fromRotationTranslation(i,g,x){var _=g[0],v=g[1],b=g[2],y=g[3],S=_+_,w=v+v,L=b+b,k=_*S,z=_*w,H=_*L,q=v*w,W=v*L,be=b*L,Ke=y*S,Xe=y*w,je=y*L;return i[0]=1-(q+be),i[1]=z+je,i[2]=H-Xe,i[3]=0,i[4]=z-je,i[5]=1-(k+be),i[6]=W+Ke,i[7]=0,i[8]=H+Xe,i[9]=W-Ke,i[10]=1-(k+q),i[11]=0,i[12]=x[0],i[13]=x[1],i[14]=x[2],i[15]=1,i}function getScaling(i,g){var x=g[0],_=g[1],v=g[2],b=g[4],y=g[5],S=g[6],w=g[8],L=g[9],k=g[10];return i[0]=Math.sqrt(x*x+_*_+v*v),i[1]=Math.sqrt(b*b+y*y+S*S),i[2]=Math.sqrt(w*w+L*L+k*k),i}function perspectiveNO(i,g,x,_,v){var b=1/Math.tan(g/2);if(i[0]=b/x,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=b,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[11]=-1,i[12]=0,i[13]=0,i[15]=0,null!=v&&v!==1/0){var y=1/(_-v);i[10]=(v+_)*y,i[14]=2*v*_*y}else i[10]=-1,i[14]=-2*_;return i}var vt=perspectiveNO;function orthoNO(i,g,x,_,v,b,y){var S=1/(g-x),w=1/(_-v),L=1/(b-y);return i[0]=-2*S,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=-2*w,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=2*L,i[11]=0,i[12]=(g+x)*S,i[13]=(v+_)*w,i[14]=(y+b)*L,i[15]=1,i}var bt=orthoNO;function orthoZO(i,g,x,_,v,b,y){var S=1/(g-x),w=1/(_-v),L=1/(b-y);return i[0]=-2*S,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=-2*w,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=L,i[11]=0,i[12]=(g+x)*S,i[13]=(v+_)*w,i[14]=b*L,i[15]=1,i}function lookAt(i,g,x,_){var v,b,y,S,w,L,k,z,H,q,W=g[0],be=g[1],Ke=g[2],Xe=_[0],je=_[1],Ye=_[2],Ze=x[0],Je=x[1],Qe=x[2];return Math.abs(W-Ze)<et&&Math.abs(be-Je)<et&&Math.abs(Ke-Qe)<et?identity$1(i):(k=W-Ze,z=be-Je,H=Ke-Qe,v=je*(H*=q=1/Math.sqrt(k*k+z*z+H*H))-Ye*(z*=q),b=Ye*(k*=q)-Xe*H,y=Xe*z-je*k,(q=Math.sqrt(v*v+b*b+y*y))?(v*=q=1/q,b*=q,y*=q):(v=0,b=0,y=0),S=z*y-H*b,w=H*v-k*y,L=k*b-z*v,(q=Math.sqrt(S*S+w*w+L*L))?(S*=q=1/q,w*=q,L*=q):(S=0,w=0,L=0),i[0]=v,i[1]=S,i[2]=k,i[3]=0,i[4]=b,i[5]=w,i[6]=z,i[7]=0,i[8]=y,i[9]=L,i[10]=H,i[11]=0,i[12]=-(v*W+b*be+y*Ke),i[13]=-(S*W+w*be+L*Ke),i[14]=-(k*W+z*be+H*Ke),i[15]=1,i)}function targetTo(i,g,x,_){var v=g[0],b=g[1],y=g[2],S=_[0],w=_[1],L=_[2],k=v-x[0],z=b-x[1],H=y-x[2],q=k*k+z*z+H*H;q>0&&(k*=q=1/Math.sqrt(q),z*=q,H*=q);var W=w*H-L*z,be=L*k-S*H,Ke=S*z-w*k;return(q=W*W+be*be+Ke*Ke)>0&&(W*=q=1/Math.sqrt(q),be*=q,Ke*=q),i[0]=W,i[1]=be,i[2]=Ke,i[3]=0,i[4]=z*Ke-H*be,i[5]=H*W-k*Ke,i[6]=k*be-z*W,i[7]=0,i[8]=k,i[9]=z,i[10]=H,i[11]=0,i[12]=v,i[13]=b,i[14]=y,i[15]=1,i}function subtract$3(i,g,x){return i[0]=g[0]-x[0],i[1]=g[1]-x[1],i[2]=g[2]-x[2],i[3]=g[3]-x[3],i[4]=g[4]-x[4],i[5]=g[5]-x[5],i[6]=g[6]-x[6],i[7]=g[7]-x[7],i[8]=g[8]-x[8],i[9]=g[9]-x[9],i[10]=g[10]-x[10],i[11]=g[11]-x[11],i[12]=g[12]-x[12],i[13]=g[13]-x[13],i[14]=g[14]-x[14],i[15]=g[15]-x[15],i}var yt=multiply$4,St=subtract$3,Tt=Object.freeze({__proto__:null,add:function(i,g,x){return i[0]=g[0]+x[0],i[1]=g[1]+x[1],i[2]=g[2]+x[2],i[3]=g[3]+x[3],i[4]=g[4]+x[4],i[5]=g[5]+x[5],i[6]=g[6]+x[6],i[7]=g[7]+x[7],i[8]=g[8]+x[8],i[9]=g[9]+x[9],i[10]=g[10]+x[10],i[11]=g[11]+x[11],i[12]=g[12]+x[12],i[13]=g[13]+x[13],i[14]=g[14]+x[14],i[15]=g[15]+x[15],i},adjoint:function(i,g){var x=g[0],_=g[1],v=g[2],b=g[3],y=g[4],S=g[5],w=g[6],L=g[7],k=g[8],z=g[9],H=g[10],q=g[11],W=g[12],be=g[13],Ke=g[14],Xe=g[15],je=x*S-_*y,Ye=x*w-v*y,Ze=x*L-b*y,Je=_*w-v*S,Qe=_*L-b*S,et=v*L-b*w,tt=k*be-z*W,it=k*Ke-H*W,ft=k*Xe-q*W,pt=z*Ke-H*be,xt=z*Xe-q*be,vt=H*Xe-q*Ke;return i[0]=S*vt-w*xt+L*pt,i[1]=v*xt-_*vt-b*pt,i[2]=be*et-Ke*Qe+Xe*Je,i[3]=H*Qe-z*et-q*Je,i[4]=w*ft-y*vt-L*it,i[5]=x*vt-v*ft+b*it,i[6]=Ke*Ze-W*et-Xe*Ye,i[7]=k*et-H*Ze+q*Ye,i[8]=y*xt-S*ft+L*tt,i[9]=_*ft-x*xt-b*tt,i[10]=W*Qe-be*Ze+Xe*je,i[11]=z*Ze-k*Qe-q*je,i[12]=S*it-y*pt-w*tt,i[13]=x*pt-_*it+v*tt,i[14]=be*Ye-W*Je-Ke*je,i[15]=k*Je-z*Ye+H*je,i},clone:clone$4,copy:copy$4,create:create$4,decompose:function(i,g,x,_){g[0]=_[12],g[1]=_[13],g[2]=_[14];var v=_[0],b=_[1],y=_[2],S=_[4],w=_[5],L=_[6],k=_[8],z=_[9],H=_[10];x[0]=Math.sqrt(v*v+b*b+y*y),x[1]=Math.sqrt(S*S+w*w+L*L),x[2]=Math.sqrt(k*k+z*z+H*H);var q=1/x[0],W=1/x[1],be=1/x[2],Ke=v*q,Xe=b*W,je=y*be,Ye=S*q,Ze=w*W,Je=L*be,Qe=k*q,et=z*W,tt=H*be,it=Ke+Ze+tt,ft=0;return it>0?(ft=2*Math.sqrt(it+1),i[3]=.25*ft,i[0]=(Je-et)/ft,i[1]=(Qe-je)/ft,i[2]=(Xe-Ye)/ft):Ke>Ze&&Ke>tt?(ft=2*Math.sqrt(1+Ke-Ze-tt),i[3]=(Je-et)/ft,i[0]=.25*ft,i[1]=(Xe+Ye)/ft,i[2]=(Qe+je)/ft):Ze>tt?(ft=2*Math.sqrt(1+Ze-Ke-tt),i[3]=(Qe-je)/ft,i[0]=(Xe+Ye)/ft,i[1]=.25*ft,i[2]=(Je+et)/ft):(ft=2*Math.sqrt(1+tt-Ke-Ze),i[3]=(Xe-Ye)/ft,i[0]=(Qe+je)/ft,i[1]=(Je+et)/ft,i[2]=.25*ft),i},determinant:function(i){var g=i[0],x=i[1],_=i[2],v=i[3],b=i[4],y=i[5],S=i[6],w=i[7],L=i[8],k=i[9],z=i[10],H=i[11],q=i[12],W=i[13],be=i[14],Ke=g*y-x*b,Xe=g*S-_*b,je=x*S-_*y,Ye=L*W-k*q,Ze=L*be-z*q,Je=k*be-z*W;return w*(g*Je-x*Ze+_*Ye)-v*(b*Je-y*Ze+S*Ye)+i[15]*(L*je-k*Xe+z*Ke)-H*(q*je-W*Xe+be*Ke)},equals:function(i,g){var x=i[0],_=i[1],v=i[2],b=i[3],y=i[4],S=i[5],w=i[6],L=i[7],k=i[8],z=i[9],H=i[10],q=i[11],W=i[12],be=i[13],Ke=i[14],Xe=i[15],je=g[0],Ye=g[1],Ze=g[2],Je=g[3],Qe=g[4],tt=g[5],it=g[6],ft=g[7],pt=g[8],xt=g[9],vt=g[10],bt=g[11],yt=g[12],St=g[13],Tt=g[14],Mt=g[15];return Math.abs(x-je)<=et*Math.max(1,Math.abs(x),Math.abs(je))&&Math.abs(_-Ye)<=et*Math.max(1,Math.abs(_),Math.abs(Ye))&&Math.abs(v-Ze)<=et*Math.max(1,Math.abs(v),Math.abs(Ze))&&Math.abs(b-Je)<=et*Math.max(1,Math.abs(b),Math.abs(Je))&&Math.abs(y-Qe)<=et*Math.max(1,Math.abs(y),Math.abs(Qe))&&Math.abs(S-tt)<=et*Math.max(1,Math.abs(S),Math.abs(tt))&&Math.abs(w-it)<=et*Math.max(1,Math.abs(w),Math.abs(it))&&Math.abs(L-ft)<=et*Math.max(1,Math.abs(L),Math.abs(ft))&&Math.abs(k-pt)<=et*Math.max(1,Math.abs(k),Math.abs(pt))&&Math.abs(z-xt)<=et*Math.max(1,Math.abs(z),Math.abs(xt))&&Math.abs(H-vt)<=et*Math.max(1,Math.abs(H),Math.abs(vt))&&Math.abs(q-bt)<=et*Math.max(1,Math.abs(q),Math.abs(bt))&&Math.abs(W-yt)<=et*Math.max(1,Math.abs(W),Math.abs(yt))&&Math.abs(be-St)<=et*Math.max(1,Math.abs(be),Math.abs(St))&&Math.abs(Ke-Tt)<=et*Math.max(1,Math.abs(Ke),Math.abs(Tt))&&Math.abs(Xe-Mt)<=et*Math.max(1,Math.abs(Xe),Math.abs(Mt))},exactEquals:function(i,g){return i[0]===g[0]&&i[1]===g[1]&&i[2]===g[2]&&i[3]===g[3]&&i[4]===g[4]&&i[5]===g[5]&&i[6]===g[6]&&i[7]===g[7]&&i[8]===g[8]&&i[9]===g[9]&&i[10]===g[10]&&i[11]===g[11]&&i[12]===g[12]&&i[13]===g[13]&&i[14]===g[14]&&i[15]===g[15]},frob:function(i){return Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]+i[3]*i[3]+i[4]*i[4]+i[5]*i[5]+i[6]*i[6]+i[7]*i[7]+i[8]*i[8]+i[9]*i[9]+i[10]*i[10]+i[11]*i[11]+i[12]*i[12]+i[13]*i[13]+i[14]*i[14]+i[15]*i[15])},fromQuat:function(i,g){var x=g[0],_=g[1],v=g[2],b=g[3],y=x+x,S=_+_,w=v+v,L=x*y,k=_*y,z=_*S,H=v*y,q=v*S,W=v*w,be=b*y,Ke=b*S,Xe=b*w;return i[0]=1-z-W,i[1]=k+Xe,i[2]=H-Ke,i[3]=0,i[4]=k-Xe,i[5]=1-L-W,i[6]=q+be,i[7]=0,i[8]=H+Ke,i[9]=q-be,i[10]=1-L-z,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},fromQuat2:function(i,g){var x=new tt(3),_=-g[0],v=-g[1],b=-g[2],y=g[3],S=g[4],w=g[5],L=g[6],k=g[7],z=_*_+v*v+b*b+y*y;return z>0?(x[0]=2*(S*y+k*_+w*b-L*v)/z,x[1]=2*(w*y+k*v+L*_-S*b)/z,x[2]=2*(L*y+k*b+S*v-w*_)/z):(x[0]=2*(S*y+k*_+w*b-L*v),x[1]=2*(w*y+k*v+L*_-S*b),x[2]=2*(L*y+k*b+S*v-w*_)),fromRotationTranslation(i,g,x),i},fromRotation:function(i,g,x){var _,v,b,y=x[0],S=x[1],w=x[2],L=Math.sqrt(y*y+S*S+w*w);return L<et?null:(y*=L=1/L,S*=L,w*=L,_=Math.sin(g),b=1-(v=Math.cos(g)),i[0]=y*y*b+v,i[1]=S*y*b+w*_,i[2]=w*y*b-S*_,i[3]=0,i[4]=y*S*b-w*_,i[5]=S*S*b+v,i[6]=w*S*b+y*_,i[7]=0,i[8]=y*w*b+S*_,i[9]=S*w*b-y*_,i[10]=w*w*b+v,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i)},fromRotationTranslation:fromRotationTranslation,fromRotationTranslationScale:function(i,g,x,_){var v=g[0],b=g[1],y=g[2],S=g[3],w=v+v,L=b+b,k=y+y,z=v*w,H=v*L,q=v*k,W=b*L,be=b*k,Ke=y*k,Xe=S*w,je=S*L,Ye=S*k,Ze=_[0],Je=_[1],Qe=_[2];return i[0]=(1-(W+Ke))*Ze,i[1]=(H+Ye)*Ze,i[2]=(q-je)*Ze,i[3]=0,i[4]=(H-Ye)*Je,i[5]=(1-(z+Ke))*Je,i[6]=(be+Xe)*Je,i[7]=0,i[8]=(q+je)*Qe,i[9]=(be-Xe)*Qe,i[10]=(1-(z+W))*Qe,i[11]=0,i[12]=x[0],i[13]=x[1],i[14]=x[2],i[15]=1,i},fromRotationTranslationScaleOrigin:function(i,g,x,_,v){var b=g[0],y=g[1],S=g[2],w=g[3],L=b+b,k=y+y,z=S+S,H=b*L,q=b*k,W=b*z,be=y*k,Ke=y*z,Xe=S*z,je=w*L,Ye=w*k,Ze=w*z,Je=_[0],Qe=_[1],et=_[2],tt=v[0],it=v[1],ft=v[2],pt=(1-(be+Xe))*Je,xt=(q+Ze)*Je,vt=(W-Ye)*Je,bt=(q-Ze)*Qe,yt=(1-(H+Xe))*Qe,St=(Ke+je)*Qe,Tt=(W+Ye)*et,Mt=(Ke-je)*et,wt=(1-(H+be))*et;return i[0]=pt,i[1]=xt,i[2]=vt,i[3]=0,i[4]=bt,i[5]=yt,i[6]=St,i[7]=0,i[8]=Tt,i[9]=Mt,i[10]=wt,i[11]=0,i[12]=x[0]+tt-(pt*tt+bt*it+Tt*ft),i[13]=x[1]+it-(xt*tt+yt*it+Mt*ft),i[14]=x[2]+ft-(vt*tt+St*it+wt*ft),i[15]=1,i},fromScaling:function(i,g){return i[0]=g[0],i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=g[1],i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=g[2],i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},fromTranslation:function(i,g){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=g[0],i[13]=g[1],i[14]=g[2],i[15]=1,i},fromValues:fromValues$4,fromXRotation:function(i,g){var x=Math.sin(g),_=Math.cos(g);return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=_,i[6]=x,i[7]=0,i[8]=0,i[9]=-x,i[10]=_,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},fromYRotation:function(i,g){var x=Math.sin(g),_=Math.cos(g);return i[0]=_,i[1]=0,i[2]=-x,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=x,i[9]=0,i[10]=_,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},fromZRotation:function(i,g){var x=Math.sin(g),_=Math.cos(g);return i[0]=_,i[1]=x,i[2]=0,i[3]=0,i[4]=-x,i[5]=_,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},frustum:function(i,g,x,_,v,b,y){var S=1/(x-g),w=1/(v-_),L=1/(b-y);return i[0]=2*b*S,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=2*b*w,i[6]=0,i[7]=0,i[8]=(x+g)*S,i[9]=(v+_)*w,i[10]=(y+b)*L,i[11]=-1,i[12]=0,i[13]=0,i[14]=y*b*2*L,i[15]=0,i},getRotation:function(i,g){var x=new tt(3);getScaling(x,g);var _=1/x[0],v=1/x[1],b=1/x[2],y=g[0]*_,S=g[1]*v,w=g[2]*b,L=g[4]*_,k=g[5]*v,z=g[6]*b,H=g[8]*_,q=g[9]*v,W=g[10]*b,be=y+k+W,Ke=0;return be>0?(Ke=2*Math.sqrt(be+1),i[3]=.25*Ke,i[0]=(z-q)/Ke,i[1]=(H-w)/Ke,i[2]=(S-L)/Ke):y>k&&y>W?(Ke=2*Math.sqrt(1+y-k-W),i[3]=(z-q)/Ke,i[0]=.25*Ke,i[1]=(S+L)/Ke,i[2]=(H+w)/Ke):k>W?(Ke=2*Math.sqrt(1+k-y-W),i[3]=(H-w)/Ke,i[0]=(S+L)/Ke,i[1]=.25*Ke,i[2]=(z+q)/Ke):(Ke=2*Math.sqrt(1+W-y-k),i[3]=(S-L)/Ke,i[0]=(H+w)/Ke,i[1]=(z+q)/Ke,i[2]=.25*Ke),i},getScaling:getScaling,getTranslation:function(i,g){return i[0]=g[12],i[1]=g[13],i[2]=g[14],i},identity:identity$1,invert:invert$1,lookAt:lookAt,mul:yt,multiply:multiply$4,multiplyScalar:function(i,g,x){return i[0]=g[0]*x,i[1]=g[1]*x,i[2]=g[2]*x,i[3]=g[3]*x,i[4]=g[4]*x,i[5]=g[5]*x,i[6]=g[6]*x,i[7]=g[7]*x,i[8]=g[8]*x,i[9]=g[9]*x,i[10]=g[10]*x,i[11]=g[11]*x,i[12]=g[12]*x,i[13]=g[13]*x,i[14]=g[14]*x,i[15]=g[15]*x,i},multiplyScalarAndAdd:function(i,g,x,_){return i[0]=g[0]+x[0]*_,i[1]=g[1]+x[1]*_,i[2]=g[2]+x[2]*_,i[3]=g[3]+x[3]*_,i[4]=g[4]+x[4]*_,i[5]=g[5]+x[5]*_,i[6]=g[6]+x[6]*_,i[7]=g[7]+x[7]*_,i[8]=g[8]+x[8]*_,i[9]=g[9]+x[9]*_,i[10]=g[10]+x[10]*_,i[11]=g[11]+x[11]*_,i[12]=g[12]+x[12]*_,i[13]=g[13]+x[13]*_,i[14]=g[14]+x[14]*_,i[15]=g[15]+x[15]*_,i},ortho:bt,orthoNO:orthoNO,orthoZO:orthoZO,perspective:vt,perspectiveFromFieldOfView:function(i,g,x,_){var v=Math.tan(g.upDegrees*Math.PI/180),b=Math.tan(g.downDegrees*Math.PI/180),y=Math.tan(g.leftDegrees*Math.PI/180),S=Math.tan(g.rightDegrees*Math.PI/180),w=2/(y+S),L=2/(v+b);return i[0]=w,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=L,i[6]=0,i[7]=0,i[8]=-(y-S)*w*.5,i[9]=(v-b)*L*.5,i[10]=_/(x-_),i[11]=-1,i[12]=0,i[13]=0,i[14]=_*x/(x-_),i[15]=0,i},perspectiveNO:perspectiveNO,perspectiveZO:function(i,g,x,_,v){var b=1/Math.tan(g/2);if(i[0]=b/x,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=b,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[11]=-1,i[12]=0,i[13]=0,i[15]=0,null!=v&&v!==1/0){var y=1/(_-v);i[10]=v*y,i[14]=v*_*y}else i[10]=-1,i[14]=-_;return i},rotate:function(i,g,x,_){var v,b,y,S,w,L,k,z,H,q,W,be,Ke,Xe,je,Ye,Ze,Je,Qe,tt,it,ft,pt,xt,vt=_[0],bt=_[1],yt=_[2],St=Math.sqrt(vt*vt+bt*bt+yt*yt);return St<et?null:(vt*=St=1/St,bt*=St,yt*=St,v=Math.sin(x),y=1-(b=Math.cos(x)),S=g[0],w=g[1],L=g[2],k=g[3],z=g[4],H=g[5],q=g[6],W=g[7],be=g[8],Ke=g[9],Xe=g[10],je=g[11],Ye=vt*vt*y+b,Ze=bt*vt*y+yt*v,Je=yt*vt*y-bt*v,Qe=vt*bt*y-yt*v,tt=bt*bt*y+b,it=yt*bt*y+vt*v,ft=vt*yt*y+bt*v,pt=bt*yt*y-vt*v,xt=yt*yt*y+b,i[0]=S*Ye+z*Ze+be*Je,i[1]=w*Ye+H*Ze+Ke*Je,i[2]=L*Ye+q*Ze+Xe*Je,i[3]=k*Ye+W*Ze+je*Je,i[4]=S*Qe+z*tt+be*it,i[5]=w*Qe+H*tt+Ke*it,i[6]=L*Qe+q*tt+Xe*it,i[7]=k*Qe+W*tt+je*it,i[8]=S*ft+z*pt+be*xt,i[9]=w*ft+H*pt+Ke*xt,i[10]=L*ft+q*pt+Xe*xt,i[11]=k*ft+W*pt+je*xt,g!==i&&(i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15]),i)},rotateX:rotateX$2,rotateY:rotateY$2,rotateZ:rotateZ$2,scale:scale$4,set:function(i,g,x,_,v,b,y,S,w,L,k,z,H,q,W,be,Ke){return i[0]=g,i[1]=x,i[2]=_,i[3]=v,i[4]=b,i[5]=y,i[6]=S,i[7]=w,i[8]=L,i[9]=k,i[10]=z,i[11]=H,i[12]=q,i[13]=W,i[14]=be,i[15]=Ke,i},str:function(i){return"mat4("+i[0]+","+i[1]+","+i[2]+","+i[3]+","+i[4]+","+i[5]+","+i[6]+","+i[7]+","+i[8]+","+i[9]+","+i[10]+","+i[11]+","+i[12]+","+i[13]+","+i[14]+","+i[15]+")"},sub:St,subtract:subtract$3,targetTo:targetTo,translate:translate,transpose:function(i,g){if(i===g){var x=g[1],_=g[2],v=g[3],b=g[6],y=g[7],S=g[11];i[1]=g[4],i[2]=g[8],i[3]=g[12],i[4]=x,i[6]=g[9],i[7]=g[13],i[8]=_,i[9]=b,i[11]=g[14],i[12]=v,i[13]=y,i[14]=S}else i[0]=g[0],i[1]=g[4],i[2]=g[8],i[3]=g[12],i[4]=g[1],i[5]=g[5],i[6]=g[9],i[7]=g[13],i[8]=g[2],i[9]=g[6],i[10]=g[10],i[11]=g[14],i[12]=g[3],i[13]=g[7],i[14]=g[11],i[15]=g[15];return i}});function create$3(){var i=new tt(3);return tt!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0),i}function clone$3(i){var g=new tt(3);return g[0]=i[0],g[1]=i[1],g[2]=i[2],g}function length$3(i){var g=i[0],x=i[1],_=i[2];return Math.sqrt(g*g+x*x+_*_)}function fromValues$3(i,g,x){var _=new tt(3);return _[0]=i,_[1]=g,_[2]=x,_}function copy$3(i,g){return i[0]=g[0],i[1]=g[1],i[2]=g[2],i}function set$3(i,g,x,_){return i[0]=g,i[1]=x,i[2]=_,i}function subtract$2(i,g,x){return i[0]=g[0]-x[0],i[1]=g[1]-x[1],i[2]=g[2]-x[2],i}function multiply$3(i,g,x){return i[0]=g[0]*x[0],i[1]=g[1]*x[1],i[2]=g[2]*x[2],i}function divide$2(i,g,x){return i[0]=g[0]/x[0],i[1]=g[1]/x[1],i[2]=g[2]/x[2],i}function scaleAndAdd$2(i,g,x,_){return i[0]=g[0]+x[0]*_,i[1]=g[1]+x[1]*_,i[2]=g[2]+x[2]*_,i}function distance$2(i,g){var x=g[0]-i[0],_=g[1]-i[1],v=g[2]-i[2];return Math.sqrt(x*x+_*_+v*v)}function squaredDistance$2(i,g){var x=g[0]-i[0],_=g[1]-i[1],v=g[2]-i[2];return x*x+_*_+v*v}function squaredLength$3(i){var g=i[0],x=i[1],_=i[2];return g*g+x*x+_*_}function normalize$3(i,g){var x=g[0],_=g[1],v=g[2],b=x*x+_*_+v*v;return b>0&&(b=1/Math.sqrt(b)),i[0]=g[0]*b,i[1]=g[1]*b,i[2]=g[2]*b,i}function dot$3(i,g){return i[0]*g[0]+i[1]*g[1]+i[2]*g[2]}function cross$2(i,g,x){var _=g[0],v=g[1],b=g[2],y=x[0],S=x[1],w=x[2];return i[0]=v*w-b*S,i[1]=b*y-_*w,i[2]=_*S-v*y,i}function lerp$3(i,g,x,_){var v=g[0],b=g[1],y=g[2];return i[0]=v+_*(x[0]-v),i[1]=b+_*(x[1]-b),i[2]=y+_*(x[2]-y),i}function transformMat4$2(i,g,x){var _=g[0],v=g[1],b=g[2],y=x[3]*_+x[7]*v+x[11]*b+x[15];return y=y||1,i[0]=(x[0]*_+x[4]*v+x[8]*b+x[12])/y,i[1]=(x[1]*_+x[5]*v+x[9]*b+x[13])/y,i[2]=(x[2]*_+x[6]*v+x[10]*b+x[14])/y,i}var Mt,wt=subtract$2,Ct=multiply$3,Pt=divide$2,Rt=distance$2,Bt=squaredDistance$2,It=length$3,Et=squaredLength$3,Dt=(Mt=create$3(),function(i,g,x,_,v,b){var y,S;for(g||(g=3),x||(x=0),S=_?Math.min(_*g+x,i.length):i.length,y=x;y<S;y+=g)Mt[0]=i[y],Mt[1]=i[y+1],Mt[2]=i[y+2],v(Mt,Mt,b),i[y]=Mt[0],i[y+1]=Mt[1],i[y+2]=Mt[2];return i}),Ut=Object.freeze({__proto__:null,add:function(i,g,x){return i[0]=g[0]+x[0],i[1]=g[1]+x[1],i[2]=g[2]+x[2],i},angle:function(i,g){var x=i[0],_=i[1],v=i[2],b=g[0],y=g[1],S=g[2],w=Math.sqrt((x*x+_*_+v*v)*(b*b+y*y+S*S)),L=w&&dot$3(i,g)/w;return Math.acos(Math.min(Math.max(L,-1),1))},bezier:function(i,g,x,_,v,b){var y=1-b,S=y*y,w=b*b,L=S*y,k=3*b*S,z=3*w*y,H=w*b;return i[0]=g[0]*L+x[0]*k+_[0]*z+v[0]*H,i[1]=g[1]*L+x[1]*k+_[1]*z+v[1]*H,i[2]=g[2]*L+x[2]*k+_[2]*z+v[2]*H,i},ceil:function(i,g){return i[0]=Math.ceil(g[0]),i[1]=Math.ceil(g[1]),i[2]=Math.ceil(g[2]),i},clone:clone$3,copy:copy$3,create:create$3,cross:cross$2,dist:Rt,distance:distance$2,div:Pt,divide:divide$2,dot:dot$3,equals:function(i,g){var x=i[0],_=i[1],v=i[2],b=g[0],y=g[1],S=g[2];return Math.abs(x-b)<=et*Math.max(1,Math.abs(x),Math.abs(b))&&Math.abs(_-y)<=et*Math.max(1,Math.abs(_),Math.abs(y))&&Math.abs(v-S)<=et*Math.max(1,Math.abs(v),Math.abs(S))},exactEquals:function(i,g){return i[0]===g[0]&&i[1]===g[1]&&i[2]===g[2]},floor:function(i,g){return i[0]=Math.floor(g[0]),i[1]=Math.floor(g[1]),i[2]=Math.floor(g[2]),i},forEach:Dt,fromValues:fromValues$3,hermite:function(i,g,x,_,v,b){var y=b*b,S=y*(2*b-3)+1,w=y*(b-2)+b,L=y*(b-1),k=y*(3-2*b);return i[0]=g[0]*S+x[0]*w+_[0]*L+v[0]*k,i[1]=g[1]*S+x[1]*w+_[1]*L+v[1]*k,i[2]=g[2]*S+x[2]*w+_[2]*L+v[2]*k,i},inverse:function(i,g){return i[0]=1/g[0],i[1]=1/g[1],i[2]=1/g[2],i},len:It,length:length$3,lerp:lerp$3,max:function(i,g,x){return i[0]=Math.max(g[0],x[0]),i[1]=Math.max(g[1],x[1]),i[2]=Math.max(g[2],x[2]),i},min:function(i,g,x){return i[0]=Math.min(g[0],x[0]),i[1]=Math.min(g[1],x[1]),i[2]=Math.min(g[2],x[2]),i},mul:Ct,multiply:multiply$3,negate:function(i,g){return i[0]=-g[0],i[1]=-g[1],i[2]=-g[2],i},normalize:normalize$3,random:function(i,g){g=void 0===g?1:g;var x=2*it()*Math.PI,_=2*it()-1,v=Math.sqrt(1-_*_)*g;return i[0]=Math.cos(x)*v,i[1]=Math.sin(x)*v,i[2]=_*g,i},rotateX:function(i,g,x,_){var v=[],b=[];return v[0]=g[0]-x[0],v[1]=g[1]-x[1],v[2]=g[2]-x[2],b[0]=v[0],b[1]=v[1]*Math.cos(_)-v[2]*Math.sin(_),b[2]=v[1]*Math.sin(_)+v[2]*Math.cos(_),i[0]=b[0]+x[0],i[1]=b[1]+x[1],i[2]=b[2]+x[2],i},rotateY:function(i,g,x,_){var v=[],b=[];return v[0]=g[0]-x[0],v[1]=g[1]-x[1],v[2]=g[2]-x[2],b[0]=v[2]*Math.sin(_)+v[0]*Math.cos(_),b[1]=v[1],b[2]=v[2]*Math.cos(_)-v[0]*Math.sin(_),i[0]=b[0]+x[0],i[1]=b[1]+x[1],i[2]=b[2]+x[2],i},rotateZ:function(i,g,x,_){var v=[],b=[];return v[0]=g[0]-x[0],v[1]=g[1]-x[1],v[2]=g[2]-x[2],b[0]=v[0]*Math.cos(_)-v[1]*Math.sin(_),b[1]=v[0]*Math.sin(_)+v[1]*Math.cos(_),b[2]=v[2],i[0]=b[0]+x[0],i[1]=b[1]+x[1],i[2]=b[2]+x[2],i},round:function(i,g){return i[0]=round$3(g[0]),i[1]=round$3(g[1]),i[2]=round$3(g[2]),i},scale:function(i,g,x){return i[0]=g[0]*x,i[1]=g[1]*x,i[2]=g[2]*x,i},scaleAndAdd:scaleAndAdd$2,set:set$3,slerp:function(i,g,x,_){var v=Math.acos(Math.min(Math.max(dot$3(g,x),-1),1)),b=Math.sin(v),y=Math.sin((1-_)*v)/b,S=Math.sin(_*v)/b;return i[0]=y*g[0]+S*x[0],i[1]=y*g[1]+S*x[1],i[2]=y*g[2]+S*x[2],i},sqrDist:Bt,sqrLen:Et,squaredDistance:squaredDistance$2,squaredLength:squaredLength$3,str:function(i){return"vec3("+i[0]+","+i[1]+","+i[2]+")"},sub:wt,subtract:subtract$2,transformMat3:function(i,g,x){var _=g[0],v=g[1],b=g[2];return i[0]=_*x[0]+v*x[3]+b*x[6],i[1]=_*x[1]+v*x[4]+b*x[7],i[2]=_*x[2]+v*x[5]+b*x[8],i},transformMat4:transformMat4$2,transformQuat:function(i,g,x){var _=x[0],v=x[1],b=x[2],y=x[3],S=g[0],w=g[1],L=g[2],k=v*L-b*w,z=b*S-_*L,H=_*w-v*S;return k+=k,z+=z,H+=H,i[0]=S+y*k+v*H-b*z,i[1]=w+y*z+b*k-_*H,i[2]=L+y*H+_*z-v*k,i},zero:function(i){return i[0]=0,i[1]=0,i[2]=0,i}});function create$2(){var i=new tt(4);return tt!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0,i[3]=0),i}function clone$2(i){var g=new tt(4);return g[0]=i[0],g[1]=i[1],g[2]=i[2],g[3]=i[3],g}function fromValues$2(i,g,x,_){var v=new tt(4);return v[0]=i,v[1]=g,v[2]=x,v[3]=_,v}function copy$2(i,g){return i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i}function set$2(i,g,x,_,v){return i[0]=g,i[1]=x,i[2]=_,i[3]=v,i}function add$2(i,g,x){return i[0]=g[0]+x[0],i[1]=g[1]+x[1],i[2]=g[2]+x[2],i[3]=g[3]+x[3],i}function subtract$1(i,g,x){return i[0]=g[0]-x[0],i[1]=g[1]-x[1],i[2]=g[2]-x[2],i[3]=g[3]-x[3],i}function multiply$2(i,g,x){return i[0]=g[0]*x[0],i[1]=g[1]*x[1],i[2]=g[2]*x[2],i[3]=g[3]*x[3],i}function divide$1(i,g,x){return i[0]=g[0]/x[0],i[1]=g[1]/x[1],i[2]=g[2]/x[2],i[3]=g[3]/x[3],i}function scale$2(i,g,x){return i[0]=g[0]*x,i[1]=g[1]*x,i[2]=g[2]*x,i[3]=g[3]*x,i}function distance$1(i,g){var x=g[0]-i[0],_=g[1]-i[1],v=g[2]-i[2],b=g[3]-i[3];return Math.sqrt(x*x+_*_+v*v+b*b)}function squaredDistance$1(i,g){var x=g[0]-i[0],_=g[1]-i[1],v=g[2]-i[2],b=g[3]-i[3];return x*x+_*_+v*v+b*b}function length$2(i){var g=i[0],x=i[1],_=i[2],v=i[3];return Math.sqrt(g*g+x*x+_*_+v*v)}function squaredLength$2(i){var g=i[0],x=i[1],_=i[2],v=i[3];return g*g+x*x+_*_+v*v}function normalize$2(i,g){var x=g[0],_=g[1],v=g[2],b=g[3],y=x*x+_*_+v*v+b*b;return y>0&&(y=1/Math.sqrt(y)),i[0]=x*y,i[1]=_*y,i[2]=v*y,i[3]=b*y,i}function dot$2(i,g){return i[0]*g[0]+i[1]*g[1]+i[2]*g[2]+i[3]*g[3]}function lerp$2(i,g,x,_){var v=g[0],b=g[1],y=g[2],S=g[3];return i[0]=v+_*(x[0]-v),i[1]=b+_*(x[1]-b),i[2]=y+_*(x[2]-y),i[3]=S+_*(x[3]-S),i}function transformMat4$1(i,g,x){var _=g[0],v=g[1],b=g[2],y=g[3];return i[0]=x[0]*_+x[4]*v+x[8]*b+x[12]*y,i[1]=x[1]*_+x[5]*v+x[9]*b+x[13]*y,i[2]=x[2]*_+x[6]*v+x[10]*b+x[14]*y,i[3]=x[3]*_+x[7]*v+x[11]*b+x[15]*y,i}function exactEquals$2(i,g){return i[0]===g[0]&&i[1]===g[1]&&i[2]===g[2]&&i[3]===g[3]}var Lt=subtract$1,At=multiply$2,Gt=divide$1,kt=distance$1,Ot=squaredDistance$1,Nt=length$2,Vt=squaredLength$2,Ft=function(){var i=create$2();return function(g,x,_,v,b,y){var S,w;for(x||(x=4),_||(_=0),w=v?Math.min(v*x+_,g.length):g.length,S=_;S<w;S+=x)i[0]=g[S],i[1]=g[S+1],i[2]=g[S+2],i[3]=g[S+3],b(i,i,y),g[S]=i[0],g[S+1]=i[1],g[S+2]=i[2],g[S+3]=i[3];return g}}(),zt=Object.freeze({__proto__:null,add:add$2,ceil:function(i,g){return i[0]=Math.ceil(g[0]),i[1]=Math.ceil(g[1]),i[2]=Math.ceil(g[2]),i[3]=Math.ceil(g[3]),i},clone:clone$2,copy:copy$2,create:create$2,cross:function(i,g,x,_){var v=x[0]*_[1]-x[1]*_[0],b=x[0]*_[2]-x[2]*_[0],y=x[0]*_[3]-x[3]*_[0],S=x[1]*_[2]-x[2]*_[1],w=x[1]*_[3]-x[3]*_[1],L=x[2]*_[3]-x[3]*_[2],k=g[0],z=g[1],H=g[2],q=g[3];return i[0]=z*L-H*w+q*S,i[1]=-k*L+H*y-q*b,i[2]=k*w-z*y+q*v,i[3]=-k*S+z*b-H*v,i},dist:kt,distance:distance$1,div:Gt,divide:divide$1,dot:dot$2,equals:function(i,g){var x=i[0],_=i[1],v=i[2],b=i[3],y=g[0],S=g[1],w=g[2],L=g[3];return Math.abs(x-y)<=et*Math.max(1,Math.abs(x),Math.abs(y))&&Math.abs(_-S)<=et*Math.max(1,Math.abs(_),Math.abs(S))&&Math.abs(v-w)<=et*Math.max(1,Math.abs(v),Math.abs(w))&&Math.abs(b-L)<=et*Math.max(1,Math.abs(b),Math.abs(L))},exactEquals:exactEquals$2,floor:function(i,g){return i[0]=Math.floor(g[0]),i[1]=Math.floor(g[1]),i[2]=Math.floor(g[2]),i[3]=Math.floor(g[3]),i},forEach:Ft,fromValues:fromValues$2,inverse:function(i,g){return i[0]=1/g[0],i[1]=1/g[1],i[2]=1/g[2],i[3]=1/g[3],i},len:Nt,length:length$2,lerp:lerp$2,max:function(i,g,x){return i[0]=Math.max(g[0],x[0]),i[1]=Math.max(g[1],x[1]),i[2]=Math.max(g[2],x[2]),i[3]=Math.max(g[3],x[3]),i},min:function(i,g,x){return i[0]=Math.min(g[0],x[0]),i[1]=Math.min(g[1],x[1]),i[2]=Math.min(g[2],x[2]),i[3]=Math.min(g[3],x[3]),i},mul:At,multiply:multiply$2,negate:function(i,g){return i[0]=-g[0],i[1]=-g[1],i[2]=-g[2],i[3]=-g[3],i},normalize:normalize$2,random:function(i,g){var x,_,v,b,y,S,w;g=void 0===g?1:g,y=(x=2*(w=it())-1)*x+(_=(4*it()-2)*Math.sqrt(w*-w+w))*_,S=(v=2*(w=it())-1)*v+(b=(4*it()-2)*Math.sqrt(w*-w+w))*b;var L=Math.sqrt((1-y)/S);return i[0]=g*x,i[1]=g*_,i[2]=g*v*L,i[3]=g*b*L,i},round:function(i,g){return i[0]=round$3(g[0]),i[1]=round$3(g[1]),i[2]=round$3(g[2]),i[3]=round$3(g[3]),i},scale:scale$2,scaleAndAdd:function(i,g,x,_){return i[0]=g[0]+x[0]*_,i[1]=g[1]+x[1]*_,i[2]=g[2]+x[2]*_,i[3]=g[3]+x[3]*_,i},set:set$2,sqrDist:Ot,sqrLen:Vt,squaredDistance:squaredDistance$1,squaredLength:squaredLength$2,str:function(i){return"vec4("+i[0]+","+i[1]+","+i[2]+","+i[3]+")"},sub:Lt,subtract:subtract$1,transformMat4:transformMat4$1,transformQuat:function(i,g,x){var _=x[0],v=x[1],b=x[2],y=x[3],S=g[0],w=g[1],L=g[2],k=v*L-b*w,z=b*S-_*L,H=_*w-v*S;return k+=k,z+=z,H+=H,i[0]=S+y*k+v*H-b*z,i[1]=w+y*z+b*k-_*H,i[2]=L+y*H+_*z-v*k,i[3]=g[3],i},zero:function(i){return i[0]=0,i[1]=0,i[2]=0,i[3]=0,i}});function create$1(){var i=new tt(4);return tt!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0),i[3]=1,i}function setAxisAngle(i,g,x){x*=.5;var _=Math.sin(x);return i[0]=_*g[0],i[1]=_*g[1],i[2]=_*g[2],i[3]=Math.cos(x),i}function multiply$1(i,g,x){var _=g[0],v=g[1],b=g[2],y=g[3],S=x[0],w=x[1],L=x[2],k=x[3];return i[0]=_*k+y*S+v*L-b*w,i[1]=v*k+y*w+b*S-_*L,i[2]=b*k+y*L+_*w-v*S,i[3]=y*k-_*S-v*w-b*L,i}function exp(i,g){var x=g[0],_=g[1],v=g[2],b=g[3],y=Math.sqrt(x*x+_*_+v*v),S=Math.exp(b),w=y>0?S*Math.sin(y)/y:0;return i[0]=x*w,i[1]=_*w,i[2]=v*w,i[3]=S*Math.cos(y),i}function ln(i,g){var x=g[0],_=g[1],v=g[2],b=g[3],y=Math.sqrt(x*x+_*_+v*v),S=y>0?Math.atan2(y,b)/y:0;return i[0]=x*S,i[1]=_*S,i[2]=v*S,i[3]=.5*Math.log(x*x+_*_+v*v+b*b),i}function slerp(i,g,x,_){var v,b,y,S,w,L=g[0],k=g[1],z=g[2],H=g[3],q=x[0],W=x[1],be=x[2],Ke=x[3];return(b=L*q+k*W+z*be+H*Ke)<0&&(b=-b,q=-q,W=-W,be=-be,Ke=-Ke),1-b>et?(v=Math.acos(b),y=Math.sin(v),S=Math.sin((1-_)*v)/y,w=Math.sin(_*v)/y):(S=1-_,w=_),i[0]=S*L+w*q,i[1]=S*k+w*W,i[2]=S*z+w*be,i[3]=S*H+w*Ke,i}function fromMat3(i,g){var x,_=g[0]+g[4]+g[8];if(_>0)x=Math.sqrt(_+1),i[3]=.5*x,x=.5/x,i[0]=(g[5]-g[7])*x,i[1]=(g[6]-g[2])*x,i[2]=(g[1]-g[3])*x;else{var v=0;g[4]>g[0]&&(v=1),g[8]>g[3*v+v]&&(v=2);var b=(v+1)%3,y=(v+2)%3;x=Math.sqrt(g[3*v+v]-g[3*b+b]-g[3*y+y]+1),i[v]=.5*x,x=.5/x,i[3]=(g[3*b+y]-g[3*y+b])*x,i[b]=(g[3*b+v]+g[3*v+b])*x,i[y]=(g[3*y+v]+g[3*v+y])*x}return i}var Ht=clone$2,$t=fromValues$2,Kt=copy$2,Xt=set$2,jt=add$2,Yt=multiply$1,qt=scale$2,Wt=dot$2,Zt=lerp$2,Jt=length$2,Qt=Jt,en=squaredLength$2,tn=en,nn=normalize$2,rn=exactEquals$2;var an,sn,on,un,cn=(an=create$3(),sn=fromValues$3(1,0,0),on=fromValues$3(0,1,0),function(i,g,x){var _=dot$3(g,x);return _<-.999999?(cross$2(an,sn,g),It(an)<1e-6&&cross$2(an,on,g),normalize$3(an,an),setAxisAngle(i,an,Math.PI),i):_>.999999?(i[0]=0,i[1]=0,i[2]=0,i[3]=1,i):(cross$2(an,g,x),i[0]=an[0],i[1]=an[1],i[2]=an[2],i[3]=1+_,nn(i,i))}),hn=function(){var i=create$1(),g=create$1();return function(x,_,v,b,y,S){return slerp(i,_,y,S),slerp(g,v,b,S),slerp(x,i,g,2*S*(1-S)),x}}(),fn=(un=create$5(),function(i,g,x,_){return un[0]=x[0],un[3]=x[1],un[6]=x[2],un[1]=_[0],un[4]=_[1],un[7]=_[2],un[2]=-g[0],un[5]=-g[1],un[8]=-g[2],nn(i,fromMat3(i,un))}),dn=Object.freeze({__proto__:null,add:jt,calculateW:function(i,g){var x=g[0],_=g[1],v=g[2];return i[0]=x,i[1]=_,i[2]=v,i[3]=Math.sqrt(Math.abs(1-x*x-_*_-v*v)),i},clone:Ht,conjugate:function(i,g){return i[0]=-g[0],i[1]=-g[1],i[2]=-g[2],i[3]=g[3],i},copy:Kt,create:create$1,dot:Wt,equals:function(i,g){return Math.abs(dot$2(i,g))>=.999999},exactEquals:rn,exp:exp,fromEuler:function(i,g,x,_){var v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"zyx",b=Math.PI/360;g*=b,_*=b,x*=b;var y=Math.sin(g),S=Math.cos(g),w=Math.sin(x),L=Math.cos(x),k=Math.sin(_),z=Math.cos(_);switch(v){case"xyz":i[0]=y*L*z+S*w*k,i[1]=S*w*z-y*L*k,i[2]=S*L*k+y*w*z,i[3]=S*L*z-y*w*k;break;case"xzy":i[0]=y*L*z-S*w*k,i[1]=S*w*z-y*L*k,i[2]=S*L*k+y*w*z,i[3]=S*L*z+y*w*k;break;case"yxz":i[0]=y*L*z+S*w*k,i[1]=S*w*z-y*L*k,i[2]=S*L*k-y*w*z,i[3]=S*L*z+y*w*k;break;case"yzx":i[0]=y*L*z+S*w*k,i[1]=S*w*z+y*L*k,i[2]=S*L*k-y*w*z,i[3]=S*L*z-y*w*k;break;case"zxy":i[0]=y*L*z-S*w*k,i[1]=S*w*z+y*L*k,i[2]=S*L*k+y*w*z,i[3]=S*L*z-y*w*k;break;case"zyx":i[0]=y*L*z-S*w*k,i[1]=S*w*z+y*L*k,i[2]=S*L*k-y*w*z,i[3]=S*L*z+y*w*k;break;default:throw new Error("Unknown angle order "+v)}return i},fromMat3:fromMat3,fromValues:$t,getAngle:function(i,g){var x=Wt(i,g);return Math.acos(2*x*x-1)},getAxisAngle:function(i,g){var x=2*Math.acos(g[3]),_=Math.sin(x/2);return _>et?(i[0]=g[0]/_,i[1]=g[1]/_,i[2]=g[2]/_):(i[0]=1,i[1]=0,i[2]=0),x},identity:function(i){return i[0]=0,i[1]=0,i[2]=0,i[3]=1,i},invert:function(i,g){var x=g[0],_=g[1],v=g[2],b=g[3],y=x*x+_*_+v*v+b*b,S=y?1/y:0;return i[0]=-x*S,i[1]=-_*S,i[2]=-v*S,i[3]=b*S,i},len:Qt,length:Jt,lerp:Zt,ln:ln,mul:Yt,multiply:multiply$1,normalize:nn,pow:function(i,g,x){return ln(i,g),qt(i,i,x),exp(i,i),i},random:function(i){var g=it(),x=it(),_=it(),v=Math.sqrt(1-g),b=Math.sqrt(g);return i[0]=v*Math.sin(2*Math.PI*x),i[1]=v*Math.cos(2*Math.PI*x),i[2]=b*Math.sin(2*Math.PI*_),i[3]=b*Math.cos(2*Math.PI*_),i},rotateX:function(i,g,x){x*=.5;var _=g[0],v=g[1],b=g[2],y=g[3],S=Math.sin(x),w=Math.cos(x);return i[0]=_*w+y*S,i[1]=v*w+b*S,i[2]=b*w-v*S,i[3]=y*w-_*S,i},rotateY:function(i,g,x){x*=.5;var _=g[0],v=g[1],b=g[2],y=g[3],S=Math.sin(x),w=Math.cos(x);return i[0]=_*w-b*S,i[1]=v*w+y*S,i[2]=b*w+_*S,i[3]=y*w-v*S,i},rotateZ:function(i,g,x){x*=.5;var _=g[0],v=g[1],b=g[2],y=g[3],S=Math.sin(x),w=Math.cos(x);return i[0]=_*w+v*S,i[1]=v*w-_*S,i[2]=b*w+y*S,i[3]=y*w-b*S,i},rotationTo:cn,scale:qt,set:Xt,setAxes:fn,setAxisAngle:setAxisAngle,slerp:slerp,sqlerp:hn,sqrLen:tn,squaredLength:en,str:function(i){return"quat("+i[0]+","+i[1]+","+i[2]+","+i[3]+")"}});function create(){var i=new tt(2);return tt!=Float32Array&&(i[0]=0,i[1]=0),i}function fromValues(i,g){var x=new tt(2);return x[0]=i,x[1]=g,x}function set(i,g,x){return i[0]=g,i[1]=x,i}function subtract(i,g,x){return i[0]=g[0]-x[0],i[1]=g[1]-x[1],i}function multiply(i,g,x){return i[0]=g[0]*x[0],i[1]=g[1]*x[1],i}function divide(i,g,x){return i[0]=g[0]/x[0],i[1]=g[1]/x[1],i}function scaleAndAdd(i,g,x,_){return i[0]=g[0]+x[0]*_,i[1]=g[1]+x[1]*_,i}function distance(i,g){var x=g[0]-i[0],_=g[1]-i[1];return Math.sqrt(x*x+_*_)}function squaredDistance(i,g){var x=g[0]-i[0],_=g[1]-i[1];return x*x+_*_}function length(i){var g=i[0],x=i[1];return Math.sqrt(g*g+x*x)}function squaredLength(i){var g=i[0],x=i[1];return g*g+x*x}function lerp(i,g,x,_){var v=g[0],b=g[1];return i[0]=v+_*(x[0]-v),i[1]=b+_*(x[1]-b),i}var mn=length,pn=subtract,gn=multiply,xn=divide,_n=distance,vn=squaredDistance,bn=squaredLength,yn=function(){var i=create();return function(g,x,_,v,b,y){var S,w;for(x||(x=2),_||(_=0),w=v?Math.min(v*x+_,g.length):g.length,S=_;S<w;S+=x)i[0]=g[S],i[1]=g[S+1],b(i,i,y),g[S]=i[0],g[S+1]=i[1];return g}}(),Sn=Object.freeze({__proto__:null,add:function(i,g,x){return i[0]=g[0]+x[0],i[1]=g[1]+x[1],i},angle:function(i,g){var x=i[0],_=i[1],v=g[0],b=g[1];return Math.abs(Math.atan2(_*v-x*b,x*v+_*b))},ceil:function(i,g){return i[0]=Math.ceil(g[0]),i[1]=Math.ceil(g[1]),i},clone:function(i){var g=new tt(2);return g[0]=i[0],g[1]=i[1],g},copy:function(i,g){return i[0]=g[0],i[1]=g[1],i},create:create,cross:function(i,g,x){var _=g[0]*x[1]-g[1]*x[0];return i[0]=i[1]=0,i[2]=_,i},dist:_n,distance:distance,div:xn,divide:divide,dot:function(i,g){return i[0]*g[0]+i[1]*g[1]},equals:function(i,g){var x=i[0],_=i[1],v=g[0],b=g[1];return Math.abs(x-v)<=et*Math.max(1,Math.abs(x),Math.abs(v))&&Math.abs(_-b)<=et*Math.max(1,Math.abs(_),Math.abs(b))},exactEquals:function(i,g){return i[0]===g[0]&&i[1]===g[1]},floor:function(i,g){return i[0]=Math.floor(g[0]),i[1]=Math.floor(g[1]),i},forEach:yn,fromValues:fromValues,inverse:function(i,g){return i[0]=1/g[0],i[1]=1/g[1],i},len:mn,length:length,lerp:lerp,max:function(i,g,x){return i[0]=Math.max(g[0],x[0]),i[1]=Math.max(g[1],x[1]),i},min:function(i,g,x){return i[0]=Math.min(g[0],x[0]),i[1]=Math.min(g[1],x[1]),i},mul:gn,multiply:multiply,negate:function(i,g){return i[0]=-g[0],i[1]=-g[1],i},normalize:function(i,g){var x=g[0],_=g[1],v=x*x+_*_;return v>0&&(v=1/Math.sqrt(v)),i[0]=g[0]*v,i[1]=g[1]*v,i},random:function(i,g){g=void 0===g?1:g;var x=2*it()*Math.PI;return i[0]=Math.cos(x)*g,i[1]=Math.sin(x)*g,i},rotate:function(i,g,x,_){var v=g[0]-x[0],b=g[1]-x[1],y=Math.sin(_),S=Math.cos(_);return i[0]=v*S-b*y+x[0],i[1]=v*y+b*S+x[1],i},round:function(i,g){return i[0]=round$3(g[0]),i[1]=round$3(g[1]),i},scale:function(i,g,x){return i[0]=g[0]*x,i[1]=g[1]*x,i},scaleAndAdd:scaleAndAdd,set:set,signedAngle:function(i,g){var x=i[0],_=i[1],v=g[0],b=g[1];return Math.atan2(x*b-_*v,x*v+_*b)},sqrDist:vn,sqrLen:bn,squaredDistance:squaredDistance,squaredLength:squaredLength,str:function(i){return"vec2("+i[0]+","+i[1]+")"},sub:pn,subtract:subtract,transformMat2:function(i,g,x){var _=g[0],v=g[1];return i[0]=x[0]*_+x[2]*v,i[1]=x[1]*_+x[3]*v,i},transformMat2d:function(i,g,x){var _=g[0],v=g[1];return i[0]=x[0]*_+x[2]*v+x[4],i[1]=x[1]*_+x[3]*v+x[5],i},transformMat3:function(i,g,x){var _=g[0],v=g[1];return i[0]=x[0]*_+x[3]*v+x[6],i[1]=x[1]*_+x[4]*v+x[7],i},transformMat4:function(i,g,x){var _=g[0],v=g[1];return i[0]=x[0]*_+x[4]*v+x[12],i[1]=x[1]*_+x[5]*v+x[13],i},zero:function(i){return i[0]=0,i[1]=0,i}});class Camera2D{#f;#Ot=create$4();#Nt=0;#Vt=0;#Ft=0;#h;constructor(){}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get modelMatrix(){return this.#Ot}get z(){return this.#Ft}get x(){return this.#Nt}set x(i){this.#Nt=i,this.#Ot[12]=i}get y(){return this.#Vt}set y(i){this.#Vt=i,this.#Ot[13]=i}get position(){return[this.#Nt,this.#Vt]}setPosition(i,g){Array.isArray(i)?[this.#Nt,this.#Vt]=i:(this.#Nt=i,this.#Vt=g),[this.#Ot[12],this.#Ot[13],this.#Ot[14]]=[this.#Nt,this.#Vt,0]}}const Tn={NEVER:"never",LESS:"less",EQUAL:"equal",LESS_EQUAL:"less-equal",GREATER:"greater",NOT_EQUAL:"not-equal",GREATER_EQUAL:"greater-equal",ALWAYS:"always"};Object.freeze(Tn);class e{constructor(i,g){this.name=i,this.attributes=g,this.size=0}get isArray(){return!1}get isStruct(){return!1}get isTemplate(){return!1}get isPointer(){return!1}getTypeName(){return this.name}}class t{constructor(i,g,x){this.name=i,this.type=g,this.attributes=x,this.offset=0,this.size=0}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class n extends e{constructor(i,g){super(i,g),this.members=[],this.align=0,this.startLine=-1,this.endLine=-1,this.inUse=!1}get isStruct(){return!0}}class s extends e{constructor(i,g){super(i,g),this.count=0,this.stride=0}get isArray(){return!0}getTypeName(){return`array<${this.format.getTypeName()},${this.count}>`}}class r extends e{constructor(i,g,x){super(i,x),this.format=g}get isPointer(){return!0}getTypeName(){return`&${this.format.getTypeName()}`}}class a extends e{constructor(i,g,x,_){super(i,x),this.format=g,this.access=_}get isTemplate(){return!0}getTypeName(){let i=this.name;if(null!==this.format){if("vec2"===i||"vec3"===i||"vec4"===i||"mat2x2"===i||"mat2x3"===i||"mat2x4"===i||"mat3x2"===i||"mat3x3"===i||"mat3x4"===i||"mat4x2"===i||"mat4x3"===i||"mat4x4"===i){if("f32"===this.format.name)return i+="f",i;if("i32"===this.format.name)return i+="i",i;if("u32"===this.format.name)return i+="u",i;if("bool"===this.format.name)return i+="b",i;if("f16"===this.format.name)return i+="h",i}i+=`<${this.format.name}>`}else if("vec2"===i||"vec3"===i||"vec4"===i)return i;return i}}var Mn;(i=>{i[i.Uniform=0]="Uniform",i[i.Storage=1]="Storage",i[i.Texture=2]="Texture",i[i.Sampler=3]="Sampler",i[i.StorageTexture=4]="StorageTexture"})(Mn||(Mn={}));class o{constructor(i,g,x,_,v,b,y){this.name=i,this.type=g,this.group=x,this.binding=_,this.attributes=v,this.resourceType=b,this.access=y}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get size(){return this.type.size}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class c{constructor(i,g){this.name=i,this.type=g}}class l{constructor(i,g,x,_){this.name=i,this.type=g,this.locationType=x,this.location=_,this.interpolation=null}}class u{constructor(i,g,x,_){this.name=i,this.type=g,this.locationType=x,this.location=_}}class h{constructor(i,g,x,_){this.name=i,this.type=g,this.attributes=x,this.id=_}}class f{constructor(i,g,x){this.name=i,this.type=g,this.attributes=x}}class p{constructor(i,g=null,x){this.stage=null,this.inputs=[],this.outputs=[],this.arguments=[],this.returnType=null,this.resources=[],this.overrides=[],this.startLine=-1,this.endLine=-1,this.inUse=!1,this.calls=new Set,this.name=i,this.stage=g,this.attributes=x}}class d{constructor(){this.vertex=[],this.fragment=[],this.compute=[]}}function m(i){var g=(32768&i)>>15,x=(31744&i)>>10,_=1023&i;return 0==x?(g?-1:1)*Math.pow(2,-14)*(_/Math.pow(2,10)):31==x?_?NaN:1/0*(g?-1:1):(g?-1:1)*Math.pow(2,x-15)*(1+_/Math.pow(2,10))}const wn=new Float32Array(1),Cn=new Int32Array(wn.buffer),Pn=new Uint16Array(1);function y$1(i){wn[0]=i;const g=Cn[0],x=g>>31&1;let _=g>>23&255,v=8388607&g;if(255===_)return Pn[0]=x<<15|31744|(0!==v?512:0),Pn[0];if(0===_){if(0===v)return Pn[0]=x<<15,Pn[0];v|=8388608;let i=113;for(;!(8388608&v);)v<<=1,i--;return _=127-i,v&=8388607,_>0?(v=(v>>126-_)+(v>>127-_&1),Pn[0]=x<<15|_<<10|v>>13,Pn[0]):(Pn[0]=x<<15,Pn[0])}return _=_-127+15,_>=31?(Pn[0]=x<<15|31744,Pn[0]):_<=0?_<-10?(Pn[0]=x<<15,Pn[0]):(v=(8388608|v)>>1-_,Pn[0]=x<<15|v>>13,Pn[0]):(v>>=13,Pn[0]=x<<15|_<<10|v,Pn[0])}const Rn=new Uint32Array(1),Bn=new Float32Array(Rn.buffer,0,1);function w$1(i){const g=112+(i>>6&31)<<23|(63&i)<<17;return Rn[0]=g,Bn[0]}function I(i,g,x,_){const v=[0,0,0,0];for(let b=0;b<_;++b)switch(x){case"8unorm":v[b]=i[g]/255,g++;break;case"8snorm":v[b]=i[g]/255*2-1,g++;break;case"8uint":v[b]=i[g],g++;break;case"8sint":v[b]=i[g]-127,g++;break;case"16uint":v[b]=i[g]|i[g+1]<<8,g+=2;break;case"16sint":v[b]=(i[g]|i[g+1]<<8)-32768,g+=2;break;case"16float":v[b]=m(i[g]|i[g+1]<<8),g+=2;break;case"32uint":case"32sint":v[b]=i[g]|i[g+1]<<8|i[g+2]<<16|i[g+3]<<24,g+=4;break;case"32float":v[b]=new Float32Array(i.buffer,g,1)[0],g+=4}return v}function T(i,g,x,_,v){for(let b=0;b<_;++b)switch(x){case"8unorm":i[g]=255*v[b],g++;break;case"8snorm":i[g]=.5*(v[b]+1)*255,g++;break;case"8uint":i[g]=v[b],g++;break;case"8sint":i[g]=v[b]+127,g++;break;case"16uint":new Uint16Array(i.buffer,g,1)[0]=v[b],g+=2;break;case"16sint":new Int16Array(i.buffer,g,1)[0]=v[b],g+=2;break;case"16float":{const x=y$1(v[b]);new Uint16Array(i.buffer,g,1)[0]=x,g+=2;break}case"32uint":new Uint32Array(i.buffer,g,1)[0]=v[b],g+=4;break;case"32sint":new Int32Array(i.buffer,g,1)[0]=v[b],g+=4;break;case"32float":new Float32Array(i.buffer,g,1)[0]=v[b],g+=4}return v}const In={r8unorm:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8snorm:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8uint:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8sint:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg8unorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8snorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8uint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8sint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba8unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},"rgba8unorm-srgb":{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8snorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},bgra8unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},"bgra8unorm-srgb":{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},r16uint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r16sint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r16float:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg16uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg16sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg16float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba16uint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba16sint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba16float:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},r32uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r32sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r32float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg32uint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg32sint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg32float:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba32uint:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba32sint:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba32float:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgb10a2uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgb10a2unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rg11b10ufloat:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},stencil8:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!1,hasStencil:!0,channels:1},depth16unorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,channels:1},depth24plus:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,depthOnlyFormat:"depth32float",channels:1},"depth24plus-stencil8":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!0,depthOnlyFormat:"depth32float",channels:1},depth32float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,channels:1},"depth32float-stencil8":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!0,stencilOnlyFormat:"depth32float",channels:1},rgb9e5ufloat:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},"bc1-rgba-unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc1-rgba-unorm-srgb":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc2-rgba-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc2-rgba-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc3-rgba-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc3-rgba-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc4-r-unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:1},"bc4-r-snorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:1},"bc5-rg-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:2},"bc5-rg-snorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:2},"bc6h-rgb-ufloat":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc6h-rgb-float":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc7-rgba-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc7-rgba-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8unorm-srgb":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8a1unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8a1unorm-srgb":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgba8unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgba8unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"eac-r11unorm":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!0,channels:1},"eac-r11snorm":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!0,channels:1},"eac-rg11unorm":{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!0,channels:2},"eac-rg11snorm":{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!0,channels:2},"astc-4x4-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"astc-4x4-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"astc-5x4-unorm":{bytesPerBlock:16,blockWidth:5,blockHeight:4,isCompressed:!0,channels:4},"astc-5x4-unorm-srgb":{bytesPerBlock:16,blockWidth:5,blockHeight:4,isCompressed:!0,channels:4},"astc-5x5-unorm":{bytesPerBlock:16,blockWidth:5,blockHeight:5,isCompressed:!0,channels:4},"astc-5x5-unorm-srgb":{bytesPerBlock:16,blockWidth:5,blockHeight:5,isCompressed:!0,channels:4},"astc-6x5-unorm":{bytesPerBlock:16,blockWidth:6,blockHeight:5,isCompressed:!0,channels:4},"astc-6x5-unorm-srgb":{bytesPerBlock:16,blockWidth:6,blockHeight:5,isCompressed:!0,channels:4},"astc-6x6-unorm":{bytesPerBlock:16,blockWidth:6,blockHeight:6,isCompressed:!0,channels:4},"astc-6x6-unorm-srgb":{bytesPerBlock:16,blockWidth:6,blockHeight:6,isCompressed:!0,channels:4},"astc-8x5-unorm":{bytesPerBlock:16,blockWidth:8,blockHeight:5,isCompressed:!0,channels:4},"astc-8x5-unorm-srgb":{bytesPerBlock:16,blockWidth:8,blockHeight:5,isCompressed:!0,channels:4},"astc-8x6-unorm":{bytesPerBlock:16,blockWidth:8,blockHeight:6,isCompressed:!0,channels:4},"astc-8x6-unorm-srgb":{bytesPerBlock:16,blockWidth:8,blockHeight:6,isCompressed:!0,channels:4},"astc-8x8-unorm":{bytesPerBlock:16,blockWidth:8,blockHeight:8,isCompressed:!0,channels:4},"astc-8x8-unorm-srgb":{bytesPerBlock:16,blockWidth:8,blockHeight:8,isCompressed:!0,channels:4},"astc-10x5-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:5,isCompressed:!0,channels:4},"astc-10x5-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:5,isCompressed:!0,channels:4},"astc-10x6-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:6,isCompressed:!0,channels:4},"astc-10x6-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:6,isCompressed:!0,channels:4},"astc-10x8-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:8,isCompressed:!0,channels:4},"astc-10x8-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:8,isCompressed:!0,channels:4},"astc-10x10-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:10,isCompressed:!0,channels:4},"astc-10x10-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:10,isCompressed:!0,channels:4},"astc-12x10-unorm":{bytesPerBlock:16,blockWidth:12,blockHeight:10,isCompressed:!0,channels:4},"astc-12x10-unorm-srgb":{bytesPerBlock:16,blockWidth:12,blockHeight:10,isCompressed:!0,channels:4},"astc-12x12-unorm":{bytesPerBlock:16,blockWidth:12,blockHeight:12,isCompressed:!0,channels:4},"astc-12x12-unorm-srgb":{bytesPerBlock:16,blockWidth:12,blockHeight:12,isCompressed:!0,channels:4}};class A{constructor(){this.id=A._id++,this.line=0}get isAstNode(){return!0}get astNodeType(){return""}search(i){i(this)}searchBlock(i,g){if(i){g(E.instance);for(const x of i)x instanceof Array?this.searchBlock(x,g):x.search(g);g($.instance)}}constEvaluate(i,g){throw new Error("Cannot evaluate node")}constEvaluateString(i){return this.constEvaluate(i).toString()}}A._id=0;class E extends A{}E.instance=new E;class $ extends A{}$.instance=new $;const En=new Set(["all","all","any","select","arrayLength","abs","acos","acosh","asin","asinh","atan","atanh","atan2","ceil","clamp","cos","cosh","countLeadingZeros","countOneBits","countTrailingZeros","cross","degrees","determinant","distance","dot","dot4U8Packed","dot4I8Packed","exp","exp2","extractBits","faceForward","firstLeadingBit","firstTrailingBit","floor","fma","fract","frexp","insertBits","inverseSqrt","ldexp","length","log","log2","max","min","mix","modf","normalize","pow","quantizeToF16","radians","reflect","refract","reverseBits","round","saturate","sign","sin","sinh","smoothStep","sqrt","step","tan","tanh","transpose","trunc","dpdx","dpdxCoarse","dpdxFine","dpdy","dpdyCoarse","dpdyFine","fwidth","fwidthCoarse","fwidthFine","textureDimensions","textureGather","textureGatherCompare","textureLoad","textureNumLayers","textureNumLevels","textureNumSamples","textureSample","textureSampleBias","textureSampleCompare","textureSampleCompareLevel","textureSampleGrad","textureSampleLevel","textureSampleBaseClampToEdge","textureStore","atomicLoad","atomicStore","atomicAdd","atomicSub","atomicMax","atomicMin","atomicAnd","atomicOr","atomicXor","atomicExchange","atomicCompareExchangeWeak","pack4x8snorm","pack4x8unorm","pack4xI8","pack4xU8","pack4x8Clamp","pack4xU8Clamp","pack2x16snorm","pack2x16unorm","pack2x16float","unpack4x8snorm","unpack4x8unorm","unpack4xI8","unpack4xU8","unpack2x16snorm","unpack2x16unorm","unpack2x16float","storageBarrier","textureBarrier","workgroupBarrier","workgroupUniformLoad","subgroupAdd","subgroupExclusiveAdd","subgroupInclusiveAdd","subgroupAll","subgroupAnd","subgroupAny","subgroupBallot","subgroupBroadcast","subgroupBroadcastFirst","subgroupElect","subgroupMax","subgroupMin","subgroupMul","subgroupExclusiveMul","subgroupInclusiveMul","subgroupOr","subgroupShuffle","subgroupShuffleDown","subgroupShuffleUp","subgroupShuffleXor","subgroupXor","quadBroadcast","quadSwapDiagonal","quadSwapX","quadSwapY"]);class C extends A{constructor(){super()}}class D extends C{constructor(i,g,x,_,v,b){super(),this.calls=new Set,this.name=i,this.args=g,this.returnType=x,this.body=_,this.startLine=v,this.endLine=b}get astNodeType(){return"function"}search(i){if(this.attributes)for(const g of this.attributes)i(g);i(this);for(const g of this.args)i(g);this.searchBlock(this.body,i)}}class N extends C{constructor(i){super(),this.expression=i}get astNodeType(){return"staticAssert"}search(i){this.expression.search(i)}}class V extends C{constructor(i,g){super(),this.condition=i,this.body=g}get astNodeType(){return"while"}search(i){this.condition.search(i),this.searchBlock(this.body,i)}}class O extends C{constructor(i,g){super(),this.body=i,this.loopId=g}get astNodeType(){return"continuing"}search(i){this.searchBlock(this.body,i)}}class B extends C{constructor(i,g,x,_){super(),this.init=i,this.condition=g,this.increment=x,this.body=_}get astNodeType(){return"for"}search(i){var g,x,_;null===(g=this.init)||void 0===g||g.search(i),null===(x=this.condition)||void 0===x||x.search(i),null===(_=this.increment)||void 0===_||_.search(i),this.searchBlock(this.body,i)}}class F extends C{constructor(i,g,x,_,v){super(),this.attributes=null,this.name=i,this.type=g,this.storage=x,this.access=_,this.value=v}get astNodeType(){return"var"}search(i){var g;i(this),null===(g=this.value)||void 0===g||g.search(i)}}class M extends C{constructor(i,g,x){super(),this.attributes=null,this.name=i,this.type=g,this.value=x}get astNodeType(){return"override"}search(i){var g;null===(g=this.value)||void 0===g||g.search(i)}}class U extends C{constructor(i,g,x,_,v){super(),this.attributes=null,this.name=i,this.type=g,this.storage=x,this.access=_,this.value=v}get astNodeType(){return"let"}search(i){var g;i(this),null===(g=this.value)||void 0===g||g.search(i)}}class P extends C{constructor(i,g,x,_,v){super(),this.attributes=null,this.name=i,this.type=g,this.storage=x,this.access=_,this.value=v}get astNodeType(){return"const"}constEvaluate(i,g){return this.value.constEvaluate(i,g)}search(i){var g;i(this),null===(g=this.value)||void 0===g||g.search(i)}}var Dn,Un,Ln,An;(i=>{i.increment="++",i.decrement="--"})(Dn||(Dn={})),(i=>{i.parse=function(g){const x=g;if("parse"==x)throw new Error("Invalid value for IncrementOperator");return i[x]}})(Dn||(Dn={}));class R extends C{constructor(i,g){super(),this.operator=i,this.variable=g}get astNodeType(){return"increment"}search(i){this.variable.search(i)}}(i=>{i.assign="=",i.addAssign="+=",i.subtractAssin="-=",i.multiplyAssign="*=",i.divideAssign="/=",i.moduloAssign="%=",i.andAssign="&=",i.orAssign="|=",i.xorAssign="^=",i.shiftLeftAssign="<<=",i.shiftRightAssign=">>="})(Un||(Un={})),(Un||(Un={})).parse=function(i){const g=i;if("parse"==g)throw new Error("Invalid value for AssignOperator");return g};class G extends C{constructor(i,g,x){super(),this.operator=i,this.variable=g,this.value=x}get astNodeType(){return"assign"}search(i){this.variable.search(i),this.value.search(i)}}class X extends C{constructor(i,g){super(),this.name=i,this.args=g}get astNodeType(){return"call"}isBuiltin(){return En.has(this.name)}search(i){for(const g of this.args)g.search(i);i(this)}}class j extends C{constructor(i,g){super(),this.body=i,this.continuing=g}get astNodeType(){return"loop"}search(i){var g;this.searchBlock(this.body,i),null===(g=this.continuing)||void 0===g||g.search(i)}}class Z extends C{constructor(i,g){super(),this.condition=i,this.cases=g}get astNodeType(){return"switch"}search(i){i(this);for(const g of this.cases)g.search(i)}}class Q extends C{constructor(i,g,x,_){super(),this.condition=i,this.body=g,this.elseif=x,this.else=_}get astNodeType(){return"if"}search(i){this.condition.search(i),this.searchBlock(this.body,i),this.searchBlock(this.elseif,i),this.searchBlock(this.else,i)}}class Y extends C{constructor(i){super(),this.value=i}get astNodeType(){return"return"}search(i){var g;null===(g=this.value)||void 0===g||g.search(i)}}class K extends C{constructor(i){super(),this.name=i}get astNodeType(){return"enable"}}class J extends C{constructor(i){super(),this.extensions=i}get astNodeType(){return"requires"}}class ee extends C{constructor(i,g){super(),this.severity=i,this.rule=g}get astNodeType(){return"diagnostic"}}class te extends C{constructor(i,g){super(),this.name=i,this.type=g}get astNodeType(){return"alias"}}class ne extends C{constructor(){super()}get astNodeType(){return"discard"}}class se extends C{constructor(){super(),this.condition=null,this.loopId=-1}get astNodeType(){return"break"}}class re extends C{constructor(){super(),this.loopId=-1}get astNodeType(){return"continue"}}class ae extends C{constructor(i){super(),this.attributes=null,this.name=i}get astNodeType(){return"type"}get isStruct(){return!1}get isArray(){return!1}static maxFormatType(i){let g=i[0];if("f32"===g.name)return g;for(let x=1;x<i.length;++x){const _=ae._priority.get(g.name);ae._priority.get(i[x].name)<_&&(g=i[x])}return"x32"===g.name?ae.i32:g}getTypeName(){return this.name}}ae.x32=new ae("x32"),ae.f32=new ae("f32"),ae.i32=new ae("i32"),ae.u32=new ae("u32"),ae.f16=new ae("f16"),ae.bool=new ae("bool"),ae.void=new ae("void"),ae._priority=new Map([["f32",0],["f16",1],["u32",2],["i32",3],["x32",3]]);class ie extends ae{constructor(i){super(i)}}class oe extends ae{constructor(i,g,x,_){super(i),this.members=g,this.startLine=x,this.endLine=_}get astNodeType(){return"struct"}get isStruct(){return!0}getMemberIndex(i){for(let g=0;g<this.members.length;g++)if(this.members[g].name==i)return g;return-1}search(i){for(const g of this.members)i(g)}}class ce extends ae{constructor(i,g,x){super(i),this.format=g,this.access=x}get astNodeType(){return"template"}getTypeName(){let i=this.name;if(null!==this.format){if("vec2"===i||"vec3"===i||"vec4"===i||"mat2x2"===i||"mat2x3"===i||"mat2x4"===i||"mat3x2"===i||"mat3x3"===i||"mat3x4"===i||"mat4x2"===i||"mat4x3"===i||"mat4x4"===i){if("f32"===this.format.name)return i+="f",i;if("i32"===this.format.name)return i+="i",i;if("u32"===this.format.name)return i+="u",i;if("bool"===this.format.name)return i+="b",i;if("f16"===this.format.name)return i+="h",i}i+=`<${this.format.name}>`}else if("vec2"===i||"vec3"===i||"vec4"===i)return i;return i}}ce.vec2f=new ce("vec2",ae.f32,null),ce.vec3f=new ce("vec3",ae.f32,null),ce.vec4f=new ce("vec4",ae.f32,null),ce.vec2i=new ce("vec2",ae.i32,null),ce.vec3i=new ce("vec3",ae.i32,null),ce.vec4i=new ce("vec4",ae.i32,null),ce.vec2u=new ce("vec2",ae.u32,null),ce.vec3u=new ce("vec3",ae.u32,null),ce.vec4u=new ce("vec4",ae.u32,null),ce.vec2h=new ce("vec2",ae.f16,null),ce.vec3h=new ce("vec3",ae.f16,null),ce.vec4h=new ce("vec4",ae.f16,null),ce.vec2b=new ce("vec2",ae.bool,null),ce.vec3b=new ce("vec3",ae.bool,null),ce.vec4b=new ce("vec4",ae.bool,null),ce.mat2x2f=new ce("mat2x2",ae.f32,null),ce.mat2x3f=new ce("mat2x3",ae.f32,null),ce.mat2x4f=new ce("mat2x4",ae.f32,null),ce.mat3x2f=new ce("mat3x2",ae.f32,null),ce.mat3x3f=new ce("mat3x3",ae.f32,null),ce.mat3x4f=new ce("mat3x4",ae.f32,null),ce.mat4x2f=new ce("mat4x2",ae.f32,null),ce.mat4x3f=new ce("mat4x3",ae.f32,null),ce.mat4x4f=new ce("mat4x4",ae.f32,null),ce.mat2x2h=new ce("mat2x2",ae.f16,null),ce.mat2x3h=new ce("mat2x3",ae.f16,null),ce.mat2x4h=new ce("mat2x4",ae.f16,null),ce.mat3x2h=new ce("mat3x2",ae.f16,null),ce.mat3x3h=new ce("mat3x3",ae.f16,null),ce.mat3x4h=new ce("mat3x4",ae.f16,null),ce.mat4x2h=new ce("mat4x2",ae.f16,null),ce.mat4x3h=new ce("mat4x3",ae.f16,null),ce.mat4x4h=new ce("mat4x4",ae.f16,null),ce.mat2x2i=new ce("mat2x2",ae.i32,null),ce.mat2x3i=new ce("mat2x3",ae.i32,null),ce.mat2x4i=new ce("mat2x4",ae.i32,null),ce.mat3x2i=new ce("mat3x2",ae.i32,null),ce.mat3x3i=new ce("mat3x3",ae.i32,null),ce.mat3x4i=new ce("mat3x4",ae.i32,null),ce.mat4x2i=new ce("mat4x2",ae.i32,null),ce.mat4x3i=new ce("mat4x3",ae.i32,null),ce.mat4x4i=new ce("mat4x4",ae.i32,null),ce.mat2x2u=new ce("mat2x2",ae.u32,null),ce.mat2x3u=new ce("mat2x3",ae.u32,null),ce.mat2x4u=new ce("mat2x4",ae.u32,null),ce.mat3x2u=new ce("mat3x2",ae.u32,null),ce.mat3x3u=new ce("mat3x3",ae.u32,null),ce.mat3x4u=new ce("mat3x4",ae.u32,null),ce.mat4x2u=new ce("mat4x2",ae.u32,null),ce.mat4x3u=new ce("mat4x3",ae.u32,null),ce.mat4x4u=new ce("mat4x4",ae.u32,null);class le extends ae{constructor(i,g,x,_){super(i),this.storage=g,this.type=x,this.access=_}get astNodeType(){return"pointer"}}class ue extends ae{constructor(i,g,x,_){super(i),this.attributes=g,this.format=x,this.count=_}get astNodeType(){return"array"}get isArray(){return!0}}class he extends ae{constructor(i,g,x){super(i),this.format=g,this.access=x}get astNodeType(){return"sampler"}}class fe extends A{constructor(){super(),this.postfix=null}}class pe extends fe{constructor(i){super(),this.value=i}get astNodeType(){return"stringExpr"}toString(){return this.value}constEvaluateString(){return this.value}}class de extends fe{constructor(i,g){super(),this.type=i,this.args=g}get astNodeType(){return"createExpr"}search(i){if(i(this),this.args)for(const g of this.args)g.search(i)}constEvaluate(i,g){return g&&(g[0]=this.type),i.evalExpression(this,i.context)}}class me extends fe{constructor(i,g){super(),this.cachedReturnValue=null,this.name=i,this.args=g}get astNodeType(){return"callExpr"}setCachedReturnValue(i){this.cachedReturnValue=i}get isBuiltin(){return En.has(this.name)}constEvaluate(i,g){return i.evalExpression(this,i.context)}search(i){for(const g of this.args)g.search(i);i(this)}}class ge extends fe{constructor(i){super(),this.name=i}get astNodeType(){return"varExpr"}search(i){i(this),this.postfix&&this.postfix.search(i)}constEvaluate(i,g){return i.evalExpression(this,i.context)}}class _e extends fe{constructor(i,g){super(),this.name=i,this.initializer=g}get astNodeType(){return"constExpr"}constEvaluate(i,g){if(this.initializer){const g=i.evalExpression(this.initializer,i.context);return null!==g&&this.postfix?g.getSubData(i,this.postfix,i.context):g}return null}search(i){this.initializer.search(i)}}class xe extends fe{constructor(i,g){super(),this.value=i,this.type=g}get astNodeType(){return"literalExpr"}constEvaluate(i,g){return void 0!==g&&(g[0]=this.type),this.value}get isScalar(){return this.value instanceof Be}get isVector(){return this.value instanceof Me||this.value instanceof Ue}get scalarValue(){return this.value instanceof Be?this.value.value:(console.error("Value is not scalar."),0)}get vectorValue(){return this.value instanceof Me||this.value instanceof Ue?this.value.data:(console.error("Value is not a vector or matrix."),new Float32Array(0))}}class ye extends fe{constructor(i,g){super(),this.type=i,this.value=g}get astNodeType(){return"bitcastExpr"}search(i){this.value.search(i)}}class ve extends fe{constructor(i){super(),this.index=i}search(i){this.index.search(i)}}class we extends fe{constructor(){super()}}class ke extends we{constructor(i,g){super(),this.operator=i,this.right=g}get astNodeType(){return"unaryOp"}constEvaluate(i,g){return i.evalExpression(this,i.context)}search(i){this.right.search(i)}}class Ie extends we{constructor(i,g,x){super(),this.operator=i,this.left=g,this.right=x}get astNodeType(){return"binaryOp"}_getPromotedType(i,g){return i.name===g.name?i:"f32"===i.name||"f32"===g.name?ae.f32:"u32"===i.name||"u32"===g.name?ae.u32:ae.i32}constEvaluate(i,g){return i.evalExpression(this,i.context)}search(i){this.left.search(i),this.right.search(i)}}class Te extends A{constructor(i){super(),this.body=i}search(i){i(this),this.searchBlock(this.body,i)}}class Se extends fe{constructor(){super()}get astNodeType(){return"default"}}class Ae extends Te{constructor(i,g){super(g),this.selectors=i}get astNodeType(){return"case"}search(i){this.searchBlock(this.body,i)}}class Ee extends Te{constructor(i){super(i)}get astNodeType(){return"default"}search(i){this.searchBlock(this.body,i)}}class $e extends A{constructor(i,g,x){super(),this.name=i,this.type=g,this.attributes=x}get astNodeType(){return"argument"}}class Le extends A{constructor(i,g){super(),this.condition=i,this.body=g}get astNodeType(){return"elseif"}search(i){this.condition.search(i),this.searchBlock(this.body,i)}}class Ce extends A{constructor(i,g,x){super(),this.name=i,this.type=g,this.attributes=x}get astNodeType(){return"member"}}class De extends A{constructor(i,g){super(),this.name=i,this.value=g}get astNodeType(){return"attribute"}}class Ne{constructor(i,g){this.parent=null,this.typeInfo=i,this.parent=g,this.id=Ne._id++}clone(){throw`Clone:Not implemented for ${this.constructor.name}`}setDataValue(i,g,x,_){console.error(`SetDataValue:Not implemented for ${this.constructor.name}`)}getSubData(i,g,x){return console.error(`GetDataValue:Not implemented for ${this.constructor.name}`),null}toString(){return`<${this.typeInfo.getTypeName()}>`}}Ne._id=0;class Ve extends Ne{constructor(){super(new e("void",null),null)}toString(){return"void"}}Ve.void=new Ve;class Oe extends Ne{constructor(i){super(new r("pointer",i.typeInfo,null),null),this.reference=i}clone(){return this}setDataValue(i,g,x,_){this.reference.setDataValue(i,g,x,_)}getSubData(i,g,x){return g?this.reference.getSubData(i,g,x):this}toString(){return`&${this.reference.toString()}`}}class Be extends Ne{constructor(i,g,x=null){super(g,x),i instanceof Int32Array||i instanceof Uint32Array||i instanceof Float32Array?this.data=i:"x32"===this.typeInfo.name?i-Math.floor(i)!==0?this.data=new Float32Array([i]):this.data=i>=0?new Uint32Array([i]):new Int32Array([i]):"i32"===this.typeInfo.name||"bool"===this.typeInfo.name?this.data=new Int32Array([i]):"u32"===this.typeInfo.name?this.data=new Uint32Array([i]):"f32"===this.typeInfo.name||"f16"===this.typeInfo.name?this.data=new Float32Array([i]):console.error("ScalarData2:Invalid type",g)}clone(){if(this.data instanceof Float32Array)return new Be(new Float32Array(this.data),this.typeInfo,null);if(this.data instanceof Int32Array)return new Be(new Int32Array(this.data),this.typeInfo,null);if(this.data instanceof Uint32Array)return new Be(new Uint32Array(this.data),this.typeInfo,null);throw"ScalarData:Invalid data type"}get value(){return this.data[0]}set value(i){this.data[0]=i}setDataValue(i,g,x,_){if(x)return void console.error("SetDataValue:Scalar data does not support postfix",x);if(!(g instanceof Be))return void console.error("SetDataValue:Invalid value",g);let v=g.data[0];"i32"===this.typeInfo.name||"u32"===this.typeInfo.name?v=Math.floor(v):"bool"===this.typeInfo.name&&(v=v?1:0),this.data[0]=v}getSubData(i,g,x){return g?(console.error("getSubData:Scalar data does not support postfix",g),null):this}toString(){return`${this.value}`}}function Fe(i,g,x){const _=g.length;return 2===_?"f32"===x?new Me(new Float32Array(g),i.getTypeInfo("vec2f")):"i32"===x||"bool"===x?new Me(new Int32Array(g),i.getTypeInfo("vec2i")):"u32"===x?new Me(new Uint32Array(g),i.getTypeInfo("vec2u")):"f16"===x?new Me(new Float32Array(g),i.getTypeInfo("vec2h")):(console.error(`getSubData:Unknown format ${x}`),null):3===_?"f32"===x?new Me(new Float32Array(g),i.getTypeInfo("vec3f")):"i32"===x||"bool"===x?new Me(new Int32Array(g),i.getTypeInfo("vec3i")):"u32"===x?new Me(new Uint32Array(g),i.getTypeInfo("vec3u")):"f16"===x?new Me(new Float32Array(g),i.getTypeInfo("vec3h")):(console.error(`getSubData:Unknown format ${x}`),null):4===_?"f32"===x?new Me(new Float32Array(g),i.getTypeInfo("vec4f")):"i32"===x||"bool"===x?new Me(new Int32Array(g),i.getTypeInfo("vec4i")):"u32"===x?new Me(new Uint32Array(g),i.getTypeInfo("vec4u")):"f16"===x?new Me(new Float32Array(g),i.getTypeInfo("vec4h")):(console.error(`getSubData:Unknown format ${x}`),null):(console.error(`getSubData:Invalid vector size ${g.length}`),null)}class Me extends Ne{constructor(i,g,x=null){if(super(g,x),i instanceof Float32Array||i instanceof Uint32Array||i instanceof Int32Array)this.data=i;else{const g=this.typeInfo.name;"vec2f"===g||"vec3f"===g||"vec4f"===g?this.data=new Float32Array(i):"vec2i"===g||"vec3i"===g||"vec4i"===g?this.data=new Int32Array(i):"vec2u"===g||"vec3u"===g||"vec4u"===g?this.data=new Uint32Array(i):"vec2h"===g||"vec3h"===g||"vec4h"===g?this.data=new Float32Array(i):"vec2b"===g||"vec3b"===g||"vec4b"===g?this.data=new Int32Array(i):"vec2"===g||"vec3"===g||"vec4"===g?this.data=new Float32Array(i):console.error(`VectorData:Invalid type ${g}`)}}clone(){if(this.data instanceof Float32Array)return new Me(new Float32Array(this.data),this.typeInfo,null);if(this.data instanceof Int32Array)return new Me(new Int32Array(this.data),this.typeInfo,null);if(this.data instanceof Uint32Array)return new Me(new Uint32Array(this.data),this.typeInfo,null);throw"VectorData:Invalid data type"}setDataValue(i,g,x,_){x instanceof pe?console.error("TODO:Set vector postfix"):g instanceof Me?this.data=g.data:console.error("SetDataValue:Invalid value",g)}getSubData(i,g,x){if(null===g)return this;let _=i.getTypeInfo("f32");if(this.typeInfo instanceof a)_=this.typeInfo.format||_;else{const g=this.typeInfo.name;"vec2f"===g||"vec3f"===g||"vec4f"===g?_=i.getTypeInfo("f32"):"vec2i"===g||"vec3i"===g||"vec4i"===g?_=i.getTypeInfo("i32"):"vec2b"===g||"vec3b"===g||"vec4b"===g?_=i.getTypeInfo("bool"):"vec2u"===g||"vec3u"===g||"vec4u"===g?_=i.getTypeInfo("u32"):"vec2h"===g||"vec3h"===g||"vec4h"===g?_=i.getTypeInfo("f16"):console.error(`GetSubData:Unknown type ${g}`)}let v=this;for(;null!==g&&null!==v;){if(g instanceof ve){const b=g.index;let y=-1;if(b instanceof xe){if(!(b.value instanceof Be))return console.error(`GetSubData:Invalid array index ${b.value}`),null;y=b.value.value}else{const g=i.evalExpression(b,x);if(!(g instanceof Be))return console.error("GetSubData:Unknown index type",b),null;y=g.value}if(y<0||y>=v.data.length)return console.error("GetSubData:Index out of range",y),null;if(v.data instanceof Float32Array){const i=new Float32Array(v.data.buffer,v.data.byteOffset+4*y,1);return new Be(i,_)}if(v.data instanceof Int32Array){const i=new Int32Array(v.data.buffer,v.data.byteOffset+4*y,1);return new Be(i,_)}if(v.data instanceof Uint32Array){const i=new Uint32Array(v.data.buffer,v.data.byteOffset+4*y,1);return new Be(i,_)}throw"GetSubData:Invalid data type"}if(!(g instanceof pe))return console.error("GetSubData:Unknown postfix",g),null;{const x=g.value.toLowerCase();if(1===x.length){let i=0;if("x"===x||"r"===x)i=0;else if("y"===x||"g"===x)i=1;else if("z"===x||"b"===x)i=2;else{if("w"!==x&&"a"!==x)return console.error(`GetSubData:Unknown member ${x}`),null;i=3}if(this.data instanceof Float32Array){let g=new Float32Array(this.data.buffer,this.data.byteOffset+4*i,1);return new Be(g,_,this)}if(this.data instanceof Int32Array){let g=new Int32Array(this.data.buffer,this.data.byteOffset+4*i,1);return new Be(g,_,this)}if(this.data instanceof Uint32Array){let g=new Uint32Array(this.data.buffer,this.data.byteOffset+4*i,1);return new Be(g,_,this)}}const b=[];for(const i of x)"x"===i||"r"===i?b.push(this.data[0]):"y"===i||"g"===i?b.push(this.data[1]):"z"===i||"b"===i?b.push(this.data[2]):"w"===i||"a"===i?b.push(this.data[3]):console.error(`GetDataValue:Unknown member ${i}`);v=Fe(i,b,_.name)}g=g.postfix}return v}toString(){let i=`${this.data[0]}`;for(let g=1;g<this.data.length;++g)i+=`,${this.data[g]}`;return i}}class Ue extends Ne{constructor(i,g,x=null){super(g,x),i instanceof Float32Array?this.data=i:this.data=new Float32Array(i)}clone(){return new Ue(new Float32Array(this.data),this.typeInfo,null)}setDataValue(i,g,x,_){x instanceof pe?console.error("TODO:Set matrix postfix"):g instanceof Ue?this.data=g.data:console.error("SetDataValue:Invalid value",g)}getSubData(i,g,x){if(null===g)return this;const _=this.typeInfo.name;if(i.getTypeInfo("f32"),this.typeInfo instanceof a)this.typeInfo.format;else if(_.endsWith("f"))i.getTypeInfo("f32");else if(_.endsWith("i"))i.getTypeInfo("i32");else if(_.endsWith("u"))i.getTypeInfo("u32");else{if(!_.endsWith("h"))return console.error(`GetDataValue:Unknown type ${_}`),null;i.getTypeInfo("f16")}if(g instanceof ve){const v=g.index;let b=-1;if(v instanceof xe){if(!(v.value instanceof Be))return console.error(`GetDataValue:Invalid array index ${v.value}`),null;b=v.value.value}else{const g=i.evalExpression(v,x);if(!(g instanceof Be))return console.error("GetDataValue:Unknown index type",v),null;b=g.value}if(b<0||b>=this.data.length)return console.error("GetDataValue:Index out of range",b),null;const y=_.endsWith("h")?"h":"f";let S;if("mat2x2"===_||"mat2x2f"===_||"mat2x2h"===_||"mat3x2"===_||"mat3x2f"===_||"mat3x2h"===_||"mat4x2"===_||"mat4x2f"===_||"mat4x2h"===_)S=new Me(new Float32Array(this.data.buffer,this.data.byteOffset+2*b*4,2),i.getTypeInfo(`vec2${y}`));else if("mat2x3"===_||"mat2x3f"===_||"mat2x3h"===_||"mat3x3"===_||"mat3x3f"===_||"mat3x3h"===_||"mat4x3"===_||"mat4x3f"===_||"mat4x3h"===_)S=new Me(new Float32Array(this.data.buffer,this.data.byteOffset+3*b*4,3),i.getTypeInfo(`vec3${y}`));else{if("mat2x4"!==_&&"mat2x4f"!==_&&"mat2x4h"!==_&&"mat3x4"!==_&&"mat3x4f"!==_&&"mat3x4h"!==_&&"mat4x4"!==_&&"mat4x4f"!==_&&"mat4x4h"!==_)return console.error(`GetDataValue:Unknown type ${_}`),null;S=new Me(new Float32Array(this.data.buffer,this.data.byteOffset+4*b*4,4),i.getTypeInfo(`vec4${y}`))}return g.postfix?S.getSubData(i,g.postfix,x):S}return console.error("GetDataValue:Invalid postfix",g),null}toString(){let i=`${this.data[0]}`;for(let g=1;g<this.data.length;++g)i+=`,${this.data[g]}`;return i}}class Pe extends Ne{constructor(i,g,x=0,_=null){super(g,_),this.buffer=i instanceof ArrayBuffer?i:i.buffer,this.offset=x}clone(){const i=new Uint8Array(new Uint8Array(this.buffer,this.offset,this.typeInfo.size));return new Pe(i.buffer,this.typeInfo,0,null)}setDataValue(i,g,x,_){if(null===g)return void console.log("setDataValue:NULL data.");let v=this.offset,b=this.typeInfo;for(;x;){if(x instanceof ve)if(b instanceof s){const g=x.index;if(g instanceof xe){if(!(g.value instanceof Be))return void console.error(`SetDataValue:Invalid index type ${g.value}`);v+=g.value.value*b.stride}else{const x=i.evalExpression(g,_);if(!(x instanceof Be))return void console.error("SetDataValue:Unknown index type",g);v+=x.value*b.stride}b=b.format}else console.error(`SetDataValue:Type ${b.getTypeName()} is not an array`);else{if(!(x instanceof pe))return void console.error("SetDataValue:Unknown postfix type",x);{const i=x.value;if(b instanceof n){let g=!1;for(const x of b.members)if(x.name===i){v+=x.offset,b=x.type,g=!0;break}if(!g)return void console.error(`SetDataValue:Member ${i} not found`)}else if(b instanceof e){const x=b.getTypeName();let _=0;if("x"===i||"r"===i)_=0;else if("y"===i||"g"===i)_=1;else if("z"===i||"b"===i)_=2;else{if("w"!==i&&"a"!==i)return void console.error(`SetDataValue:Unknown member ${i}`);_=3}if(!(g instanceof Be))return void console.error("SetDataValue:Invalid value",g);const y=g.value;return"vec2f"===x?void(new Float32Array(this.buffer,v,2)[_]=y):"vec3f"===x?void(new Float32Array(this.buffer,v,3)[_]=y):"vec4f"===x?void(new Float32Array(this.buffer,v,4)[_]=y):"vec2i"===x?void(new Int32Array(this.buffer,v,2)[_]=y):"vec3i"===x?void(new Int32Array(this.buffer,v,3)[_]=y):"vec4i"===x?void(new Int32Array(this.buffer,v,4)[_]=y):"vec2u"===x?void(new Uint32Array(this.buffer,v,2)[_]=y):"vec3u"===x?void(new Uint32Array(this.buffer,v,3)[_]=y):"vec4u"===x?void(new Uint32Array(this.buffer,v,4)[_]=y):void console.error(`SetDataValue:Type ${x} is not a struct`)}}}x=x.postfix}this.setData(i,g,b,v,_)}setData(i,g,x,_,v){const b=x.getTypeName();if("f32"!==b&&"f16"!==b)if("i32"!==b&&"atomic<i32>"!==b&&"x32"!==b)if("u32"!==b&&"atomic<u32>"!==b)if("bool"!==b){if("vec2f"===b||"vec2h"===b){const i=new Float32Array(this.buffer,_,2);return void(g instanceof Me?(i[0]=g.data[0],i[1]=g.data[1]):(i[0]=g[0],i[1]=g[1]))}if("vec3f"===b||"vec3h"===b){const i=new Float32Array(this.buffer,_,3);return void(g instanceof Me?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2]):(i[0]=g[0],i[1]=g[1],i[2]=g[2]))}if("vec4f"===b||"vec4h"===b){const i=new Float32Array(this.buffer,_,4);return void(g instanceof Me?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3]))}if("vec2i"===b){const i=new Int32Array(this.buffer,_,2);return void(g instanceof Me?(i[0]=g.data[0],i[1]=g.data[1]):(i[0]=g[0],i[1]=g[1]))}if("vec3i"===b){const i=new Int32Array(this.buffer,_,3);return void(g instanceof Me?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2]):(i[0]=g[0],i[1]=g[1],i[2]=g[2]))}if("vec4i"===b){const i=new Int32Array(this.buffer,_,4);return void(g instanceof Me?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3]))}if("vec2u"===b){const i=new Uint32Array(this.buffer,_,2);return void(g instanceof Me?(i[0]=g.data[0],i[1]=g.data[1]):(i[0]=g[0],i[1]=g[1]))}if("vec3u"===b){const i=new Uint32Array(this.buffer,_,3);return void(g instanceof Me?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2]):(i[0]=g[0],i[1]=g[1],i[2]=g[2]))}if("vec4u"===b){const i=new Uint32Array(this.buffer,_,4);return void(g instanceof Me?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3]))}if("vec2b"===b){const i=new Uint32Array(this.buffer,_,2);return void(g instanceof Me?(i[0]=g.data[0],i[1]=g.data[1]):(i[0]=g[0],i[1]=g[1]))}if("vec3b"===b){const i=new Uint32Array(this.buffer,_,3);return void(g instanceof Me?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2]):(i[0]=g[0],i[1]=g[1],i[2]=g[2]))}if("vec4b"===b){const i=new Uint32Array(this.buffer,_,4);return void(g instanceof Me?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3]))}if("mat2x2f"===b||"mat2x2h"===b){const i=new Float32Array(this.buffer,_,4);return void(g instanceof Ue?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3]))}if("mat2x3f"===b||"mat2x3h"===b){const i=new Float32Array(this.buffer,_,6);return void(g instanceof Ue?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3],i[4]=g.data[4],i[5]=g.data[5]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5]))}if("mat2x4f"===b||"mat2x4h"===b){const i=new Float32Array(this.buffer,_,8);return void(g instanceof Ue?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3],i[4]=g.data[4],i[5]=g.data[5],i[6]=g.data[6],i[7]=g.data[7]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7]))}if("mat3x2f"===b||"mat3x2h"===b){const i=new Float32Array(this.buffer,_,6);return void(g instanceof Ue?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3],i[4]=g.data[4],i[5]=g.data[5]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5]))}if("mat3x3f"===b||"mat3x3h"===b){const i=new Float32Array(this.buffer,_,9);return void(g instanceof Ue?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3],i[4]=g.data[4],i[5]=g.data[5],i[6]=g.data[6],i[7]=g.data[7],i[8]=g.data[8]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7],i[8]=g[8]))}if("mat3x4f"===b||"mat3x4h"===b){const i=new Float32Array(this.buffer,_,12);return void(g instanceof Ue?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3],i[4]=g.data[4],i[5]=g.data[5],i[6]=g.data[6],i[7]=g.data[7],i[8]=g.data[8],i[9]=g.data[9],i[10]=g.data[10],i[11]=g.data[11]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7],i[8]=g[8],i[9]=g[9],i[10]=g[10],i[11]=g[11]))}if("mat4x2f"===b||"mat4x2h"===b){const i=new Float32Array(this.buffer,_,8);return void(g instanceof Ue?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3],i[4]=g.data[4],i[5]=g.data[5],i[6]=g.data[6],i[7]=g.data[7]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7]))}if("mat4x3f"===b||"mat4x3h"===b){const i=new Float32Array(this.buffer,_,12);return void(g instanceof Ue?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3],i[4]=g.data[4],i[5]=g.data[5],i[6]=g.data[6],i[7]=g.data[7],i[8]=g.data[8],i[9]=g.data[9],i[10]=g.data[10],i[11]=g.data[11]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7],i[8]=g[8],i[9]=g[9],i[10]=g[10],i[11]=g[11]))}if("mat4x4f"===b||"mat4x4h"===b){const i=new Float32Array(this.buffer,_,16);return void(g instanceof Ue?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3],i[4]=g.data[4],i[5]=g.data[5],i[6]=g.data[6],i[7]=g.data[7],i[8]=g.data[8],i[9]=g.data[9],i[10]=g.data[10],i[11]=g.data[11],i[12]=g.data[12],i[13]=g.data[13],i[14]=g.data[14],i[15]=g.data[15]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7],i[8]=g[8],i[9]=g[9],i[10]=g[10],i[11]=g[11],i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15]))}if(g instanceof Pe){if(x===g.typeInfo)return void new Uint8Array(this.buffer,_,g.buffer.byteLength).set(new Uint8Array(g.buffer));console.error("SetDataValue:Type mismatch",b,g.typeInfo.getTypeName())}else console.error(`SetData:Unknown type ${b}`)}else g instanceof Be&&(new Int32Array(this.buffer,_,1)[0]=g.value);else g instanceof Be&&(new Uint32Array(this.buffer,_,1)[0]=g.value);else g instanceof Be&&(new Int32Array(this.buffer,_,1)[0]=g.value);else g instanceof Be&&(new Float32Array(this.buffer,_,1)[0]=g.value)}getSubData(i,g,x){var _,v,b;if(null===g)return this;let y=this.offset,S=this.typeInfo;for(;g;){if(g instanceof ve){const _=g.index,v=_ instanceof fe?i.evalExpression(_,x):_;let b=0;if(v instanceof Be?b=v.value:"number"==typeof v?b=v:console.error("GetDataValue:Invalid index type",_),S instanceof s)y+=b*S.stride,S=S.format;else{const g=S.getTypeName();"mat4x4"===g||"mat4x4f"===g||"mat4x4h"===g?(y+=16*b,S=i.getTypeInfo("vec4f")):console.error(`getDataValue:Type ${S.getTypeName()} is not an array`)}}else{if(!(g instanceof pe))return console.error("GetDataValue:Unknown postfix type",g),null;{const x=g.value;if(S instanceof n){let i=!1;for(const g of S.members)if(g.name===x){y+=g.offset,S=g.type,i=!0;break}if(!i)return console.error(`GetDataValue:Member ${x} not found`),null}else if(S instanceof e){const g=S.getTypeName();if("vec2f"===g||"vec3f"===g||"vec4f"===g||"vec2i"===g||"vec3i"===g||"vec4i"===g||"vec2u"===g||"vec3u"===g||"vec4u"===g||"vec2b"===g||"vec3b"===g||"vec4b"===g||"vec2h"===g||"vec3h"===g||"vec4h"===g||"vec2"===g||"vec3"===g||"vec4"===g){if(x.length>0&&x.length<5){let _="f";const v=[];for(let b=0;b<x.length;++b){const S=x[b].toLowerCase();let w=0;if("x"===S||"r"===S)w=0;else if("y"===S||"g"===S)w=1;else if("z"===S||"b"===S)w=2;else{if("w"!==S&&"a"!==S)return console.error(`Unknown member ${x}`),null;w=3}if(1===x.length){if(g.endsWith("f"))return this.buffer.byteLength<y+4*w+4?(console.log("Insufficient buffer data"),null):new Be(new Float32Array(this.buffer,y+4*w,1),i.getTypeInfo("f32"),this);if(g.endsWith("h"))return new Be(new Float32Array(this.buffer,y+4*w,1),i.getTypeInfo("f16"),this);if(g.endsWith("i"))return new Be(new Int32Array(this.buffer,y+4*w,1),i.getTypeInfo("i32"),this);if(g.endsWith("b"))return new Be(new Int32Array(this.buffer,y+4*w,1),i.getTypeInfo("bool"),this);if(g.endsWith("u"))return new Be(new Uint32Array(this.buffer,y+4*w,1),i.getTypeInfo("i32"),this)}if("vec2f"===g)v.push(new Float32Array(this.buffer,y,2)[w]);else if("vec3f"===g){if(y+12>=this.buffer.byteLength)return console.log("Insufficient buffer data"),null;const i=new Float32Array(this.buffer,y,3);v.push(i[w])}else if("vec4f"===g)v.push(new Float32Array(this.buffer,y,4)[w]);else if("vec2i"===g)_="i",v.push(new Int32Array(this.buffer,y,2)[w]);else if("vec3i"===g)_="i",v.push(new Int32Array(this.buffer,y,3)[w]);else if("vec4i"===g)_="i",v.push(new Int32Array(this.buffer,y,4)[w]);else if("vec2u"===g){_="u";const i=new Uint32Array(this.buffer,y,2);v.push(i[w])}else"vec3u"===g?(_="u",v.push(new Uint32Array(this.buffer,y,3)[w])):"vec4u"===g&&(_="u",v.push(new Uint32Array(this.buffer,y,4)[w]))}return 2===v.length?S=i.getTypeInfo(`vec2${_}`):3===v.length?S=i.getTypeInfo(`vec3${_}`):4===v.length?S=i.getTypeInfo(`vec4${_}`):console.error(`GetDataValue:Invalid vector length ${v.length}`),new Me(v,S,null)}return console.error(`GetDataValue:Unknown member ${x}`),null}return console.error(`GetDataValue:Type ${g} is not a struct`),null}}}g=g.postfix}const w=S.getTypeName();return"f32"===w?new Be(new Float32Array(this.buffer,y,1),S,this):"i32"===w?new Be(new Int32Array(this.buffer,y,1),S,this):"u32"===w?new Be(new Uint32Array(this.buffer,y,1),S,this):"vec2f"===w?new Me(new Float32Array(this.buffer,y,2),S,this):"vec3f"===w?new Me(new Float32Array(this.buffer,y,3),S,this):"vec4f"===w?new Me(new Float32Array(this.buffer,y,4),S,this):"vec2i"===w?new Me(new Int32Array(this.buffer,y,2),S,this):"vec3i"===w?new Me(new Int32Array(this.buffer,y,3),S,this):"vec4i"===w?new Me(new Int32Array(this.buffer,y,4),S,this):"vec2u"===w?new Me(new Uint32Array(this.buffer,y,2),S,this):"vec3u"===w?new Me(new Uint32Array(this.buffer,y,3),S,this):"vec4u"===w?new Me(new Uint32Array(this.buffer,y,4),S,this):S instanceof a&&"atomic"===S.name?"u32"===(null===(_=S.format)||void 0===_?void 0:_.name)?new Be(new Uint32Array(this.buffer,y,1)[0],S.format,this):"i32"===(null===(v=S.format)||void 0===v?void 0:v.name)?new Be(new Int32Array(this.buffer,y,1)[0],S.format,this):(console.error(`GetDataValue:Invalid atomic format ${null===(b=S.format)||void 0===b?void 0:b.name}`),null):new Pe(this.buffer,S,y,this)}toString(){let i="";if(this.typeInfo instanceof s)if("f32"===this.typeInfo.format.name){const g=new Float32Array(this.buffer,this.offset);i=`[${g[0]}`;for(let x=1;x<g.length;++x)i+=`,${g[x]}`}else if("i32"===this.typeInfo.format.name){const g=new Int32Array(this.buffer,this.offset);i=`[${g[0]}`;for(let x=1;x<g.length;++x)i+=`,${g[x]}`}else if("u32"===this.typeInfo.format.name){const g=new Uint32Array(this.buffer,this.offset);i=`[${g[0]}`;for(let x=1;x<g.length;++x)i+=`,${g[x]}`}else if("vec2f"===this.typeInfo.format.name){const g=new Float32Array(this.buffer,this.offset);i=`[${g[0]},${g[1]}]`;for(let x=1;x<g.length/2;++x)i+=`,[${g[2*x]},${g[2*x+1]}]`}else if("vec3f"===this.typeInfo.format.name){const g=new Float32Array(this.buffer,this.offset);i=`[${g[0]},${g[1]},${g[2]}]`;for(let x=4;x<g.length;x+=4)i+=`,[${g[x]},${g[x+1]},${g[x+2]}]`}else if("vec4f"===this.typeInfo.format.name){const g=new Float32Array(this.buffer,this.offset);i=`[${g[0]},${g[1]},${g[2]},${g[3]}]`;for(let x=4;x<g.length;x+=4)i+=`,[${g[x]},${g[x+1]},${g[x+2]},${g[x+3]}]`}else i="[...]";else this.typeInfo instanceof n?i+="{...}":i="[...]";return i}}class We extends Ne{constructor(i,g,x,_){super(g,null),this.data=i,this.descriptor=x,this.view=_}clone(){return new We(this.data,this.typeInfo,this.descriptor,this.view)}get width(){var i,g;const x=this.descriptor.size;return x instanceof Array&&x.length>0?null!==(i=x[0])&&void 0!==i?i:0:x instanceof Object&&null!==(g=x.width)&&void 0!==g?g:0}get height(){var i,g;const x=this.descriptor.size;return x instanceof Array&&x.length>1?null!==(i=x[1])&&void 0!==i?i:0:x instanceof Object&&null!==(g=x.height)&&void 0!==g?g:0}get depthOrArrayLayers(){var i,g;const x=this.descriptor.size;return x instanceof Array&&x.length>2?null!==(i=x[2])&&void 0!==i?i:0:x instanceof Object&&null!==(g=x.depthOrArrayLayers)&&void 0!==g?g:0}get format(){var i;return this.descriptor&&null!==(i=this.descriptor.format)&&void 0!==i?i:"rgba8unorm"}get sampleCount(){var i;return this.descriptor&&null!==(i=this.descriptor.sampleCount)&&void 0!==i?i:1}get mipLevelCount(){var i;return this.descriptor&&null!==(i=this.descriptor.mipLevelCount)&&void 0!==i?i:1}get dimension(){var i;return this.descriptor&&null!==(i=this.descriptor.dimension)&&void 0!==i?i:"2d"}getMipLevelSize(i){if(i>=this.mipLevelCount)return[0,0,0];const g=[this.width,this.height,this.depthOrArrayLayers];for(let x=0;x<g.length;++x)g[x]=Math.max(1,g[x]>>i);return g}get texelByteSize(){const i=this.format,g=In[i];return g?g.isDepthStencil?4:g.bytesPerBlock:0}get bytesPerRow(){return this.width*this.texelByteSize}get isDepthStencil(){const i=this.format,g=In[i];return!!g&&g.isDepthStencil}getGpuSize(){const i=this.format,g=In[i],x=this.width;if(!i||x<=0||!g)return-1;const _=this.height,v=this.depthOrArrayLayers,b=this.dimension;return x/g.blockWidth*("1d"===b?1:_/g.blockHeight)*g.bytesPerBlock*v}getPixel(i,g,x=0,_=0){const v=this.texelByteSize,b=this.bytesPerRow,y=this.height,S=this.data[_];return function(i,g,x,_,v,b,y,S,w){const L=_*(y>>=v)*(b>>=v)+x*y+g*S;switch(w){case"r8unorm":return[I(i,L,"8unorm",1)[0]];case"r8snorm":return[I(i,L,"8snorm",1)[0]];case"r8uint":return[I(i,L,"8uint",1)[0]];case"r8sint":return[I(i,L,"8sint",1)[0]];case"rg8unorm":{const g=I(i,L,"8unorm",2);return[g[0],g[1]]}case"rg8snorm":{const g=I(i,L,"8snorm",2);return[g[0],g[1]]}case"rg8uint":{const g=I(i,L,"8uint",2);return[g[0],g[1]]}case"rg8sint":{const g=I(i,L,"8sint",2);return[g[0],g[1]]}case"rgba8unorm-srgb":case"rgba8unorm":{const g=I(i,L,"8unorm",4);return[g[0],g[1],g[2],g[3]]}case"rgba8snorm":{const g=I(i,L,"8snorm",4);return[g[0],g[1],g[2],g[3]]}case"rgba8uint":{const g=I(i,L,"8uint",4);return[g[0],g[1],g[2],g[3]]}case"rgba8sint":{const g=I(i,L,"8sint",4);return[g[0],g[1],g[2],g[3]]}case"bgra8unorm-srgb":case"bgra8unorm":{const g=I(i,L,"8unorm",4);return[g[2],g[1],g[0],g[3]]}case"r16uint":return[I(i,L,"16uint",1)[0]];case"r16sint":return[I(i,L,"16sint",1)[0]];case"r16float":return[I(i,L,"16float",1)[0]];case"rg16uint":{const g=I(i,L,"16uint",2);return[g[0],g[1]]}case"rg16sint":{const g=I(i,L,"16sint",2);return[g[0],g[1]]}case"rg16float":{const g=I(i,L,"16float",2);return[g[0],g[1]]}case"rgba16uint":{const g=I(i,L,"16uint",4);return[g[0],g[1],g[2],g[3]]}case"rgba16sint":{const g=I(i,L,"16sint",4);return[g[0],g[1],g[2],g[3]]}case"rgba16float":{const g=I(i,L,"16float",4);return[g[0],g[1],g[2],g[3]]}case"r32uint":return[I(i,L,"32uint",1)[0]];case"r32sint":return[I(i,L,"32sint",1)[0]];case"depth16unorm":case"depth24plus":case"depth24plus-stencil8":case"depth32float":case"depth32float-stencil8":case"r32float":return[I(i,L,"32float",1)[0]];case"rg32uint":{const g=I(i,L,"32uint",2);return[g[0],g[1]]}case"rg32sint":{const g=I(i,L,"32sint",2);return[g[0],g[1]]}case"rg32float":{const g=I(i,L,"32float",2);return[g[0],g[1]]}case"rgba32uint":{const g=I(i,L,"32uint",4);return[g[0],g[1],g[2],g[3]]}case"rgba32sint":{const g=I(i,L,"32sint",4);return[g[0],g[1],g[2],g[3]]}case"rgba32float":{const g=I(i,L,"32float",4);return[g[0],g[1],g[2],g[3]]}case"rg11b10ufloat":{const g=new Uint32Array(i.buffer,L,1)[0],x=(4192256&g)>>11,_=(4290772992&g)>>22;return[w$1(2047&g),w$1(x),function(i){const g=112+(i>>5&31)<<23|(31&i)<<18;return Rn[0]=g,Bn[0]}(_),1]}}return null}(new Uint8Array(S),i,g,x,_,y,b,v,this.format)}setPixel(i,g,x,_,v){const b=this.texelByteSize,y=this.bytesPerRow,S=this.height,w=this.data[_];!function(i,g,x,_,v,b,y,S,w,L){const k=_*(y>>=v)*(b>>=v)+x*y+g*S;switch(w){case"r8unorm":return void T(i,k,"8unorm",1,L);case"r8snorm":return void T(i,k,"8snorm",1,L);case"r8uint":return void T(i,k,"8uint",1,L);case"r8sint":return void T(i,k,"8sint",1,L);case"rg8unorm":return void T(i,k,"8unorm",2,L);case"rg8snorm":return void T(i,k,"8snorm",2,L);case"rg8uint":return void T(i,k,"8uint",2,L);case"rg8sint":return void T(i,k,"8sint",2,L);case"rgba8unorm-srgb":case"rgba8unorm":case"bgra8unorm-srgb":case"bgra8unorm":return void T(i,k,"8unorm",4,L);case"rgba8snorm":return void T(i,k,"8snorm",4,L);case"rgba8uint":return void T(i,k,"8uint",4,L);case"rgba8sint":return void T(i,k,"8sint",4,L);case"r16uint":return void T(i,k,"16uint",1,L);case"r16sint":return void T(i,k,"16sint",1,L);case"r16float":return void T(i,k,"16float",1,L);case"rg16uint":return void T(i,k,"16uint",2,L);case"rg16sint":return void T(i,k,"16sint",2,L);case"rg16float":return void T(i,k,"16float",2,L);case"rgba16uint":return void T(i,k,"16uint",4,L);case"rgba16sint":return void T(i,k,"16sint",4,L);case"rgba16float":return void T(i,k,"16float",4,L);case"r32uint":return void T(i,k,"32uint",1,L);case"r32sint":return void T(i,k,"32sint",1,L);case"depth16unorm":case"depth24plus":case"depth24plus-stencil8":case"depth32float":case"depth32float-stencil8":case"r32float":return void T(i,k,"32float",1,L);case"rg32uint":return void T(i,k,"32uint",2,L);case"rg32sint":return void T(i,k,"32sint",2,L);case"rg32float":return void T(i,k,"32float",2,L);case"rgba32uint":return void T(i,k,"32uint",4,L);case"rgba32sint":return void T(i,k,"32sint",4,L);case"rgba32float":return void T(i,k,"32float",4,L);case"rg11b10ufloat":console.error("TODO:rg11b10ufloat not supported for writing")}}(new Uint8Array(w),i,g,x,_,S,y,b,this.format,v)}}(i=>{i[i.token=0]="token",i[i.keyword=1]="keyword",i[i.reserved=2]="reserved"})(An||(An={}));class qe{constructor(i,g,x){this.name=i,this.type=g,this.rule=x}toString(){return this.name}}class He{}Ln=He,He.none=new qe("",An.reserved,""),He.eof=new qe("EOF",An.token,""),He.reserved={asm:new qe("asm",An.reserved,"asm"),bf16:new qe("bf16",An.reserved,"bf16"),do:new qe("do",An.reserved,"do"),enum:new qe("enum",An.reserved,"enum"),f16:new qe("f16",An.reserved,"f16"),f64:new qe("f64",An.reserved,"f64"),handle:new qe("handle",An.reserved,"handle"),i8:new qe("i8",An.reserved,"i8"),i16:new qe("i16",An.reserved,"i16"),i64:new qe("i64",An.reserved,"i64"),mat:new qe("mat",An.reserved,"mat"),premerge:new qe("premerge",An.reserved,"premerge"),regardless:new qe("regardless",An.reserved,"regardless"),typedef:new qe("typedef",An.reserved,"typedef"),u8:new qe("u8",An.reserved,"u8"),u16:new qe("u16",An.reserved,"u16"),u64:new qe("u64",An.reserved,"u64"),unless:new qe("unless",An.reserved,"unless"),using:new qe("using",An.reserved,"using"),vec:new qe("vec",An.reserved,"vec"),void:new qe("void",An.reserved,"void")},He.keywords={array:new qe("array",An.keyword,"array"),atomic:new qe("atomic",An.keyword,"atomic"),bool:new qe("bool",An.keyword,"bool"),f32:new qe("f32",An.keyword,"f32"),i32:new qe("i32",An.keyword,"i32"),mat2x2:new qe("mat2x2",An.keyword,"mat2x2"),mat2x3:new qe("mat2x3",An.keyword,"mat2x3"),mat2x4:new qe("mat2x4",An.keyword,"mat2x4"),mat3x2:new qe("mat3x2",An.keyword,"mat3x2"),mat3x3:new qe("mat3x3",An.keyword,"mat3x3"),mat3x4:new qe("mat3x4",An.keyword,"mat3x4"),mat4x2:new qe("mat4x2",An.keyword,"mat4x2"),mat4x3:new qe("mat4x3",An.keyword,"mat4x3"),mat4x4:new qe("mat4x4",An.keyword,"mat4x4"),ptr:new qe("ptr",An.keyword,"ptr"),sampler:new qe("sampler",An.keyword,"sampler"),sampler_comparison:new qe("sampler_comparison",An.keyword,"sampler_comparison"),struct:new qe("struct",An.keyword,"struct"),texture_1d:new qe("texture_1d",An.keyword,"texture_1d"),texture_2d:new qe("texture_2d",An.keyword,"texture_2d"),texture_2d_array:new qe("texture_2d_array",An.keyword,"texture_2d_array"),texture_3d:new qe("texture_3d",An.keyword,"texture_3d"),texture_cube:new qe("texture_cube",An.keyword,"texture_cube"),texture_cube_array:new qe("texture_cube_array",An.keyword,"texture_cube_array"),texture_multisampled_2d:new qe("texture_multisampled_2d",An.keyword,"texture_multisampled_2d"),texture_storage_1d:new qe("texture_storage_1d",An.keyword,"texture_storage_1d"),texture_storage_2d:new qe("texture_storage_2d",An.keyword,"texture_storage_2d"),texture_storage_2d_array:new qe("texture_storage_2d_array",An.keyword,"texture_storage_2d_array"),texture_storage_3d:new qe("texture_storage_3d",An.keyword,"texture_storage_3d"),texture_depth_2d:new qe("texture_depth_2d",An.keyword,"texture_depth_2d"),texture_depth_2d_array:new qe("texture_depth_2d_array",An.keyword,"texture_depth_2d_array"),texture_depth_cube:new qe("texture_depth_cube",An.keyword,"texture_depth_cube"),texture_depth_cube_array:new qe("texture_depth_cube_array",An.keyword,"texture_depth_cube_array"),texture_depth_multisampled_2d:new qe("texture_depth_multisampled_2d",An.keyword,"texture_depth_multisampled_2d"),texture_external:new qe("texture_external",An.keyword,"texture_external"),u32:new qe("u32",An.keyword,"u32"),vec2:new qe("vec2",An.keyword,"vec2"),vec3:new qe("vec3",An.keyword,"vec3"),vec4:new qe("vec4",An.keyword,"vec4"),bitcast:new qe("bitcast",An.keyword,"bitcast"),block:new qe("block",An.keyword,"block"),break:new qe("break",An.keyword,"break"),case:new qe("case",An.keyword,"case"),continue:new qe("continue",An.keyword,"continue"),continuing:new qe("continuing",An.keyword,"continuing"),default:new qe("default",An.keyword,"default"),diagnostic:new qe("diagnostic",An.keyword,"diagnostic"),discard:new qe("discard",An.keyword,"discard"),else:new qe("else",An.keyword,"else"),enable:new qe("enable",An.keyword,"enable"),fallthrough:new qe("fallthrough",An.keyword,"fallthrough"),false:new qe("false",An.keyword,"false"),fn:new qe("fn",An.keyword,"fn"),for:new qe("for",An.keyword,"for"),function:new qe("function",An.keyword,"function"),if:new qe("if",An.keyword,"if"),let:new qe("let",An.keyword,"let"),const:new qe("const",An.keyword,"const"),loop:new qe("loop",An.keyword,"loop"),while:new qe("while",An.keyword,"while"),private:new qe("private",An.keyword,"private"),read:new qe("read",An.keyword,"read"),read_write:new qe("read_write",An.keyword,"read_write"),return:new qe("return",An.keyword,"return"),requires:new qe("requires",An.keyword,"requires"),storage:new qe("storage",An.keyword,"storage"),switch:new qe("switch",An.keyword,"switch"),true:new qe("true",An.keyword,"true"),alias:new qe("alias",An.keyword,"alias"),type:new qe("type",An.keyword,"type"),uniform:new qe("uniform",An.keyword,"uniform"),var:new qe("var",An.keyword,"var"),override:new qe("override",An.keyword,"override"),workgroup:new qe("workgroup",An.keyword,"workgroup"),write:new qe("write",An.keyword,"write"),r8unorm:new qe("r8unorm",An.keyword,"r8unorm"),r8snorm:new qe("r8snorm",An.keyword,"r8snorm"),r8uint:new qe("r8uint",An.keyword,"r8uint"),r8sint:new qe("r8sint",An.keyword,"r8sint"),r16uint:new qe("r16uint",An.keyword,"r16uint"),r16sint:new qe("r16sint",An.keyword,"r16sint"),r16float:new qe("r16float",An.keyword,"r16float"),rg8unorm:new qe("rg8unorm",An.keyword,"rg8unorm"),rg8snorm:new qe("rg8snorm",An.keyword,"rg8snorm"),rg8uint:new qe("rg8uint",An.keyword,"rg8uint"),rg8sint:new qe("rg8sint",An.keyword,"rg8sint"),r32uint:new qe("r32uint",An.keyword,"r32uint"),r32sint:new qe("r32sint",An.keyword,"r32sint"),r32float:new qe("r32float",An.keyword,"r32float"),rg16uint:new qe("rg16uint",An.keyword,"rg16uint"),rg16sint:new qe("rg16sint",An.keyword,"rg16sint"),rg16float:new qe("rg16float",An.keyword,"rg16float"),rgba8unorm:new qe("rgba8unorm",An.keyword,"rgba8unorm"),rgba8unorm_srgb:new qe("rgba8unorm_srgb",An.keyword,"rgba8unorm_srgb"),rgba8snorm:new qe("rgba8snorm",An.keyword,"rgba8snorm"),rgba8uint:new qe("rgba8uint",An.keyword,"rgba8uint"),rgba8sint:new qe("rgba8sint",An.keyword,"rgba8sint"),bgra8unorm:new qe("bgra8unorm",An.keyword,"bgra8unorm"),bgra8unorm_srgb:new qe("bgra8unorm_srgb",An.keyword,"bgra8unorm_srgb"),rgb10a2unorm:new qe("rgb10a2unorm",An.keyword,"rgb10a2unorm"),rg11b10float:new qe("rg11b10float",An.keyword,"rg11b10float"),rg32uint:new qe("rg32uint",An.keyword,"rg32uint"),rg32sint:new qe("rg32sint",An.keyword,"rg32sint"),rg32float:new qe("rg32float",An.keyword,"rg32float"),rgba16uint:new qe("rgba16uint",An.keyword,"rgba16uint"),rgba16sint:new qe("rgba16sint",An.keyword,"rgba16sint"),rgba16float:new qe("rgba16float",An.keyword,"rgba16float"),rgba32uint:new qe("rgba32uint",An.keyword,"rgba32uint"),rgba32sint:new qe("rgba32sint",An.keyword,"rgba32sint"),rgba32float:new qe("rgba32float",An.keyword,"rgba32float"),static_assert:new qe("static_assert",An.keyword,"static_assert")},He.tokens={decimal_float_literal:new qe("decimal_float_literal",An.token,/((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/),hex_float_literal:new qe("hex_float_literal",An.token,/-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+[fh]?))/),int_literal:new qe("int_literal",An.token,/-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),uint_literal:new qe("uint_literal",An.token,/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),name:new qe("name",An.token,/([_\p{XID_Start}][\p{XID_Continue}]+)|([\p{XID_Start}])/u),ident:new qe("ident",An.token,/[_a-zA-Z][0-9a-zA-Z_]*/),and:new qe("and",An.token,"&"),and_and:new qe("and_and",An.token,"&&"),arrow:new qe("arrow ",An.token,"->"),attr:new qe("attr",An.token,"@"),forward_slash:new qe("forward_slash",An.token,"/"),bang:new qe("bang",An.token,"!"),bracket_left:new qe("bracket_left",An.token,"["),bracket_right:new qe("bracket_right",An.token,"]"),brace_left:new qe("brace_left",An.token,"{"),brace_right:new qe("brace_right",An.token,"}"),colon:new qe("colon",An.token,":"),comma:new qe("comma",An.token,","),equal:new qe("equal",An.token,"="),equal_equal:new qe("equal_equal",An.token,"=="),not_equal:new qe("not_equal",An.token,"!="),greater_than:new qe("greater_than",An.token,">"),greater_than_equal:new qe("greater_than_equal",An.token,">="),shift_right:new qe("shift_right",An.token,">>"),less_than:new qe("less_than",An.token,"<"),less_than_equal:new qe("less_than_equal",An.token,"<="),shift_left:new qe("shift_left",An.token,"<<"),modulo:new qe("modulo",An.token,"%"),minus:new qe("minus",An.token,"-"),minus_minus:new qe("minus_minus",An.token,"--"),period:new qe("period",An.token,"."),plus:new qe("plus",An.token,"+"),plus_plus:new qe("plus_plus",An.token,"++"),or:new qe("or",An.token,"|"),or_or:new qe("or_or",An.token,"||"),paren_left:new qe("paren_left",An.token,"("),paren_right:new qe("paren_right",An.token,")"),semicolon:new qe("semicolon",An.token,";"),star:new qe("star",An.token,"*"),tilde:new qe("tilde",An.token,"~"),underscore:new qe("underscore",An.token,"_"),xor:new qe("xor",An.token,"^"),plus_equal:new qe("plus_equal",An.token,"+="),minus_equal:new qe("minus_equal",An.token,"-="),times_equal:new qe("times_equal",An.token,"*="),division_equal:new qe("division_equal",An.token,"/="),modulo_equal:new qe("modulo_equal",An.token,"%="),and_equal:new qe("and_equal",An.token,"&="),or_equal:new qe("or_equal",An.token,"|="),xor_equal:new qe("xor_equal",An.token,"^="),shift_right_equal:new qe("shift_right_equal",An.token,">>="),shift_left_equal:new qe("shift_left_equal",An.token,"<<=")},He.simpleTokens={"@":Ln.tokens.attr,"{":Ln.tokens.brace_left,"}":Ln.tokens.brace_right,":":Ln.tokens.colon,",":Ln.tokens.comma,"(":Ln.tokens.paren_left,")":Ln.tokens.paren_right,";":Ln.tokens.semicolon},He.literalTokens={"&":Ln.tokens.and,"&&":Ln.tokens.and_and,"->":Ln.tokens.arrow,"/":Ln.tokens.forward_slash,"!":Ln.tokens.bang,"[":Ln.tokens.bracket_left,"]":Ln.tokens.bracket_right,"=":Ln.tokens.equal,"==":Ln.tokens.equal_equal,"!=":Ln.tokens.not_equal,">":Ln.tokens.greater_than,">=":Ln.tokens.greater_than_equal,">>":Ln.tokens.shift_right,"<":Ln.tokens.less_than,"<=":Ln.tokens.less_than_equal,"<<":Ln.tokens.shift_left,"%":Ln.tokens.modulo,"-":Ln.tokens.minus,"--":Ln.tokens.minus_minus,".":Ln.tokens.period,"+":Ln.tokens.plus,"++":Ln.tokens.plus_plus,"|":Ln.tokens.or,"||":Ln.tokens.or_or,"*":Ln.tokens.star,"~":Ln.tokens.tilde,_:Ln.tokens.underscore,"^":Ln.tokens.xor,"+=":Ln.tokens.plus_equal,"-=":Ln.tokens.minus_equal,"*=":Ln.tokens.times_equal,"/=":Ln.tokens.division_equal,"%=":Ln.tokens.modulo_equal,"&=":Ln.tokens.and_equal,"|=":Ln.tokens.or_equal,"^=":Ln.tokens.xor_equal,">>=":Ln.tokens.shift_right_equal,"<<=":Ln.tokens.shift_left_equal},He.regexTokens={decimal_float_literal:Ln.tokens.decimal_float_literal,hex_float_literal:Ln.tokens.hex_float_literal,int_literal:Ln.tokens.int_literal,uint_literal:Ln.tokens.uint_literal,ident:Ln.tokens.ident},He.storage_class=[Ln.keywords.function,Ln.keywords.private,Ln.keywords.workgroup,Ln.keywords.uniform,Ln.keywords.storage],He.access_mode=[Ln.keywords.read,Ln.keywords.write,Ln.keywords.read_write],He.sampler_type=[Ln.keywords.sampler,Ln.keywords.sampler_comparison],He.sampled_texture_type=[Ln.keywords.texture_1d,Ln.keywords.texture_2d,Ln.keywords.texture_2d_array,Ln.keywords.texture_3d,Ln.keywords.texture_cube,Ln.keywords.texture_cube_array],He.multisampled_texture_type=[Ln.keywords.texture_multisampled_2d],He.storage_texture_type=[Ln.keywords.texture_storage_1d,Ln.keywords.texture_storage_2d,Ln.keywords.texture_storage_2d_array,Ln.keywords.texture_storage_3d],He.depth_texture_type=[Ln.keywords.texture_depth_2d,Ln.keywords.texture_depth_2d_array,Ln.keywords.texture_depth_cube,Ln.keywords.texture_depth_cube_array,Ln.keywords.texture_depth_multisampled_2d],He.texture_external_type=[Ln.keywords.texture_external],He.any_texture_type=[...Ln.sampled_texture_type,...Ln.multisampled_texture_type,...Ln.storage_texture_type,...Ln.depth_texture_type,...Ln.texture_external_type],He.texel_format=[Ln.keywords.r8unorm,Ln.keywords.r8snorm,Ln.keywords.r8uint,Ln.keywords.r8sint,Ln.keywords.r16uint,Ln.keywords.r16sint,Ln.keywords.r16float,Ln.keywords.rg8unorm,Ln.keywords.rg8snorm,Ln.keywords.rg8uint,Ln.keywords.rg8sint,Ln.keywords.r32uint,Ln.keywords.r32sint,Ln.keywords.r32float,Ln.keywords.rg16uint,Ln.keywords.rg16sint,Ln.keywords.rg16float,Ln.keywords.rgba8unorm,Ln.keywords.rgba8unorm_srgb,Ln.keywords.rgba8snorm,Ln.keywords.rgba8uint,Ln.keywords.rgba8sint,Ln.keywords.bgra8unorm,Ln.keywords.bgra8unorm_srgb,Ln.keywords.rgb10a2unorm,Ln.keywords.rg11b10float,Ln.keywords.rg32uint,Ln.keywords.rg32sint,Ln.keywords.rg32float,Ln.keywords.rgba16uint,Ln.keywords.rgba16sint,Ln.keywords.rgba16float,Ln.keywords.rgba32uint,Ln.keywords.rgba32sint,Ln.keywords.rgba32float],He.const_literal=[Ln.tokens.int_literal,Ln.tokens.uint_literal,Ln.tokens.decimal_float_literal,Ln.tokens.hex_float_literal,Ln.keywords.true,Ln.keywords.false],He.literal_or_ident=[Ln.tokens.ident,Ln.tokens.int_literal,Ln.tokens.uint_literal,Ln.tokens.decimal_float_literal,Ln.tokens.hex_float_literal,Ln.tokens.name],He.element_count_expression=[Ln.tokens.int_literal,Ln.tokens.uint_literal,Ln.tokens.ident],He.template_types=[Ln.keywords.vec2,Ln.keywords.vec3,Ln.keywords.vec4,Ln.keywords.mat2x2,Ln.keywords.mat2x3,Ln.keywords.mat2x4,Ln.keywords.mat3x2,Ln.keywords.mat3x3,Ln.keywords.mat3x4,Ln.keywords.mat4x2,Ln.keywords.mat4x3,Ln.keywords.mat4x4,Ln.keywords.atomic,Ln.keywords.bitcast,...Ln.any_texture_type],He.attribute_name=[Ln.tokens.ident,Ln.keywords.block,Ln.keywords.diagnostic],He.assignment_operators=[Ln.tokens.equal,Ln.tokens.plus_equal,Ln.tokens.minus_equal,Ln.tokens.times_equal,Ln.tokens.division_equal,Ln.tokens.modulo_equal,Ln.tokens.and_equal,Ln.tokens.or_equal,Ln.tokens.xor_equal,Ln.tokens.shift_right_equal,Ln.tokens.shift_left_equal],He.increment_operators=[Ln.tokens.plus_plus,Ln.tokens.minus_minus];class ze{constructor(i,g,x,_,v){this.type=i,this.lexeme=g,this.line=x,this.start=_,this.end=v}toString(){return this.lexeme}isTemplateType(){return-1!=He.template_types.indexOf(this.type)}isArrayType(){return this.type==He.keywords.array}isArrayOrTemplateType(){return this.isArrayType()||this.isTemplateType()}}class Re{constructor(i){this._tokens=[],this._start=0,this._current=0,this._line=1,this._source=null!=i?i:""}scanTokens(){for(;!this._isAtEnd();)if(this._start=this._current,!this.scanToken())throw`Invalid syntax at line ${this._line}`;return this._tokens.push(new ze(He.eof,"",this._line,this._current,this._current)),this._tokens}scanToken(){let i=this._advance();if("\n"==i)return this._line++,!0;if(this._isWhitespace(i))return!0;if("/"==i){if("/"==this._peekAhead()){for(;"\n"!=i;){if(this._isAtEnd())return!0;i=this._advance()}return this._line++,!0}if("*"==this._peekAhead()){this._advance();let g=1;for(;g>0;){if(this._isAtEnd())return!0;if(i=this._advance(),"\n"==i)this._line++;else if("*"==i){if("/"==this._peekAhead()&&(this._advance(),g--,0==g))return!0}else"/"==i&&"*"==this._peekAhead()&&(this._advance(),g++)}return!0}}const g=He.simpleTokens[i];if(g)return this._addToken(g),!0;let x=He.none;const _=this._isAlpha(i),v="_"===i;if(this._isAlphaNumeric(i)){let g=this._peekAhead();for(;this._isAlphaNumeric(g);)i+=this._advance(),g=this._peekAhead()}if(_){const g=He.keywords[i];if(g)return this._addToken(g),!0}if(_||v)return this._addToken(He.tokens.ident),!0;for(;;){let g=this._findType(i);const _=this._peekAhead();if("-"==i&&this._tokens.length>0){if("="==_)return this._current++,i+=_,this._addToken(He.tokens.minus_equal),!0;if("-"==_)return this._current++,i+=_,this._addToken(He.tokens.minus_minus),!0;const x=this._tokens.length-1;if((-1!=He.literal_or_ident.indexOf(this._tokens[x].type)||this._tokens[x].type==He.tokens.paren_right)&&">"!=_)return this._addToken(g),!0}if(">"==i&&(">"==_||"="==_)){let i=!1,x=this._tokens.length-1;for(let g=0;g<5&&x>=0&&-1===He.assignment_operators.indexOf(this._tokens[x].type);++g,--x)if(this._tokens[x].type===He.tokens.less_than){x>0&&this._tokens[x-1].isArrayOrTemplateType()&&(i=!0);break}if(i)return this._addToken(g),!0}if(g===He.none){let _=i,v=0;const b=2;for(let i=0;i<b;++i)if(_+=this._peekAhead(i),g=this._findType(_),g!==He.none){v=i;break}if(g===He.none)return x!==He.none&&(this._current--,this._addToken(x),!0);i=_,this._current+=v+1}if(x=g,this._isAtEnd())break;i+=this._advance()}return x!==He.none&&(this._addToken(x),!0)}_findType(i){for(const g in He.regexTokens){const x=He.regexTokens[g];if(this._match(i,x.rule))return x}return He.literalTokens[i]||He.none}_match(i,g){const x=g.exec(i);return x&&0==x.index&&x[0]==i}_isAtEnd(){return this._current>=this._source.length}_isAlpha(i){return!this._isNumeric(i)&&!this._isWhitespace(i)&&"_"!==i&&"."!==i&&"("!==i&&")"!==i&&"["!==i&&"]"!==i&&"{"!==i&&"}"!==i&&","!==i&&";"!==i&&":"!==i&&"="!==i&&"!"!==i&&"<"!==i&&">"!==i&&"+"!==i&&"-"!==i&&"*"!==i&&"/"!==i&&"%"!==i&&"&"!==i&&"|"!==i&&"^"!==i&&"~"!==i&&"@"!==i&&"#"!==i&&"?"!==i&&"'"!==i&&"`"!==i&&'"'!==i&&"\\"!==i&&"\n"!==i&&"\r"!==i&&"\t"!==i&&"\0"!==i}_isNumeric(i){return i>="0"&&i<="9"}_isAlphaNumeric(i){return this._isAlpha(i)||this._isNumeric(i)||"_"===i}_isWhitespace(i){return" "==i||"\t"==i||"\r"==i}_advance(i=0){let g=this._source[this._current];return i=i||0,i++,this._current+=i,g}_peekAhead(i=0){return i=i||0,this._current+i>=this._source.length?"\0":this._source[this._current+i]}_addToken(i){const g=this._source.substring(this._start,this._current);this._tokens.push(new ze(i,g,this._line,this._start,this._current))}}function Ge(i){return Array.isArray(i)||(null==i?void 0:i.buffer)instanceof ArrayBuffer}const Gn=new Float32Array(1),kn=new Uint32Array(Gn.buffer),On=new Uint32Array(Gn.buffer),Nn=new Int32Array(1),Vn=new Float32Array(Nn.buffer),Fn=new Uint32Array(Nn.buffer),zn=new Uint32Array(1),Hn=new Float32Array(zn.buffer),$n=new Int32Array(zn.buffer);function nt(i,g,x){if(g===x)return i;if("f32"===g){if("i32"===x||"x32"===x)return Gn[0]=i,kn[0];if("u32"===x)return Gn[0]=i,On[0]}else if("i32"===g||"x32"===g){if("f32"===x)return Nn[0]=i,Vn[0];if("u32"===x)return Nn[0]=i,Fn[0]}else if("u32"===g){if("f32"===x)return zn[0]=i,Hn[0];if("i32"===x||"x32"===x)return zn[0]=i,$n[0]}return console.error(`Unsupported cast from ${g} to ${x}`),i}class st{constructor(i){this.resources=null,this.inUse=!1,this.info=null,this.node=i}}class rt{constructor(i,g){this.align=i,this.size=g}}class at{constructor(){this.uniforms=[],this.storage=[],this.textures=[],this.samplers=[],this.aliases=[],this.overrides=[],this.structs=[],this.entry=new d,this.functions=[],this._types=new Map,this._functions=new Map}_isStorageTexture(i){return"texture_storage_1d"==i.name||"texture_storage_2d"==i.name||"texture_storage_2d_array"==i.name||"texture_storage_3d"==i.name}updateAST(i){for(const g of i)g instanceof D&&this._functions.set(g.name,new st(g));for(const g of i)if(g instanceof oe){const i=this.getTypeInfo(g,null);i instanceof n&&this.structs.push(i)}for(const g of i)if(g instanceof te)this.aliases.push(this._getAliasInfo(g));else{if(g instanceof M){const i=g,x=this._getAttributeNum(i.attributes,"id",0),_=null!=i.type?this.getTypeInfo(i.type,i.attributes):null;this.overrides.push(new h(i.name,_,i.attributes,x));continue}if(this._isUniformVar(g)){const i=g,x=this._getAttributeNum(i.attributes,"group",0),_=this._getAttributeNum(i.attributes,"binding",0),v=this.getTypeInfo(i.type,i.attributes),b=new o(i.name,v,x,_,i.attributes,Mn.Uniform,i.access);b.access||(b.access="read"),this.uniforms.push(b);continue}if(this._isStorageVar(g)){const i=g,x=this._getAttributeNum(i.attributes,"group",0),_=this._getAttributeNum(i.attributes,"binding",0),v=this.getTypeInfo(i.type,i.attributes),b=this._isStorageTexture(v),y=new o(i.name,v,x,_,i.attributes,b?Mn.StorageTexture:Mn.Storage,i.access);y.access||(y.access="read"),this.storage.push(y);continue}if(this._isTextureVar(g)){const i=g,x=this._getAttributeNum(i.attributes,"group",0),_=this._getAttributeNum(i.attributes,"binding",0),v=this.getTypeInfo(i.type,i.attributes),b=this._isStorageTexture(v),y=new o(i.name,v,x,_,i.attributes,b?Mn.StorageTexture:Mn.Texture,i.access);y.access||(y.access="read"),b?this.storage.push(y):this.textures.push(y);continue}if(this._isSamplerVar(g)){const i=g,x=this._getAttributeNum(i.attributes,"group",0),_=this._getAttributeNum(i.attributes,"binding",0),v=this.getTypeInfo(i.type,i.attributes),b=new o(i.name,v,x,_,i.attributes,Mn.Sampler,i.access);this.samplers.push(b);continue}}for(const g of i)if(g instanceof D){const i=this._getAttribute(g,"vertex"),x=this._getAttribute(g,"fragment"),_=this._getAttribute(g,"compute"),v=i||x||_,b=new p(g.name,null==v?void 0:v.name,g.attributes);b.attributes=g.attributes,b.startLine=g.startLine,b.endLine=g.endLine,this.functions.push(b),this._functions.get(g.name).info=b,v&&(this._functions.get(g.name).inUse=!0,b.inUse=!0,b.resources=this._findResources(g,!!v),b.inputs=this._getInputs(g.args),b.outputs=this._getOutputs(g.returnType),this.entry[v.name].push(b)),b.arguments=g.args.map(i=>new f(i.name,this.getTypeInfo(i.type,i.attributes),i.attributes)),b.returnType=g.returnType?this.getTypeInfo(g.returnType,g.attributes):null;continue}for(const i of this._functions.values())i.info&&(i.info.inUse=i.inUse,this._addCalls(i.node,i.info.calls));for(const i of this._functions.values())i.node.search(g=>{var x,_,v;if(g instanceof De){if(g.value)if(Ge(g.value))for(const _ of g.value)for(const g of this.overrides)_===g.name&&(null===(x=i.info)||void 0===x||x.overrides.push(g));else for(const x of this.overrides)g.value===x.name&&(null===(_=i.info)||void 0===_||_.overrides.push(x))}else if(g instanceof ge)for(const x of this.overrides)g.name===x.name&&(null===(v=i.info)||void 0===v||v.overrides.push(x))});for(const i of this.uniforms)this._markStructsInUse(i.type);for(const i of this.storage)this._markStructsInUse(i.type)}getFunctionInfo(i){for(const g of this.functions)if(g.name==i)return g;return null}getStructInfo(i){for(const g of this.structs)if(g.name==i)return g;return null}getOverrideInfo(i){for(const g of this.overrides)if(g.name==i)return g;return null}_markStructsInUse(i){if(i)if(i.isStruct){if(i.inUse=!0,i.members)for(const g of i.members)this._markStructsInUse(g.type)}else if(i.isArray)this._markStructsInUse(i.format);else if(i.isTemplate)i.format&&this._markStructsInUse(i.format);else{const g=this._getAlias(i.name);g&&this._markStructsInUse(g)}}_addCalls(i,g){var x;for(const _ of i.calls){const i=null===(x=this._functions.get(_.name))||void 0===x?void 0:x.info;i&&g.add(i)}}findResource(i,g,x){if(x){for(const _ of this.entry.compute)if(_.name===x)for(const x of _.resources)if(x.group==i&&x.binding==g)return x;for(const _ of this.entry.vertex)if(_.name===x)for(const x of _.resources)if(x.group==i&&x.binding==g)return x;for(const _ of this.entry.fragment)if(_.name===x)for(const x of _.resources)if(x.group==i&&x.binding==g)return x}for(const x of this.uniforms)if(x.group==i&&x.binding==g)return x;for(const x of this.storage)if(x.group==i&&x.binding==g)return x;for(const x of this.textures)if(x.group==i&&x.binding==g)return x;for(const x of this.samplers)if(x.group==i&&x.binding==g)return x;return null}_findResource(i){for(const g of this.uniforms)if(g.name==i)return g;for(const g of this.storage)if(g.name==i)return g;for(const g of this.textures)if(g.name==i)return g;for(const g of this.samplers)if(g.name==i)return g;return null}_markStructsFromAST(i){const g=this.getTypeInfo(i,null);this._markStructsInUse(g)}_findResources(i,g){const x=[],_=this,v=[];return i.search(b=>{if(b instanceof E)v.push({});else if(b instanceof $)v.pop();else if(b instanceof F){const i=b;g&&null!==i.type&&this._markStructsFromAST(i.type),v.length>0&&(v[v.length-1][i.name]=i)}else if(b instanceof de){const i=b;g&&null!==i.type&&this._markStructsFromAST(i.type)}else if(b instanceof U){const i=b;g&&null!==i.type&&this._markStructsFromAST(i.type),v.length>0&&(v[v.length-1][i.name]=i)}else if(b instanceof ge){const i=b;if(v.length>0&&v[v.length-1][i.name])return;const g=_._findResource(i.name);g&&x.push(g)}else if(b instanceof me){const v=b,y=_._functions.get(v.name);y&&(g&&(y.inUse=!0),i.calls.add(y.node),null===y.resources&&(y.resources=_._findResources(y.node,g)),x.push(...y.resources))}else if(b instanceof X){const v=b,y=_._functions.get(v.name);y&&(g&&(y.inUse=!0),i.calls.add(y.node),null===y.resources&&(y.resources=_._findResources(y.node,g)),x.push(...y.resources))}}),[...new Map(x.map(i=>[i.name,i])).values()]}getBindGroups(){const i=[];function t(g,x){g>=i.length&&(i.length=g+1),void 0===i[g]&&(i[g]=[]),x>=i[g].length&&(i[g].length=x+1)}for(const g of this.uniforms)t(g.group,g.binding),i[g.group][g.binding]=g;for(const g of this.storage)t(g.group,g.binding),i[g.group][g.binding]=g;for(const g of this.textures)t(g.group,g.binding),i[g.group][g.binding]=g;for(const g of this.samplers)t(g.group,g.binding),i[g.group][g.binding]=g;return i}_getOutputs(i,g=void 0){if(void 0===g&&(g=[]),i instanceof oe)this._getStructOutputs(i,g);else{const x=this._getOutputInfo(i);null!==x&&g.push(x)}return g}_getStructOutputs(i,g){for(const x of i.members)if(x.type instanceof oe)this._getStructOutputs(x.type,g);else{const i=this._getAttribute(x,"location")||this._getAttribute(x,"builtin");if(null!==i){const _=this.getTypeInfo(x.type,x.type.attributes),v=this._parseInt(i.value),b=new u(x.name,_,i.name,v);g.push(b)}}}_getOutputInfo(i){const g=this._getAttribute(i,"location")||this._getAttribute(i,"builtin");if(null!==g){const x=this.getTypeInfo(i,i.attributes),_=this._parseInt(g.value);return new u("",x,g.name,_)}return null}_getInputs(i,g=void 0){void 0===g&&(g=[]);for(const x of i)if(x.type instanceof oe)this._getStructInputs(x.type,g);else{const i=this._getInputInfo(x);null!==i&&g.push(i)}return g}_getStructInputs(i,g){for(const x of i.members)if(x.type instanceof oe)this._getStructInputs(x.type,g);else{const i=this._getInputInfo(x);null!==i&&g.push(i)}}_getInputInfo(i){const g=this._getAttribute(i,"location")||this._getAttribute(i,"builtin");if(null!==g){const x=this._getAttribute(i,"interpolation"),_=this.getTypeInfo(i.type,i.attributes),v=this._parseInt(g.value),b=new l(i.name,_,g.name,v);return null!==x&&(b.interpolation=this._parseString(x.value)),b}return null}_parseString(i){return i instanceof Array&&(i=i[0]),i}_parseInt(i){i instanceof Array&&(i=i[0]);const g=parseInt(i);return isNaN(g)?i:g}_getAlias(i){for(const g of this.aliases)if(g.name==i)return g.type;return null}_getAliasInfo(i){return new c(i.name,this.getTypeInfo(i.type,null))}getTypeInfoByName(i){for(const g of this.structs)if(g.name==i)return g;for(const g of this.aliases)if(g.name==i)return g.type;return null}getTypeInfo(i,g=null){if(this._types.has(i))return this._types.get(i);if(i instanceof le){const x=i.type?this.getTypeInfo(i.type,i.attributes):null,_=new r(i.name,x,g);return this._types.set(i,_),this._updateTypeInfo(_),_}if(i instanceof ue){const x=i,_=x.format?this.getTypeInfo(x.format,x.attributes):null,v=new s(x.name,g);return v.format=_,v.count=x.count,this._types.set(i,v),this._updateTypeInfo(v),v}if(i instanceof oe){const x=i,_=new n(x.name,g);_.startLine=x.startLine,_.endLine=x.endLine;for(const i of x.members){const g=this.getTypeInfo(i.type,i.attributes);_.members.push(new t(i.name,g,i.attributes))}return this._types.set(i,_),this._updateTypeInfo(_),_}if(i instanceof he){const x=i,_=x.format instanceof ae,v=x.format?_?this.getTypeInfo(x.format,null):new e(x.format,null):null,b=new a(x.name,v,g,x.access);return this._types.set(i,b),this._updateTypeInfo(b),b}if(i instanceof ce){const x=i,_=x.format?this.getTypeInfo(x.format,null):null,v=new a(x.name,_,g,x.access);return this._types.set(i,v),this._updateTypeInfo(v),v}const x=new e(i.name,g);return this._types.set(i,x),this._updateTypeInfo(x),x}_updateTypeInfo(i){var g,x,_;const v=this._getTypeSize(i);if(i.size=null!==(g=null==v?void 0:v.size)&&void 0!==g?g:0,i instanceof s&&i.format){const g=this._getTypeSize(i.format);i.stride=Math.max(null!==(x=null==g?void 0:g.size)&&void 0!==x?x:0,null!==(_=null==g?void 0:g.align)&&void 0!==_?_:0),this._updateTypeInfo(i.format)}i instanceof r&&this._updateTypeInfo(i.format),i instanceof n&&this._updateStructInfo(i)}_updateStructInfo(i){var g;let x=0,_=0,v=0,b=0;for(let y=0,S=i.members.length;y<S;++y){const S=i.members[y],w=this._getTypeSize(S);if(!w)continue;null!==(g=this._getAlias(S.type.name))&&void 0!==g||S.type;const L=w.align,k=w.size;x=this._roundUp(L,x+_),_=k,v=x,b=Math.max(b,L),S.offset=x,S.size=k,this._updateTypeInfo(S.type)}i.size=this._roundUp(b,v+_),i.align=b}_getTypeSize(i){var g,x;if(null==i)return null;const _=this._getAttributeNum(i.attributes,"size",0),v=this._getAttributeNum(i.attributes,"align",0);if(i instanceof t&&(i=i.type),i instanceof e){const g=this._getAlias(i.name);null!==g&&(i=g)}{const x=at._typeInfo[i.name];if(void 0!==x){const b="f16"===(null===(g=i.format)||void 0===g?void 0:g.name)?2:1;return new rt(Math.max(v,x.align/b),Math.max(_,x.size/b))}}{const g=at._typeInfo[i.name.substring(0,i.name.length-1)];if(g){const x="h"===i.name[i.name.length-1]?2:1;return new rt(Math.max(v,g.align/x),Math.max(_,g.size/x))}}if(i instanceof s){let g=i,b=8,y=8;const S=this._getTypeSize(g.format);return null!==S&&(y=S.size,b=S.align),y=g.count*this._getAttributeNum(null!==(x=null==i?void 0:i.attributes)&&void 0!==x?x:null,"stride",this._roundUp(b,y)),_&&(y=_),new rt(Math.max(v,b),Math.max(_,y))}if(i instanceof n){let g=0,x=0,b=0,y=0,S=0;for(const x of i.members){const i=this._getTypeSize(x.type);null!==i&&(g=Math.max(i.align,g),b=this._roundUp(i.align,b+y),y=i.size,S=b)}return x=this._roundUp(g,S+y),new rt(Math.max(v,g),Math.max(_,x))}return null}_isUniformVar(i){return i instanceof F&&"uniform"==i.storage}_isStorageVar(i){return i instanceof F&&"storage"==i.storage}_isTextureVar(i){return i instanceof F&&null!==i.type&&-1!=at._textureTypes.indexOf(i.type.name)}_isSamplerVar(i){return i instanceof F&&null!==i.type&&-1!=at._samplerTypes.indexOf(i.type.name)}_getAttribute(i,g){const x=i;if(!x||!x.attributes)return null;const _=x.attributes;for(let i of _)if(i.name==g)return i;return null}_getAttributeNum(i,g,x){if(null===i)return x;for(let _ of i)if(_.name==g){let i=null!==_&&null!==_.value?_.value:x;return i instanceof Array&&(i=i[0]),"number"==typeof i?i:"string"==typeof i?parseInt(i):x}return x}_roundUp(i,g){return Math.ceil(g/i)*i}}at._typeInfo={f16:{align:2,size:2},i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},atomic:{align:4,size:4},vec2:{align:8,size:8},vec3:{align:16,size:12},vec4:{align:16,size:16},mat2x2:{align:8,size:16},mat3x2:{align:8,size:24},mat4x2:{align:8,size:32},mat2x3:{align:16,size:32},mat3x3:{align:16,size:48},mat4x3:{align:16,size:64},mat2x4:{align:16,size:32},mat3x4:{align:16,size:48},mat4x4:{align:16,size:64}},at._textureTypes=He.any_texture_type.map(i=>i.name),at._samplerTypes=He.sampler_type.map(i=>i.name);let Kn=0;class ot{constructor(i,g,x){this.id=Kn++,this.name=i,this.value=g,this.node=x}clone(){return new ot(this.name,this.value,this.node)}}class ct{constructor(i){this.id=Kn++,this.name=i.name,this.node=i}clone(){return new ct(this.node)}}class lt{constructor(i){this.parent=null,this.variables=new Map,this.functions=new Map,this.currentFunctionName="",this.id=Kn++,i&&(this.parent=i,this.currentFunctionName=i.currentFunctionName)}getVariable(i){var g;return this.variables.has(i)?null!==(g=this.variables.get(i))&&void 0!==g?g:null:this.parent?this.parent.getVariable(i):null}getFunction(i){var g;return this.functions.has(i)?null!==(g=this.functions.get(i))&&void 0!==g?g:null:this.parent?this.parent.getFunction(i):null}createVariable(i,g,x){this.variables.set(i,new ot(i,g,null!=x?x:null))}setVariable(i,g,x){const _=this.getVariable(i);null!==_?_.value=g:this.createVariable(i,g,x)}getVariableValue(i){var g;const x=this.getVariable(i);return null!==(g=null==x?void 0:x.value)&&void 0!==g?g:null}clone(){return new lt(this)}}class ut{evalExpression(i,g){return null}getTypeInfo(i){return null}getVariableName(i,g){return""}}class ht{constructor(i){this.exec=i}getTypeInfo(i){return this.exec.getTypeInfo(i)}All(i,g){const x=this.exec.evalExpression(i.args[0],g);let _=!0;if(x instanceof Me)return x.data.forEach(i=>{i||(_=!1)}),new Be(_?1:0,this.getTypeInfo("bool"));throw new Error(`All() expects a vector argument. Line ${i.line}`)}Any(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me){const i=x.data.some(i=>i);return new Be(i?1:0,this.getTypeInfo("bool"))}throw new Error(`Any() expects a vector argument. Line ${i.line}`)}Select(i,g){const x=this.exec.evalExpression(i.args[2],g);if(!(x instanceof Be))throw new Error(`Select() expects a bool condition. Line ${i.line}`);return x.value?this.exec.evalExpression(i.args[1],g):this.exec.evalExpression(i.args[0],g)}ArrayLength(i,g){let x=i.args[0];x instanceof ke&&(x=x.right);const _=this.exec.evalExpression(x,g);if(_ instanceof Pe&&0===_.typeInfo.size){const i=_.typeInfo,g=_.buffer.byteLength/i.stride;return new Be(g,this.getTypeInfo("u32"))}return new Be(_.typeInfo.size,this.getTypeInfo("u32"))}Abs(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.abs(i)),x.typeInfo);const _=x;return new Be(Math.abs(_.value),_.typeInfo)}Acos(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.acos(i)),x.typeInfo);const _=x;return new Be(Math.acos(_.value),x.typeInfo)}Acosh(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.acosh(i)),x.typeInfo);const _=x;return new Be(Math.acosh(_.value),x.typeInfo)}Asin(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.asin(i)),x.typeInfo);const _=x;return new Be(Math.asin(_.value),x.typeInfo)}Asinh(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.asinh(i)),x.typeInfo);const _=x;return new Be(Math.asinh(_.value),x.typeInfo)}Atan(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.atan(i)),x.typeInfo);const _=x;return new Be(Math.atan(_.value),x.typeInfo)}Atanh(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.atanh(i)),x.typeInfo);const _=x;return new Be(Math.atanh(_.value),x.typeInfo)}Atan2(i,g){const x=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);if(x instanceof Me&&_ instanceof Me)return new Me(x.data.map((i,g)=>Math.atan2(i,_.data[g])),x.typeInfo);const v=x,b=_;return new Be(Math.atan2(v.value,b.value),x.typeInfo)}Ceil(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.ceil(i)),x.typeInfo);const _=x;return new Be(Math.ceil(_.value),x.typeInfo)}_clamp(i,g,x){return Math.min(Math.max(i,g),x)}Clamp(i,g){const x=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g),v=this.exec.evalExpression(i.args[2],g);if(x instanceof Me&&_ instanceof Me&&v instanceof Me)return new Me(x.data.map((i,g)=>this._clamp(i,_.data[g],v.data[g])),x.typeInfo);const b=x,y=_,S=v;return new Be(this._clamp(b.value,y.value,S.value),x.typeInfo)}Cos(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.cos(i)),x.typeInfo);const _=x;return new Be(Math.cos(_.value),x.typeInfo)}Cosh(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.cosh(i)),x.typeInfo);const _=x;return new Be(Math.cos(_.value),x.typeInfo)}CountLeadingZeros(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.clz32(i)),x.typeInfo);const _=x;return new Be(Math.clz32(_.value),x.typeInfo)}_countOneBits(i){let g=0;for(;0!==i;)1&i&&g++,i>>=1;return g}CountOneBits(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>this._countOneBits(i)),x.typeInfo);const _=x;return new Be(this._countOneBits(_.value),x.typeInfo)}_countTrailingZeros(i){if(0===i)return 32;let g=0;for(;!(1&i);)i>>=1,g++;return g}CountTrailingZeros(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>this._countTrailingZeros(i)),x.typeInfo);const _=x;return new Be(this._countTrailingZeros(_.value),x.typeInfo)}Cross(i,g){const x=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);if(x instanceof Me&&_ instanceof Me){if(3!==x.data.length||3!==_.data.length)return console.error(`Cross() expects 3D vectors. Line ${i.line}`),null;const g=x.data,v=_.data;return new Me([g[1]*v[2]-v[1]*g[2],g[2]*v[0]-v[2]*g[0],g[0]*v[1]-v[0]*g[1]],x.typeInfo)}return console.error(`Cross() expects vector arguments. Line ${i.line}`),null}Degrees(i,g){const x=this.exec.evalExpression(i.args[0],g),_=180/Math.PI;return x instanceof Me?new Me(x.data.map(i=>i*_),x.typeInfo):new Be(x.value*_,this.getTypeInfo("f32"))}Determinant(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Ue){const i=x.data,g=x.typeInfo.getTypeName(),_=g.endsWith("h")?this.getTypeInfo("f16"):this.getTypeInfo("f32");if("mat2x2"===g||"mat2x2f"===g||"mat2x2h"===g)return new Be(i[0]*i[3]-i[1]*i[2],_);if("mat2x3"===g||"mat2x3f"===g||"mat2x3h"===g)return new Be(i[0]*(i[4]*i[8]-i[5]*i[7])-i[1]*(i[3]*i[8]-i[5]*i[6])+i[2]*(i[3]*i[7]-i[4]*i[6]),_);if("mat2x4"===g||"mat2x4f"===g||"mat2x4h"===g)console.error(`TODO:Determinant for ${g}`);else if("mat3x2"===g||"mat3x2f"===g||"mat3x2h"===g)console.error(`TODO:Determinant for ${g}`);else{if("mat3x3"===g||"mat3x3f"===g||"mat3x3h"===g)return new Be(i[0]*(i[4]*i[8]-i[5]*i[7])-i[1]*(i[3]*i[8]-i[5]*i[6])+i[2]*(i[3]*i[7]-i[4]*i[6]),_);"mat3x4"===g||"mat3x4f"===g||"mat3x4h"===g||"mat4x2"===g||"mat4x2f"===g||"mat4x2h"===g||"mat4x3"===g||"mat4x3f"===g||"mat4x3h"===g?console.error(`TODO:Determinant for ${g}`):"mat4x4"!==g&&"mat4x4f"!==g&&"mat4x4h"!==g||console.error(`TODO:Determinant for ${g}`)}}return console.error(`Determinant expects a matrix argument. Line ${i.line}`),null}Distance(i,g){const x=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);if(x instanceof Me&&_ instanceof Me){let i=0;for(let g=0;g<x.data.length;++g)i+=(x.data[g]-_.data[g])*(x.data[g]-_.data[g]);return new Be(Math.sqrt(i),this.getTypeInfo("f32"))}const v=x,b=_;return new Be(Math.abs(v.value-b.value),x.typeInfo)}_dot(i,g){let x=0;for(let _=0;_<i.length;++_)x+=g[_]*i[_];return x}Dot(i,g){const x=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);return x instanceof Me&&_ instanceof Me?new Be(this._dot(x.data,_.data),this.getTypeInfo("f32")):(console.error(`Dot() expects vector arguments. Line ${i.line}`),null)}Dot4U8Packed(i,g){return console.error(`TODO:dot4U8Packed. Line ${i.line}`),null}Dot4I8Packed(i,g){return console.error(`TODO:dot4I8Packed. Line ${i.line}`),null}Exp(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.exp(i)),x.typeInfo);const _=x;return new Be(Math.exp(_.value),x.typeInfo)}Exp2(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.pow(2,i)),x.typeInfo);const _=x;return new Be(Math.pow(2,_.value),x.typeInfo)}ExtractBits(i,g){const x=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g),v=this.exec.evalExpression(i.args[2],g);if("u32"!==_.typeInfo.name&&"x32"!==_.typeInfo.name)return console.error(`ExtractBits() expects an i32 offset argument. Line ${i.line}`),null;if("u32"!==v.typeInfo.name&&"x32"!==v.typeInfo.name)return console.error(`ExtractBits() expects an i32 count argument. Line ${i.line}`),null;const b=_.value,y=v.value;if(x instanceof Me)return new Me(x.data.map(i=>i>>b&(1<<y)-1),x.typeInfo);if("i32"!==x.typeInfo.name&&"x32"!==x.typeInfo.name)return console.error(`ExtractBits() expects an i32 argument. Line ${i.line}`),null;const S=x.value;return new Be(S>>b&(1<<y)-1,this.getTypeInfo("i32"))}FaceForward(i,g){const x=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g),v=this.exec.evalExpression(i.args[2],g);if(x instanceof Me&&_ instanceof Me&&v instanceof Me){const i=this._dot(_.data,v.data);return new Me(i<0?Array.from(x.data):x.data.map(i=>-i),x.typeInfo)}return console.error(`FaceForward() expects vector arguments. Line ${i.line}`),null}_firstLeadingBit(i){return 0===i?-1:31-Math.clz32(i)}FirstLeadingBit(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>this._firstLeadingBit(i)),x.typeInfo);const _=x;return new Be(this._firstLeadingBit(_.value),x.typeInfo)}_firstTrailingBit(i){return 0===i?-1:Math.log2(i&-i)}FirstTrailingBit(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>this._firstTrailingBit(i)),x.typeInfo);const _=x;return new Be(this._firstTrailingBit(_.value),x.typeInfo)}Floor(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.floor(i)),x.typeInfo);const _=x;return new Be(Math.floor(_.value),x.typeInfo)}Fma(i,g){const x=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g),v=this.exec.evalExpression(i.args[2],g);if(x instanceof Me&&_ instanceof Me&&v instanceof Me)return x.data.length!==_.data.length||x.data.length!==v.data.length?(console.error(`Fma() expects vectors of the same length. Line ${i.line}`),null):new Me(x.data.map((i,g)=>i*_.data[g]+v.data[g]),x.typeInfo);const b=x,y=_,S=v;return new Be(b.value*y.value+S.value,b.typeInfo)}Fract(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>i-Math.floor(i)),x.typeInfo);const _=x;return new Be(_.value-Math.floor(_.value),x.typeInfo)}Frexp(i,g){return console.error(`TODO:frexp. Line ${i.line}`),null}InsertBits(i,g){const x=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g),v=this.exec.evalExpression(i.args[2],g),b=this.exec.evalExpression(i.args[3],g);if("u32"!==v.typeInfo.name&&"x32"!==v.typeInfo.name)return console.error(`InsertBits() expects an i32 offset argument. Line ${i.line}`),null;const y=v.value,S=(1<<b.value)-1<<y,w=~S;if(x instanceof Me&&_ instanceof Me)return new Me(x.data.map((i,g)=>i&w|_.data[g]<<y&S),x.typeInfo);const L=x.value,k=_.value;return new Be(L&w|k<<y&S,x.typeInfo)}InverseSqrt(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>1/Math.sqrt(i)),x.typeInfo);const _=x;return new Be(1/Math.sqrt(_.value),x.typeInfo)}Ldexp(i,g){return console.error(`TODO:ldexp. Line ${i.line}`),null}Length(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me){let i=0;return x.data.forEach(g=>{i+=g*g}),new Be(Math.sqrt(i),this.getTypeInfo("f32"))}const _=x;return new Be(Math.abs(_.value),x.typeInfo)}Log(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.log(i)),x.typeInfo);const _=x;return new Be(Math.log(_.value),x.typeInfo)}Log2(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.log2(i)),x.typeInfo);const _=x;return new Be(Math.log2(_.value),x.typeInfo)}Max(i,g){const x=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);if(x instanceof Me&&_ instanceof Me)return new Me(x.data.map((i,g)=>Math.max(i,_.data[g])),x.typeInfo);const v=x,b=_;return new Be(Math.max(v.value,b.value),x.typeInfo)}Min(i,g){const x=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);if(x instanceof Me&&_ instanceof Me)return new Me(x.data.map((i,g)=>Math.min(i,_.data[g])),x.typeInfo);const v=x,b=_;return new Be(Math.min(v.value,b.value),x.typeInfo)}Mix(i,g){const x=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g),v=this.exec.evalExpression(i.args[2],g);if(x instanceof Me&&_ instanceof Me&&v instanceof Me)return new Me(x.data.map((i,g)=>x.data[g]*(1-v.data[g])+_.data[g]*v.data[g]),x.typeInfo);const b=_,y=v;return new Be(x.value*(1-y.value)+b.value*y.value,x.typeInfo)}Modf(i,g){const x=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);if(x instanceof Me&&_ instanceof Me)return new Me(x.data.map((i,g)=>i%_.data[g]),x.typeInfo);const v=_;return new Be(x.value%v.value,x.typeInfo)}Normalize(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me){const _=this.Length(i,g).value;return new Me(x.data.map(i=>i/_),x.typeInfo)}return console.error(`Normalize() expects a vector argument. Line ${i.line}`),null}Pow(i,g){const x=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);if(x instanceof Me&&_ instanceof Me)return new Me(x.data.map((i,g)=>Math.pow(i,_.data[g])),x.typeInfo);const v=x,b=_;return new Be(Math.pow(v.value,b.value),x.typeInfo)}QuantizeToF16(i,g){const x=this.exec.evalExpression(i.args[0],g);return x instanceof Me?new Me(x.data.map(i=>i),x.typeInfo):new Be(x.value,x.typeInfo)}Radians(i,g){const x=this.exec.evalExpression(i.args[0],g);return x instanceof Me?new Me(x.data.map(i=>i*Math.PI/180),x.typeInfo):new Be(x.value*Math.PI/180,this.getTypeInfo("f32"))}Reflect(i,g){let x=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);if(x instanceof Me&&_ instanceof Me){const i=this._dot(x.data,_.data);return new Me(x.data.map((g,x)=>g-2*i*_.data[x]),x.typeInfo)}return console.error(`Reflect() expects vector arguments. Line ${i.line}`),null}Refract(i,g){let x=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g),v=this.exec.evalExpression(i.args[2],g);if(x instanceof Me&&_ instanceof Me&&v instanceof Be){const i=this._dot(_.data,x.data);return new Me(x.data.map((g,x)=>{const b=1-v.value*v.value*(1-i*i);if(b<0)return 0;const y=Math.sqrt(b);return v.value*g-(v.value*i+y)*_.data[x]}),x.typeInfo)}return console.error(`Refract() expects vector arguments and a scalar argument. Line ${i.line}`),null}ReverseBits(i,g){return console.error(`TODO:reverseBits. Line ${i.line}`),null}Round(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.round(i)),x.typeInfo);const _=x;return new Be(Math.round(_.value),x.typeInfo)}Saturate(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.min(Math.max(i,0),1)),x.typeInfo);const _=x;return new Be(Math.min(Math.max(_.value,0),1),x.typeInfo)}Sign(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.sign(i)),x.typeInfo);const _=x;return new Be(Math.sign(_.value),x.typeInfo)}Sin(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.sin(i)),x.typeInfo);const _=x;return new Be(Math.sin(_.value),x.typeInfo)}Sinh(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.sinh(i)),x.typeInfo);const _=x;return new Be(Math.sinh(_.value),x.typeInfo)}_smoothstep(i,g,x){const _=Math.min(Math.max((x-i)/(g-i),0),1);return _*_*(3-2*_)}SmoothStep(i,g){const x=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g),v=this.exec.evalExpression(i.args[2],g);if(v instanceof Me&&x instanceof Me&&_ instanceof Me)return new Me(v.data.map((i,g)=>this._smoothstep(x.data[g],_.data[g],i)),v.typeInfo);const b=x,y=_,S=v;return new Be(this._smoothstep(b.value,y.value,S.value),v.typeInfo)}Sqrt(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.sqrt(i)),x.typeInfo);const _=x;return new Be(Math.sqrt(_.value),x.typeInfo)}Step(i,g){const x=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);if(_ instanceof Me&&x instanceof Me)return new Me(_.data.map((i,g)=>i<x.data[g]?0:1),_.typeInfo);const v=x;return new Be(_.value<v.value?0:1,v.typeInfo)}Tan(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.tan(i)),x.typeInfo);const _=x;return new Be(Math.tan(_.value),x.typeInfo)}Tanh(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.tanh(i)),x.typeInfo);const _=x;return new Be(Math.tanh(_.value),x.typeInfo)}_getTransposeType(i){const g=i.getTypeName();return"mat2x2f"===g||"mat2x2h"===g?i:"mat2x3f"===g?this.getTypeInfo("mat3x2f"):"mat2x3h"===g?this.getTypeInfo("mat3x2h"):"mat2x4f"===g?this.getTypeInfo("mat4x2f"):"mat2x4h"===g?this.getTypeInfo("mat4x2h"):"mat3x2f"===g?this.getTypeInfo("mat2x3f"):"mat3x2h"===g?this.getTypeInfo("mat2x3h"):"mat3x3f"===g||"mat3x3h"===g?i:"mat3x4f"===g?this.getTypeInfo("mat4x3f"):"mat3x4h"===g?this.getTypeInfo("mat4x3h"):"mat4x2f"===g?this.getTypeInfo("mat2x4f"):"mat4x2h"===g?this.getTypeInfo("mat2x4h"):"mat4x3f"===g?this.getTypeInfo("mat3x4f"):"mat4x3h"===g?this.getTypeInfo("mat3x4h"):("mat4x4f"===g||"mat4x4h"===g||console.error(`Invalid matrix type ${g}`),i)}Transpose(i,g){const x=this.exec.evalExpression(i.args[0],g);if(!(x instanceof Ue))return console.error(`Transpose() expects a matrix argument. Line ${i.line}`),null;const _=this._getTransposeType(x.typeInfo);if("mat2x2"===x.typeInfo.name||"mat2x2f"===x.typeInfo.name||"mat2x2h"===x.typeInfo.name){const i=x.data;return new Ue([i[0],i[2],i[1],i[3]],_)}if("mat2x3"===x.typeInfo.name||"mat2x3f"===x.typeInfo.name||"mat2x3h"===x.typeInfo.name){const i=x.data;return new Ue([i[0],i[3],i[6],i[1],i[4],i[7]],_)}if("mat2x4"===x.typeInfo.name||"mat2x4f"===x.typeInfo.name||"mat2x4h"===x.typeInfo.name){const i=x.data;return new Ue([i[0],i[4],i[8],i[12],i[1],i[5],i[9],i[13]],_)}if("mat3x2"===x.typeInfo.name||"mat3x2f"===x.typeInfo.name||"mat3x2h"===x.typeInfo.name){const i=x.data;return new Ue([i[0],i[3],i[1],i[4],i[2],i[5]],_)}if("mat3x3"===x.typeInfo.name||"mat3x3f"===x.typeInfo.name||"mat3x3h"===x.typeInfo.name){const i=x.data;return new Ue([i[0],i[3],i[6],i[1],i[4],i[7],i[2],i[5],i[8]],_)}if("mat3x4"===x.typeInfo.name||"mat3x4f"===x.typeInfo.name||"mat3x4h"===x.typeInfo.name){const i=x.data;return new Ue([i[0],i[4],i[8],i[12],i[1],i[5],i[9],i[13],i[2],i[6],i[10],i[14]],_)}if("mat4x2"===x.typeInfo.name||"mat4x2f"===x.typeInfo.name||"mat4x2h"===x.typeInfo.name){const i=x.data;return new Ue([i[0],i[4],i[1],i[5],i[2],i[6]],_)}if("mat4x3"===x.typeInfo.name||"mat4x3f"===x.typeInfo.name||"mat4x3h"===x.typeInfo.name){const i=x.data;return new Ue([i[0],i[4],i[8],i[1],i[5],i[9],i[2],i[6],i[10]],_)}if("mat4x4"===x.typeInfo.name||"mat4x4f"===x.typeInfo.name||"mat4x4h"===x.typeInfo.name){const i=x.data;return new Ue([i[0],i[4],i[8],i[12],i[1],i[5],i[9],i[13],i[2],i[6],i[10],i[14],i[3],i[7],i[11],i[15]],_)}return console.error(`Invalid matrix type ${x.typeInfo.name}`),null}Trunc(i,g){const x=this.exec.evalExpression(i.args[0],g);if(x instanceof Me)return new Me(x.data.map(i=>Math.trunc(i)),x.typeInfo);const _=x;return new Be(Math.trunc(_.value),x.typeInfo)}Dpdx(i,g){return console.error(`TODO:dpdx. Line ${i.line}`),null}DpdxCoarse(i,g){return console.error(`TODO:dpdxCoarse. Line ${i.line}`),null}DpdxFine(i,g){return console.error("TODO:dpdxFine"),null}Dpdy(i,g){return console.error("TODO:dpdy"),null}DpdyCoarse(i,g){return console.error("TODO:dpdyCoarse"),null}DpdyFine(i,g){return console.error("TODO:dpdyFine"),null}Fwidth(i,g){return console.error("TODO:fwidth"),null}FwidthCoarse(i,g){return console.error("TODO:fwidthCoarse"),null}FwidthFine(i,g){return console.error("TODO:fwidthFine"),null}TextureDimensions(i,g){const x=i.args[0],_=i.args.length>1?this.exec.evalExpression(i.args[1],g).value:0;if(x instanceof ge){const v=x.name,b=g.getVariableValue(v);if(b instanceof We){if(_<0||_>=b.mipLevelCount)return console.error(`Invalid mip level for textureDimensions. Line ${i.line}`),null;const g=b.getMipLevelSize(_),x=b.dimension;return"1d"===x?new Be(g[0],this.getTypeInfo("u32")):"3d"===x?new Me(g,this.getTypeInfo("vec3u")):"2d"===x?new Me(g.slice(0,2),this.getTypeInfo("vec2u")):(console.error(`Invalid texture dimension ${x} not found. Line ${i.line}`),null)}return console.error(`Texture ${v} not found. Line ${i.line}`),null}return console.error(`Invalid texture argument for textureDimensions. Line ${i.line}`),null}TextureGather(i,g){return console.error("TODO:textureGather"),null}TextureGatherCompare(i,g){return console.error("TODO:textureGatherCompare"),null}TextureLoad(i,g){const x=i.args[0],_=this.exec.evalExpression(i.args[1],g),v=i.args.length>2?this.exec.evalExpression(i.args[2],g).value:0;if(!(_ instanceof Me)||2!==_.data.length)return console.error(`Invalid UV argument for textureLoad. Line ${i.line}`),null;if(x instanceof ge){const b=x.name,y=g.getVariableValue(b);if(y instanceof We){const g=Math.floor(_.data[0]),x=Math.floor(_.data[1]);if(g<0||g>=y.width||x<0||x>=y.height)return console.error(`Texture ${b} out of bounds. Line ${i.line}`),null;const S=y.getPixel(g,x,0,v);return null===S?(console.error(`Invalid texture format for textureLoad. Line ${i.line}`),null):new Me(S,this.getTypeInfo("vec4f"))}return console.error(`Texture ${b} not found. Line ${i.line}`),null}return console.error(`Invalid texture argument for textureLoad. Line ${i.line}`),null}TextureNumLayers(i,g){const x=i.args[0];if(x instanceof ge){const _=x.name,v=g.getVariableValue(_);return v instanceof We?new Be(v.depthOrArrayLayers,this.getTypeInfo("u32")):(console.error(`Texture ${_} not found. Line ${i.line}`),null)}return console.error(`Invalid texture argument for textureNumLayers. Line ${i.line}`),null}TextureNumLevels(i,g){const x=i.args[0];if(x instanceof ge){const _=x.name,v=g.getVariableValue(_);return v instanceof We?new Be(v.mipLevelCount,this.getTypeInfo("u32")):(console.error(`Texture ${_} not found. Line ${i.line}`),null)}return console.error(`Invalid texture argument for textureNumLevels. Line ${i.line}`),null}TextureNumSamples(i,g){const x=i.args[0];if(x instanceof ge){const _=x.name,v=g.getVariableValue(_);return v instanceof We?new Be(v.sampleCount,this.getTypeInfo("u32")):(console.error(`Texture ${_} not found. Line ${i.line}`),null)}return console.error(`Invalid texture argument for textureNumSamples. Line ${i.line}`),null}TextureSample(i,g){return console.error("TODO:textureSample"),null}TextureSampleBias(i,g){return console.error("TODO:textureSampleBias"),null}TextureSampleCompare(i,g){return console.error("TODO:textureSampleCompare"),null}TextureSampleCompareLevel(i,g){return console.error("TODO:textureSampleCompareLevel"),null}TextureSampleGrad(i,g){return console.error("TODO:textureSampleGrad"),null}TextureSampleLevel(i,g){return console.error("TODO:textureSampleLevel"),null}TextureSampleBaseClampToEdge(i,g){return console.error("TODO:textureSampleBaseClampToEdge"),null}TextureStore(i,g){const x=i.args[0],_=this.exec.evalExpression(i.args[1],g),v=4===i.args.length?this.exec.evalExpression(i.args[2],g).value:0,b=4===i.args.length?this.exec.evalExpression(i.args[3],g).data:this.exec.evalExpression(i.args[2],g).data;if(4!==b.length)return console.error(`Invalid value argument for textureStore. Line ${i.line}`),null;if(!(_ instanceof Me)||2!==_.data.length)return console.error(`Invalid UV argument for textureStore. Line ${i.line}`),null;if(x instanceof ge){const y=x.name,S=g.getVariableValue(y);if(S instanceof We){const g=S.getMipLevelSize(0),x=Math.floor(_.data[0]),w=Math.floor(_.data[1]);return x<0||x>=g[0]||w<0||w>=g[1]?(console.error(`Texture ${y} out of bounds. Line ${i.line}`),null):(S.setPixel(x,w,0,v,Array.from(b)),null)}return console.error(`Texture ${y} not found. Line ${i.line}`),null}return console.error(`Invalid texture argument for textureStore. Line ${i.line}`),null}AtomicLoad(i,g){let x=i.args[0];x instanceof ke&&(x=x.right);const _=this.exec.getVariableName(x,g);return g.getVariable(_).value.getSubData(this.exec,x.postfix,g)}AtomicStore(i,g){let x=i.args[0];x instanceof ke&&(x=x.right);const _=this.exec.getVariableName(x,g),v=g.getVariable(_);let b=i.args[1];const y=this.exec.evalExpression(b,g),S=v.value.getSubData(this.exec,x.postfix,g);return S instanceof Be&&y instanceof Be&&(S.value=y.value),v.value instanceof Pe&&v.value.setDataValue(this.exec,S,x.postfix,g),null}AtomicAdd(i,g){let x=i.args[0];x instanceof ke&&(x=x.right);const _=this.exec.getVariableName(x,g),v=g.getVariable(_);let b=i.args[1];const y=this.exec.evalExpression(b,g),S=v.value.getSubData(this.exec,x.postfix,g),w=new Be(S.value,S.typeInfo);return S instanceof Be&&y instanceof Be&&(S.value+=y.value),v.value instanceof Pe&&v.value.setDataValue(this.exec,S,x.postfix,g),w}AtomicSub(i,g){let x=i.args[0];x instanceof ke&&(x=x.right);const _=this.exec.getVariableName(x,g),v=g.getVariable(_);let b=i.args[1];const y=this.exec.evalExpression(b,g),S=v.value.getSubData(this.exec,x.postfix,g),w=new Be(S.value,S.typeInfo);return S instanceof Be&&y instanceof Be&&(S.value-=y.value),v.value instanceof Pe&&v.value.setDataValue(this.exec,S,x.postfix,g),w}AtomicMax(i,g){let x=i.args[0];x instanceof ke&&(x=x.right);const _=this.exec.getVariableName(x,g),v=g.getVariable(_);let b=i.args[1];const y=this.exec.evalExpression(b,g),S=v.value.getSubData(this.exec,x.postfix,g),w=new Be(S.value,S.typeInfo);return S instanceof Be&&y instanceof Be&&(S.value=Math.max(S.value,y.value)),v.value instanceof Pe&&v.value.setDataValue(this.exec,S,x.postfix,g),w}AtomicMin(i,g){let x=i.args[0];x instanceof ke&&(x=x.right);const _=this.exec.getVariableName(x,g),v=g.getVariable(_);let b=i.args[1];const y=this.exec.evalExpression(b,g),S=v.value.getSubData(this.exec,x.postfix,g),w=new Be(S.value,S.typeInfo);return S instanceof Be&&y instanceof Be&&(S.value=Math.min(S.value,y.value)),v.value instanceof Pe&&v.value.setDataValue(this.exec,S,x.postfix,g),w}AtomicAnd(i,g){let x=i.args[0];x instanceof ke&&(x=x.right);const _=this.exec.getVariableName(x,g),v=g.getVariable(_);let b=i.args[1];const y=this.exec.evalExpression(b,g),S=v.value.getSubData(this.exec,x.postfix,g),w=new Be(S.value,S.typeInfo);return S instanceof Be&&y instanceof Be&&(S.value=S.value&y.value),v.value instanceof Pe&&v.value.setDataValue(this.exec,S,x.postfix,g),w}AtomicOr(i,g){let x=i.args[0];x instanceof ke&&(x=x.right);const _=this.exec.getVariableName(x,g),v=g.getVariable(_);let b=i.args[1];const y=this.exec.evalExpression(b,g),S=v.value.getSubData(this.exec,x.postfix,g),w=new Be(S.value,S.typeInfo);return S instanceof Be&&y instanceof Be&&(S.value=S.value|y.value),v.value instanceof Pe&&v.value.setDataValue(this.exec,S,x.postfix,g),w}AtomicXor(i,g){let x=i.args[0];x instanceof ke&&(x=x.right);const _=this.exec.getVariableName(x,g),v=g.getVariable(_);let b=i.args[1];const y=this.exec.evalExpression(b,g),S=v.value.getSubData(this.exec,x.postfix,g),w=new Be(S.value,S.typeInfo);return S instanceof Be&&y instanceof Be&&(S.value=S.value^y.value),v.value instanceof Pe&&v.value.setDataValue(this.exec,S,x.postfix,g),w}AtomicExchange(i,g){let x=i.args[0];x instanceof ke&&(x=x.right);const _=this.exec.getVariableName(x,g),v=g.getVariable(_);let b=i.args[1];const y=this.exec.evalExpression(b,g),S=v.value.getSubData(this.exec,x.postfix,g),w=new Be(S.value,S.typeInfo);return S instanceof Be&&y instanceof Be&&(S.value=y.value),v.value instanceof Pe&&v.value.setDataValue(this.exec,S,x.postfix,g),w}AtomicCompareExchangeWeak(i,g){return console.error("TODO:atomicCompareExchangeWeak"),null}Pack4x8snorm(i,g){return console.error("TODO:pack4x8snorm"),null}Pack4x8unorm(i,g){return console.error("TODO:pack4x8unorm"),null}Pack4xI8(i,g){return console.error("TODO:pack4xI8"),null}Pack4xU8(i,g){return console.error("TODO:pack4xU8"),null}Pack4x8Clamp(i,g){return console.error("TODO:pack4x8Clamp"),null}Pack4xU8Clamp(i,g){return console.error("TODO:pack4xU8Clamp"),null}Pack2x16snorm(i,g){return console.error("TODO:pack2x16snorm"),null}Pack2x16unorm(i,g){return console.error("TODO:pack2x16unorm"),null}Pack2x16float(i,g){return console.error("TODO:pack2x16float"),null}Unpack4x8snorm(i,g){return console.error("TODO:unpack4x8snorm"),null}Unpack4x8unorm(i,g){return console.error("TODO:unpack4x8unorm"),null}Unpack4xI8(i,g){return console.error("TODO:unpack4xI8"),null}Unpack4xU8(i,g){return console.error("TODO:unpack4xU8"),null}Unpack2x16snorm(i,g){return console.error("TODO:unpack2x16snorm"),null}Unpack2x16unorm(i,g){return console.error("TODO:unpack2x16unorm"),null}Unpack2x16float(i,g){return console.error("TODO:unpack2x16float"),null}StorageBarrier(i,g){return null}TextureBarrier(i,g){return null}WorkgroupBarrier(i,g){return null}WorkgroupUniformLoad(i,g){return null}SubgroupAdd(i,g){return console.error("TODO:subgroupAdd"),null}SubgroupExclusiveAdd(i,g){return console.error("TODO:subgroupExclusiveAdd"),null}SubgroupInclusiveAdd(i,g){return console.error("TODO:subgroupInclusiveAdd"),null}SubgroupAll(i,g){return console.error("TODO:subgroupAll"),null}SubgroupAnd(i,g){return console.error("TODO:subgroupAnd"),null}SubgroupAny(i,g){return console.error("TODO:subgroupAny"),null}SubgroupBallot(i,g){return console.error("TODO:subgroupBallot"),null}SubgroupBroadcast(i,g){return console.error("TODO:subgroupBroadcast"),null}SubgroupBroadcastFirst(i,g){return console.error("TODO:subgroupBroadcastFirst"),null}SubgroupElect(i,g){return console.error("TODO:subgroupElect"),null}SubgroupMax(i,g){return console.error("TODO:subgroupMax"),null}SubgroupMin(i,g){return console.error("TODO:subgroupMin"),null}SubgroupMul(i,g){return console.error("TODO:subgroupMul"),null}SubgroupExclusiveMul(i,g){return console.error("TODO:subgroupExclusiveMul"),null}SubgroupInclusiveMul(i,g){return console.error("TODO:subgroupInclusiveMul"),null}SubgroupOr(i,g){return console.error("TODO:subgroupOr"),null}SubgroupShuffle(i,g){return console.error("TODO:subgroupShuffle"),null}SubgroupShuffleDown(i,g){return console.error("TODO:subgroupShuffleDown"),null}SubgroupShuffleUp(i,g){return console.error("TODO:subgroupShuffleUp"),null}SubgroupShuffleXor(i,g){return console.error("TODO:subgroupShuffleXor"),null}SubgroupXor(i,g){return console.error("TODO:subgroupXor"),null}QuadBroadcast(i,g){return console.error("TODO:quadBroadcast"),null}QuadSwapDiagonal(i,g){return console.error("TODO:quadSwapDiagonal"),null}QuadSwapX(i,g){return console.error("TODO:quadSwapX"),null}QuadSwapY(i,g){return console.error("TODO:quadSwapY"),null}}const Xn={vec2:2,vec2f:2,vec2i:2,vec2u:2,vec2b:2,vec2h:2,vec3:3,vec3f:3,vec3i:3,vec3u:3,vec3b:3,vec3h:3,vec4:4,vec4f:4,vec4i:4,vec4u:4,vec4b:4,vec4h:4},jn={mat2x2:[2,2,4],mat2x2f:[2,2,4],mat2x2h:[2,2,4],mat2x3:[2,3,6],mat2x3f:[2,3,6],mat2x3h:[2,3,6],mat2x4:[2,4,8],mat2x4f:[2,4,8],mat2x4h:[2,4,8],mat3x2:[3,2,6],mat3x2f:[3,2,6],mat3x2h:[3,2,6],mat3x3:[3,3,9],mat3x3f:[3,3,9],mat3x3h:[3,3,9],mat3x4:[3,4,12],mat3x4f:[3,4,12],mat3x4h:[3,4,12],mat4x2:[4,2,8],mat4x2f:[4,2,8],mat4x2h:[4,2,8],mat4x3:[4,3,12],mat4x3f:[4,3,12],mat4x3h:[4,3,12],mat4x4:[4,4,16],mat4x4f:[4,4,16],mat4x4h:[4,4,16]};class dt extends ut{constructor(i,g){var x;super(),this.ast=null!=i?i:[],this.reflection=new at,this.reflection.updateAST(this.ast),this.context=null!==(x=null==g?void 0:g.clone())&&void 0!==x?x:new lt,this.builtins=new ht(this),this.typeInfo={bool:this.getTypeInfo(ae.bool),i32:this.getTypeInfo(ae.i32),u32:this.getTypeInfo(ae.u32),f32:this.getTypeInfo(ae.f32),f16:this.getTypeInfo(ae.f16),vec2f:this.getTypeInfo(ce.vec2f),vec2u:this.getTypeInfo(ce.vec2u),vec2i:this.getTypeInfo(ce.vec2i),vec2h:this.getTypeInfo(ce.vec2h),vec3f:this.getTypeInfo(ce.vec3f),vec3u:this.getTypeInfo(ce.vec3u),vec3i:this.getTypeInfo(ce.vec3i),vec3h:this.getTypeInfo(ce.vec3h),vec4f:this.getTypeInfo(ce.vec4f),vec4u:this.getTypeInfo(ce.vec4u),vec4i:this.getTypeInfo(ce.vec4i),vec4h:this.getTypeInfo(ce.vec4h),mat2x2f:this.getTypeInfo(ce.mat2x2f),mat2x3f:this.getTypeInfo(ce.mat2x3f),mat2x4f:this.getTypeInfo(ce.mat2x4f),mat3x2f:this.getTypeInfo(ce.mat3x2f),mat3x3f:this.getTypeInfo(ce.mat3x3f),mat3x4f:this.getTypeInfo(ce.mat3x4f),mat4x2f:this.getTypeInfo(ce.mat4x2f),mat4x3f:this.getTypeInfo(ce.mat4x3f),mat4x4f:this.getTypeInfo(ce.mat4x4f)}}getVariableValue(i){var g,x;const _=null!==(x=null===(g=this.context.getVariable(i))||void 0===g?void 0:g.value)&&void 0!==x?x:null;if(null===_)return null;if(_ instanceof Be)return _.value;if(_ instanceof Me)return Array.from(_.data);if(_ instanceof Ue)return Array.from(_.data);if(_ instanceof Pe&&_.typeInfo instanceof s){if("u32"===_.typeInfo.format.name)return Array.from(new Uint32Array(_.buffer,_.offset,_.typeInfo.count));if("i32"===_.typeInfo.format.name)return Array.from(new Int32Array(_.buffer,_.offset,_.typeInfo.count));if("f32"===_.typeInfo.format.name)return Array.from(new Float32Array(_.buffer,_.offset,_.typeInfo.count))}return console.error(`Unsupported return variable type ${_.typeInfo.name}`),null}execute(i){(i=null!=i?i:{}).constants&&this._setOverrides(i.constants,this.context),this._execStatements(this.ast,this.context)}dispatchWorkgroups(i,g,x,_){const v=this.context.clone();(_=null!=_?_:{}).constants&&this._setOverrides(_.constants,v),this._execStatements(this.ast,v);const b=v.getFunction(i);if(!b)return void console.error(`Function ${i} not found`);if("number"==typeof g)g=[g,1,1];else{if(0===g.length)return void console.error("Invalid dispatch count");1===g.length?g=[g[0],1,1]:2===g.length?g=[g[0],g[1],1]:g.length>3&&(g=[g[0],g[1],g[2]])}const y=g[0],S=g[1],w=g[2],L=this.getTypeInfo("vec3u");v.setVariable("@num_workgroups",new Me(g,L));const k=this.reflection.getFunctionInfo(i);null===k&&console.error(`Function ${i} not found in reflection data`);for(const i in x)for(const g in x[i]){const _=x[i][g];v.variables.forEach(x=>{var v;const b=x.node;if(null==b?void 0:b.attributes){let y=null,S=null;for(const i of b.attributes)"binding"===i.name?y=i.value:"group"===i.name&&(S=i.value);if(g==y&&i==S){let y=!1;for(const _ of k.resources)if(_.name===x.name&&_.group===parseInt(i)&&_.binding===parseInt(g)){y=!0;break}if(y)if(void 0!==_.texture&&void 0!==_.descriptor){const i=new We(_.texture,this.getTypeInfo(b.type),_.descriptor,null!==(v=_.texture.view)&&void 0!==v?v:null);x.value=i}else void 0!==_.uniform?x.value=new Pe(_.uniform,this.getTypeInfo(b.type)):x.value=new Pe(_,this.getTypeInfo(b.type))}}})}for(let i=0;i<w;++i)for(let g=0;g<S;++g)for(let x=0;x<y;++x)v.setVariable("@workgroup_id",new Me([x,g,i],this.getTypeInfo("vec3u"))),this._dispatchWorkgroup(b,[x,g,i],v)}execStatement(i,g){if(i instanceof Y)return this.evalExpression(i.value,g);if(i instanceof se){if(i.condition){const x=this.evalExpression(i.condition,g);if(!(x instanceof Be))throw new Error("Invalid break-if condition");if(!x.value)return null}return dt._breakObj}if(i instanceof re)return dt._continueObj;if(i instanceof U)this._let(i,g);else if(i instanceof F)this._var(i,g);else if(i instanceof P)this._const(i,g);else if(i instanceof D)this._function(i,g);else{if(i instanceof Q)return this._if(i,g);if(i instanceof Z)return this._switch(i,g);if(i instanceof B)return this._for(i,g);if(i instanceof V)return this._while(i,g);if(i instanceof j)return this._loop(i,g);if(i instanceof O){const x=g.clone();return x.currentFunctionName=g.currentFunctionName,this._execStatements(i.body,x)}if(i instanceof G)this._assign(i,g);else if(i instanceof R)this._increment(i,g);else{if(i instanceof oe)return null;if(i instanceof M){const x=i.name;null===g.getVariable(x)&&g.setVariable(x,new Be(0,this.getTypeInfo("u32")))}else if(i instanceof X)this._call(i,g);else{if(i instanceof ee)return null;if(i instanceof te)return null;console.error("Invalid statement type.",i,`Line ${i.line}`)}}}return null}evalExpression(i,g){return i instanceof Ie?this._evalBinaryOp(i,g):i instanceof xe?this._evalLiteral(i,g):i instanceof ge?this._evalVariable(i,g):i instanceof me?this._evalCall(i,g):i instanceof de?this._evalCreate(i,g):i instanceof _e?this._evalConst(i,g):i instanceof ye?this._evalBitcast(i,g):i instanceof ke?this._evalUnaryOp(i,g):(console.error("Invalid expression type",i,`Line ${i.line}`),null)}getTypeInfo(i){var g;if(i instanceof ae){const g=this.reflection.getTypeInfo(i);if(null!==g)return g}let x=null!==(g=this.typeInfo[i])&&void 0!==g?g:null;return null!==x||(x=this.reflection.getTypeInfoByName(i)),x}_setOverrides(i,g){for(const x in i){const _=i[x],v=this.reflection.getOverrideInfo(x);null!==v?(null===v.type&&(v.type=this.getTypeInfo("u32")),"u32"===v.type.name||"i32"===v.type.name||"f32"===v.type.name||"f16"===v.type.name?g.setVariable(x,new Be(_,v.type)):"bool"===v.type.name?g.setVariable(x,new Be(_?1:0,v.type)):"vec2"===v.type.name||"vec3"===v.type.name||"vec4"===v.type.name||"vec2f"===v.type.name||"vec3f"===v.type.name||"vec4f"===v.type.name||"vec2i"===v.type.name||"vec3i"===v.type.name||"vec4i"===v.type.name||"vec2u"===v.type.name||"vec3u"===v.type.name||"vec4u"===v.type.name||"vec2h"===v.type.name||"vec3h"===v.type.name||"vec4h"===v.type.name?g.setVariable(x,new Me(_,v.type)):console.error(`Invalid constant type for ${x}`)):console.error(`Override ${x} does not exist in the shader.`)}}_dispatchWorkgroup(i,g,x){const _=[1,1,1];for(const g of i.node.attributes)if("workgroup_size"===g.name){if(g.value.length>0){const i=x.getVariableValue(g.value[0]);_[0]=i instanceof Be?i.value:parseInt(g.value[0])}if(g.value.length>1){const i=x.getVariableValue(g.value[1]);_[1]=i instanceof Be?i.value:parseInt(g.value[1])}if(g.value.length>2){const i=x.getVariableValue(g.value[2]);_[2]=i instanceof Be?i.value:parseInt(g.value[2])}}const v=this.getTypeInfo("vec3u"),b=this.getTypeInfo("u32");x.setVariable("@workgroup_size",new Me(_,v));const y=_[0],S=_[1],w=_[2];for(let L=0,k=0;L<w;++L)for(let w=0;w<S;++w)for(let S=0;S<y;++S,++k){const y=[S,w,L],z=[S+g[0]*_[0],w+g[1]*_[1],L+g[2]*_[2]];x.setVariable("@local_invocation_id",new Me(y,v)),x.setVariable("@global_invocation_id",new Me(z,v)),x.setVariable("@local_invocation_index",new Be(k,b)),this._dispatchExec(i,x)}}_dispatchExec(i,g){for(const x of i.node.args)for(const i of x.attributes)if("builtin"===i.name){const _=`@${i.value}`,v=g.getVariable(_);void 0!==v&&g.variables.set(x.name,v)}this._execStatements(i.node.body,g)}getVariableName(i,g){for(;i instanceof ke;)i=i.right;return i instanceof ge?i.name:(console.error("Unknown variable type",i,"Line",i.line),null)}_execStatements(i,g){for(const x of i){if(x instanceof Array){const i=g.clone(),_=this._execStatements(x,i);if(_)return _;continue}const i=this.execStatement(x,g);if(i)return i}return null}_call(i,g){const x=g.clone();x.currentFunctionName=i.name;const _=g.getFunction(i.name);if(_){for(let g=0;g<_.node.args.length;++g){const v=_.node.args[g],b=this.evalExpression(i.args[g],x);x.setVariable(v.name,b,v)}this._execStatements(_.node.body,x)}else i.isBuiltin?this._callBuiltinFunction(i,x):this.getTypeInfo(i.name)&&this._evalCreate(i,g)}_increment(i,g){const x=this.getVariableName(i.variable,g),_=g.getVariable(x);_?"++"===i.operator?_.value instanceof Be?_.value.value++:console.error(`Variable ${x} is not a scalar. Line ${i.line}`):"--"===i.operator?_.value instanceof Be?_.value.value--:console.error(`Variable ${x} is not a scalar. Line ${i.line}`):console.error(`Unknown increment operator ${i.operator}. Line ${i.line}`):console.error(`Variable ${x} not found. Line ${i.line}`)}_getVariableData(i,g){if(i instanceof ge){const x=this.getVariableName(i,g),_=g.getVariable(x);return null===_?(console.error(`Variable ${x} not found. Line ${i.line}`),null):_.value.getSubData(this,i.postfix,g)}if(i instanceof ke){if("*"===i.operator){const x=this._getVariableData(i.right,g);return x instanceof Oe?x.reference.getSubData(this,i.postfix,g):(console.error(`Variable ${i.right} is not a pointer. Line ${i.line}`),null)}if("&"===i.operator){const x=this._getVariableData(i.right,g);return new Oe(x)}}return null}_assign(i,g){let x=null,_="<var>",v=null;if(i.variable instanceof ke){const x=this._getVariableData(i.variable,g),_=this.evalExpression(i.value,g),v=i.operator;if("="===v){if(x instanceof Be||x instanceof Me||x instanceof Ue){if(_ instanceof Be||_ instanceof Me||_ instanceof Ue&&x.data.length===_.data.length)return void x.data.set(_.data);console.error(`Invalid assignment. Line ${i.line}`)}else if(x instanceof Pe&&_ instanceof Pe&&x.buffer.byteLength-x.offset>=_.buffer.byteLength-_.offset)return void(x.buffer.byteLength%4==0?new Uint32Array(x.buffer,x.offset,x.typeInfo.size/4).set(new Uint32Array(_.buffer,_.offset,_.typeInfo.size/4)):new Uint8Array(x.buffer,x.offset,x.typeInfo.size).set(new Uint8Array(_.buffer,_.offset,_.typeInfo.size)));return console.error(`Invalid assignment. Line ${i.line}`),null}if("+="===v)return x instanceof Be||x instanceof Me||x instanceof Ue?_ instanceof Be||_ instanceof Me||_ instanceof Ue?void x.data.set(_.data.map((i,g)=>x.data[g]+i)):void console.error(`Invalid assignment . Line ${i.line}`):void console.error(`Invalid assignment. Line ${i.line}`);if("-="===v)return(x instanceof Be||x instanceof Me||x instanceof Ue)&&(_ instanceof Be||_ instanceof Me||_ instanceof Ue)?void x.data.set(_.data.map((i,g)=>x.data[g]-i)):void console.error(`Invalid assignment. Line ${i.line}`)}if(i.variable instanceof ke){if("*"===i.variable.operator){_=this.getVariableName(i.variable.right,g);const v=g.getVariable(_);if(!(v&&v.value instanceof Oe))return void console.error(`Variable ${_} is not a pointer. Line ${i.line}`);x=v.value.reference;let b=i.variable.postfix;if(!b){let g=i.variable.right;for(;g instanceof ke;){if(g.postfix){b=g.postfix;break}g=g.right}}b&&(x=x.getSubData(this,b,g))}}else{v=i.variable.postfix,_=this.getVariableName(i.variable,g);const b=g.getVariable(_);if(null===b)return void console.error(`Variable ${_} not found. Line ${i.line}`);x=b.value}if(x instanceof Oe&&(x=x.reference),null===x)return void console.error(`Variable ${_} not found. Line ${i.line}`);const b=this.evalExpression(i.value,g),y=i.operator;if("="!==y){const _=x.getSubData(this,v,g);if(_ instanceof Me&&b instanceof Be){const g=_.data,x=b.value;if("+="===y)for(let i=0;i<g.length;++i)g[i]+=x;else if("-="===y)for(let i=0;i<g.length;++i)g[i]-=x;else if("*="===y)for(let i=0;i<g.length;++i)g[i]*=x;else if("/="===y)for(let i=0;i<g.length;++i)g[i]/=x;else if("%="===y)for(let i=0;i<g.length;++i)g[i]%=x;else if("&="===y)for(let i=0;i<g.length;++i)g[i]&=x;else if("|="===y)for(let i=0;i<g.length;++i)g[i]|=x;else if("^="===y)for(let i=0;i<g.length;++i)g[i]^=x;else if("<<="===y)for(let i=0;i<g.length;++i)g[i]<<=x;else if(">>="===y)for(let i=0;i<g.length;++i)g[i]>>=x;else console.error(`Invalid operator ${y}. Line ${i.line}`)}else if(_ instanceof Me&&b instanceof Me){const g=_.data,x=b.data;if(g.length!==x.length)return void console.error(`Vector length mismatch. Line ${i.line}`);if("+="===y)for(let i=0;i<g.length;++i)g[i]+=x[i];else if("-="===y)for(let i=0;i<g.length;++i)g[i]-=x[i];else if("*="===y)for(let i=0;i<g.length;++i)g[i]*=x[i];else if("/="===y)for(let i=0;i<g.length;++i)g[i]/=x[i];else if("%="===y)for(let i=0;i<g.length;++i)g[i]%=x[i];else if("&="===y)for(let i=0;i<g.length;++i)g[i]&=x[i];else if("|="===y)for(let i=0;i<g.length;++i)g[i]|=x[i];else if("^="===y)for(let i=0;i<g.length;++i)g[i]^=x[i];else if("<<="===y)for(let i=0;i<g.length;++i)g[i]<<=x[i];else if(">>="===y)for(let i=0;i<g.length;++i)g[i]>>=x[i];else console.error(`Invalid operator ${y}. Line ${i.line}`)}else{if(!(_ instanceof Be&&b instanceof Be))return void console.error(`Invalid type for ${i.operator} operator. Line ${i.line}`);"+="===y?_.value+=b.value:"-="===y?_.value-=b.value:"*="===y?_.value*=b.value:"/="===y?_.value/=b.value:"%="===y?_.value%=b.value:"&="===y?_.value&=b.value:"|="===y?_.value|=b.value:"^="===y?_.value^=b.value:"<<="===y?_.value<<=b.value:">>="===y?_.value>>=b.value:console.error(`Invalid operator ${y}. Line ${i.line}`)}return void(x instanceof Pe&&x.setDataValue(this,_,v,g))}if(x instanceof Pe)x.setDataValue(this,b,v,g);else if(v){if(!(x instanceof Me||x instanceof Ue))return void console.error(`Variable ${_} is not a vector or matrix. Line ${i.line}`);if(v instanceof ve){const y=this.evalExpression(v.index,g).value;if(x instanceof Me){if(!(b instanceof Be))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);x.data[y]=b.value}else{if(!(x instanceof Ue))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);{const y=this.evalExpression(v.index,g).value;if(y<0)return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);if(!(b instanceof Me))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);{const g=x.typeInfo.getTypeName();if("mat2x2"===g||"mat2x2f"===g||"mat2x2h"===g){if(!(y<2&&2===b.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);x.data[2*y]=b.data[0],x.data[2*y+1]=b.data[1]}else if("mat2x3"===g||"mat2x3f"===g||"mat2x3h"===g){if(!(y<2&&3===b.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);x.data[3*y]=b.data[0],x.data[3*y+1]=b.data[1],x.data[3*y+2]=b.data[2]}else if("mat2x4"===g||"mat2x4f"===g||"mat2x4h"===g){if(!(y<2&&4===b.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);x.data[4*y]=b.data[0],x.data[4*y+1]=b.data[1],x.data[4*y+2]=b.data[2],x.data[4*y+3]=b.data[3]}else if("mat3x2"===g||"mat3x2f"===g||"mat3x2h"===g){if(!(y<3&&2===b.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);x.data[2*y]=b.data[0],x.data[2*y+1]=b.data[1]}else if("mat3x3"===g||"mat3x3f"===g||"mat3x3h"===g){if(!(y<3&&3===b.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);x.data[3*y]=b.data[0],x.data[3*y+1]=b.data[1],x.data[3*y+2]=b.data[2]}else if("mat3x4"===g||"mat3x4f"===g||"mat3x4h"===g){if(!(y<3&&4===b.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);x.data[4*y]=b.data[0],x.data[4*y+1]=b.data[1],x.data[4*y+2]=b.data[2],x.data[4*y+3]=b.data[3]}else if("mat4x2"===g||"mat4x2f"===g||"mat4x2h"===g){if(!(y<4&&2===b.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);x.data[2*y]=b.data[0],x.data[2*y+1]=b.data[1]}else if("mat4x3"===g||"mat4x3f"===g||"mat4x3h"===g){if(!(y<4&&3===b.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);x.data[3*y]=b.data[0],x.data[3*y+1]=b.data[1],x.data[3*y+2]=b.data[2]}else{if("mat4x4"!==g&&"mat4x4f"!==g&&"mat4x4h"!==g)return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);if(!(y<4&&4===b.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);x.data[4*y]=b.data[0],x.data[4*y+1]=b.data[1],x.data[4*y+2]=b.data[2],x.data[4*y+3]=b.data[3]}}}}}else if(v instanceof pe){const g=v.value;if(!(x instanceof Me))return void console.error(`Invalid assignment to ${g}. Variable ${_} is not a vector. Line ${i.line}`);if(b instanceof Be){if(g.length>1)return void console.error(`Invalid assignment to ${g} for variable ${_}. Line ${i.line}`);if("x"===g)x.data[0]=b.value;else if("y"===g){if(x.data.length<2)return void console.error(`Invalid assignment to ${g} for variable ${_}. Line ${i.line}`);x.data[1]=b.value}else if("z"===g){if(x.data.length<3)return void console.error(`Invalid assignment to ${g} for variable ${_}. Line ${i.line}`);x.data[2]=b.value}else if("w"===g){if(x.data.length<4)return void console.error(`Invalid assignment to ${g} for variable ${_}. Line ${i.line}`);x.data[3]=b.value}}else{if(!(b instanceof Me))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);if(g.length!==b.data.length)return void console.error(`Invalid assignment to ${g} for variable ${_}. Line ${i.line}`);for(let v=0;v<g.length;++v){const y=g[v];if("x"===y||"r"===y)x.data[0]=b.data[v];else if("y"===y||"g"===y){if(b.data.length<2)return void console.error(`Invalid assignment to ${y} for variable ${_}. Line ${i.line}`);x.data[1]=b.data[v]}else if("z"===y||"b"===y){if(b.data.length<3)return void console.error(`Invalid assignment to ${y} for variable ${_}. Line ${i.line}`);x.data[2]=b.data[v]}else{if("w"!==y&&"a"!==y)return void console.error(`Invalid assignment to ${y} for variable ${_}. Line ${i.line}`);if(b.data.length<4)return void console.error(`Invalid assignment to ${y} for variable ${_}. Line ${i.line}`);x.data[3]=b.data[v]}}}}}else x instanceof Be&&b instanceof Be?x.value=b.value:x instanceof Me&&b instanceof Me||x instanceof Ue&&b instanceof Ue?x.data.set(b.data):console.error(`Invalid assignment to ${_}. Line ${i.line}`)}_function(i,g){const x=new ct(i);g.functions.set(i.name,x)}_const(i,g){let x=null;null!==i.value&&(x=this.evalExpression(i.value,g)),g.createVariable(i.name,x,i)}_let(i,g){let x=null;if(null!==i.value){if(x=this.evalExpression(i.value,g),null===x)return void console.error(`Invalid value for variable ${i.name}. Line ${i.line}`);i.value instanceof ke||(x=x.clone())}else{const _=i.type.name;if("f32"===_||"i32"===_||"u32"===_||"bool"===_||"f16"===_||"vec2"===_||"vec3"===_||"vec4"===_||"vec2f"===_||"vec3f"===_||"vec4f"===_||"vec2i"===_||"vec3i"===_||"vec4i"===_||"vec2u"===_||"vec3u"===_||"vec4u"===_||"vec2h"===_||"vec3h"===_||"vec4h"===_||"vec2b"===_||"vec3b"===_||"vec4b"===_||"mat2x2"===_||"mat2x3"===_||"mat2x4"===_||"mat3x2"===_||"mat3x3"===_||"mat3x4"===_||"mat4x2"===_||"mat4x3"===_||"mat4x4"===_||"mat2x2f"===_||"mat2x3f"===_||"mat2x4f"===_||"mat3x2f"===_||"mat3x3f"===_||"mat3x4f"===_||"mat4x2f"===_||"mat4x3f"===_||"mat4x4f"===_||"mat2x2h"===_||"mat2x3h"===_||"mat2x4h"===_||"mat3x2h"===_||"mat3x3h"===_||"mat3x4h"===_||"mat4x2h"===_||"mat4x3h"===_||"mat4x4h"===_||"array"===_){const _=new de(i.type,[]);x=this._evalCreate(_,g)}}g.createVariable(i.name,x,i)}_var(i,g){let x=null;if(null!==i.value){if(x=this.evalExpression(i.value,g),null===x)return void console.error(`Invalid value for variable ${i.name}. Line ${i.line}`);i.value instanceof ke||(x=x.clone())}else{if(null===i.type)return void console.error(`Variable ${i.name} has no type. Line ${i.line}`);const _=i.type.name;if("f32"===_||"i32"===_||"u32"===_||"bool"===_||"f16"===_||"vec2"===_||"vec3"===_||"vec4"===_||"vec2f"===_||"vec3f"===_||"vec4f"===_||"vec2i"===_||"vec3i"===_||"vec4i"===_||"vec2u"===_||"vec3u"===_||"vec4u"===_||"vec2h"===_||"vec3h"===_||"vec4h"===_||"vec2b"===_||"vec3b"===_||"vec4b"===_||"mat2x2"===_||"mat2x3"===_||"mat2x4"===_||"mat3x2"===_||"mat3x3"===_||"mat3x4"===_||"mat4x2"===_||"mat4x3"===_||"mat4x4"===_||"mat2x2f"===_||"mat2x3f"===_||"mat2x4f"===_||"mat3x2f"===_||"mat3x3f"===_||"mat3x4f"===_||"mat4x2f"===_||"mat4x3f"===_||"mat4x4f"===_||"mat2x2h"===_||"mat2x3h"===_||"mat2x4h"===_||"mat3x2h"===_||"mat3x3h"===_||"mat3x4h"===_||"mat4x2h"===_||"mat4x3h"===_||"mat4x4h"===_||i.type instanceof ue||i.type instanceof oe||i.type instanceof ce){const _=new de(i.type,[]);x=this._evalCreate(_,g)}}g.createVariable(i.name,x,i)}_switch(i,g){g=g.clone();const x=this.evalExpression(i.condition,g);if(!(x instanceof Be))return console.error(`Invalid if condition. Line ${i.line}`),null;let _=null;for(const v of i.cases)if(v instanceof Ae)for(const b of v.selectors){if(b instanceof Se){_=v;continue}const y=this.evalExpression(b,g);if(!(y instanceof Be))return console.error(`Invalid case selector. Line ${i.line}`),null;if(y.value===x.value)return this._execStatements(v.body,g)}else v instanceof Ee&&(_=v);return _?this._execStatements(_.body,g):null}_if(i,g){g=g.clone();const x=this.evalExpression(i.condition,g);if(!(x instanceof Be))return console.error(`Invalid if condition. Line ${i.line}`),null;if(x.value)return this._execStatements(i.body,g);for(const x of i.elseif){const _=this.evalExpression(x.condition,g);if(!(_ instanceof Be))return console.error(`Invalid if condition. Line ${i.line}`),null;if(_.value)return this._execStatements(x.body,g)}return i.else?this._execStatements(i.else,g):null}_getScalarValue(i){return i instanceof Be?i.value:(console.error("Expected scalar value.",i),0)}_for(i,g){for(g=g.clone(),this.execStatement(i.init,g);this._getScalarValue(this.evalExpression(i.condition,g));){const x=this._execStatements(i.body,g);if(x===dt._breakObj)break;if(null!==x&&x!==dt._continueObj)return x;this.execStatement(i.increment,g)}return null}_loop(i,g){for(g=g.clone();;){const x=this._execStatements(i.body,g);if(x===dt._breakObj)break;if(x===dt._continueObj){if(i.continuing&&this._execStatements(i.continuing.body,g)===dt._breakObj)break}else if(null!==x)return x}return null}_while(i,g){for(g=g.clone();this._getScalarValue(this.evalExpression(i.condition,g));){const x=this._execStatements(i.body,g);if(x===dt._breakObj)break;if(x!==dt._continueObj&&null!==x)return x}return null}_evalBitcast(i,g){const x=this.evalExpression(i.value,g),_=i.type;if(x instanceof Be){const i=nt(x.value,x.typeInfo.name,_.name);return new Be(i,this.getTypeInfo(_))}if(x instanceof Me){const g=x.typeInfo.getTypeName();let v="";if(g.endsWith("f"))v="f32";else if(g.endsWith("i"))v="i32";else if(g.endsWith("u"))v="u32";else if(g.endsWith("b"))v="bool";else{if(!g.endsWith("h"))return console.error(`Unknown vector type ${g}. Line ${i.line}`),null;v="f16"}const b=_.getTypeName();let y="";if(b.endsWith("f"))y="f32";else if(b.endsWith("i"))y="i32";else if(b.endsWith("u"))y="u32";else if(b.endsWith("b"))y="bool";else{if(!b.endsWith("h"))return console.error(`Unknown vector type ${y}. Line ${i.line}`),null;y="f16"}const S=function(i,g,x){if(g===x)return i;const _=new Array(i.length);for(let v=0;v<i.length;v++)_[v]=nt(i[v],g,x);return _}(Array.from(x.data),v,y);return new Me(S,this.getTypeInfo(_))}return console.error(`TODO:bitcast for ${x.typeInfo.name}. Line ${i.line}`),null}_evalConst(i,g){return g.getVariableValue(i.name).clone().getSubData(this,i.postfix,g)}_evalCreate(i,g){var x;if(i instanceof de){if(null===i.type)return Ve.void;switch(i.type.getTypeName()){case"bool":case"i32":case"u32":case"f32":case"f16":return this._callConstructorValue(i,g);case"vec2":case"vec3":case"vec4":case"vec2f":case"vec3f":case"vec4f":case"vec2h":case"vec3h":case"vec4h":case"vec2i":case"vec3i":case"vec4i":case"vec2u":case"vec3u":case"vec4u":case"vec2b":case"vec3b":case"vec4b":return this._callConstructorVec(i,g);case"mat2x2":case"mat2x2f":case"mat2x2h":case"mat2x3":case"mat2x3f":case"mat2x3h":case"mat2x4":case"mat2x4f":case"mat2x4h":case"mat3x2":case"mat3x2f":case"mat3x2h":case"mat3x3":case"mat3x3f":case"mat3x3h":case"mat3x4":case"mat3x4f":case"mat3x4h":case"mat4x2":case"mat4x2f":case"mat4x2h":case"mat4x3":case"mat4x3f":case"mat4x3h":case"mat4x4":case"mat4x4f":case"mat4x4h":return this._callConstructorMatrix(i,g)}}const _=i instanceof de?i.type.name:i.name,v=i instanceof de?this.getTypeInfo(i.type):this.getTypeInfo(i.name);if(null===v)return console.error(`Unknown type ${_}. Line ${i.line}`),null;if(0===v.size)return null;const b=new Pe(new ArrayBuffer(v.size),v,0);if(v instanceof n){if(i.args)for(let x=0;x<i.args.length;++x){const _=v.members[x],y=i.args[x],S=this.evalExpression(y,g);b.setData(this,S,_.type,_.offset,g)}}else if(v instanceof s){let _=0;if(i.args)for(let y=0;y<i.args.length;++y){const S=i.args[y],w=this.evalExpression(S,g);null===v.format&&("x32"===(null===(x=w.typeInfo)||void 0===x?void 0:x.name)?v.format=this.getTypeInfo("i32"):v.format=w.typeInfo),b.setData(this,w,v.format,_,g),_+=v.stride}}else console.error(`Unknown type "${_}". Line ${i.line}`);return i instanceof de?b.getSubData(this,i.postfix,g):b}_evalLiteral(i,g){const x=this.getTypeInfo(i.type),_=x.name;return"x32"===_||"u32"===_||"f32"===_||"f16"===_||"i32"===_||"bool"===_?new Be(i.scalarValue,x):"vec2"===_||"vec3"===_||"vec4"===_||"vec2f"===_||"vec3f"===_||"vec4f"===_||"vec2h"===_||"vec3h"===_||"vec4h"===_||"vec2i"===_||"vec3i"===_||"vec4i"===_||"vec2u"===_||"vec3u"===_||"vec4u"===_?this._callConstructorVec(i,g):"mat2x2"===_||"mat2x3"===_||"mat2x4"===_||"mat3x2"===_||"mat3x3"===_||"mat3x4"===_||"mat4x2"===_||"mat4x3"===_||"mat4x4"===_||"mat2x2f"===_||"mat2x3f"===_||"mat2x4f"===_||"mat3x2f"===_||"mat3x3f"===_||"mat3x4f"===_||"mat4x2f"===_||"mat4x3f"===_||"mat4x4f"===_||"mat2x2h"===_||"mat2x3h"===_||"mat2x4h"===_||"mat3x2h"===_||"mat3x3h"===_||"mat3x4h"===_||"mat4x2h"===_||"mat4x3h"===_||"mat4x4h"===_?this._callConstructorMatrix(i,g):i.value}_evalVariable(i,g){const x=g.getVariableValue(i.name);return null===x?x:x.getSubData(this,i.postfix,g)}_maxFormatTypeInfo(i){let g=i[0];if("f32"===g.name)return g;for(let x=1;x<i.length;++x){const _=dt._priority.get(g.name);dt._priority.get(i[x].name)<_&&(g=i[x])}return"x32"===g.name?this.getTypeInfo("i32"):g}_evalUnaryOp(i,g){const x=this.evalExpression(i.right,g);if("&"===i.operator)return new Oe(x);if("*"===i.operator)return x instanceof Oe?x.reference.getSubData(this,i.postfix,g):(console.error(`Invalid dereference. Line ${i.line}`),null);const _=x instanceof Be?x.value:x instanceof Me?Array.from(x.data):null;switch(i.operator){case"+":{if(Ge(_)){const i=_.map((i,g)=>+i);return new Me(i,x.typeInfo)}const i=_,g=this._maxFormatTypeInfo([x.typeInfo,x.typeInfo]);return new Be(+i,g)}case"-":{if(Ge(_)){const i=_.map((i,g)=>-i);return new Me(i,x.typeInfo)}const i=_,g=this._maxFormatTypeInfo([x.typeInfo,x.typeInfo]);return new Be(-i,g)}case"!":{if(Ge(_)){const i=_.map((i,g)=>i?0:1);return new Me(i,x.typeInfo)}const i=_,g=this._maxFormatTypeInfo([x.typeInfo,x.typeInfo]);return new Be(i?0:1,g)}case"~":{if(Ge(_)){const i=_.map((i,g)=>~i);return new Me(i,x.typeInfo)}const i=_,g=this._maxFormatTypeInfo([x.typeInfo,x.typeInfo]);return new Be(~i,g)}}return console.error(`Invalid unary operator ${i.operator}. Line ${i.line}`),null}_evalBinaryOp(i,g){const x=this.evalExpression(i.left,g),_=this.evalExpression(i.right,g),v=x instanceof Be?x.value:x instanceof Me||x instanceof Ue?Array.from(x.data):null,b=_ instanceof Be?_.value:_ instanceof Me||_ instanceof Ue?Array.from(_.data):null;switch(i.operator){case"+":{if(Ge(v)&&Ge(b)){const g=v,_=b;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=g.map((i,g)=>i+_[g]);return new Me(y,x.typeInfo)}if(Ge(v)){const i=b,g=v.map((g,x)=>g+i);return new Me(g,x.typeInfo)}if(Ge(b)){const i=v,g=b.map((g,x)=>i+g);return new Me(g,_.typeInfo)}const g=v,y=b,S=this._maxFormatTypeInfo([x.typeInfo,_.typeInfo]);return new Be(g+y,S)}case"-":{if(Ge(v)&&Ge(b)){const g=v,_=b;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=g.map((i,g)=>i-_[g]);return new Me(y,x.typeInfo)}if(Ge(v)){const i=b,g=v.map((g,x)=>g-i);return new Me(g,x.typeInfo)}if(Ge(b)){const i=v,g=b.map((g,x)=>i-g);return new Me(g,_.typeInfo)}const g=v,y=b,S=this._maxFormatTypeInfo([x.typeInfo,_.typeInfo]);return new Be(g-y,S)}case"*":{if(Ge(v)&&Ge(b)){const g=v,y=b;if(x instanceof Ue&&_ instanceof Ue){const v=function(i,g,x,_){if(void 0===jn[g.name]||void 0===jn[_.name])return null;const v=jn[g.name][0],b=jn[g.name][1],y=jn[_.name][0];if(v!==jn[_.name][1])return null;const S=new Array(y*b);for(let g=0;g<b;g++)for(let _=0;_<y;_++){let w=0;for(let y=0;y<v;y++)w+=i[y*b+g]*x[_*v+y];S[g*y+_]=w}return S}(g,x.typeInfo,y,_.typeInfo);if(null===v)return console.error(`Matrix multiplication failed. Line ${i.line}.`),null;const b=jn[_.typeInfo.name][0],S=jn[x.typeInfo.name][1],w=this.getTypeInfo(`mat${b}x${S}f`);return new Ue(v,w)}if(x instanceof Ue&&_ instanceof Me){const v=function(i,g,x,_){if(void 0===jn[g.name]||void 0===Xn[_.name])return null;const v=jn[g.name][0],b=jn[g.name][1];if(v!==x.length)return null;const y=new Array(b);for(let g=0;g<b;g++){let _=0;for(let y=0;y<v;y++)_+=i[y*b+g]*x[y];y[g]=_}return y}(g,x.typeInfo,y,_.typeInfo);return null===v?(console.error(`Matrix vector multiplication failed. Line ${i.line}.`),null):new Me(v,_.typeInfo)}if(x instanceof Me&&_ instanceof Ue){const v=function(i,g,x,_){if(void 0===Xn[g.name]||void 0===jn[_.name])return null;const v=jn[_.name][0],b=jn[_.name][1];if(b!==i.length)return null;const y=[];for(let g=0;g<v;g++){let _=0;for(let y=0;y<b;y++)_+=i[y]*x[y*v+g];y[g]=_}return y}(g,x.typeInfo,y,_.typeInfo);return null===v?(console.error(`Matrix vector multiplication failed. Line ${i.line}.`),null):new Me(v,x.typeInfo)}{if(g.length!==y.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const _=g.map((i,g)=>i*y[g]);return new Me(_,x.typeInfo)}}if(Ge(v)){const i=b,g=v.map((g,x)=>g*i);return x instanceof Ue?new Ue(g,x.typeInfo):new Me(g,x.typeInfo)}if(Ge(b)){const i=v,g=b.map((g,x)=>i*g);return _ instanceof Ue?new Ue(g,_.typeInfo):new Me(g,_.typeInfo)}const g=v,y=b,S=this._maxFormatTypeInfo([x.typeInfo,_.typeInfo]);return new Be(g*y,S)}case"%":{if(Ge(v)&&Ge(b)){const g=v,_=b;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=g.map((i,g)=>i%_[g]);return new Me(y,x.typeInfo)}if(Ge(v)){const i=b,g=v.map((g,x)=>g%i);return new Me(g,x.typeInfo)}if(Ge(b)){const i=v,g=b.map((g,x)=>i%g);return new Me(g,_.typeInfo)}const g=v,y=b,S=this._maxFormatTypeInfo([x.typeInfo,_.typeInfo]);return new Be(g%y,S)}case"/":{if(Ge(v)&&Ge(b)){const g=v,_=b;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=g.map((i,g)=>i/_[g]);return new Me(y,x.typeInfo)}if(Ge(v)){const i=b,g=v.map((g,x)=>g/i);return new Me(g,x.typeInfo)}if(Ge(b)){const i=v,g=b.map((g,x)=>i/g);return new Me(g,_.typeInfo)}const g=v,y=b,S=this._maxFormatTypeInfo([x.typeInfo,_.typeInfo]);return new Be(g/y,S)}case"&":{if(Ge(v)&&Ge(b)){const g=v,_=b;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=g.map((i,g)=>i&_[g]);return new Me(y,x.typeInfo)}if(Ge(v)){const i=b,g=v.map((g,x)=>g&i);return new Me(g,x.typeInfo)}if(Ge(b)){const i=v,g=b.map((g,x)=>i&g);return new Me(g,_.typeInfo)}const g=v,y=b,S=this._maxFormatTypeInfo([x.typeInfo,_.typeInfo]);return new Be(g&y,S)}case"|":{if(Ge(v)&&Ge(b)){const g=v,_=b;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=g.map((i,g)=>i|_[g]);return new Me(y,x.typeInfo)}if(Ge(v)){const i=b,g=v.map((g,x)=>g|i);return new Me(g,x.typeInfo)}if(Ge(b)){const i=v,g=b.map((g,x)=>i|g);return new Me(g,_.typeInfo)}const g=v,y=b,S=this._maxFormatTypeInfo([x.typeInfo,_.typeInfo]);return new Be(g|y,S)}case"^":{if(Ge(v)&&Ge(b)){const g=v,_=b;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=g.map((i,g)=>i^_[g]);return new Me(y,x.typeInfo)}if(Ge(v)){const i=b,g=v.map((g,x)=>g^i);return new Me(g,x.typeInfo)}if(Ge(b)){const i=v,g=b.map((g,x)=>i^g);return new Me(g,_.typeInfo)}const g=v,y=b,S=this._maxFormatTypeInfo([x.typeInfo,_.typeInfo]);return new Be(g^y,S)}case"<<":{if(Ge(v)&&Ge(b)){const g=v,_=b;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=g.map((i,g)=>i<<_[g]);return new Me(y,x.typeInfo)}if(Ge(v)){const i=b,g=v.map((g,x)=>g<<i);return new Me(g,x.typeInfo)}if(Ge(b)){const i=v,g=b.map((g,x)=>i<<g);return new Me(g,_.typeInfo)}const g=v,y=b,S=this._maxFormatTypeInfo([x.typeInfo,_.typeInfo]);return new Be(g<<y,S)}case">>":{if(Ge(v)&&Ge(b)){const g=v,_=b;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=g.map((i,g)=>i>>_[g]);return new Me(y,x.typeInfo)}if(Ge(v)){const i=b,g=v.map((g,x)=>g>>i);return new Me(g,x.typeInfo)}if(Ge(b)){const i=v,g=b.map((g,x)=>i>>g);return new Me(g,_.typeInfo)}const g=v,y=b,S=this._maxFormatTypeInfo([x.typeInfo,_.typeInfo]);return new Be(g>>y,S)}case">":if(Ge(v)&&Ge(b)){const g=v,_=b;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=g.map((i,g)=>i>_[g]?1:0);return new Me(y,x.typeInfo)}if(Ge(v)){const i=b,g=v.map((g,x)=>g>i?1:0);return new Me(g,x.typeInfo)}if(Ge(b)){const i=v,g=b.map((g,x)=>i>g?1:0);return new Me(g,_.typeInfo)}return new Be(v>b?1:0,this.getTypeInfo("bool"));case"<":if(Ge(v)&&Ge(b)){const g=v,_=b;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=g.map((i,g)=>i<_[g]?1:0);return new Me(y,x.typeInfo)}if(Ge(v)){const i=b,g=v.map((g,x)=>g<i?1:0);return new Me(g,x.typeInfo)}if(Ge(b)){const i=v,g=b.map((g,x)=>i<g?1:0);return new Me(g,_.typeInfo)}return new Be(v<b?1:0,this.getTypeInfo("bool"));case"==":if(Ge(v)&&Ge(b)){const g=v,_=b;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=g.map((i,g)=>i===_[g]?1:0);return new Me(y,x.typeInfo)}if(Ge(v)){const i=b,g=v.map((g,x)=>g==i?1:0);return new Me(g,x.typeInfo)}if(Ge(b)){const i=v,g=b.map((g,x)=>i==g?1:0);return new Me(g,_.typeInfo)}return new Be(v===b?1:0,this.getTypeInfo("bool"));case"!=":if(Ge(v)&&Ge(b)){const g=v,_=b;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=g.map((i,g)=>i!==_[g]?1:0);return new Me(y,x.typeInfo)}if(Ge(v)){const i=b,g=v.map((g,x)=>g!==i?1:0);return new Me(g,x.typeInfo)}if(Ge(b)){const i=v,g=b.map((g,x)=>i!==g?1:0);return new Me(g,_.typeInfo)}return new Be(v!==b?1:0,this.getTypeInfo("bool"));case">=":if(Ge(v)&&Ge(b)){const g=v,_=b;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=g.map((i,g)=>i>=_[g]?1:0);return new Me(y,x.typeInfo)}if(Ge(v)){const i=b,g=v.map((g,x)=>g>=i?1:0);return new Me(g,x.typeInfo)}if(Ge(b)){const i=v,g=b.map((g,x)=>i>=g?1:0);return new Me(g,_.typeInfo)}return new Be(v>=b?1:0,this.getTypeInfo("bool"));case"<=":if(Ge(v)&&Ge(b)){const g=v,_=b;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=g.map((i,g)=>i<=_[g]?1:0);return new Me(y,x.typeInfo)}if(Ge(v)){const i=b,g=v.map((g,x)=>g<=i?1:0);return new Me(g,x.typeInfo)}if(Ge(b)){const i=v,g=b.map((g,x)=>i<=g?1:0);return new Me(g,_.typeInfo)}return new Be(v<=b?1:0,this.getTypeInfo("bool"));case"&&":if(Ge(v)&&Ge(b)){const g=v,_=b;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=g.map((i,g)=>i&&_[g]?1:0);return new Me(y,x.typeInfo)}if(Ge(v)){const i=b,g=v.map((g,x)=>g&&i?1:0);return new Me(g,x.typeInfo)}if(Ge(b)){const i=v,g=b.map((g,x)=>i&&g?1:0);return new Me(g,_.typeInfo)}return new Be(v&&b?1:0,this.getTypeInfo("bool"));case"||":if(Ge(v)&&Ge(b)){const g=v,_=b;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const y=g.map((i,g)=>i||_[g]?1:0);return new Me(y,x.typeInfo)}if(Ge(v)){const i=b,g=v.map((g,x)=>g||i?1:0);return new Me(g,x.typeInfo)}if(Ge(b)){const i=v,g=b.map((g,x)=>i||g?1:0);return new Me(g,_.typeInfo)}return new Be(v||b?1:0,this.getTypeInfo("bool"))}return console.error(`Unknown operator ${i.operator}. Line ${i.line}`),null}_evalCall(i,g){if(null!==i.cachedReturnValue)return i.cachedReturnValue;const x=g.clone();x.currentFunctionName=i.name;const _=g.getFunction(i.name);if(!_)return i.isBuiltin?this._callBuiltinFunction(i,x):this.getTypeInfo(i.name)?this._evalCreate(i,g):(console.error(`Unknown function "${i.name}". Line ${i.line}`),null);for(let g=0;g<_.node.args.length;++g){const v=_.node.args[g],b=this.evalExpression(i.args[g],x);x.createVariable(v.name,b,v)}return this._execStatements(_.node.body,x)}_callBuiltinFunction(i,g){switch(i.name){case"all":return this.builtins.All(i,g);case"any":return this.builtins.Any(i,g);case"select":return this.builtins.Select(i,g);case"arrayLength":return this.builtins.ArrayLength(i,g);case"abs":return this.builtins.Abs(i,g);case"acos":return this.builtins.Acos(i,g);case"acosh":return this.builtins.Acosh(i,g);case"asin":return this.builtins.Asin(i,g);case"asinh":return this.builtins.Asinh(i,g);case"atan":return this.builtins.Atan(i,g);case"atanh":return this.builtins.Atanh(i,g);case"atan2":return this.builtins.Atan2(i,g);case"ceil":return this.builtins.Ceil(i,g);case"clamp":return this.builtins.Clamp(i,g);case"cos":return this.builtins.Cos(i,g);case"cosh":return this.builtins.Cosh(i,g);case"countLeadingZeros":return this.builtins.CountLeadingZeros(i,g);case"countOneBits":return this.builtins.CountOneBits(i,g);case"countTrailingZeros":return this.builtins.CountTrailingZeros(i,g);case"cross":return this.builtins.Cross(i,g);case"degrees":return this.builtins.Degrees(i,g);case"determinant":return this.builtins.Determinant(i,g);case"distance":return this.builtins.Distance(i,g);case"dot":return this.builtins.Dot(i,g);case"dot4U8Packed":return this.builtins.Dot4U8Packed(i,g);case"dot4I8Packed":return this.builtins.Dot4I8Packed(i,g);case"exp":return this.builtins.Exp(i,g);case"exp2":return this.builtins.Exp2(i,g);case"extractBits":return this.builtins.ExtractBits(i,g);case"faceForward":return this.builtins.FaceForward(i,g);case"firstLeadingBit":return this.builtins.FirstLeadingBit(i,g);case"firstTrailingBit":return this.builtins.FirstTrailingBit(i,g);case"floor":return this.builtins.Floor(i,g);case"fma":return this.builtins.Fma(i,g);case"fract":return this.builtins.Fract(i,g);case"frexp":return this.builtins.Frexp(i,g);case"insertBits":return this.builtins.InsertBits(i,g);case"inverseSqrt":return this.builtins.InverseSqrt(i,g);case"ldexp":return this.builtins.Ldexp(i,g);case"length":return this.builtins.Length(i,g);case"log":return this.builtins.Log(i,g);case"log2":return this.builtins.Log2(i,g);case"max":return this.builtins.Max(i,g);case"min":return this.builtins.Min(i,g);case"mix":return this.builtins.Mix(i,g);case"modf":return this.builtins.Modf(i,g);case"normalize":return this.builtins.Normalize(i,g);case"pow":return this.builtins.Pow(i,g);case"quantizeToF16":return this.builtins.QuantizeToF16(i,g);case"radians":return this.builtins.Radians(i,g);case"reflect":return this.builtins.Reflect(i,g);case"refract":return this.builtins.Refract(i,g);case"reverseBits":return this.builtins.ReverseBits(i,g);case"round":return this.builtins.Round(i,g);case"saturate":return this.builtins.Saturate(i,g);case"sign":return this.builtins.Sign(i,g);case"sin":return this.builtins.Sin(i,g);case"sinh":return this.builtins.Sinh(i,g);case"smoothstep":return this.builtins.SmoothStep(i,g);case"sqrt":return this.builtins.Sqrt(i,g);case"step":return this.builtins.Step(i,g);case"tan":return this.builtins.Tan(i,g);case"tanh":return this.builtins.Tanh(i,g);case"transpose":return this.builtins.Transpose(i,g);case"trunc":return this.builtins.Trunc(i,g);case"dpdx":return this.builtins.Dpdx(i,g);case"dpdxCoarse":return this.builtins.DpdxCoarse(i,g);case"dpdxFine":return this.builtins.DpdxFine(i,g);case"dpdy":return this.builtins.Dpdy(i,g);case"dpdyCoarse":return this.builtins.DpdyCoarse(i,g);case"dpdyFine":return this.builtins.DpdyFine(i,g);case"fwidth":return this.builtins.Fwidth(i,g);case"fwidthCoarse":return this.builtins.FwidthCoarse(i,g);case"fwidthFine":return this.builtins.FwidthFine(i,g);case"textureDimensions":return this.builtins.TextureDimensions(i,g);case"textureGather":return this.builtins.TextureGather(i,g);case"textureGatherCompare":return this.builtins.TextureGatherCompare(i,g);case"textureLoad":return this.builtins.TextureLoad(i,g);case"textureNumLayers":return this.builtins.TextureNumLayers(i,g);case"textureNumLevels":return this.builtins.TextureNumLevels(i,g);case"textureNumSamples":return this.builtins.TextureNumSamples(i,g);case"textureSample":return this.builtins.TextureSample(i,g);case"textureSampleBias":return this.builtins.TextureSampleBias(i,g);case"textureSampleCompare":return this.builtins.TextureSampleCompare(i,g);case"textureSampleCompareLevel":return this.builtins.TextureSampleCompareLevel(i,g);case"textureSampleGrad":return this.builtins.TextureSampleGrad(i,g);case"textureSampleLevel":return this.builtins.TextureSampleLevel(i,g);case"textureSampleBaseClampToEdge":return this.builtins.TextureSampleBaseClampToEdge(i,g);case"textureStore":return this.builtins.TextureStore(i,g);case"atomicLoad":return this.builtins.AtomicLoad(i,g);case"atomicStore":return this.builtins.AtomicStore(i,g);case"atomicAdd":return this.builtins.AtomicAdd(i,g);case"atomicSub":return this.builtins.AtomicSub(i,g);case"atomicMax":return this.builtins.AtomicMax(i,g);case"atomicMin":return this.builtins.AtomicMin(i,g);case"atomicAnd":return this.builtins.AtomicAnd(i,g);case"atomicOr":return this.builtins.AtomicOr(i,g);case"atomicXor":return this.builtins.AtomicXor(i,g);case"atomicExchange":return this.builtins.AtomicExchange(i,g);case"atomicCompareExchangeWeak":return this.builtins.AtomicCompareExchangeWeak(i,g);case"pack4x8snorm":return this.builtins.Pack4x8snorm(i,g);case"pack4x8unorm":return this.builtins.Pack4x8unorm(i,g);case"pack4xI8":return this.builtins.Pack4xI8(i,g);case"pack4xU8":return this.builtins.Pack4xU8(i,g);case"pack4x8Clamp":return this.builtins.Pack4x8Clamp(i,g);case"pack4xU8Clamp":return this.builtins.Pack4xU8Clamp(i,g);case"pack2x16snorm":return this.builtins.Pack2x16snorm(i,g);case"pack2x16unorm":return this.builtins.Pack2x16unorm(i,g);case"pack2x16float":return this.builtins.Pack2x16float(i,g);case"unpack4x8snorm":return this.builtins.Unpack4x8snorm(i,g);case"unpack4x8unorm":return this.builtins.Unpack4x8unorm(i,g);case"unpack4xI8":return this.builtins.Unpack4xI8(i,g);case"unpack4xU8":return this.builtins.Unpack4xU8(i,g);case"unpack2x16snorm":return this.builtins.Unpack2x16snorm(i,g);case"unpack2x16unorm":return this.builtins.Unpack2x16unorm(i,g);case"unpack2x16float":return this.builtins.Unpack2x16float(i,g);case"storageBarrier":return this.builtins.StorageBarrier(i,g);case"textureBarrier":return this.builtins.TextureBarrier(i,g);case"workgroupBarrier":return this.builtins.WorkgroupBarrier(i,g);case"workgroupUniformLoad":return this.builtins.WorkgroupUniformLoad(i,g);case"subgroupAdd":return this.builtins.SubgroupAdd(i,g);case"subgroupExclusiveAdd":return this.builtins.SubgroupExclusiveAdd(i,g);case"subgroupInclusiveAdd":return this.builtins.SubgroupInclusiveAdd(i,g);case"subgroupAll":return this.builtins.SubgroupAll(i,g);case"subgroupAnd":return this.builtins.SubgroupAnd(i,g);case"subgroupAny":return this.builtins.SubgroupAny(i,g);case"subgroupBallot":return this.builtins.SubgroupBallot(i,g);case"subgroupBroadcast":return this.builtins.SubgroupBroadcast(i,g);case"subgroupBroadcastFirst":return this.builtins.SubgroupBroadcastFirst(i,g);case"subgroupElect":return this.builtins.SubgroupElect(i,g);case"subgroupMax":return this.builtins.SubgroupMax(i,g);case"subgroupMin":return this.builtins.SubgroupMin(i,g);case"subgroupMul":return this.builtins.SubgroupMul(i,g);case"subgroupExclusiveMul":return this.builtins.SubgroupExclusiveMul(i,g);case"subgroupInclusiveMul":return this.builtins.SubgroupInclusiveMul(i,g);case"subgroupOr":return this.builtins.SubgroupOr(i,g);case"subgroupShuffle":return this.builtins.SubgroupShuffle(i,g);case"subgroupShuffleDown":return this.builtins.SubgroupShuffleDown(i,g);case"subgroupShuffleUp":return this.builtins.SubgroupShuffleUp(i,g);case"subgroupShuffleXor":return this.builtins.SubgroupShuffleXor(i,g);case"subgroupXor":return this.builtins.SubgroupXor(i,g);case"quadBroadcast":return this.builtins.QuadBroadcast(i,g);case"quadSwapDiagonal":return this.builtins.QuadSwapDiagonal(i,g);case"quadSwapX":return this.builtins.QuadSwapX(i,g);case"quadSwapY":return this.builtins.QuadSwapY(i,g)}const x=g.getFunction(i.name);if(x){const _=g.clone();for(let g=0;g<x.node.args.length;++g){const v=x.node.args[g],b=this.evalExpression(i.args[g],_);_.setVariable(v.name,b,v)}return this._execStatements(x.node.body,_)}return null}_callConstructorValue(i,g){if(!i.args||0===i.args.length)return new Be(0,this.getTypeInfo(i.type));const x=this.evalExpression(i.args[0],g);return x.typeInfo=this.getTypeInfo(i.type),x.getSubData(this,i.postfix,g).clone()}_callConstructorVec(i,g){const x=this.getTypeInfo(i.type),_=i.type.getTypeName(),v=Xn[_];if(void 0===v)return console.error(`Invalid vec constructor ${_}. Line ${i.line}`),null;const b=[];if(i instanceof xe)if(i.isVector){const g=i.vectorValue;for(const i of g)b.push(i)}else b.push(i.scalarValue);else if(i.args)for(const x of i.args){const i=this.evalExpression(x,g);if(i instanceof Me){const g=i.data;for(let i=0;i<g.length;++i){let x=g[i];b.push(x)}}else if(i instanceof Be){let g=i.value;b.push(g)}}if(i.type instanceof ce&&null===i.type.format&&(i.type.format=ce.f32),0===b.length){const _=new Array(v).fill(0);return new Me(_,x).getSubData(this,i.postfix,g)}if(1===b.length)for(;b.length<v;)b.push(b[0]);return b.length<v?(console.error(`Invalid vec constructor. Line ${i.line}`),null):new Me(b.length>v?b.slice(0,v):b,x).getSubData(this,i.postfix,g)}_callConstructorMatrix(i,g){const x=this.getTypeInfo(i.type),_=i.type.getTypeName(),v=jn[_];if(void 0===v)return console.error(`Invalid matrix constructor ${_}. Line ${i.line}`),null;const b=[];if(i instanceof xe)if(i.isVector){const g=i.vectorValue;for(const i of g)b.push(i)}else b.push(i.scalarValue);else if(i.args)for(const x of i.args){const i=this.evalExpression(x,g);i instanceof Me?b.push(...i.data):i instanceof Be?b.push(i.value):i instanceof Ue&&b.push(...i.data)}if(x instanceof a&&null===x.format&&(x.format=this.getTypeInfo("f32")),0===b.length){const _=new Array(v[2]).fill(0);return new Ue(_,x).getSubData(this,i.postfix,g)}return b.length!==v[2]?(console.error(`Invalid matrix constructor. Line ${i.line}`),null):new Ue(b,x).getSubData(this,i.postfix,g)}}dt._breakObj=new Ne(new e("BREAK",null),null),dt._continueObj=new Ne(new e("CONTINUE",null),null),dt._priority=new Map([["f32",0],["f16",1],["u32",2],["i32",3],["x32",3]]);class mt{constructor(){this.constants=new Map,this.aliases=new Map,this.structs=new Map}}class gt{constructor(){this._tokens=[],this._current=0,this._currentLine=1,this._deferArrayCountEval=[],this._currentLoop=[],this._context=new mt,this._exec=new dt,this._forwardTypeCount=0}parse(i){this._initialize(i),this._deferArrayCountEval.length=0;const g=[];for(;!this._isAtEnd();){const i=this._global_decl_or_directive();if(!i)break;g.push(i)}if(this._deferArrayCountEval.length>0){for(const g of this._deferArrayCountEval){const x=g.arrayType,_=g.countNode;if(_ instanceof ge){const g=_.name,v=this._context.constants.get(g);if(v)try{const i=v.constEvaluate(this._exec);x.count=i}catch(i){}}}this._deferArrayCountEval.length=0}if(this._forwardTypeCount>0)for(const i of g)i.search(i=>{i instanceof Ce||i instanceof le?i.type=this._forwardType(i.type):i instanceof ue?i.format=this._forwardType(i.format):i instanceof F||i instanceof U||i instanceof P?i.type=this._forwardType(i.type):i instanceof D?i.returnType=this._forwardType(i.returnType):i instanceof $e&&(i.type=this._forwardType(i.type))});return g}_forwardType(i){if(i instanceof ie){const g=this._getType(i.name);if(g)return g}else i instanceof le?i.type=this._forwardType(i.type):i instanceof ue&&(i.format=this._forwardType(i.format));return i}_initialize(i){if(i)if("string"==typeof i){const g=new Re(i);this._tokens=g.scanTokens()}else this._tokens=i;else this._tokens=[];this._current=0}_updateNode(i,g){return i.line=null!=g?g:this._currentLine,i}_error(i,g){return{token:i,message:g,toString:()=>`${g}`}}_isAtEnd(){return this._current>=this._tokens.length||this._peek().type==He.eof}_match(i){if(i instanceof qe)return!!this._check(i)&&(this._advance(),!0);for(let g=0,x=i.length;g<x;++g){const x=i[g];if(this._check(x))return this._advance(),!0}return!1}_consume(i,g){if(this._check(i))return this._advance();throw this._error(this._peek(),`${g}. Line:${this._currentLine}`)}_check(i){if(this._isAtEnd())return!1;const g=this._peek();if(i instanceof Array){const x=g.type;let _=!1;for(const g of i){if(x===g)return!0;g===He.tokens.name&&(_=!0)}if(_){const i=He.tokens.name.rule.exec(g.lexeme);if(i&&0==i.index&&i[0]==g.lexeme)return!0}return!1}if(g.type===i)return!0;if(i===He.tokens.name){const i=He.tokens.name.rule.exec(g.lexeme);return i&&0==i.index&&i[0]==g.lexeme}return!1}_advance(){var i,g;return this._currentLine=null!==(g=null===(i=this._peek())||void 0===i?void 0:i.line)&&void 0!==g?g:-1,this._isAtEnd()||this._current++,this._previous()}_peek(){return this._tokens[this._current]}_previous(){return this._tokens[this._current-1]}_global_decl_or_directive(){for(;this._match(He.tokens.semicolon)&&!this._isAtEnd(););if(this._match(He.keywords.alias)){const i=this._type_alias();return this._consume(He.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([i]),i}if(this._match(He.keywords.diagnostic)){const i=this._diagnostic();return this._consume(He.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([i]),i}if(this._match(He.keywords.requires)){const i=this._requires_directive();return this._consume(He.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([i]),i}if(this._match(He.keywords.enable)){const i=this._enable_directive();return this._consume(He.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([i]),i}const i=this._attribute();if(this._check(He.keywords.var)){const g=this._global_variable_decl();return null!=g&&(g.attributes=i),this._consume(He.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([g]),g}if(this._check(He.keywords.override)){const g=this._override_variable_decl();return null!=g&&(g.attributes=i),this._consume(He.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([g]),g}if(this._check(He.keywords.let)){const g=this._global_let_decl();return null!=g&&(g.attributes=i),this._consume(He.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([g]),g}if(this._check(He.keywords.const)){const g=this._global_const_decl();return null!=g&&(g.attributes=i),this._consume(He.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([g]),g}if(this._check(He.keywords.struct)){const g=this._struct_decl();return null!=g&&(g.attributes=i),this._exec.reflection.updateAST([g]),g}if(this._check(He.keywords.fn)){const g=this._function_decl();return null!=g&&(g.attributes=i),this._exec.reflection.updateAST([g]),g}return null}_function_decl(){if(!this._match(He.keywords.fn))return null;const i=this._currentLine,g=this._consume(He.tokens.ident,"Expected function name.").toString();this._consume(He.tokens.paren_left,"Expected '(' for function arguments.");const x=[];if(!this._check(He.tokens.paren_right))do{if(this._check(He.tokens.paren_right))break;const i=this._attribute(),g=this._consume(He.tokens.name,"Expected argument name.").toString();this._consume(He.tokens.colon,"Expected ':' for argument type.");const _=this._attribute(),v=this._type_decl();null!=v&&(v.attributes=_,x.push(this._updateNode(new $e(g,v,i))))}while(this._match(He.tokens.comma));this._consume(He.tokens.paren_right,"Expected ')' after function arguments.");let _=null;if(this._match(He.tokens.arrow)){const i=this._attribute();_=this._type_decl(),null!=_&&(_.attributes=i)}const v=this._compound_statement(),b=this._currentLine;return this._updateNode(new D(g,x,_,v,i,b),i)}_compound_statement(){const i=[];for(this._consume(He.tokens.brace_left,"Expected '{' for block.");!this._check(He.tokens.brace_right);){const g=this._statement();null!==g&&i.push(g)}return this._consume(He.tokens.brace_right,"Expected '}' for block."),i}_statement(){for(;this._match(He.tokens.semicolon)&&!this._isAtEnd(););if(this._check(He.tokens.attr)&&this._attribute(),this._check(He.keywords.if))return this._if_statement();if(this._check(He.keywords.switch))return this._switch_statement();if(this._check(He.keywords.loop))return this._loop_statement();if(this._check(He.keywords.for))return this._for_statement();if(this._check(He.keywords.while))return this._while_statement();if(this._check(He.keywords.continuing))return this._continuing_statement();if(this._check(He.keywords.static_assert))return this._static_assert_statement();if(this._check(He.tokens.brace_left))return this._compound_statement();let i=null;if(this._check(He.keywords.return))i=this._return_statement();else if(this._check([He.keywords.var,He.keywords.let,He.keywords.const]))i=this._variable_statement();else if(this._match(He.keywords.discard))i=this._updateNode(new ne);else if(this._match(He.keywords.break)){const g=this._updateNode(new se);if(this._currentLoop.length>0){const i=this._currentLoop[this._currentLoop.length-1];g.loopId=i.id}i=g,this._check(He.keywords.if)&&(this._advance(),g.condition=this._optional_paren_expression())}else if(this._match(He.keywords.continue)){const g=this._updateNode(new re);if(!(this._currentLoop.length>0))throw this._error(this._peek(),`Continue statement must be inside a loop. Line:${g.line}`);{const i=this._currentLoop[this._currentLoop.length-1];g.loopId=i.id}i=g}else i=this._increment_decrement_statement()||this._func_call_statement()||this._assignment_statement();return null!=i&&this._consume(He.tokens.semicolon,"Expected ';' after statement."),i}_static_assert_statement(){if(!this._match(He.keywords.static_assert))return null;const i=this._currentLine,g=this._optional_paren_expression();return this._updateNode(new N(g),i)}_while_statement(){if(!this._match(He.keywords.while))return null;const i=this._updateNode(new V(null,null));return this._currentLoop.push(i),i.condition=this._optional_paren_expression(),this._check(He.tokens.attr)&&this._attribute(),i.body=this._compound_statement(),this._currentLoop.pop(),i}_continuing_statement(){const i=this._currentLoop.length>0?this._currentLoop[this._currentLoop.length-1].id:-1;if(!this._match(He.keywords.continuing))return null;const g=this._currentLine,x=this._compound_statement();return this._updateNode(new O(x,i),g)}_for_statement(){if(!this._match(He.keywords.for))return null;this._consume(He.tokens.paren_left,"Expected '('.");const i=this._updateNode(new B(null,null,null,null));return this._currentLoop.push(i),i.init=this._check(He.tokens.semicolon)?null:this._for_init(),this._consume(He.tokens.semicolon,"Expected ';'."),i.condition=this._check(He.tokens.semicolon)?null:this._short_circuit_or_expression(),this._consume(He.tokens.semicolon,"Expected ';'."),i.increment=this._check(He.tokens.paren_right)?null:this._for_increment(),this._consume(He.tokens.paren_right,"Expected ')'."),this._check(He.tokens.attr)&&this._attribute(),i.body=this._compound_statement(),this._currentLoop.pop(),i}_for_init(){return this._variable_statement()||this._func_call_statement()||this._assignment_statement()}_for_increment(){return this._func_call_statement()||this._increment_decrement_statement()||this._assignment_statement()}_variable_statement(){if(this._check(He.keywords.var)){const i=this._variable_decl();if(null===i)throw this._error(this._peek(),"Variable declaration expected.");let g=null;return this._match(He.tokens.equal)&&(g=this._short_circuit_or_expression()),this._updateNode(new F(i.name,i.type,i.storage,i.access,g),i.line)}if(this._match(He.keywords.let)){const i=this._currentLine,g=this._consume(He.tokens.name,"Expected name for let.").toString();let x=null;if(this._match(He.tokens.colon)){const i=this._attribute();x=this._type_decl(),null!=x&&(x.attributes=i)}this._consume(He.tokens.equal,"Expected '=' for let.");const _=this._short_circuit_or_expression();return this._updateNode(new U(g,x,null,null,_),i)}if(this._match(He.keywords.const)){const i=this._currentLine,g=this._consume(He.tokens.name,"Expected name for const.").toString();let x=null;if(this._match(He.tokens.colon)){const i=this._attribute();x=this._type_decl(),null!=x&&(x.attributes=i)}this._consume(He.tokens.equal,"Expected '=' for const.");const _=this._short_circuit_or_expression();return null===x&&_ instanceof xe&&(x=_.type),this._updateNode(new P(g,x,null,null,_),i)}return null}_increment_decrement_statement(){const i=this._current,g=this._unary_expression();if(null==g)return null;if(!this._check(He.increment_operators))return this._current=i,null;const x=this._consume(He.increment_operators,"Expected increment operator");return this._updateNode(new R(x.type===He.tokens.plus_plus?Dn.increment:Dn.decrement,g))}_assignment_statement(){let i=null;const g=this._currentLine;if(this._check(He.tokens.brace_right))return null;let x=this._match(He.tokens.underscore);if(x||(i=this._unary_expression()),!x&&null==i)return null;const _=this._consume(He.assignment_operators,"Expected assignment operator."),v=this._short_circuit_or_expression();return this._updateNode(new G(Un.parse(_.lexeme),i,v),g)}_func_call_statement(){if(!this._check(He.tokens.ident))return null;const i=this._currentLine,g=this._current,x=this._consume(He.tokens.ident,"Expected function name."),_=this._argument_expression_list();return null===_?(this._current=g,null):this._updateNode(new X(x.lexeme,_),i)}_loop_statement(){if(!this._match(He.keywords.loop))return null;this._check(He.tokens.attr)&&this._attribute(),this._consume(He.tokens.brace_left,"Expected '{' for loop.");const i=this._updateNode(new j([],null));this._currentLoop.push(i);let g=this._statement();for(;null!==g;){if(Array.isArray(g))for(let x of g)i.body.push(x);else i.body.push(g);if(g instanceof O){i.continuing=g;break}g=this._statement()}return this._currentLoop.pop(),this._consume(He.tokens.brace_right,"Expected '}' for loop."),i}_switch_statement(){if(!this._match(He.keywords.switch))return null;const i=this._updateNode(new Z(null,[]));if(this._currentLoop.push(i),i.condition=this._optional_paren_expression(),this._check(He.tokens.attr)&&this._attribute(),this._consume(He.tokens.brace_left,"Expected '{' for switch."),i.cases=this._switch_body(),null==i.cases||0==i.cases.length)throw this._error(this._previous(),"Expected 'case' or 'default'.");return this._consume(He.tokens.brace_right,"Expected '}' for switch."),this._currentLoop.pop(),i}_switch_body(){const i=[];let g=!1;for(;this._check([He.keywords.default,He.keywords.case]);){if(this._match(He.keywords.case)){const x=this._case_selectors();for(const i of x)if(i instanceof Se){if(g)throw this._error(this._previous(),"Multiple default cases in switch statement.");g=!0;break}this._match(He.tokens.colon),this._check(He.tokens.attr)&&this._attribute(),this._consume(He.tokens.brace_left,"Exected '{' for switch case.");const _=this._case_body();this._consume(He.tokens.brace_right,"Exected '}' for switch case."),i.push(this._updateNode(new Ae(x,_)))}if(this._match(He.keywords.default)){if(g)throw this._error(this._previous(),"Multiple default cases in switch statement.");this._match(He.tokens.colon),this._check(He.tokens.attr)&&this._attribute(),this._consume(He.tokens.brace_left,"Exected '{' for switch default.");const x=this._case_body();this._consume(He.tokens.brace_right,"Exected '}' for switch default."),i.push(this._updateNode(new Ee(x)))}}return i}_case_selectors(){const i=[];for(this._match(He.keywords.default)?i.push(this._updateNode(new Se)):i.push(this._shift_expression());this._match(He.tokens.comma);)this._match(He.keywords.default)?i.push(this._updateNode(new Se)):i.push(this._shift_expression());return i}_case_body(){if(this._match(He.keywords.fallthrough))return this._consume(He.tokens.semicolon,"Expected ';'"),[];let i=this._statement();if(null==i)return[];i instanceof Array||(i=[i]);const g=this._case_body();return 0==g.length?i:[...i,g[0]]}_if_statement(){if(!this._match(He.keywords.if))return null;const i=this._currentLine,g=this._optional_paren_expression();this._check(He.tokens.attr)&&this._attribute();const x=this._compound_statement();let _=[];this._match_elseif()&&(this._check(He.tokens.attr)&&this._attribute(),_=this._elseif_statement(_));let v=null;return this._match(He.keywords.else)&&(this._check(He.tokens.attr)&&this._attribute(),v=this._compound_statement()),this._updateNode(new Q(g,x,_,v),i)}_match_elseif(){return this._tokens[this._current].type===He.keywords.else&&this._tokens[this._current+1].type===He.keywords.if&&(this._advance(),this._advance(),!0)}_elseif_statement(i=[]){const g=this._optional_paren_expression(),x=this._compound_statement();return i.push(this._updateNode(new Le(g,x))),this._match_elseif()&&(this._check(He.tokens.attr)&&this._attribute(),this._elseif_statement(i)),i}_return_statement(){if(!this._match(He.keywords.return))return null;const i=this._short_circuit_or_expression();return this._updateNode(new Y(i))}_short_circuit_or_expression(){let i=this._short_circuit_and_expr();for(;this._match(He.tokens.or_or);)i=this._updateNode(new Ie(this._previous().toString(),i,this._short_circuit_and_expr()));return i}_short_circuit_and_expr(){let i=this._inclusive_or_expression();for(;this._match(He.tokens.and_and);)i=this._updateNode(new Ie(this._previous().toString(),i,this._inclusive_or_expression()));return i}_inclusive_or_expression(){let i=this._exclusive_or_expression();for(;this._match(He.tokens.or);)i=this._updateNode(new Ie(this._previous().toString(),i,this._exclusive_or_expression()));return i}_exclusive_or_expression(){let i=this._and_expression();for(;this._match(He.tokens.xor);)i=this._updateNode(new Ie(this._previous().toString(),i,this._and_expression()));return i}_and_expression(){let i=this._equality_expression();for(;this._match(He.tokens.and);)i=this._updateNode(new Ie(this._previous().toString(),i,this._equality_expression()));return i}_equality_expression(){const i=this._relational_expression();return this._match([He.tokens.equal_equal,He.tokens.not_equal])?this._updateNode(new Ie(this._previous().toString(),i,this._relational_expression())):i}_relational_expression(){let i=this._shift_expression();for(;this._match([He.tokens.less_than,He.tokens.greater_than,He.tokens.less_than_equal,He.tokens.greater_than_equal]);)i=this._updateNode(new Ie(this._previous().toString(),i,this._shift_expression()));return i}_shift_expression(){let i=this._additive_expression();for(;this._match([He.tokens.shift_left,He.tokens.shift_right]);)i=this._updateNode(new Ie(this._previous().toString(),i,this._additive_expression()));return i}_additive_expression(){let i=this._multiplicative_expression();for(;this._match([He.tokens.plus,He.tokens.minus]);)i=this._updateNode(new Ie(this._previous().toString(),i,this._multiplicative_expression()));return i}_multiplicative_expression(){let i=this._unary_expression();for(;this._match([He.tokens.star,He.tokens.forward_slash,He.tokens.modulo]);)i=this._updateNode(new Ie(this._previous().toString(),i,this._unary_expression()));return i}_unary_expression(){return this._match([He.tokens.minus,He.tokens.bang,He.tokens.tilde,He.tokens.star,He.tokens.and])?this._updateNode(new ke(this._previous().toString(),this._unary_expression())):this._singular_expression()}_singular_expression(){const i=this._primary_expression(),g=this._postfix_expression();return g&&(i.postfix=g),i}_postfix_expression(){if(this._match(He.tokens.bracket_left)){const i=this._short_circuit_or_expression();this._consume(He.tokens.bracket_right,"Expected ']'.");const g=this._updateNode(new ve(i)),x=this._postfix_expression();return x&&(g.postfix=x),g}if(this._match(He.tokens.period)){const i=this._consume(He.tokens.name,"Expected member name."),g=this._postfix_expression(),x=this._updateNode(new pe(i.lexeme));return g&&(x.postfix=g),x}return null}_getStruct(i){return this._context.aliases.has(i)?this._context.aliases.get(i).type:this._context.structs.has(i)?this._context.structs.get(i):null}_getType(i){const g=this._getStruct(i);if(null!==g)return g;switch(i){case"void":return ae.void;case"bool":return ae.bool;case"i32":return ae.i32;case"u32":return ae.u32;case"f32":return ae.f32;case"f16":return ae.f16;case"vec2f":return ce.vec2f;case"vec3f":return ce.vec3f;case"vec4f":return ce.vec4f;case"vec2i":return ce.vec2i;case"vec3i":return ce.vec3i;case"vec4i":return ce.vec4i;case"vec2u":return ce.vec2u;case"vec3u":return ce.vec3u;case"vec4u":return ce.vec4u;case"vec2h":return ce.vec2h;case"vec3h":return ce.vec3h;case"vec4h":return ce.vec4h;case"mat2x2f":return ce.mat2x2f;case"mat2x3f":return ce.mat2x3f;case"mat2x4f":return ce.mat2x4f;case"mat3x2f":return ce.mat3x2f;case"mat3x3f":return ce.mat3x3f;case"mat3x4f":return ce.mat3x4f;case"mat4x2f":return ce.mat4x2f;case"mat4x3f":return ce.mat4x3f;case"mat4x4f":return ce.mat4x4f;case"mat2x2h":return ce.mat2x2h;case"mat2x3h":return ce.mat2x3h;case"mat2x4h":return ce.mat2x4h;case"mat3x2h":return ce.mat3x2h;case"mat3x3h":return ce.mat3x3h;case"mat3x4h":return ce.mat3x4h;case"mat4x2h":return ce.mat4x2h;case"mat4x3h":return ce.mat4x3h;case"mat4x4h":return ce.mat4x4h;case"mat2x2i":return ce.mat2x2i;case"mat2x3i":return ce.mat2x3i;case"mat2x4i":return ce.mat2x4i;case"mat3x2i":return ce.mat3x2i;case"mat3x3i":return ce.mat3x3i;case"mat3x4i":return ce.mat3x4i;case"mat4x2i":return ce.mat4x2i;case"mat4x3i":return ce.mat4x3i;case"mat4x4i":return ce.mat4x4i;case"mat2x2u":return ce.mat2x2u;case"mat2x3u":return ce.mat2x3u;case"mat2x4u":return ce.mat2x4u;case"mat3x2u":return ce.mat3x2u;case"mat3x3u":return ce.mat3x3u;case"mat3x4u":return ce.mat3x4u;case"mat4x2u":return ce.mat4x2u;case"mat4x3u":return ce.mat4x3u;case"mat4x4u":return ce.mat4x4u}return null}_validateTypeRange(i,g){if("i32"===g.name){if(i<-2147483648||i>2147483647)throw this._error(this._previous(),`Value out of range for i32:${i}. Line:${this._currentLine}.`)}else if("u32"===g.name&&(i<0||i>4294967295))throw this._error(this._previous(),`Value out of range for u32:${i}. Line:${this._currentLine}.`)}_primary_expression(){if(this._match(He.tokens.ident)){const i=this._previous().toString();if(this._check(He.tokens.paren_left)){const g=this._argument_expression_list(),x=this._getType(i);return null!==x?this._updateNode(new de(x,g)):this._updateNode(new me(i,g))}if(this._context.constants.has(i)){const g=this._context.constants.get(i);return this._updateNode(new _e(i,g.value))}return this._updateNode(new ge(i))}if(this._match(He.tokens.int_literal)){const i=this._previous().toString();let g=i.endsWith("i")||i.endsWith("i")?ae.i32:i.endsWith("u")||i.endsWith("U")?ae.u32:ae.x32;const x=parseInt(i);return this._validateTypeRange(x,g),this._updateNode(new xe(new Be(x,this._exec.getTypeInfo(g)),g))}if(this._match(He.tokens.uint_literal)){const i=parseInt(this._previous().toString());return this._validateTypeRange(i,ae.u32),this._updateNode(new xe(new Be(i,this._exec.getTypeInfo(ae.u32)),ae.u32))}if(this._match([He.tokens.decimal_float_literal,He.tokens.hex_float_literal])){let i=this._previous().toString(),g=i.endsWith("h");g&&(i=i.substring(0,i.length-1));const x=parseFloat(i);this._validateTypeRange(x,g?ae.f16:ae.f32);const _=g?ae.f16:ae.f32;return this._updateNode(new xe(new Be(x,this._exec.getTypeInfo(_)),_))}if(this._match([He.keywords.true,He.keywords.false])){let i=this._previous().toString()===He.keywords.true.rule;return this._updateNode(new xe(new Be(i?1:0,this._exec.getTypeInfo(ae.bool)),ae.bool))}if(this._check(He.tokens.paren_left))return this._paren_expression();if(this._match(He.keywords.bitcast)){this._consume(He.tokens.less_than,"Expected '<'.");const i=this._type_decl();this._consume(He.tokens.greater_than,"Expected '>'.");const g=this._paren_expression();return this._updateNode(new ye(i,g))}const i=this._type_decl(),g=this._argument_expression_list();return this._updateNode(new de(i,g))}_argument_expression_list(){if(!this._match(He.tokens.paren_left))return null;const i=[];do{if(this._check(He.tokens.paren_right))break;const g=this._short_circuit_or_expression();i.push(g)}while(this._match(He.tokens.comma));return this._consume(He.tokens.paren_right,"Expected ')' for agument list"),i}_optional_paren_expression(){this._match(He.tokens.paren_left);const i=this._short_circuit_or_expression();return this._match(He.tokens.paren_right),i}_paren_expression(){this._consume(He.tokens.paren_left,"Expected '('.");const i=this._short_circuit_or_expression();return this._consume(He.tokens.paren_right,"Expected ')'."),i}_struct_decl(){if(!this._match(He.keywords.struct))return null;const i=this._currentLine,g=this._consume(He.tokens.ident,"Expected name for struct.").toString();this._consume(He.tokens.brace_left,"Expected '{' for struct body.");const x=[];for(;!this._check(He.tokens.brace_right);){const i=this._attribute(),g=this._consume(He.tokens.name,"Expected variable name.").toString();this._consume(He.tokens.colon,"Expected ':' for struct member type.");const _=this._attribute(),v=this._type_decl();null!=v&&(v.attributes=_),this._check(He.tokens.brace_right)?this._match(He.tokens.comma):this._consume(He.tokens.comma,"Expected ',' for struct member."),x.push(this._updateNode(new Ce(g,v,i)))}this._consume(He.tokens.brace_right,"Expected '}' after struct body.");const _=this._currentLine,v=this._updateNode(new oe(g,x,i,_),i);return this._context.structs.set(g,v),v}_global_variable_decl(){const i=this._variable_decl();if(!i)return null;if(this._match(He.tokens.equal)){const g=this._const_expression();i.value=g}if(null!==i.type&&i.value instanceof xe){if("x32"!==i.value.type.name&&i.type.getTypeName()!==i.value.type.getTypeName())throw this._error(this._peek(),`Invalid cast from ${i.value.type.name} to ${i.type.name}. Line:${this._currentLine}`);i.value.isScalar&&this._validateTypeRange(i.value.scalarValue,i.type),i.value.type=i.type}else null===i.type&&i.value instanceof xe&&(i.type="x32"===i.value.type.name?ae.i32:i.value.type,i.value.isScalar&&this._validateTypeRange(i.value.scalarValue,i.type));return i}_override_variable_decl(){const i=this._override_decl();return i&&this._match(He.tokens.equal)&&(i.value=this._const_expression()),i}_global_const_decl(){var i;if(!this._match(He.keywords.const))return null;const g=this._consume(He.tokens.name,"Expected variable name"),x=this._currentLine;let _=null;if(this._match(He.tokens.colon)){const i=this._attribute();_=this._type_decl(),null!=_&&(_.attributes=i)}let v=null;this._consume(He.tokens.equal,"const declarations require an assignment");const b=this._short_circuit_or_expression();try{let i=[ae.f32],x=b.constEvaluate(this._exec,i);x instanceof Be&&this._validateTypeRange(x.value,i[0]),i[0]instanceof ce&&null===i[0].format&&x.typeInfo instanceof a&&null!==x.typeInfo.format&&("f16"===x.typeInfo.format.name?i[0].format=ae.f16:"f32"===x.typeInfo.format.name?i[0].format=ae.f32:"i32"===x.typeInfo.format.name?i[0].format=ae.i32:"u32"===x.typeInfo.format.name?i[0].format=ae.u32:"bool"===x.typeInfo.format.name?i[0].format=ae.bool:console.error(`TODO:impelement template format type ${x.typeInfo.format.name}`)),v=this._updateNode(new xe(x,i[0])),this._exec.context.setVariable(g.toString(),x)}catch(i){v=b}if(null!==_&&v instanceof xe){if("x32"!==v.type.name&&_.getTypeName()!==v.type.getTypeName())throw this._error(this._peek(),`Invalid cast from ${v.type.name} to ${_.name}. Line:${this._currentLine}`);v.type=_,v.isScalar&&this._validateTypeRange(v.scalarValue,v.type)}else null===_&&v instanceof xe&&(_=null!==(i=null==v?void 0:v.type)&&void 0!==i?i:ae.f32,_===ae.x32&&(_=ae.i32));const y=this._updateNode(new P(g.toString(),_,"","",v),x);return this._context.constants.set(y.name,y),y}_global_let_decl(){if(!this._match(He.keywords.let))return null;const i=this._currentLine,g=this._consume(He.tokens.name,"Expected variable name");let x=null;if(this._match(He.tokens.colon)){const i=this._attribute();x=this._type_decl(),null!=x&&(x.attributes=i)}let _=null;if(this._match(He.tokens.equal)&&(_=this._const_expression()),null!==x&&_ instanceof xe){if("x32"!==_.type.name&&x.getTypeName()!==_.type.getTypeName())throw this._error(this._peek(),`Invalid cast from ${_.type.name} to ${x.name}. Line:${this._currentLine}`);_.type=x}else null===x&&_ instanceof xe&&(x="x32"===_.type.name?ae.i32:_.type);return _ instanceof xe&&_.isScalar&&this._validateTypeRange(_.scalarValue,x),this._updateNode(new U(g.toString(),x,"","",_),i)}_const_expression(){return this._short_circuit_or_expression()}_variable_decl(){if(!this._match(He.keywords.var))return null;const i=this._currentLine;let g="",x="";this._match(He.tokens.less_than)&&(g=this._consume(He.storage_class,"Expected storage_class.").toString(),this._match(He.tokens.comma)&&(x=this._consume(He.access_mode,"Expected access_mode.").toString()),this._consume(He.tokens.greater_than,"Expected '>'."));const _=this._consume(He.tokens.name,"Expected variable name");let v=null;if(this._match(He.tokens.colon)){const i=this._attribute();v=this._type_decl(),null!=v&&(v.attributes=i)}return this._updateNode(new F(_.toString(),v,g,x,null),i)}_override_decl(){if(!this._match(He.keywords.override))return null;const i=this._consume(He.tokens.name,"Expected variable name");let g=null;if(this._match(He.tokens.colon)){const i=this._attribute();g=this._type_decl(),null!=g&&(g.attributes=i)}return this._updateNode(new M(i.toString(),g,null))}_diagnostic(){this._consume(He.tokens.paren_left,"Expected '('");const i=this._consume(He.tokens.ident,"Expected severity control name.");this._consume(He.tokens.comma,"Expected ','");let g=this._consume(He.tokens.ident,"Expected diagnostic rule name.").toString();return this._match(He.tokens.period)&&(g+=`.${this._consume(He.tokens.ident,"Expected diagnostic message.").toString()}`),this._consume(He.tokens.paren_right,"Expected ')'"),this._updateNode(new ee(i.toString(),g))}_enable_directive(){const i=this._consume(He.tokens.ident,"identity expected.");return this._updateNode(new K(i.toString()))}_requires_directive(){const i=[this._consume(He.tokens.ident,"identity expected.").toString()];for(;this._match(He.tokens.comma);){const g=this._consume(He.tokens.ident,"identity expected.");i.push(g.toString())}return this._updateNode(new J(i))}_type_alias(){const i=this._consume(He.tokens.ident,"identity expected.");this._consume(He.tokens.equal,"Expected '=' for type alias.");let g=this._type_decl();if(null===g)throw this._error(this._peek(),"Expected Type for Alias.");this._context.aliases.has(g.name)&&(g=this._context.aliases.get(g.name).type);const x=this._updateNode(new te(i.toString(),g));return this._context.aliases.set(x.name,x),x}_type_decl(){if(this._check([He.tokens.ident,...He.texel_format,He.keywords.bool,He.keywords.f32,He.keywords.i32,He.keywords.u32])){const i=this._advance().toString();if(this._context.structs.has(i))return this._context.structs.get(i);if(this._context.aliases.has(i))return this._context.aliases.get(i).type;if(!this._getType(i)){const g=this._updateNode(new ie(i));return this._forwardTypeCount++,g}return this._updateNode(new ae(i))}let i=this._texture_sampler_types();if(i)return i;if(this._check(He.template_types)){let i=this._advance().toString(),g=null,x=null;return this._match(He.tokens.less_than)&&(g=this._type_decl(),x=null,this._match(He.tokens.comma)&&(x=this._consume(He.access_mode,"Expected access_mode for pointer").toString()),this._consume(He.tokens.greater_than,"Expected '>' for type.")),this._updateNode(new ce(i,g,x))}if(this._match(He.keywords.ptr)){let i=this._previous().toString();this._consume(He.tokens.less_than,"Expected '<' for pointer.");const g=this._consume(He.storage_class,"Expected storage_class for pointer");this._consume(He.tokens.comma,"Expected ',' for pointer.");const x=this._type_decl();let _=null;return this._match(He.tokens.comma)&&(_=this._consume(He.access_mode,"Expected access_mode for pointer").toString()),this._consume(He.tokens.greater_than,"Expected '>' for pointer."),this._updateNode(new le(i,g.toString(),x,_))}const g=this._attribute();if(this._match(He.keywords.array)){let x=null,_=-1;const v=this._previous();let b=null;if(this._match(He.tokens.less_than)){x=this._type_decl(),this._context.aliases.has(x.name)&&(x=this._context.aliases.get(x.name).type);let g="";if(this._match(He.tokens.comma)){b=this._shift_expression();try{g=b.constEvaluate(this._exec).toString(),b=null}catch(i){g="1"}}this._consume(He.tokens.greater_than,"Expected '>' for array."),_=g?parseInt(g):0}const y=this._updateNode(new ue(v.toString(),g,x,_));return b&&this._deferArrayCountEval.push({arrayType:y,countNode:b}),y}return null}_texture_sampler_types(){if(this._match(He.sampler_type))return this._updateNode(new he(this._previous().toString(),null,null));if(this._match(He.depth_texture_type))return this._updateNode(new he(this._previous().toString(),null,null));if(this._match(He.sampled_texture_type)||this._match(He.multisampled_texture_type)){const i=this._previous();this._consume(He.tokens.less_than,"Expected '<' for sampler type.");const g=this._type_decl();return this._consume(He.tokens.greater_than,"Expected '>' for sampler type."),this._updateNode(new he(i.toString(),g,null))}if(this._match(He.storage_texture_type)){const i=this._previous();this._consume(He.tokens.less_than,"Expected '<' for sampler type.");const g=this._consume(He.texel_format,"Invalid texel format.").toString();this._consume(He.tokens.comma,"Expected ',' after texel format.");const x=this._consume(He.access_mode,"Expected access mode for storage texture type.").toString();return this._consume(He.tokens.greater_than,"Expected '>' for sampler type."),this._updateNode(new he(i.toString(),g,x))}return null}_attribute(){let i=[];for(;this._match(He.tokens.attr);){const g=this._consume(He.attribute_name,"Expected attribute name"),x=this._updateNode(new De(g.toString(),null));if(this._match(He.tokens.paren_left)){if(x.value=this._consume(He.literal_or_ident,"Expected attribute value").toString(),this._check(He.tokens.comma)){this._advance();do{const i=this._consume(He.literal_or_ident,"Expected attribute value").toString();x.value instanceof Array||(x.value=[x.value]),x.value.push(i)}while(this._match(He.tokens.comma))}this._consume(He.tokens.paren_right,"Expected ')'")}i.push(x)}return 0==i.length?null:i}}class _t extends at{constructor(i){super(),i&&this.update(i)}update(i){const g=(new gt).parse(i);this.updateAST(g)}}function ensureVertexIndexBuiltin(i){if(/@builtin\s*\(\s*vertex_index\s*\)/.test(i))return i;return i.replace(/(@vertex\s+fn\s+)([a-zA-Z_][a-zA-Z0-9_]*)\s*\(([^)]*)(\))/,(i,g,x,_,v)=>{const b=_.trim(),y="@builtin(vertex_index) redgpu_auto_builtin_vertex_index:u32";return`${g}${x}(${0===b.length?y:`${b},${y}`}${v}`})}class WGSLUniformTypes{static get i32(){return{numElements:1,align:4,size:4,type:"i32",wgslType:"i32",View:Int32Array}}static get u32(){return{numElements:1,align:4,size:4,type:"u32",wgslType:"u32",View:Uint32Array}}static get f32(){return{numElements:1,align:4,size:4,type:"f32",wgslType:"f32",View:Float32Array}}static get f16(){return{numElements:1,align:2,size:2,type:"f16",wgslType:"f16",View:Uint16Array}}static get vec2f32(){return{numElements:2,align:8,size:8,type:"f32",wgslType:"vec2<f32>",View:Float32Array}}static get vec2i32(){return{numElements:2,align:8,size:8,type:"i32",wgslType:"vec2<i32>",View:Int32Array}}static get vec2u32(){return{numElements:2,align:8,size:8,type:"u32",wgslType:"vec2<u32>",View:Uint32Array}}static get vec2u16(){return{numElements:2,align:4,size:4,type:"u16",wgslType:"vec2<u16>",View:Uint16Array}}static get vec3i32(){return{numElements:3,align:16,size:12,type:"i32",wgslType:"vec3<i32>",View:Int32Array}}static get vec3u32(){return{numElements:3,align:16,size:12,type:"u32",wgslType:"vec3<u32>",View:Uint32Array}}static get vec3f32(){return{numElements:3,align:16,size:12,type:"f32",wgslType:"vec3<f32>",View:Float32Array}}static get vec3u16(){return{numElements:3,align:8,size:6,type:"u16",wgslType:"vec3<u16>",View:Uint16Array}}static get vec4i32(){return{numElements:4,align:16,size:16,type:"i32",wgslType:"vec4<i32>",View:Int32Array}}static get vec4u32(){return{numElements:4,align:16,size:16,type:"u32",wgslType:"vec4<u32>",View:Uint32Array}}static get vec4f32(){return{numElements:4,align:16,size:16,type:"f32",wgslType:"vec4<f32>",View:Float32Array}}static get vec4u16(){return{numElements:4,align:8,size:8,type:"u16",wgslType:"vec4<u16>",View:Uint16Array}}static get mat2x2f32(){return{numElements:4,align:8,size:16,type:"f32",wgslType:"mat2x2<f32>",View:Float32Array}}static get mat2x2u16(){return{numElements:4,align:4,size:8,type:"u16",wgslType:"mat2x2<u16>",View:Uint16Array}}static get mat3x2f32(){return{numElements:6,align:8,size:24,type:"f32",wgslType:"mat3x2<f32>",View:Float32Array}}static get mat3x2u16(){return{numElements:6,align:4,size:12,type:"u16",wgslType:"mat3x2<u16>",View:Uint16Array}}static get mat3x3f32(){return{numElements:16,align:16,size:64,type:"f32",wgslType:"mat3x3<f32>",View:Float32Array}}static get mat4x2f32(){return{numElements:8,align:8,size:32,type:"f32",wgslType:"mat4x2<f32>",View:Float32Array}}static get mat4x2u16(){return{numElements:8,align:4,size:16,type:"u16",wgslType:"mat4x2<u16>",View:Uint16Array}}static get mat2x3f32(){return{numElements:8,align:16,size:32,type:"f32",wgslType:"mat2x3<f32>",View:Float32Array}}static get mat2x3u16(){return{numElements:8,align:8,size:16,type:"u16",wgslType:"mat2x3<u16>",View:Uint16Array}}static get mat4x4f32(){return{numElements:16,align:16,size:64,type:"f32",wgslType:"mat4x4<f32>",View:Float32Array}}static get mat4x4u16(){return{numElements:16,align:8,size:32,type:"u16",wgslType:"mat4x4<u16>",View:Uint16Array}}}Object.freeze(WGSLUniformTypes);const processMembers=(i,g=0,x=0)=>{let _=0,v=x;const b=i?.reduce((i,x,b)=>{const{type:y,offset:S,size:w,stride:L,count:k,isArray:z}=x,{format:H}=y,q="array"===y.name?`${H.name}${H.format?`${H.format.name}`:""}`:`${y.name}${H?`${H.name}`:""}`;if(_=g,v=S+w,i[x.name]=((i,g,x)=>{const _=WGSLUniformTypes[x];return{uniformOffset:i.offset+g,uniformOffsetForData:i.offset,stride:i.stride,isArray:i.isArray,typeInfo:_,View:_?.View}})(x,g,q),z&&H.members){const g=processMembers(H.members).members;i[x.name].memberList=Array.from({length:k},(i,x)=>{const _={};for(const i in g){const v=_[i]={...g[i]};v.uniformOffset=v.uniformOffset+S+L*x}return _})}else y.members&&(i[x.name]=processMembers(y.members,S+g,v));return i},{});return{members:b,startOffset:_,endOffset:v}},Yn=new Map,parseWGSL=i=>{i=ensureVertexIndexBuiltin(i);const{defaultSource:g,shaderSourceVariant:x,conditionalBlocks:_,cacheKey:v}=preprocessWGSL(i),b=Yn.get(v);let y;if(b)y=b;else{const i=new _t(g);y={uniforms:{...(w=i.uniforms,w.reduce((i,g)=>(i[g.name]={name:g.name,...processMembers(g.members),arrayBufferByteLength:g.size,stride:g.stride},g.attributes?.forEach(x=>i[g.name][x.name]=+x.value),i),{}))},storage:{...(S=i.storage,S.reduce((i,g)=>(i[g.name]={name:g.name,...processMembers(g.members),arrayBufferByteLength:g.size,stride:g.stride,acccess:g.access,type:g.type},g.attributes?.forEach(x=>i[g.name][x.name]=+x.value),i),{}))},samplers:i.samplers,textures:i.textures,vertexEntries:i.entry.vertex.map(i=>i.name),fragmentEntries:i.entry.fragment.map(i=>i.name),computeEntries:i.entry.compute.map(i=>i.name)},x.setBaseInfo(y.textures,y.samplers),_.forEach(i=>{const g=x.getVariant(i),_=new _t(g),v=_.textures.filter(i=>!y.textures.find(g=>g.name===i.name)),b=_.samplers.filter(i=>!y.samplers.find(g=>g.name===i.name));x.addConditionalInfo(i,v,b)}),y.textures=x.getUnionTextures(),y.samplers=x.getUnionSamplers(),Yn.set(v,y)}var S,w;return{...y,defaultSource:g,shaderSourceVariant:x,conditionalBlocks:_}};class PassClusterLightBound{#zt;#Ht;#$t;#Kt;#Xt;#l;constructor(i,g){validateRedGPUContext(i),this.#l=i,this.#zt=g,this.#jt()}get clusterBoundBuffer(){return this.#Ht}render(){const i=this.#zt.systemUniform_Vertex_UniformBindGroup;if(i){const{gpuDevice:g}=this.#l,x=g.createCommandEncoder(),_=x.beginComputePass({label:"Bound cluster"}),v=q.getDispatchSize();_.setPipeline(this.#Xt),_.setBindGroup(0,i),_.setBindGroup(1,this.#Kt),_.dispatchWorkgroups(v[0],v[1],v[2]),_.end(),g.queue.submit([x.finish()])}}#jt(){const{gpuDevice:i,resourceManager:g}=this.#l,x=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\n@group(1) @binding(0) var<storage,read_write> clusterLight_Clusters:ClusterLight_Clusters;\nfn lineIntersectionToZPlane(a:vec3<f32>,b:vec3<f32>,zDistance:f32) -> vec3<f32> { let normal=vec3<f32>(0.0,0.0,0.5); let ab=b - a; let t=(zDistance - dot(normal,a))/dot(normal,ab); return a + t * ab;\n}\nfn clipToView(clip:vec4<f32>) -> vec4<f32> { let view=systemUniforms.inverseProjectionMatrix * clip; return view/vec4<f32>(view.w,view.w,view.w,view.w);\n}\nfn screen2View(screen:vec4<f32>) -> vec4<f32> { let texCoord=screen.xy/systemUniforms.resolution.xy; let clip=vec4<f32>(vec2<f32>(texCoord.x,1.0 - texCoord.y) * 2.0 - vec2<f32>(1.0,1.0),screen.z,screen.w ); return clipToView(clip);\n}\nconst eyePos=vec3<f32>(0.0);\n@compute @workgroup_size(REDGPU_DEFINE_WORKGROUP_SIZE_X,REDGPU_DEFINE_WORKGROUP_SIZE_Y,REDGPU_DEFINE_WORKGROUP_SIZE_Z)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>) { let tileIndex=global_id.x + global_id.y * clusterLight_tileCount.x + global_id.z * clusterLight_tileCount.x * clusterLight_tileCount.y; let tileSize=vec2<f32>( systemUniforms.resolution.x/f32(clusterLight_tileCount.x), systemUniforms.resolution.y/f32(clusterLight_tileCount.y) ); let global_id_x_pos_one=vec2<f32>(f32(global_id.x + 1u),f32(global_id.y + 1u)) * tileSize; let global_id_x_y=vec2<f32>(f32(global_id.x),f32(global_id.y)) * tileSize; let maxPoint_sS=vec4<f32>(global_id_x_pos_one,0.0,1.0); let minPoint_sS=vec4<f32>(global_id_x_y,0.0,1.0); let maxPoint_vS=screen2View(maxPoint_sS).xyz; let minPoint_vS=screen2View(minPoint_sS).xyz; let nearFarX=systemUniforms.camera.nearClipping; let nearFarY=systemUniforms.camera.farClipping; let tileZ=f32(global_id.z)/f32(clusterLight_tileCount.z); let tileZ_plus_one=f32(global_id.z + 1u)/f32(clusterLight_tileCount.z); let tileNear=-nearFarX * pow(nearFarY/nearFarX,tileZ); let tileFar=-nearFarX * pow(nearFarY/nearFarX,tileZ_plus_one); let minPointNear=lineIntersectionToZPlane(eyePos,minPoint_vS,tileNear); let minPointFar=lineIntersectionToZPlane(eyePos,minPoint_vS,tileFar); let maxPointNear=lineIntersectionToZPlane(eyePos,maxPoint_vS,tileNear); let maxPointFar=lineIntersectionToZPlane(eyePos,maxPoint_vS,tileFar); let minAABB=min(min(minPointNear,minPointFar),min(maxPointNear,maxPointFar)); let maxAABB=max(max(minPointNear,minPointFar),max(maxPointNear,maxPointFar)); clusterLight_Clusters.cubeList[tileIndex].minAABB=vec4<f32>(minAABB,0.0); clusterLight_Clusters.cubeList[tileIndex].maxAABB=vec4<f32>(maxAABB,0.0);\n}\n").defaultSource;this.#Ht=g.createGPUBuffer("PASS_CLUSTER_BOUND_BUFFER",{size:32*q.getTotalTileSize(),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.#$t=i.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),this.#Kt=i.createBindGroup({label:"CLUSTER_BOUND_BIND_GROUP",layout:this.#$t,entries:[{binding:0,resource:{buffer:this.#Ht}}]}),this.#Xt=i.createComputePipeline({label:"CLUSTER_BOUND_PIPELINE",layout:i.createPipelineLayout({bindGroupLayouts:[g.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),this.#$t]}),compute:{module:g.createGPUShaderModule("CLUSTER_BOUND_SHADER",{code:x}),entryPoint:"main"}})}}const qn=new Uint32Array([0,0,0,0]);class PassClustersLight{#zt;#Yt;#qt;#Wt;#l;constructor(i,g){validateRedGPUContext(i),this.#l=i,this.#zt=g,this.#jt()}get clusterLightsBuffer(){return this.#Wt}render(){const{gpuDevice:i}=this.#l,g=this.#zt.systemUniform_Vertex_UniformBindGroup;if(g){const x=i.createCommandEncoder(),_=x.beginComputePass({label:"ClusterLight cluster"}),v=q.getDispatchSize();this.#l.gpuDevice.queue.writeBuffer(this.clusterLightsBuffer,0,qn),_.setPipeline(this.#qt),_.setBindGroup(0,g),_.setBindGroup(1,this.#Yt),_.dispatchWorkgroups(v[0],v[1],v[2]),_.end(),i.queue.submit([x.finish()])}}#jt(){const{gpuDevice:i,resourceManager:g}=this.#l,x=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\n@group(1) @binding(0) var<storage> clusterLight_Clusters:ClusterLight_Clusters;\nfn pointLight_testSphereAABB(light:u32,tile:u32) -> bool { let targetLight=clusterLightList.lights[light]; let targetTile=clusterLight_Clusters.cubeList[tile]; let radius:f32=targetLight.radius; let position:vec3<f32>=targetLight.position; let center:vec3<f32>=(systemUniforms.camera.cameraMatrix * vec4<f32>(position,1.0)).xyz; let squaredDistance:f32=pointLight_sqDistPointAABB(center,tile,targetTile.minAABB.xyz,targetTile.maxAABB.xyz); return squaredDistance <=(radius * radius);\n}\nfn pointLight_sqDistPointAABB(targetPoint:vec3<f32>,tile:u32,minAABB:vec3<f32>,maxAABB:vec3<f32>) -> f32 { var sqDist=0.0; for(var i=0u;i < 3u;i=i + 1u) { let v=targetPoint[i]; let _minAABB=minAABB[i]; let _maxAABB=maxAABB[i]; if(v < _minAABB){ sqDist +=(_minAABB - v) * (_minAABB - v); } if(v > _maxAABB){ sqDist +=(v - _maxAABB) * (v - _maxAABB); } } return sqDist;\n}\nfn spotLight_testSphereAABB(light:u32,tile:u32) -> bool { let targetLight=clusterLightList.lights[light]; let targetTile=clusterLight_Clusters.cubeList[tile]; let radius:f32=targetLight.radius; let position:vec3<f32>=targetLight.position; let center:vec3<f32>=(systemUniforms.camera.cameraMatrix * vec4<f32>(position,1.0)).xyz; let squaredDistance:f32=pointLight_sqDistPointAABB(center,tile,targetTile.minAABB.xyz,targetTile.maxAABB.xyz); return squaredDistance <=(radius * radius);\n}\n@compute @workgroup_size(REDGPU_DEFINE_WORKGROUP_SIZE_X,REDGPU_DEFINE_WORKGROUP_SIZE_Y,REDGPU_DEFINE_WORKGROUP_SIZE_Z)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>) { let tileIndex=global_id.x + global_id.y * clusterLight_tileCount.x + global_id.z * clusterLight_tileCount.x * clusterLight_tileCount.y; var clusterLightCount=0u; var clusterLightIndices:array<u32,REDGPU_DEFINE_MAX_LIGHTS_PER_CLUSTERu>; for (var i=0u;i < u32(clusterLightList.count[0]);i=i + 1u) { let lightInCluster=pointLight_testSphereAABB(i,tileIndex); if (lightInCluster) { clusterLightIndices[clusterLightCount]=i; clusterLightCount=clusterLightCount + 1u; } if (clusterLightCount==REDGPU_DEFINE_MAX_LIGHTS_PER_CLUSTERu) { break; } } let spotLightStartIndex=u32(clusterLightList.count[0]); for (var i=0u;i < u32(clusterLightList.count[1]);i=i + 1u) { let actualLightIndex=spotLightStartIndex + i; let sphereTest=spotLight_testSphereAABB(actualLightIndex,tileIndex); if (sphereTest) { clusterLightIndices[clusterLightCount]=actualLightIndex; clusterLightCount=clusterLightCount + 1u; } if (clusterLightCount==REDGPU_DEFINE_MAX_LIGHTS_PER_CLUSTERu) { break; } } var offset=atomicAdd(&clusterLightGroup.offset,clusterLightCount); for(var i=0u;i < clusterLightCount;i=i + 1u) { clusterLightGroup.indices[offset + i]=clusterLightIndices[i]; } clusterLightGroup.lights[tileIndex].offset=offset; clusterLightGroup.lights[tileIndex].count=clusterLightCount;\n}\n").defaultSource;this.#Wt=g.createGPUBuffer("PASS_CLUSTER_LIGHTS_BUFFER",{size:q.getClusterLightsBufferSize(),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});const _=i.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]});this.#Yt=i.createBindGroup({label:"CLUSTER_LIGHT_BIND_GROUP",layout:_,entries:[{binding:0,resource:{buffer:this.#zt.passLightClustersBound.clusterBoundBuffer}}]}),this.#qt=i.createComputePipeline({label:"CLUSTER_LIGHT_PIPELINE",layout:i.createPipelineLayout({label:"CLUSTER_LIGHT_PIPELINE_LAYOUT",bindGroupLayouts:[g.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),_]}),compute:{module:g.createGPUShaderModule("CLUSTER_LIGHTS_SHADER",{code:x}),entryPoint:"main"}})}}class ResourceStateUniformBuffer{static dirtyList=[];buffer;uuid;#Zt=0;constructor(i){this.buffer=i,this.uuid=i.uuid}get useNum(){return this.#Zt}set useNum(i){this.#Zt=i,ResourceStateUniformBuffer.dirtyList.push(this)}}const Wn=Symbol("gpuBuffer"),Zn=Symbol("gpuBufferData"),Jn=Symbol("gpuBufferDataViewF32"),Qn=Symbol("gpuBufferDataViewU32"),er=Symbol("gpuBufferCacheKey");class ABaseBuffer extends ManagementResourceBase{[Wn];[er];#Jt;constructor(i,g,x){super(i,g),this.#Jt=x}get cacheKey(){return this[er]||this.uuid}get gpuBuffer(){return this[Wn]}get usage(){return this.#Jt}get size(){return this[Zn]?.byteLength||0}get videoMemorySize(){return this.size}destroy(){const i=this[Wn];i&&(this[Wn]=null,this.__fireListenerList(!0),this.redGPUContext.resourceManager.unregisterManagementResource(this),i&&i.destroy())}}class AUniformBaseBuffer extends ABaseBuffer{[Zn];#Qt;#en;constructor(i,g,x,_,v=""){super(i,g,x),this.#en=_.byteLength,this.#Qt={size:this.#en,usage:this.usage,label:v};try{this[Wn]=i.gpuDevice.createBuffer(this.#Qt)}catch(i){console.error("GPU 버퍼 생성에 실패했습니다:",i)}i.gpuDevice.queue.writeBuffer(this[Wn],0,_),this[Zn]=_,this[Jn]=new Float32Array(_),this[Qn]=new Uint32Array(_)}get data(){return this[Zn]}get dataViewF32(){return this[Jn]}get dataViewU32(){return this[Qn]}get size(){return this.#en}get uniformBufferDescriptor(){return this.#Qt}writeOnlyBuffer(i,g){this.redGPUContext.gpuDevice.queue.writeBuffer(this.gpuBuffer,i.uniformOffset,new i.View("number"==typeof g?[g]:g))}}class UniformBuffer extends AUniformBaseBuffer{constructor(i,g,x="",_=""){super(i,"managedUniformBufferState",GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,g,x);const{table:v}=this.targetResourceManagedState,b=v.get(_);if(b)return b.buffer;_&&(this.name=_,this[er]=_),this.redGPUContext.resourceManager.registerManagementResource(this,new ResourceStateUniformBuffer(this))}}Object.freeze(UniformBuffer);var tr="struct Camera { cameraMatrix:mat4x4<f32>, inverseCameraMatrix:mat4x4<f32>, cameraPosition:vec3<f32>, nearClipping:f32, farClipping:f32, fieldOfView:f32\n};\nstruct SystemUniform { projectionMatrix:mat4x4<f32>, inverseProjectionMatrix:mat4x4<f32>, projectionCameraMatrix:mat4x4<f32>, inverseProjectionCameraMatrix:mat4x4<f32>, camera:Camera,\n};\n@group(1) @binding(1) var<uniform> systemUniforms:SystemUniform;\n";const defineProperty=(i,g,x,_,...v)=>{Object.defineProperty(i.prototype,g,x(g,_,...v))},defineProperties=i=>(g,x)=>{x.forEach(x=>{if(Array.isArray(x)){const[_,v,...b]=x;defineProperty(g,_,i,v,...b)}else defineProperty(g,x,i)})},createDefineByPreset=i=>{const g={};return Object.keys(i).forEach(x=>{const[_,v]=i[x];Object.assign(g,(i=>g=>g.reduce((g,x)=>({...g,[x]:i}),{}))(_)(Object.values(v)))}),{defineByPreset:(i,x)=>((i,g,x)=>{g.forEach(g=>{if(Array.isArray(g)){const[_,v,...b]=g,y=x[_];y||consoleAndThrowError(_,"is a key not defined in Define Preset."),defineProperty(i,_,y,v,...b)}else{const _=x[g];_||consoleAndThrowError(g,"is a key not defined in Define Preset."),defineProperty(i,g,_)}})})(i,x,g)}},nr={enumerable:!0,configurable:!1};function createSetter$6(i,g,x){return function(_){this[g]=_;const{gpuRenderInfo:v}=this;if(x){const{fragmentUniformInfo:g,fragmentUniformBuffer:x}=v;x.writeOnlyBuffer(g.members[i],_?1:0),this.dirtyPipeline=!0}else if(v){const{vertexUniformInfo:g,vertexUniformBuffer:x}=v;g.members[i]&&(x.writeOnlyBuffer(g.members[i],_?1:0),this.dirtyPipeline=!0)}}}function defineBoolean(i,g=!1,x=!0){const _=Symbol(i);return{get:function(){return void 0===this[_]&&(this[_]=g),this[_]},set:createSetter$6(i,_,x),...nr}}function defineColorRGB(i,g="#fff",x=!0){const _=Symbol(i);return{get:function(){if(void 0===this[_]){let v=255,b=255,y=255;if(isHexColor(g)){const i=convertHexToRgb(g);v=i.r,b=i.g,y=i.b}this[_]=new ColorRGB(v,b,y,()=>{const{gpuRenderInfo:g}=this;if(g)if(x){const{fragmentUniformInfo:x,fragmentUniformBuffer:v}=g;v.writeOnlyBuffer(x.members[i],this[_].rgbNormalLinear)}else{const{vertexUniformInfo:x,vertexUniformBuffer:v}=g;v.writeOnlyBuffer(x.members[i],this[_].rgbNormalLinear)}})}return this[_]},...nr}}function defineColorRGBA(i,g="#fff",x=!0){const _=Symbol(i);return{get:function(){if(void 0===this[_]){let v=255,b=255,y=255,S=1;if(isHexColor(g)){const i=convertHexToRgb(g);v=i.r,b=i.g,y=i.b}this[_]=new ColorRGBA(v,b,y,S,()=>{const{gpuRenderInfo:g}=this;if(g)if(x){const{fragmentUniformInfo:x,fragmentUniformBuffer:v}=g;v.writeOnlyBuffer(x.members[i],this[_].rgbaNormalLinear)}else{const{vertexUniformInfo:x,vertexUniformBuffer:v}=g;v.writeOnlyBuffer(x.members[i],this[_].rgbaNormalLinear)}})}return this[_]},...nr}}function createSetter$5(i,g,x){const _=`use${i.charAt(0).toUpperCase()}${i.substring(1)}`;return function(i){const v=this[g];this[g]=i,this.updateTexture(v,i);const{gpuRenderInfo:b}=this;if(x){const{fragmentUniformInfo:g,fragmentUniformBuffer:x}=b;_ in this?this[_]=!!i:g.members[_]&&x.writeOnlyBuffer(g.members[_],i?1:0)}else if(b){const{vertexUniformInfo:g,vertexUniformBuffer:x}=b;g.members[_]&&x.writeOnlyBuffer(x.members[_],i?1:0)}}}function defineCubeTexture(i,g=!0){const x=Symbol(i);return{get:function(){return this[x]},set:createSetter$5(i,x,g),...nr}}function createSetter$4(i,g,x,_=0,v){return function(b){void 0!==_&&b<_&&(console.warn(`Value for ${i} is below the minimum (${_}). Received:${b}. Adjusted to ${_}.`),b=_),void 0!==v&&b>v&&(console.warn(`Value for ${i} exceeds the maximum (${v}). Received:${b}. Adjusted to ${v}.`),b=v),validatePositiveNumberRange(b),this[g]=b;const{gpuRenderInfo:y}=this;if(x){const{fragmentUniformInfo:x,fragmentUniformBuffer:_}=y;_.writeOnlyBuffer(x.members[i],this[g])}else if(y){const{vertexUniformInfo:x,vertexUniformBuffer:_}=y;_.writeOnlyBuffer(x.members[i],this[g])}}}function definePositiveNumberRange(i,g=1,x=!0,_=0,v){const b=Symbol(i);return{get:function(){return void 0===this[b]&&(this[b]=g),this[b]},set:createSetter$4(i,b,x,_,v),...nr}}function defineSampler(i){const g=Symbol(i);return{get:function(){return this[g]},set:function(i){const x=this[g];this[g]=i,this.updateSampler(x,i)},...nr}}function createSetter$3(i,g,x){const _=`use${i.charAt(0).toUpperCase()}${i.substring(1)}`;return function(i){const v=this[g];this[g]=i,this.updateTexture(v,i);const{gpuRenderInfo:b}=this;if(x){const{fragmentUniformInfo:g,fragmentUniformBuffer:x}=b;_ in this?this[_]=!!i:g.members[_]&&x.writeOnlyBuffer(g.members[_],i?1:0)}else if(b){const{vertexUniformInfo:g,vertexUniformBuffer:x}=b;g.members[_]&&x.writeOnlyBuffer(x.members[_],i?1:0)}}}function defineTexture$1(i,g=!0){const x=Symbol(i);return{get:function(){return this[x]},set:createSetter$3(i,x,g),...nr}}function createSetter$2(i,g,x){const _=`use${i.charAt(0).toUpperCase()}${i.substring(1)}`;return function(i){const v=this[g];this[g]=i,this.updateTexture(v,i);const{gpuRenderInfo:b}=this;if(x){const{fragmentUniformInfo:g,fragmentUniformBuffer:x}=b;_ in this?this[_]=!!i:g.members[_]&&x.writeOnlyBuffer(g.members[_],i?1:0)}else if(b){const{vertexUniformInfo:g,vertexUniformBuffer:x}=b;g.members[_]&&x.writeOnlyBuffer(x.members[_],i?1:0)}}}function defineTexture3D(i,g=!0){const x=Symbol(i);return{get:function(){return this[x]},set:createSetter$2(i,x,g),...nr}}function createSetter$1(i,g,x,_=0,v){return function(b){validateUintRange(b),void 0!==_&&b<_&&(console.warn(`Value for ${i} is below the minimum (${_}). Received:${b}. Adjusted to ${_}.`),b=_),void 0!==v&&b>v&&(console.warn(`Value for ${i} exceeds the maximum (${v}). Received:${b}. Adjusted to ${v}.`),b=v),this[g]=b;const{gpuRenderInfo:y}=this;if(x){const{fragmentUniformInfo:x,fragmentUniformBuffer:_}=y;_.writeOnlyBuffer(x.members[i],this[g])}else if(y){const{vertexUniformInfo:x,vertexUniformBuffer:_}=y;_.writeOnlyBuffer(x.members[i],this[g])}}}function defineUintRange(i,g=0,x=!0,_=0,v){const b=Symbol(i);return{get:function(){return void 0===this[b]&&(this[b]=g),this[b]},set:createSetter$1(i,b,x,_,v),...nr}}function createSetter(i,g,x){return function(_){this[g]=_;const{gpuRenderInfo:v}=this;if(x){const{fragmentUniformInfo:g,fragmentUniformBuffer:x}=v;x.writeOnlyBuffer(g.members[i],_)}else if(v){const{vertexUniformInfo:g,vertexUniformBuffer:x}=v;x.writeOnlyBuffer(g.members[i],_)}}}function defineVector(i,g,x=!0){const _=Symbol(i);return{get:function(){return void 0===this[_]&&(this[_]=g),this[_]},set:createSetter(i,_,x),...nr}}function defineProperty_vec4$1(i,g=[0,0,0,0]){return defineVector(i,g)}function defineProperty_vec3$1(i,g=[0,0,0]){return defineVector(i,g)}function defineProperty_vec2$1(i,g=[0,0]){return defineVector(i,g)}function defineProperty_PositiveNumberRange$1(i,g=1,x,_){return definePositiveNumberRange(i,g,!0,x,_)}Object.freeze(nr),Object.freeze(defineBoolean),Object.freeze(defineColorRGB),Object.freeze(defineColorRGBA),Object.freeze(defineCubeTexture),Object.freeze(definePositiveNumberRange),Object.freeze(defineSampler),Object.freeze(defineTexture$1),Object.freeze(defineTexture3D),Object.freeze(defineUintRange),Object.freeze(defineVector);const rr={},ir={AO_STRENGTH:"aoStrength",SPECULAR_STRENGTH:"specularStrength",EMISSIVE_STRENGTH:"emissiveStrength",OPACITY:"opacity",SHININESS:"shininess",NORMAL_SCALE:"normalScale"},ar={},sr={ALPHA_TEXTURE_SAMPLER:"alphaTextureSampler",AO_TEXTURE_SAMPLER:"aoTextureSampler",DIFFUSE_TEXTURE_SAMPLER:"diffuseTextureSampler",EMISSIVE_TEXTURE_SAMPLER:"emissiveTextureSampler",ENVIRONMENT_TEXTURE_SAMPLER:"environmentTextureSampler",NORMAL_TEXTURE_SAMPLER:"normalTextureSampler",SPECULAR_TEXTURE_SAMPLER:"specularTextureSampler"},or={ENVIRONMENT_TEXTURE:"environmentTexture"},ur={},lr={},cr={},hr={ALPHA_TEXTURE:"alphaTexture",AO_TEXTURE:"aoTexture",DIFFUSE_TEXTURE:"diffuseTexture",EMISSIVE_TEXTURE:"emissiveTexture",NORMAL_TEXTURE:"normalTexture",SPECULAR_TEXTURE:"specularTexture"},fr={COLOR:"color",EMISSIVE_COLOR:"emissiveColor",SPECULAR_COLOR:"specularColor"},dr={...createDefineByPreset({defineBoolean:[defineBoolean,rr],definePositiveNumber:[defineProperty_PositiveNumberRange$1,ir],defineUint:[defineUintRange,ar],defineVec2:[defineProperty_vec2$1,ur],defineVec3:[defineProperty_vec3$1,lr],defineVec4:[defineProperty_vec4$1,cr],defineColorRGB:[defineColorRGB,fr],defineSampler:[defineSampler,sr],defineTexture:[defineTexture$1,hr],defineTexture3D:[defineTexture3D,{}],defineCubeTexture:[defineCubeTexture,or]}),defineBoolean:defineProperties(defineBoolean),definePositiveNumber:defineProperties(defineProperty_PositiveNumberRange$1),defineUint:defineProperties(defineUintRange),defineVec2:defineProperties(defineProperty_vec2$1),defineVec3:defineProperties(defineProperty_vec3$1),defineVec4:defineProperties(defineProperty_vec4$1),defineColorRGB:defineProperties(defineColorRGB),defineColorRGBA:defineProperties(defineColorRGBA),defineSampler:defineProperties(defineSampler),defineTexture:defineProperties(defineTexture$1),defineTexture3D:defineProperties(defineTexture3D),defineCubeTexture:defineProperties(defineCubeTexture),PRESET_BOOLEAN:rr,PRESET_POSITIVE_NUMBER:ir,PRESET_UINT:ar,PRESET_SAMPLER:sr,PRESET_TEXTURE:hr,PRESET_CUBE_TEXTURE:or,PRESET_VEC2:ur,PRESET_VEC3:lr,PRESET_VEC4:cr,PRESET_COLOR_RGB:fr};Object.freeze(dr);const mr={ZERO:"zero",ONE:"one",SRC:"src",ONE_MINUS_SRC:"one-minus-src",SRC_ALPHA:"src-alpha",ONE_MINUS_SRC_ALPHA:"one-minus-src-alpha",DST:"dst",ONE_MINUS_DST:"one-minus-dst",DST_ALPHA:"dst-alpha",ONE_MINUS_DST_ALPHA:"one-minus-dst-alpha",SRC_ALPHA_SATURATED:"src-alpha-saturated",CONSTANT:"constant",ONE_MINUS_CONSTANT:"one-minus-constant",SRC1:"src1",ONE_MINUS_SRC1:"one-minus-src1",SRC1_ALPHA:"src1-alpha",ONE_MINUS_SRC1_ALPHA:"one-minus-src1-alpha"};Object.freeze(mr);const pr={ADD:"add",SUBTRACT:"subtract",REVERSE_SUBTRACT:"reverse-subtract",MIN:"min",MAX:"max"};Object.freeze(pr);const gr=Object.values(mr),xr=Object.values(pr);class BlendState{state;#tn;#nn;#rn;#in;constructor(i,g,x,_){this.#in=i,this.srcFactor=g,this.dstFactor=x,this.operation=_}get operation(){return this.#rn}set operation(i){xr.includes(i)||consoleAndThrowError(`Invalid GPUBlendOperation:${i}. Valid operations are ${xr.join(",")}`),this.#rn=i,this.#an()}get srcFactor(){return this.#tn}set srcFactor(i){gr.includes(i)||consoleAndThrowError(`Invalid GPUBlendFactor:${i}. Valid srcFactor factors are ${gr.join(",")}`),this.#tn=i,this.#an()}get dstFactor(){return this.#nn}set dstFactor(i){gr.includes(i)||consoleAndThrowError(`Invalid GPUBlendFactor:${i}. Valid dstFactor factors are ${gr.join(",")}`),this.#nn=i,this.#an()}#an(){const i=this.#rn?{operation:this.#rn}:{},g=this.#tn?{srcFactor:this.#tn}:{},x=this.#nn?{dstFactor:this.#nn}:{};this.state={...i,...g,...x},this.#in.dirtyPipeline=!0}}const _r=new Map,vr=new WeakMap;let br,yr,Sr;class PackedTexture{#u=createUUID();#l;#ae;#L;#c;#sn;#xe=new Map;constructor(i){this.#l=i,this.#c=i.gpuDevice,this.#on(),this.#ae=this.#un()}get uuid(){return this.#u}get gpuTexture(){return this.#L}static getCacheMap(){return _r}async packing(i,g,x,_,v){const b={r:"r",g:"g",b:"b",a:"a",...v},y=`${i.r?.label||""}_${i.g?.label||""}_${i.b?.label||""}_${i.a?.label||""}`,S=`${JSON.stringify(b)}_${y}`;if(!(i.r||i.g||i.b||i.a))return;this.#ln(S);_r.get(S)||await this.#cn(i,g,x,_,b,S)}destroy(){const i=vr.get(this);if(i){const g=_r.get(i);g&&(g.useNum--,0===g.useNum&&(g.gpuTexture?.destroy(),_r.delete(i))),vr.delete(this)}}#on(){Sr=this.#l.resourceManager.createGPUBuffer("PACK_TEXTURE_MAPPING_BUFFER",{size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),yr||(yr=this.#l.resourceManager.createBindGroupLayout("PACK_TEXTURE_BIND_GROUP_LAYOUT",{entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:3,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:4,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:5,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]})),br||(br=this.#hn())}#fn(i){const g=`${i.r?.label||"empty"}_${i.g?.label||"empty"}_${i.b?.label||"empty"}_${i.a?.label||"empty"}`,{resourceManager:x}=this.#l;if(!this.#xe.has(g)){const _=[{binding:0,resource:x.getGPUResourceBitmapTextureView(i.r)},{binding:1,resource:x.getGPUResourceBitmapTextureView(i.g)},{binding:2,resource:x.getGPUResourceBitmapTextureView(i.b)},{binding:3,resource:x.getGPUResourceBitmapTextureView(i.a)},{binding:4,resource:this.#ae},{binding:5,resource:{buffer:Sr}}],v=this.#c.createBindGroup({label:`PACK_TEXTURE_BIND_GROUP_${g}`,layout:yr,entries:_});this.#xe.set(g,v)}this.#sn=this.#xe.get(g)}#ln(i){const g=vr.get(this);if(g&&g!==i){const i=_r.get(g);i&&(i.useNum--,0===i.useNum&&(i.gpuTexture?.destroy(),_r.delete(g)))}const x=_r.get(i);x&&(this.#L=x.gpuTexture,x.useNum++),vr.set(this,i)}async#cn(i,g,x,_,v,b){const y={size:[g,x,1],format:"rgba8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC,label:_||`PACK_TEXTURE_${createUUID()}`,mipLevelCount:getMipLevelCount(g,x)};this.#L&&(this.#L=null);const S=this.#l.resourceManager.createManagedTexture(y),w=new Uint32Array([["r","g","b","a"].indexOf(v.r),["r","g","b","a"].indexOf(v.g),["r","g","b","a"].indexOf(v.b),["r","g","b","a"].indexOf(v.a)]);this.#c.queue.writeBuffer(Sr,0,w),this.#fn(i),this.#dn(S),this.#L=y.mipLevelCount>1?this.#l.resourceManager.mipmapGenerator.generateMipmap(S,y):S,_r.set(b,{gpuTexture:this.#L,useNum:1,mappingKey:b,uuid:this.#u}),this.#sn=null}#dn(i){const{resourceManager:g}=this.#l,x=this.#c.createCommandEncoder({label:"PackedTexture_CommandEncoder"}),_=x.beginRenderPass({colorAttachments:[{view:g.getGPUResourceBitmapTextureView(i,{baseMipLevel:0,mipLevelCount:1,dimension:"2d",label:`${i.label}_RENDER_TARGET`}),loadOp:"clear",storeOp:"store",clearValue:[0,0,0,0]}]});_.setPipeline(br),_.setBindGroup(0,this.#sn),_.draw(6,1,0,0),_.end(),this.#c.queue.submit([x.finish()])}#hn(){const i="struct VertexOut { @builtin(position) position:vec4<f32>, @location(0) uv:vec2<f32>,\n};\n@vertex\nfn vertexMain(@builtin(vertex_index) VertexIndex:u32) -> VertexOut { var pos=array<vec2<f32>,6>( vec2(-1.0,-1.0), vec2( 1.0,-1.0), vec2(-1.0,1.0), vec2(-1.0,1.0), vec2( 1.0,-1.0), vec2( 1.0,1.0) ); var uv=array<vec2<f32>,6>( vec2(0.0,1.0), vec2(1.0,1.0), vec2(0.0,0.0), vec2(0.0,0.0), vec2(1.0,1.0), vec2(1.0,0.0) ); var output:VertexOut; output.position=vec4(pos[VertexIndex],0.0,1.0); output.uv=uv[VertexIndex]; return output;\n}\nstruct ComponentMapping { r_component:u32, g_component:u32, b_component:u32, a_component:u32,\n};\n@group(0) @binding(0) var textureR:texture_2d<f32>;\n@group(0) @binding(1) var textureG:texture_2d<f32>;\n@group(0) @binding(2) var textureB:texture_2d<f32>;\n@group(0) @binding(3) var textureA:texture_2d<f32>;\n@group(0) @binding(4) var sampler0:sampler;\n@group(0) @binding(5) var<uniform> mapping:ComponentMapping;\nfn getComponent(color:vec4<f32>,componentIndex:u32) -> f32 { switch componentIndex { case 0u:{ return color.r;} case 1u:{ return color.g;} case 2u:{ return color.b;} case 3u:{ return color.a;} default:{ return 0.0;} }\n}\n@fragment\nfn fragmentMain(input:VertexOut) -> @location(0) vec4<f32> { let colorR=textureSample(textureR,sampler0,input.uv); let colorG=textureSample(textureG,sampler0,input.uv); let colorB=textureSample(textureB,sampler0,input.uv); let colorA=textureSample(textureA,sampler0,input.uv); let r=getComponent(colorR,mapping.r_component); let g=getComponent(colorG,mapping.g_component); let b=getComponent(colorB,mapping.b_component); let a=getComponent(colorA,mapping.a_component); return vec4(r,g,b,a);\n}\n",{resourceManager:g}=this.#l,x=this.#c.createPipelineLayout({label:"PACK_TEXTURE_PIPELINE_LAYOUT",bindGroupLayouts:[yr]});return this.#c.createRenderPipeline({label:"PACK_TEXTURE_PIPELINE",layout:x,vertex:{module:g.createGPUShaderModule("PACK_TEXTURE_SHADER_MODULE",{code:i}),entryPoint:"vertexMain"},fragment:{module:g.createGPUShaderModule("PACK_TEXTURE_SHADER_MODULE",{code:i}),entryPoint:"fragmentMain",targets:[{format:"rgba8unorm"}]},primitive:{topology:"triangle-list"}})}#un(){return new Sampler(this.#l).gpuSampler}}const Tr={NORMAL:0,MULTIPLY:1,LIGHTEN:2,SCREEN:3,LINEAR_DODGE:4,SUBTRACT:5,DARKEN:6,OVERLAY:7,COLOR_DODGE:8,COLOR_BURN:9,HARD_LIGHT:10,SOFT_LIGHT:11,DIFFERENCE:12,EXCLUSION:13,DIVIDE:14,VIVID_LIGHT:15,LINEAR_BURN:16,PIN_LIGHT:17,SATURATION:18,HUE:19,LUMINOSITY:20,COLOR:21,NEGATION:22};class FragmentGPURenderInfo{fragmentShaderModule;fragmentShaderSourceVariant;fragmentShaderVariantConditionalBlocks;fragmentUniformInfo;fragmentBindGroupLayout;fragmentUniformBuffer;fragmentUniformBindGroup;fragmentState;constructor(i,g,x,_,v,b,y,S){this.fragmentShaderModule=i,this.fragmentShaderSourceVariant=g,this.fragmentShaderVariantConditionalBlocks=x,this.fragmentUniformInfo=_,this.fragmentBindGroupLayout=v,this.fragmentUniformBuffer=b,this.fragmentUniformBindGroup=y,this.fragmentState=S}}Object.freeze(FragmentGPURenderInfo);const getBindGroupLayoutDescriptorFromShaderInfo=(i,g,x,_=!0)=>{const{textures:v,samplers:b,uniforms:y,storage:S}=i,w=[];for(const i in S){const _=S[i],{binding:v,name:b,group:y,type:L}=_;if(_.access){const i={write:"write-only-storage",read:"read-only-storage",read_write:"read-write-storage"}[_.access];g===y&&w.push({binding:v,visibility:x,buffer:{type:i}})}else if(g===y){const{access:i,format:g}=L,_={write:"write-only",read:"read-only",read_write:"read-write"}[i],b=g.name;w.push({binding:v,visibility:x,storageTexture:{access:_,format:b}})}}for(const i in v){const b=v[i],{binding:y,name:S,group:L,type:k}=b,{name:z}=k;g===L&&w.push({binding:y,visibility:x,texture:"texture_depth_2d"===z||"texture_depth_multisampled_2d"===z?{viewDimension:"2d",sampleType:"depth",multisampled:_}:"texture_cube"===z?{viewDimension:"cube"}:"texture_3d"===z?{viewDimension:"3d"}:"texture_2d_array"===z?{viewDimension:"2d-array",sampleType:"float",multisampled:!1}:{}})}for(const i in b){const _=b[i],{binding:v,name:y,group:S}=_;g===S&&w.push({binding:v,visibility:x,sampler:{type:"filtering"}})}for(const i in y){const _=y[i],{binding:v,name:b,group:S}=_;g===S&&w.push({binding:v,visibility:x,buffer:{type:"uniform"}})}return{entries:w}},getFragmentBindGroupLayoutDescriptorFromShaderInfo=(i,g)=>getBindGroupLayoutDescriptorFromShaderInfo(i,g,GPUShaderStage.FRAGMENT),getVertexBindGroupLayoutDescriptorFromShaderInfo=(i,g)=>getBindGroupLayoutDescriptorFromShaderInfo(i,g,GPUShaderStage.VERTEX),getComputeBindGroupLayoutDescriptorFromShaderInfo=(i,g,x)=>getBindGroupLayoutDescriptorFromShaderInfo(i,g,GPUShaderStage.COMPUTE,x);class ABaseMaterial extends ResourceBase{use2PathRender;gpuRenderInfo;dirtyPipeline=!1;transparent=!1;#mn;#pn;#gn=GPUColorWrite.ALL;#xn;#_n;#vn;#We;#bn;#yn;#Sn;#Tn;#Mn;#wn;#Cn;#Pn;#Rn;#Pe;#Bn;#In=Tr.MULTIPLY;constructor(i,g,x,_){super(i),this.#Rn=g,this.#bn=`FRAGMENT_MODULE_${this.#Rn}`,this.#yn=`FRAGMENT_BIND_GROUP_DESCRIPTOR_${g}`,this.#Sn=`FRAGMENT_BIND_GROUP_LAYOUT_${g}`,this.#Tn=x,this.#Mn=x?.storage,this.#wn=x?.uniforms.uniforms,this.#Bn=_,this.#Cn=x.shaderSourceVariant.getUnionTextures(),this.#Pn=x.shaderSourceVariant.getUnionSamplers(),this.#Pe=i.resourceManager.getGPUBindGroupLayout(this.#Sn)||i.resourceManager.createBindGroupLayout(this.#Sn,getFragmentBindGroupLayoutDescriptorFromShaderInfo(x,_)),this.#mn=new BlendState(this,mr.SRC_ALPHA,mr.ONE_MINUS_SRC_ALPHA,pr.ADD),this.#pn=new BlendState(this,mr.SRC_ALPHA,mr.ONE_MINUS_SRC_ALPHA,pr.ADD),this.#xn=i.resourceManager,this.#_n=this.#xn.basicSampler.gpuSampler,this.#vn=this.#xn.emptyBitmapTextureView,this.#We=this.#xn.emptyCubeTextureView}get tintBlendMode(){const i=Object.entries(Tr).find(([,i])=>i===this.#In);if(!i)throw new Error(`Invalid tint mode value:${this.#In}`);return i[0]}set tintBlendMode(i){const{fragmentUniformInfo:g,fragmentUniformBuffer:x}=this.gpuRenderInfo;let _;if("string"==typeof i){if(!(i in Tr))throw new Error(`Invalid tint mode key:${i}`);_=Tr[i]}else{if("number"!=typeof i||!Object.values(Tr).includes(i))throw new Error(`Invalid tint mode:${i}`);_=i}x.writeOnlyBuffer(g.members.tintBlendMode,_),this.#In=_}get MODULE_NAME(){return this.#Rn}get FRAGMENT_SHADER_MODULE_NAME(){return this.#bn}get FRAGMENT_BIND_GROUP_DESCRIPTOR_NAME(){return this.#yn}get STORAGE_STRUCT(){return this.#Mn}get UNIFORM_STRUCT(){return this.#wn}get blendColorState(){return this.#mn}get blendAlphaState(){return this.#pn}get writeMaskState(){return this.#gn}set writeMaskState(i){this.#gn=i}initGPURenderInfos(){const{redGPUContext:i}=this,{resourceManager:g}=i,x=g.createGPUShaderModule(this.#bn,{code:this.#Tn.defaultSource}),_=new ArrayBuffer(Math.max(this.#wn.arrayBufferByteLength,16)),v=new UniformBuffer(i,_,`UniformBuffer_${this.#Rn}_${this.uuid}`);this.gpuRenderInfo=new FragmentGPURenderInfo(x,this.#Tn.shaderSourceVariant,this.#Tn.conditionalBlocks,this.#wn,this.#Pe,v,null,null),this._updateBaseProperty(),this._updateFragmentState()}_updateFragmentState(){const{gpuDevice:i,resourceManager:g}=this.redGPUContext;this.#En();const x=[];for(const i in this.#Cn){const _=this.#Cn[i],{binding:v,name:b,group:y,type:S}=_,{name:w}=S;let L;L="texture_cube"===w?g.getGPUResourceCubeTextureView(this[b]):"texture_3d"===w?this[b]?g.getGPUResourceBitmapTextureView(this[b],{dimension:"3d"}):g.emptyTexture3DView:this[b]instanceof PackedTexture?g.getGPUResourceBitmapTextureView(this[b]):g.getGPUResourceBitmapTextureView(this[b])||this.#vn,2===y&&x.push({binding:v,resource:L})}for(const i in this.#Pn){const g=this.#Pn[i],{binding:_,name:v,group:b}=g;2===b&&x.push({binding:_,resource:this.getGPUResourceSampler(this[v])})}this.#wn&&x.push({binding:this.#wn.binding,resource:{buffer:this.gpuRenderInfo.fragmentUniformBuffer.gpuBuffer,offset:0,size:this.gpuRenderInfo.fragmentUniformBuffer.size}});const _={layout:this.gpuRenderInfo.fragmentBindGroupLayout,label:this.#yn,entries:x},v=i.createBindGroup(_);this.gpuRenderInfo.fragmentState=this.getFragmentRenderState(),this.gpuRenderInfo.fragmentUniformBindGroup=v}getFragmentRenderState(i="main"){return{module:this.gpuRenderInfo.fragmentShaderModule,entryPoint:i,targets:[{format:"rgba16float",blend:{color:this.blendColorState.state,alpha:this.blendAlphaState.state},writeMask:this.writeMaskState},{format:navigator.gpu.getPreferredCanvasFormat(),blend:void 0,writeMask:this.writeMaskState},{format:"rgba16float",blend:void 0,writeMask:this.writeMaskState}]}}_updateBaseProperty(){const{fragmentUniformInfo:i,fragmentUniformBuffer:g}=this.gpuRenderInfo,{members:x}=i;for(const _ in x){const x=this[_];x instanceof ColorRGBA?g.writeOnlyBuffer(i.members[_],x.rgbaNormalLinear):x instanceof ColorRGB?g.writeOnlyBuffer(i.members[_],x.rgbNormalLinear):Mr.test(_)||(this[_]=x)}}getGPUResourceSampler(i){return i?.gpuSampler||this.#_n}#En(){const{gpuDevice:i,resourceManager:g}=this.redGPUContext,x=this.#Dn(),_=`${this.#bn}_${x}`;let v=g.getGPUShaderModule(_);if(!v){const i=this.gpuRenderInfo.fragmentShaderSourceVariant.getVariant(x);v=i?g.createGPUShaderModule(_,{code:i}):this.gpuRenderInfo.fragmentShaderModule}this.gpuRenderInfo.fragmentShaderModule=v,this.#Cn=this.gpuRenderInfo.fragmentShaderSourceVariant.getVariantTextures(x),this.#Pn=this.gpuRenderInfo.fragmentShaderSourceVariant.getVariantSamplers(x);const b=`${this.#Sn}_${x}`;let y=g.getGPUBindGroupLayout(b);if(!y){const i={...this.#Tn,textures:this.#Cn,samplers:this.#Pn};y=g.createBindGroupLayout(b,getFragmentBindGroupLayoutDescriptorFromShaderInfo(i,this.#Bn))}this.gpuRenderInfo.fragmentBindGroupLayout=y}#Dn(){const{fragmentShaderVariantConditionalBlocks:i}=this.gpuRenderInfo,g=new Set;for(const x of i)this[x]&&g.add(x);const x=g.size>0?Array.from(g).sort().join("+"):"none";return g.size,x}}const Mr=/^use\w+Texture$/;dr.defineByPreset(ABaseMaterial,[dr.PRESET_POSITIVE_NUMBER.OPACITY]),dr.defineBoolean(ABaseMaterial,[["useTint",!1]]),dr.defineColorRGBA(ABaseMaterial,["tint","#ff0000"]),Object.freeze(ABaseMaterial);class ABitmapBaseMaterial extends ABaseMaterial{__packingList;constructor(i,g,x,_){super(i,g,x,_)}updateTexture(i,g){i&&i.__removeDirtyPipelineListener(this.#Un),g&&g.__addDirtyPipelineListener(this.#Un),this.#Un()}updateSampler(i,g){i&&i.__removeDirtyPipelineListener(this.#Un),g&&g.__addDirtyPipelineListener(this.#Un),this.#Un()}#Un=()=>{this.dirtyPipeline=!0;{let i=(this.__packingList||[]).length;for(;i--;)this.__packingList[i]()}this.gpuRenderInfo?.fragmentShaderModule?this._updateFragmentState():this.initGPURenderInfos()}}Object.freeze(ABitmapBaseMaterial);class AUVTransformBaseMaterial extends ABitmapBaseMaterial{dirtyTextureTransform=!1;#Ln=[0,0];#An=[1,1];get textureOffset(){return this.#Ln}set textureOffset(i){this.dirtyTextureTransform=!0,this.#Ln=i}get textureScale(){return this.#An}set textureScale(i){this.dirtyTextureTransform=!0,this.#An=i}constructor(i,g,x,_){super(i,g,x,_)}}Object.freeze(AUVTransformBaseMaterial);var wr=Object.freeze({__proto__:null,ABaseMaterial:ABaseMaterial,ABitmapBaseMaterial:ABitmapBaseMaterial,AUVTransformBaseMaterial:AUVTransformBaseMaterial,FragmentGPURenderInfo:FragmentGPURenderInfo,getComputeBindGroupLayoutDescriptorFromShaderInfo:getComputeBindGroupLayoutDescriptorFromShaderInfo,getFragmentBindGroupLayoutDescriptorFromShaderInfo:getFragmentBindGroupLayoutDescriptorFromShaderInfo,getVertexBindGroupLayoutDescriptorFromShaderInfo:getVertexBindGroupLayoutDescriptorFromShaderInfo});class ASinglePassPostEffect{#Gn;#kn;#On;#Nn;#Vn;#Fn;#zn;#Hn;#$n;#Kn;#Xn;#jn;#Yn;#qn;#Wn;#h;#Zn;#Jn;#Qn;#er;#tr;#nr=16;#rr=16;#ir=1;#ar=!1;#sr=!1;#l;#or;#ur=[];#N=0;#lr;#cr;constructor(i){this.#l=i,this.#or=i.antialiasingManager}get useGBufferNormalTexture(){return this.#sr}set useGBufferNormalTexture(i){this.#sr=i}get videoMemorySize(){return this.#N}get useDepthTexture(){return this.#ar}set useDepthTexture(i){this.#ar=i}get redGPUContext(){return this.#l}get storageInfo(){return this.#Wn}get shaderInfo(){return this.#or.useMSAA?this.#Zn:this.#Jn}get uniformBuffer(){return this.#jn}get uniformsInfo(){return this.#Yn}get systemUuniformsInfo(){return this.#qn}get WORK_SIZE_X(){return this.#nr}set WORK_SIZE_X(i){this.#nr=i}get WORK_SIZE_Y(){return this.#rr}set WORK_SIZE_Y(i){this.#rr=i}get WORK_SIZE_Z(){return this.#ir}set WORK_SIZE_Z(i){this.#ir=i}get outputTextureView(){return this.#tr}clear(){this.#er&&(this.#er.destroy(),this.#er=null,this.#tr=null)}init(i,g,x,_){this.#h=g;const{resourceManager:v}=i;this.#Gn=v.createGPUShaderModule(`${g}_MSAA`,{code:x.msaa}),this.#kn=v.createGPUShaderModule(`${g}_NonMSAA`,{code:x.nonMsaa}),this.#Zn=parseWGSL(x.msaa),this.#Jn=parseWGSL(x.nonMsaa);const b=this.#Zn.storage,y=this.#Zn.uniforms;if(this.#Wn=b,this.#Yn=y.uniforms,this.#qn=y.systemUniforms,this.#Yn){const g=new ArrayBuffer(this.#Yn.arrayBufferByteLength);this.#jn=new UniformBuffer(i,g,`${this.constructor.name}_UniformBuffer`)}}execute(i,g,x,_){const v=g.createCommandEncoder({label:"ASinglePassPostEffect_Execute_CommandEncoder"}),b=v.beginComputePass();b.setPipeline(this.#Xn),b.setBindGroup(0,i.renderViewStateData.swapBufferIndex?this.#Fn:this.#Vn),b.setBindGroup(1,this.#zn),b.dispatchWorkgroups(Math.ceil(x/this.WORK_SIZE_X),Math.ceil(_/this.WORK_SIZE_Y)),b.end(),g.queue.submit([v.finish()])}render(i,g,x,..._){const{gpuDevice:v,antialiasingManager:b}=this.#l,{useMSAA:y,msaaID:S}=b,w=this.#hr(i),L=this.#lr!==y||this.#cr!==S,k=this.#fr(_),z=this.outputTextureView,{redGPUContext:H}=i;return(w||L||k)&&this.#dr(i,_,z,y,H,v),this.update(performance.now()),this.execute(i,v,g,x),this.#lr=y,this.#cr=S,{texture:this.#er,textureView:z}}update(i){}updateUniform(i,g){this.uniformBuffer.writeOnlyBuffer(this.uniformsInfo.members[i],g)}#dr(i,g,x,_,v,b){const y=this.storageInfo,S=this.uniformsInfo,w=this.systemUuniformsInfo;this.#Hn=[],this.#$n=[],this.#Kn=[];for(const i in y){const x=y[i],{binding:_,name:v}=x;"outputTexture"!==v&&(this.#Hn.push({binding:_,resource:g[_].textureView}),this.#$n.push({binding:_,resource:g[_].textureView}))}this.#Kn.push({binding:0,resource:x}),this.shaderInfo.textures.forEach(g=>{const{name:x,binding:_}=g;"depthTexture"===x&&(this.#Hn.push({binding:_,resource:i.viewRenderTextureManager.depthTextureView}),this.#$n.push({binding:_,resource:i.viewRenderTextureManager.prevDepthTextureView})),"gBufferNormalTexture"===x&&(this.#Hn.push({binding:_,resource:i.redGPUContext.antialiasingManager.useMSAA?i.viewRenderTextureManager.gBufferNormalResolveTextureView:i.viewRenderTextureManager.gBufferNormalTextureView}),this.#$n.push({binding:_,resource:i.redGPUContext.antialiasingManager.useMSAA?i.viewRenderTextureManager.gBufferNormalResolveTextureView:i.viewRenderTextureManager.gBufferNormalTextureView}))}),w&&this.#Kn.push({binding:w.binding,resource:{buffer:i.postEffectManager.postEffectSystemUniformBuffer.gpuBuffer,offset:0,size:i.postEffectManager.postEffectSystemUniformBuffer.size}}),this.#jn&&S&&this.#Kn.push({binding:S.binding,resource:{buffer:this.#jn.gpuBuffer,offset:0,size:this.#jn.size}});const L=_?this.#Zn:this.#Jn,k=_?this.#Gn:this.#kn;this.#On=v.resourceManager.getGPUBindGroupLayout(`${this.#h}_BIND_GROUP_LAYOUT_0_USE_MSAA_${_}`)||v.resourceManager.createBindGroupLayout(`${this.#h}_BIND_GROUP_LAYOUT_0_USE_MSAA_${_}`,getComputeBindGroupLayoutDescriptorFromShaderInfo(L,0,_)),this.#Nn=v.resourceManager.getGPUBindGroupLayout(`${this.#h}_BIND_GROUP_LAYOUT_1_USE_MSAA_${_}`)||v.resourceManager.createBindGroupLayout(`${this.#h}_BIND_GROUP_LAYOUT_1_USE_MSAA_${_}`,getComputeBindGroupLayoutDescriptorFromShaderInfo(L,1,_)),this.#Vn=b.createBindGroup({label:`${this.#h}_BIND_GROUP_0_USE_MSAA_${_}_SWAP0`,layout:this.#On,entries:this.#Hn}),this.#Fn=b.createBindGroup({label:`${this.#h}_BIND_GROUP_0_USE_MSAA_${_}_SWAP0`,layout:this.#On,entries:this.#$n}),this.#zn=b.createBindGroup({label:`${this.#h}_BIND_GROUP_1_USE_MSAA_${_}`,layout:this.#Nn,entries:this.#Kn}),this.#Xn=b.createComputePipeline({label:`${this.#h}_COMPUTE_PIPELINE_USE_MSAA_${_}`,layout:b.createPipelineLayout({bindGroupLayouts:[this.#On,this.#Nn]}),compute:{module:k,entryPoint:"main"}}),this.#mr(g)}#pr(){this.#N=0,this.#er&&(this.#N=calculateTextureByteSize(this.#er))}#fr(i){if(!this.#ur||this.#ur.length!==i.length)return!0;for(let g=0;g<i.length;g++)if(this.#ur[g].textureView!==i[g].textureView)return!0;return!1}#mr(i){this.#ur=[...i]}#hr(i){const{redGPUContext:g,viewRenderTextureManager:x,name:_}=i,{gBufferColorTexture:v}=x,{resourceManager:b}=g,{width:y,height:S}=v,w=y!==this.#Qn?.width||S!==this.#Qn?.height||!this.#er;return w&&(this.clear(),this.#er=b.createManagedTexture({size:{width:y,height:S},format:"rgba16float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC,label:`${_}_${this.#h}_${y}x${S}}`}),this.#tr=b.getGPUResourceBitmapTextureView(this.#er)),this.#Qn={width:y,height:S},this.#pr(),w}}Object.freeze(ASinglePassPostEffect);class AMultiPassPostEffect extends ASinglePassPostEffect{#gr=[];#N=0;constructor(i,g){super(i),this.#gr.push(...g)}get videoMemorySize(){return this.#pr(),this.#N}get passList(){return this.#gr}clear(){this.#gr.forEach(i=>i.clear())}render(i,g,x,_){let v;return this.#gr.forEach((b,y)=>{y&&(_=v),v=b.render(i,g,x,_)}),v}#pr(){this.#N=0,this.#gr.forEach(i=>{this.#N+=i.videoMemorySize})}}Object.freeze(AMultiPassPostEffect);const validateNumberRange=(i,g=-Number.MAX_VALUE,x=Number.MAX_VALUE)=>("number"!=typeof i&&consoleAndThrowError("Only numbers allowed."),"number"!=typeof g&&consoleAndThrowError("Only numbers allowed."),"number"!=typeof x&&consoleAndThrowError("Only numbers allowed."),(i<g||i>x)&&consoleAndThrowError(`Only numbers within the range of [${g},${x}] are allowed. input:${i}`),!0),createCode=(i,g,x="",_=!1)=>{const{WORK_SIZE_X:v,WORK_SIZE_Y:b,WORK_SIZE_Z:y}=i,S=_?"texture_depth_multisampled_2d":"texture_depth_2d";return`\n ${x} @group(0) @binding(0) var sourceTexture:texture_storage_2d<rgba16float,read>; ${i.useDepthTexture?`@group(0) @binding(1) var depthTexture:${S}`:""}; ${i.useGBufferNormalTexture?`@group(0) @binding(${i.useDepthTexture?2:1}) var gBufferNormalTexture:texture_2d<f32>`:""}; @group(1) @binding(0) var outputTexture:texture_storage_2d<rgba16float,write>; ${tr} ${x?"@group(1) @binding(2) var<uniform> uniforms:Uniforms;":""} @compute @workgroup_size(${v},${b},${y}) fn main (  @builtin(global_invocation_id) global_id:vec3<u32>, ){ ${g} } `},createBasicPostEffectCode=(i,g,x="")=>({msaa:createCode(i,g,x,!0),nonMsaa:createCode(i,g,x,!1)});Object.freeze(createBasicPostEffectCode);class BlurX extends ASinglePassPostEffect{#en=32;constructor(i){super(i),this.init(i,"POST_EFFECT_BLUR_X",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy);\nlet dimensions=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet size_value:f32=uniforms.size;\nvar sum:vec4<f32>=vec4<f32>(0.0,0.0,0.0,0.0);\nvar offset=random(global_id,0.0);\nvar total=0.0;\nlet loopSize=10.0;\nfor (var t=-loopSize;t <=loopSize;t=t + 1.0) { var percent=(t + offset - 0.5)/loopSize; var weight=1.0 - abs(percent); var ix=clamp((f32(global_id.x) + f32(size_value * percent)),0.0,dimW - 1.0); let delta=vec2<i32>(i32(ix),i32(global_id.y)); sum +=textureLoad(sourceTexture,delta).xyzw * weight; total +=weight;\n}\nsum/=total;\ntextureStore(outputTexture,vec2<i32>(global_id.xy),sum);\n","struct Uniforms { size:f32,\n};\nfn random(id:vec3<u32>,delta:f32) -> f32 { let seed:u32=((id.x << 16) | (id.y & 0xFFFF)) ^ (id.z * 0x63641362); let t:vec3<f32>=vec3<f32>(f32(seed & 0xFF),f32((seed >> 8) & 0xFF),f32(seed >> 16)); return delta + fract(sin(dot(t,vec3<f32>(12.9898,78.233,12.9898))) * 43758.5453);\n}\n")),this.size=this.#en}get size(){return this.#en}set size(i){validateNumberRange(i,0),this.#en=i,this.updateUniform("size",i)}}Object.freeze(BlurX);class BlurY extends ASinglePassPostEffect{#en=32;constructor(i){super(i),this.init(i,"POST_EFFECT_BLUR_Y",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy);\nlet dimensions=textureDimensions(sourceTexture);\nlet dimH=f32(dimensions.y);\nlet size_value:f32=uniforms.size;\nvar sum:vec4<f32>=vec4<f32>(0.0,0.0,0.0,0.0);\nvar offset=random(global_id,0.0);\nvar total=0.0;\nlet loopSize=10.0;\nfor (var t=-loopSize;t <=loopSize;t=t + 1.0) { var percent=(t + offset - 0.5)/loopSize; var weight=1.0 - abs(percent); var iy=clamp((f32(global_id.y) + f32(size_value * percent)),0.0,dimH - 1.0); let delta=vec2<i32>(i32(global_id.x),i32(iy)); sum +=textureLoad(sourceTexture,delta).xyzw * weight; total +=weight;\n}\nsum/=total;\ntextureStore(outputTexture,vec2<i32>(global_id.xy),sum);\n","struct Uniforms { size:f32,\n};\nfn random(id:vec3<u32>,delta:f32) -> f32 { let seed:u32=((id.x << 16) | (id.y & 0xFFFF)) ^ (id.z * 0x63641362); let t:vec3<f32>=vec3<f32>(f32(seed & 0xFF),f32((seed >> 8) & 0xFF),f32(seed >> 16)); return delta + fract(sin(dot(t,vec3<f32>(12.9898,78.233,12.9898))) * 43758.5453);\n}\n")),this.size=this.#en}get size(){return this.#en}set size(i){validateNumberRange(i,0),this.#en=i,this.updateUniform("size",i)}}Object.freeze(BlurY);class GaussianBlur extends AMultiPassPostEffect{#en=32;constructor(i){super(i,[new BlurX(i),new BlurY(i)])}get size(){return this.#en}set size(i){this.#en=i,this.passList.forEach(g=>g.size=i)}}Object.freeze(GaussianBlur);class SSAO_AO extends ASinglePassPostEffect{#xr=.253;#_r=1;#vr=.02;#br=.02;#yr=30;#Sr=20;#Tr=1.5;#Mr=!0;constructor(i){super(i),this.useDepthTexture=!0,this.useGBufferNormalTexture=!0,this.init(i,"POST_EFFECT_SSAO",createBasicPostEffectCode(this,"{ let screenCoord=vec2<i32>(global_id.xy); let texSize=vec2<i32>(textureDimensions(sourceTexture)); if (screenCoord.x >=texSize.x || screenCoord.y >=texSize.y) { return;} let originalColor=textureLoad(sourceTexture,screenCoord); let depth=textureLoad(depthTexture,screenCoord,0); var failColor=vec4<f32>(select(originalColor.rgb,vec3<f32>(1.0),uniforms.useBlur > 0.0),originalColor.a); if (depth < 0.001) { textureStore(outputTexture,screenCoord,failColor); return; } let normalData=textureLoad(gBufferNormalTexture,screenCoord,0); if (length(normalData.rgb)<0.001) { textureStore(outputTexture,screenCoord,failColor); return; } let viewPos=reconstructViewPosition(screenCoord,depth); let viewNormal=reconstructViewNormal(textureLoad(gBufferNormalTexture,screenCoord,0)); let distToCamera=-viewPos.z; let depthScale=distToCamera * 0.1; let adaptiveRadius=uniforms.radius * (1.0 + depthScale); let noiseVec=getNoiseVec(vec2<f32>(screenCoord)); let tangent=normalize(noiseVec - viewNormal * dot(noiseVec,viewNormal)); let bitangent=cross(viewNormal,tangent); let tbn=mat3x3<f32>(tangent,bitangent,viewNormal); let samples=array<vec3<f32>,8>( vec3<f32>(0.04,0.03,0.08),vec3<f32>(-0.04,0.04,0.08), vec3<f32>(0.10,-0.08,0.18),vec3<f32>(-0.09,-0.10,0.18), vec3<f32>(0.18,0.15,0.30),vec3<f32>(-0.17,0.18,0.30), vec3<f32>(0.28,-0.25,0.45),vec3<f32>(-0.27,-0.28,0.45) ); var totalOcclusion=0.0; for (var i=0u;i < 8u;i++) { let sampleOffset=tbn * samples[i]; let sampleDir=normalize(sampleOffset); let sampleViewPos=viewPos + sampleOffset * adaptiveRadius; let clipPos=systemUniforms.projectionMatrix * vec4<f32>(sampleViewPos,1.0); let sampleUV=(clipPos.xy/clipPos.w) * vec2<f32>(0.5,-0.5) + 0.5; if (sampleUV.x < 0.0 || sampleUV.x > 1.0 || sampleUV.y < 0.0 || sampleUV.y > 1.0) { continue; } let sampleCoord=vec2<i32>(sampleUV * vec2<f32>(texSize)); let realDepth=textureLoad(depthTexture,sampleCoord,0); if (realDepth < 0.001) { continue;} let realViewPos=reconstructViewPosition(sampleCoord,realDepth); let adaptiveBias=uniforms.bias * (1.0 + distToCamera * uniforms.biasDistanceScale); let deltaZ=realViewPos.z - sampleViewPos.z; if (deltaZ > adaptiveBias && deltaZ < adaptiveRadius * 1.5) { let sampleDist=length(viewPos - realViewPos); if (sampleDist < adaptiveRadius * 1.5) { let angleWeight=pow(max(0.0,dot(viewNormal,sampleDir)),2.0); let distFalloff=1.0 - smoothstep(0.0,adaptiveRadius * 1.5,sampleDist); totalOcclusion +=angleWeight * distFalloff; } } } let ao=(totalOcclusion/8.0) * uniforms.intensity; let distanceFade=smoothstep( uniforms.fadeDistanceStart + uniforms.fadeDistanceRange, uniforms.fadeDistanceStart, distToCamera ); var finalAO=saturate(1.0 - (ao * distanceFade)); finalAO=pow(finalAO,uniforms.contrast); let finalColor=vec4<f32>( select(originalColor.rgb * vec3<f32>(finalAO),vec3<f32>(finalAO),uniforms.useBlur > 0.0), originalColor.a ); textureStore(outputTexture,screenCoord,finalColor);\n}\n","struct Uniforms { radius:f32, intensity:f32, bias:f32, biasDistanceScale:f32, fadeDistanceStart:f32, fadeDistanceRange:f32, contrast:f32, useBlur:f32,\n}\nfn getTextureSize() -> vec2<f32> { return vec2<f32>(textureDimensions(sourceTexture));\n}\nfn reconstructViewPosition(screenCoord:vec2<i32>,depth:f32) -> vec3<f32> { let texSize=getTextureSize(); let uv=(vec2<f32>(screenCoord) + 0.5)/texSize; let ndc=vec3<f32>(uv.x * 2.0 - 1.0,(1.0 - uv.y) * 2.0 - 1.0,depth); let clipPos=vec4<f32>(ndc,1.0); let viewPos4=systemUniforms.inverseProjectionMatrix * clipPos; return viewPos4.xyz/viewPos4.w;\n}\nfn reconstructViewNormal(gBufferNormalData:vec4<f32>) -> vec3<f32> { let worldNormal=normalize(gBufferNormalData.rgb * 2.0 - 1.0); let viewNormal=(systemUniforms.camera.cameraMatrix * vec4<f32>(worldNormal,0.0)).xyz; return normalize(viewNormal);\n}\nfn getNoiseVec(p:vec2<f32>) -> vec3<f32> { let noise=fract(52.9829189 * fract(dot(p,vec2<f32>(0.06711056,0.00583715)))); let angle=noise * 6.28318530718; return vec3<f32>(cos(angle),sin(angle),0.0);\n}\n")),this.radius=this.#xr,this.intensity=this.#_r,this.bias=this.#vr,this.biasDistanceScale=this.#br,this.fadeDistanceStart=this.#yr,this.fadeDistanceRange=this.#Sr,this.contrast=this.#Tr,this.useBlur=!0}get useBlur(){return this.#Mr}set useBlur(i){this.#Mr=i,this.updateUniform("useBlur",i?1:0)}get radius(){return this.#xr}set radius(i){validatePositiveNumberRange(i,.01,5),this.#xr=i,this.updateUniform("radius",i)}get intensity(){return this.#_r}set intensity(i){validateNumberRange(i,0,10),this.#_r=i,this.updateUniform("intensity",i)}get bias(){return this.#vr}set bias(i){validateNumberRange(i,0,.1),this.#vr=i,this.updateUniform("bias",i)}get biasDistanceScale(){return this.#br}set biasDistanceScale(i){validateNumberRange(i,0,.5),this.#br=i,this.updateUniform("biasDistanceScale",i)}get fadeDistanceStart(){return this.#yr}set fadeDistanceStart(i){validatePositiveNumberRange(i,1,200),this.#yr=i,this.updateUniform("fadeDistanceStart",i)}get fadeDistanceRange(){return this.#Sr}set fadeDistanceRange(i){validatePositiveNumberRange(i,1,100),this.#Sr=i,this.updateUniform("fadeDistanceRange",i)}get contrast(){return this.#Tr}set contrast(i){validateNumberRange(i,.5,4),this.#Tr=i,this.updateUniform("contrast",i)}}Object.freeze(SSAO_AO);class SSAOBlend extends ASinglePassPostEffect{constructor(i){super(i);const{WORK_SIZE_X:g,WORK_SIZE_Y:x,WORK_SIZE_Z:_}=this,v=`\n @group(0) @binding(0) var sourceTexture0:texture_storage_2d<rgba16float,read>; @group(0) @binding(1) var sourceTexture1:texture_storage_2d<rgba16float,read>; @group(1) @binding(0) var outputTexture:texture_storage_2d<rgba16float,write>;\n @compute @workgroup_size(${g},${x},${_}) fn main ( @builtin(global_invocation_id) global_id:vec3<u32>, ){ let index=vec2<u32>(global_id.xy ); let dimensions:vec2<u32>=textureDimensions(sourceTexture0); let dimW=f32(dimensions.x); let dimH=f32(dimensions.y); let uv=\tvec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH); var diffuse:vec4<f32>=textureLoad( sourceTexture0, index, ); var blur:vec4<f32>=textureLoad( sourceTexture1, index, );  let finalColor=vec4<f32>((diffuse.rgb * blur.rgb ) ,diffuse.a); textureStore(outputTexture,index,finalColor ); }; `;this.init(i,"POST_EFFECT_OLD_BLOOM",{msaa:v,nonMsaa:v})}render(i,g,x,_,v){return super.render(i,g,x,_,v)}}Object.freeze(SSAOBlend);class SSAO extends AMultiPassPostEffect{#wr;#Cr;#Pr;constructor(i){super(i,[new SSAO_AO(i),new GaussianBlur(i),new SSAOBlend(i)]),this.#wr=this.passList[0],this.#Cr=this.passList[1],this.#Cr.size=3,this.#Pr=this.passList[2]}get useBlur(){return this.#wr.useBlur}set useBlur(i){this.#wr.useBlur=i}get radius(){return this.#wr.radius}set radius(i){this.#wr.radius=i}get intensity(){return this.#wr.intensity}set intensity(i){this.#wr.intensity=i}get bias(){return this.#wr.bias}set bias(i){this.#wr.bias=i}get biasDistanceScale(){return this.#wr.biasDistanceScale}set biasDistanceScale(i){this.#wr.biasDistanceScale=i}get fadeDistanceStart(){return this.#wr.fadeDistanceStart}set fadeDistanceStart(i){this.#wr.fadeDistanceStart=i}get fadeDistanceRange(){return this.#wr.fadeDistanceRange}set fadeDistanceRange(i){this.#wr.fadeDistanceRange=i}get contrast(){return this.#wr.contrast}set contrast(i){this.#wr.contrast=i}render(i,g,x,_){const v=this.#wr.render(i,g,x,_);if(this.useBlur){const b=this.#Cr.render(i,g,x,v);return this.#Pr.render(i,g,x,_,b)}return v}}Object.freeze(SSAO);class SSR extends ASinglePassPostEffect{#Rr=64;#Br=15;#Ir=.02;#Er=1;#Dr=12;#Ur=.15;constructor(i){super(i),this.WORK_SIZE_X=8,this.WORK_SIZE_Y=8,this.WORK_SIZE_Z=1,this.useDepthTexture=!0,this.useGBufferNormalTexture=!0,this.init(i,"POST_EFFECT_SSR",createBasicPostEffectCode(this,"let screenCoord=vec2<i32>(global_id.xy);\nlet texDims=textureDimensions(sourceTexture);\nlet texSize=vec2<i32>(texDims);\nif (screenCoord.x >=texSize.x || screenCoord.y >=texSize.y) { return;\n}\nlet originalColor=textureLoad(sourceTexture,screenCoord);\nlet depth=textureLoad(depthTexture,screenCoord,0);\nif (depth >=0.999) { textureStore(outputTexture,screenCoord,originalColor); return;\n}\nlet gBufferNormalData=textureLoad(gBufferNormalTexture,screenCoord,0);\nlet precomputedReflectionStrength=gBufferNormalData.a;\nif (precomputedReflectionStrength < 0.05) { textureStore(outputTexture,screenCoord,originalColor); return;\n}\nlet worldPos=reconstructWorldPosition(screenCoord,depth);\nlet worldNormal=reconstructWorldNormal(gBufferNormalData);\nif (length(worldNormal) < 0.01) { textureStore(outputTexture,screenCoord,originalColor); return;\n}\nlet normal=normalize(worldNormal);\nlet cameraWorldPos=systemUniforms.camera.inverseCameraMatrix[3].xyz;\nlet reflectionDir=calculateWorldReflectionRay(worldPos,normal,cameraWorldPos);\nlet reflection=performWorldRayMarching(worldPos,reflectionDir);\nif (reflection.a > 0.001) { let finalReflectionStrength=reflection.a * uniforms.reflectionIntensity * precomputedReflectionStrength; let reflectionColor=reflection.rgb * finalReflectionStrength; let diffuseColor=originalColor.rgb * (1.0 - finalReflectionStrength); let finalColor=diffuseColor + reflectionColor; textureStore(outputTexture,screenCoord,vec4<f32>(finalColor,originalColor.a));\n} else { textureStore(outputTexture,screenCoord,originalColor);\n}\n","struct Uniforms { maxSteps:u32, maxDistance:f32, stepSize:f32, reflectionIntensity:f32, fadeDistance:f32, edgeFade:f32, _padding:f32, _padding2:f32, } fn getTextureDimensions() -> vec2<u32> { return textureDimensions(depthTexture); } fn reconstructWorldPosition(screenCoord:vec2<i32>,depth:f32) -> vec3<f32> { let texDims=getTextureDimensions(); let invTexDims=1.0/vec2<f32>(texDims); let uv=(vec2<f32>(screenCoord) + 0.5) * invTexDims; let ndc=vec3<f32>( uv.x * 2.0 - 1.0, -(uv.y * 2.0 - 1.0), depth * 2.0 - 1.0 ); let clipPos=vec4<f32>(ndc,1.0); let viewPos4=systemUniforms.inverseProjectionMatrix * clipPos; if (abs(viewPos4.w) < 1e-6) { return vec3<f32>(0.0); } let viewPos=viewPos4.xyz/viewPos4.w; let worldPos4=systemUniforms.camera.inverseCameraMatrix * vec4<f32>(viewPos,1.0); return worldPos4.xyz; } fn reconstructWorldNormal(gBufferNormalData:vec4<f32>) -> vec3<f32> { return normalize(gBufferNormalData.rgb * 2.0 - 1.0); } fn worldToScreen(worldPos:vec3<f32>) -> vec2<f32> { let clipPos4=systemUniforms.projectionCameraMatrix * vec4<f32>(worldPos,1.0); if (abs(clipPos4.w) < 1e-6) { return vec2<f32>(-1.0); } let ndc=clipPos4.xyz/clipPos4.w; return vec2<f32>(ndc.x * 0.5 + 0.5,-ndc.y * 0.5 + 0.5); } fn calculateEdgeFade(screenUV:vec2<f32>) -> f32 { let edge=min(screenUV,1.0 - screenUV); let edgeDist=min(edge.x,edge.y); return smoothstep(0.0,uniforms.edgeFade,edgeDist); } fn calculateWorldReflectionRay(worldPos:vec3<f32>,worldNormal:vec3<f32>,cameraWorldPos:vec3<f32>) -> vec3<f32> { let viewDir=normalize(cameraWorldPos - worldPos); return reflect(-viewDir,worldNormal); }\nfn performWorldRayMarching(startWorldPos:vec3<f32>,rayDir:vec3<f32>) -> vec4<f32> { let cameraWorldPos=systemUniforms.camera.inverseCameraMatrix[3].xyz; let cameraDistance=length(startWorldPos - cameraWorldPos); let distanceScale=1.0 + cameraDistance * 0.1; let adaptiveStepSize=uniforms.stepSize * min(distanceScale,4.0); let stepScale=1.0 + cameraDistance * 0.067; let adaptiveMaxSteps=u32(f32(uniforms.maxSteps) * min(stepScale,2.0)); let maxDistanceSq=uniforms.maxDistance * uniforms.maxDistance; let texDims=getTextureDimensions(); let texSizeF=vec2<f32>(texDims); let maxRefinementLevels=4u; let invMaxSteps=1.0/f32(adaptiveMaxSteps); var currentWorldPos=startWorldPos + rayDir * 0.01; var currentStepSize=adaptiveStepSize; var refinementLevel=0u; for (var i=0u;i < adaptiveMaxSteps;i++) { currentWorldPos +=rayDir * currentStepSize; let travelVec=currentWorldPos - startWorldPos; let travelDistanceSq=dot(travelVec,travelVec); if (travelDistanceSq > maxDistanceSq) { break; } let currentScreenUV=worldToScreen(currentWorldPos); if (any(currentScreenUV < vec2<f32>(0.0)) || any(currentScreenUV > vec2<f32>(1.0))) { break; } let screenCoord=vec2<i32>(currentScreenUV * texSizeF); let sampledDepth=textureLoad(depthTexture,screenCoord,0); if (sampledDepth >=0.999) { continue; } let sampledWorldPos=reconstructWorldPosition(screenCoord,sampledDepth); let rayDistanceFromCamera=length(currentWorldPos - cameraWorldPos); let surfaceDistanceFromCamera=length(sampledWorldPos - cameraWorldPos); let distanceDiff=rayDistanceFromCamera - surfaceDistanceFromCamera; let intersectionThreshold=currentStepSize * (4.0 + cameraDistance * 0.033); if (distanceDiff > 0.0 && distanceDiff < intersectionThreshold) { if (refinementLevel < maxRefinementLevels) { currentWorldPos -=rayDir * currentStepSize; currentStepSize *=0.6; refinementLevel++; continue; } let reflectionColor=textureLoad(sourceTexture,screenCoord); let travelDistance=sqrt(travelDistanceSq); let distanceFade=1.0 - smoothstep(0.0,uniforms.fadeDistance,travelDistance); let edgeFade=calculateEdgeFade(currentScreenUV); let stepFade=1.0 - f32(i) * invMaxSteps; let distanceCompensation=min(1.5,1.0 + cameraDistance * 0.04); let totalFade=distanceFade * edgeFade * stepFade * distanceCompensation; return vec4<f32>(reflectionColor.rgb,totalFade); } } return vec4<f32>(0.0);\n}\n")),this.maxSteps=this.#Rr,this.maxDistance=this.#Br,this.stepSize=this.#Ir,this.reflectionIntensity=this.#Er,this.fadeDistance=this.#Dr,this.edgeFade=this.#Ur}get maxSteps(){return this.#Rr}set maxSteps(i){validateNumberRange(i,1,512),this.#Rr=i,this.updateUniform("maxSteps",i)}get maxDistance(){return this.#Br}set maxDistance(i){validatePositiveNumberRange(i,1,200),this.#Br=i,this.updateUniform("maxDistance",i)}get stepSize(){return this.#Ir}set stepSize(i){validatePositiveNumberRange(i,.001,5),this.#Ir=i,this.updateUniform("stepSize",i)}get reflectionIntensity(){return this.#Er}set reflectionIntensity(i){validateNumberRange(i,0,5),this.#Er=i,this.updateUniform("reflectionIntensity",i)}get fadeDistance(){return this.#Dr}set fadeDistance(i){validatePositiveNumberRange(i,1,100),this.#Dr=i,this.updateUniform("fadeDistance",i)}get edgeFade(){return this.#Ur}set edgeFade(i){validateNumberRange(i,0,.5),this.#Ur=i,this.updateUniform("edgeFade",i)}}Object.freeze(SSR);class TAASharpen extends ASinglePassPostEffect{#Lr=.5;constructor(i){super(i),this.init(i,"POST_EFFECT_TAA_SHARPEN",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy);\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nif (any(index >=dimensions)) { return;\n}\nlet centerRGBA=textureLoad(sourceTexture,index);\nlet leftRGBA=textureLoad(sourceTexture,index - vec2<u32>(select(0u,1u,index.x > 0u),0u));\nlet rightRGBA=textureLoad(sourceTexture,min(index + vec2<u32>(1u,0u),dimensions - 1u));\nlet upRGBA=textureLoad(sourceTexture,index - vec2<u32>(0u,select(0u,1u,index.y > 0u)));\nlet downRGBA=textureLoad(sourceTexture,min(index + vec2<u32>(0u,1u),dimensions - 1u));\nlet lumaWeight=vec3<f32>(0.299,0.587,0.114);\nlet lCenter=dot(centerRGBA.rgb,lumaWeight);\nlet lLeft=dot(leftRGBA.rgb,lumaWeight);\nlet lRight=dot(rightRGBA.rgb,lumaWeight);\nlet lUp=dot(upRGBA.rgb,lumaWeight);\nlet lDown=dot(downRGBA.rgb,lumaWeight);\nlet minL=min(lCenter,min(min(lLeft,lRight),min(lUp,lDown)));\nlet maxL=max(lCenter,max(max(lLeft,lRight),max(lUp,lDown)));\nlet contrast=maxL - minL;\nvar finalRGBA:vec4<f32>;\nlet k=uniforms.sharpness * 0.2;\nif (contrast > 0.001) { let edgeRGB=4.0 * centerRGBA.rgb - (leftRGBA.rgb + rightRGBA.rgb + upRGBA.rgb + downRGBA.rgb); let sharpRGB=centerRGBA.rgb + edgeRGB * k; let edgeAlpha=4.0 * centerRGBA.a - (leftRGBA.a + rightRGBA.a + upRGBA.a + downRGBA.a); let sharpAlpha=centerRGBA.a + edgeAlpha * k; finalRGBA=vec4<f32>(sharpRGB,sharpAlpha);\n} else { finalRGBA=centerRGBA;\n}\ntextureStore(outputTexture,index,saturate(finalRGBA));","struct Uniforms { sharpness:f32\n};")),this.sharpness=.5}get sharpness(){return this.#Lr}set sharpness(i){validateNumberRange(i,0,1),this.#Lr=i,this.updateUniform("sharpness",i)}}Object.freeze(TAASharpen);class PostEffectManager{#zt;#Ar=[];#Gr;#kr;#Or;#me=16;#pe=4;#Nr=1;#Vr;#Fr;#zr;#Hr;#$r;#Kr;#Xr;#N=0;#jr;#Yr;#qr;#Wr;#Zr;#Jr=!1;#Qr;#ei=!1;constructor(i){this.#zt=i,this.#ne()}get useSSAO(){return this.#Jr}set useSSAO(i){this.#Jr=i,this.#ti()}get ssao(){return this.#Zr||(this.#Zr=new SSAO(this.#zt.redGPUContext)),this.#Zr}get useSSR(){return this.#ei}set useSSR(i){this.#ei=i,this.#ni()}get ssr(){return this.#Qr||(this.#Qr=new SSR(this.#zt.redGPUContext)),this.#Qr}get postEffectSystemUniformBuffer(){return this.#Kr}get view(){return this.#zt}get effectList(){return this.#Ar}get videoMemorySize(){return this.#pr(),this.#N}addEffect(i){this.#Ar.push(i)}getEffectAt(i){return this.#Ar[i]}removeAllEffect(){this.#Ar.forEach(i=>{i.clear()}),this.#Ar.length=0}render(){const{viewRenderTextureManager:i,redGPUContext:g,taa:x,fxaa:_,toneMappingManager:v}=this.#zt,{antialiasingManager:b}=g,{useMSAA:y,useFXAA:S,useTAA:w}=b,{gBufferColorTextureView:L,gBufferColorResolveTextureView:k,gBufferColorTexture:z}=i,{width:H,height:q}=z,W=y?k:L;this.#ri(),this.#kr=this.#ii(this.#zt,W);let be={texture:this.#Gr,textureView:this.#kr};return be=v.render(H,q,be),this.#Ar.forEach(i=>{be=i.render(this.#zt,H,q,be)}),S&&(be=_.render(this.#zt,H,q,be)),this.#Jr&&(be=this.ssao.render(this.#zt,H,q,be)),this.#ei&&(be=this.ssr.render(this.#zt,H,q,be)),w&&("View3D"===this.#zt.constructor.name?(be=x.render(this.#zt,H,q,be),this.#Wr||(this.#Wr=new TAASharpen(g)),be=this.#Wr.render(this.#zt,H,q,be)):be=_.render(this.#zt,H,q,be)),be}clear(){this.#Ar.forEach(i=>{i.clear()})}#ti(){!this.#Zr&&this.#Jr&&(this.#Zr=new SSAO(this.#zt.redGPUContext))}#ni(){!this.#Qr&&this.#ei&&(this.#Qr=new SSR(this.#zt.redGPUContext))}#ai(i){i.forEach(({key:i,value:g,dataView:x,targetMembers:_})=>{const v=_[i];x.set("number"==typeof g?[g]:g,v.uniformOffset/v.View.BYTES_PER_ELEMENT)})}#ri(){const{inverseProjectionMatrix:i,projectionMatrix:g,rawCamera:x,redGPUContext:_,scene:v}=this.#zt,{gpuDevice:b}=_,{modelMatrix:y,position:S}=x,w=this.#Xr,L=this.#Kr.gpuBuffer,k=x instanceof Camera2D,z=multiply$4(Cr,g,y);{const{members:_}=w,v=_.camera.members;this.#ai([{key:"projectionMatrix",value:g,dataView:this.#Yr,targetMembers:_},{key:"inverseProjectionMatrix",value:i,dataView:this.#Yr,targetMembers:_},{key:"projectionCameraMatrix",value:z,dataView:this.#Yr,targetMembers:_},{key:"inverseProjectionCameraMatrix",value:invert$1(Pr,z),dataView:this.#Yr,targetMembers:_},{key:"cameraMatrix",value:y,dataView:this.#Yr,targetMembers:v},{key:"inverseCameraMatrix",value:invert$1(Pr,y),dataView:this.#Yr,targetMembers:v},{key:"cameraPosition",value:S,dataView:this.#Yr,targetMembers:v},{key:"nearClipping",value:k?0:x.nearClipping,dataView:this.#Yr,targetMembers:v},{key:"farClipping",value:k?0:x.farClipping,dataView:this.#Yr,targetMembers:v},{key:"fieldOfView",value:x.fieldOfView*Math.PI/180,dataView:this.#Yr,targetMembers:v}])}b.queue.writeBuffer(L,0,this.#jr)}#ne(){const{redGPUContext:i}=this.#zt,{gpuDevice:g,resourceManager:x}=i,_=this.#si();this.#Vr=x.createGPUShaderModule("POST_EFFECT_TEXTURE_COPY_COMPUTE_SHADER",{code:_}),this.#zr=this.#oi(i),this.#Hr=this.#ui(g,this.#Vr,this.#zr);const v=parseWGSL(tr).uniforms.systemUniforms,b=new ArrayBuffer(v.arrayBufferByteLength);this.#Xr=v,this.#Kr=new UniformBuffer(i,b,`${this.#zt.name}_POST_EFFECT_SYSTEM_UNIFORM_BUFFER`),this.#jr=new ArrayBuffer(this.#Xr.endOffset),this.#Yr=new Float32Array(this.#jr),this.#qr=new Uint32Array(this.#jr)}#pr(){const i=this.#Gr;if(!i)return 0;this.#N=calculateTextureByteSize(i),this.#Ar.forEach(i=>{this.#N+=i.videoMemorySize})}#ii(i,g){const{redGPUContext:x,viewRenderTextureManager:_}=i,{gBufferColorTexture:v}=_,{gpuDevice:b,antialiasingManager:y,resourceManager:S}=x,{useMSAA:w,changedMSAA:L}=y,{width:k,height:z}=v,H=k!==this.#$r?.width||z!==this.#$r?.height;return H&&(this.#Gr&&(this.#Gr.destroy(),this.#Gr=null),this.#Gr=this.#li(b,k,z),this.#Or=S.getGPUResourceBitmapTextureView(this.#Gr)),(H||L)&&(this.#Fr=this.#ci(x,this.#zr,g,this.#Or)),this.#$r={width:k,height:z},this.#hi(b,this.#Hr,this.#Fr,k,z),this.#Or}#si(){return`\n\t @group(0) @binding(0) var sourceTextureSampler:sampler; @group(0) @binding(1) var sourceTexture:texture_2d<f32>; @group(0) @binding(2) var outputTexture:texture_storage_2d<rgba16float,write>;  @compute @workgroup_size(${this.#me},${this.#pe},${this.#Nr}) fn main ( @builtin(global_invocation_id) global_id:vec3<u32>, ){ let index=vec2<u32>(global_id.xy ); let dimensions:vec2<u32>=textureDimensions(sourceTexture); let dimW=f32(dimensions.x); let dimH=f32(dimensions.y); let uv=\tvec2<f32>((f32(index.x)+0.5)/dimW,(f32(index.y)+0.5)/dimH); var color:vec4<f32>=textureSampleLevel( sourceTexture, sourceTextureSampler, uv, 0 );  textureStore(outputTexture,index,color ); }; `}#oi(i){return i.resourceManager.createBindGroupLayout(`${this.#zt.name}_POST_EFFECT_TEXTURE_COPY_BIND_GROUP_LAYOUT`,{entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,sampler:{type:"filtering"}},{binding:1,visibility:GPUShaderStage.COMPUTE,texture:{}},{binding:2,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba16float"}}]})}#li(i,g,x){return this.#zt.redGPUContext.resourceManager.createManagedTexture({size:{width:g,height:x},format:"rgba16float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC,label:`${this.#zt.name}_POST_EFFECT_STORAGE_TEXTURE_${g}x${x}`})}#ci(i,g,x,_){const v=Date.now();return i.gpuDevice.createBindGroup({label:`${this.#zt.name}_POST_EFFECT_TEXTURE_COPY_BIND_GROUP_${v}`,layout:g,entries:[{binding:0,resource:new Sampler(i).gpuSampler},{binding:1,resource:x},{binding:2,resource:_}]})}#ui(i,g,x){return i.createComputePipeline({label:"POST_EFFECT_TEXTURE_COPY_COMPUTE_PIPELINE",layout:i.createPipelineLayout({label:"POST_EFFECT_TEXTURE_COPY_PIPELINE_LAYOUT",bindGroupLayouts:[x]}),compute:{module:g,entryPoint:"main"}})}#hi(i,g,x,_,v){const b=i.createCommandEncoder({label:"POST_EFFECT_TEXTURE_COPY_COMMAND_ENCODER"}),y=b.beginComputePass({label:"POST_EFFECT_TEXTURE_COPY_COMPUTE_PASS"});y.setPipeline(g),y.setBindGroup(0,x),y.dispatchWorkgroups(Math.ceil(_/this.#me),Math.ceil(v/this.#pe)),y.end(),i.queue.submit([b.finish()])}}let Cr=create$4(),Pr=create$4();function defineProperty_boolean(i,g=!1){return defineBoolean(i,g,!1)}function defineProperty_uintRange(i,g=0,x,_){return defineUintRange(i,g,!1,x,_)}function defineProperty_PositiveNumberRange(i,g=1,x,_){return definePositiveNumberRange(i,g,!1,x,_)}Object.freeze(PostEffectManager);const Rr={USE_BILLBOARD:"useBillboard",RECEIVE_SHADOW:"receiveShadow"},Br={},Ir={},Er={...createDefineByPreset({defineBoolean:[defineProperty_boolean,Rr],defineUint:[defineProperty_uintRange,Ir],definePositiveNumber:[defineProperty_PositiveNumberRange,Br]}),defineBoolean:defineProperties(defineProperty_boolean),defineUint:defineProperties(defineProperty_uintRange),definePositiveNumber:defineProperties(defineProperty_PositiveNumberRange),defineVec4:defineProperties(function(i,g=[0,0,0,0]){return defineVector(i,g,!1)}),defineVec3:defineProperties(function(i,g=[0,0,0]){return defineVector(i,g,!1)}),defineVec2:defineProperties(function(i,g=[0,0]){return defineVector(i,g,!1)}),PRESET_BOOLEAN:Rr,PRESET_POSITIVE_NUMBER:Br,PRESET_UINT:Ir,PRESET_SAMPLER:{},PRESET_TEXTURE:{},PRESET_CUBE_TEXTURE:{},PRESET_VEC2:{},PRESET_VEC3:{},PRESET_VEC4:{},PRESET_COLOR_RGB:{}};Object.freeze(Er);class GeometryGPURenderInfo{buffers;constructor(i){this.buffers=i}}Object.freeze(GeometryGPURenderInfo);class AABB{minX;maxX;minY;maxY;minZ;maxZ;centerX;centerY;centerZ;xSize;ySize;zSize;geometryRadius;constructor(i,g,x,_,v,b){this.minX=i,this.maxX=g,this.minY=x,this.maxY=_,this.minZ=v,this.maxZ=b,this.centerX=(g+i)/2,this.centerY=(_+x)/2,this.centerZ=(b+v)/2,this.xSize=g-i,this.ySize=_-x,this.zSize=b-v,this.geometryRadius=Math.sqrt((this.xSize/2)**2+(this.ySize/2)**2+(this.zSize/2)**2)}intersects(i){return i instanceof AABB||consoleAndThrowError("allow only AABB instance"),this.minX<=i.maxX&&this.maxX>=i.minX&&this.minY<=i.maxY&&this.maxY>=i.minY&&this.minZ<=i.maxZ&&this.maxZ>=i.minZ}contains(i,g,x){if(Array.isArray(i)){const[g,x,_]=i;return g>=this.minX&&g<=this.maxX&&x>=this.minY&&x<=this.maxY&&_>=this.minZ&&_<=this.maxZ}return i>=this.minX&&i<=this.maxX&&g>=this.minY&&g<=this.maxY&&x>=this.minZ&&x<=this.maxZ}clone(){return new AABB(this.minX,this.maxX,this.minY,this.maxY,this.minZ,this.maxZ)}}const calculateGeometryAABB=i=>{if(!i||!i.data||0===i.vertexCount)return new AABB(0,0,0,0,0,0);const g=i.stride,x=i.data,_=i.vertexCount;let v=1/0,b=1/0,y=1/0,S=-1/0,w=-1/0,L=-1/0,k=0;for(;k<=_-4;k+=4){let i=k*g;const _=x[i],z=x[i+1],H=x[i+2];i=(k+1)*g;const q=x[i],W=x[i+1],be=x[i+2];i=(k+2)*g;const Ke=x[i],Xe=x[i+1],je=x[i+2];i=(k+3)*g;const Ye=x[i],Ze=x[i+1],Je=x[i+2];_<v&&(v=_),q<v&&(v=q),Ke<v&&(v=Ke),Ye<v&&(v=Ye),_>S&&(S=_),q>S&&(S=q),Ke>S&&(S=Ke),Ye>S&&(S=Ye),z<b&&(b=z),W<b&&(b=W),Xe<b&&(b=Xe),Ze<b&&(b=Ze),z>w&&(w=z),W>w&&(w=W),Xe>w&&(w=Xe),Ze>w&&(w=Ze),H<y&&(y=H),be<y&&(y=be),je<y&&(y=je),Je<y&&(y=Je),H>L&&(L=H),be>L&&(L=be),je>L&&(L=je),Je>L&&(L=Je)}for(;k<_;k++){const i=k*g,_=x[i],z=x[i+1],H=x[i+2];_<v&&(v=_),z<b&&(b=z),H<y&&(y=H),_>S&&(S=_),z>w&&(w=z),H>L&&(L=H)}return new AABB(v,S,b,w,y,L)};class Geometry extends ResourceBase{gpuRenderInfo;#fi;#di;#mi;constructor(i,g,x){super(i),this.#pi(g),this.#gi(x);const{interleavedStruct:_}=this.#fi;this.gpuRenderInfo=new GeometryGPURenderInfo([{arrayStride:_.arrayStride,attributes:_.attributes}])}get vertexBuffer(){return this.#fi}get indexBuffer(){return this.#di}get volume(){return this.#mi||(this.#mi=calculateGeometryAABB(this.#fi)),this.#mi}#pi(i){const g=this.#fi;this.#fi=i,g&&g.__removeDirtyPipelineListener(this.#xi),i&&i.__addDirtyPipelineListener(this.#xi),this.#mi=null}#gi(i){const g=this.#di;this.#di=i,g&&g.__removeDirtyPipelineListener(this.#_i),i&&i.__addDirtyPipelineListener(this.#_i)}#xi(){this.__fireListenerList()}#_i(){this.__fireListenerList()}}Object.freeze(Geometry);const Dr={UINT16:"uint16",UINT32:"uint32"};Object.freeze(Dr);class ResourceStateIndexBuffer{static dirtyList=[];buffer;label;uuid;#Zt=0;constructor(i){this.buffer=i,this.label=i.name,this.uuid=i.uuid}get useNum(){return this.#Zt}set useNum(i){this.#Zt=i,ResourceStateIndexBuffer.dirtyList.push(this)}}class IndexBuffer extends ABaseBuffer{[Zn];#vi=0;#bi=0;#F=Dr.UINT32;constructor(i,g,x=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,_=""){super(i,"managedIndexBufferState",x);const{table:v}=this.targetResourceManagedState,b=v.get(_);if(b)return b.buffer;_&&(this.name=_,this[er]=_),this.changeData(g),this.redGPUContext.resourceManager.registerManagementResource(this,new ResourceStateIndexBuffer(this))}get format(){return this.#F}get triangleCount(){return this.#bi}get indexCount(){return this.#vi}get data(){return this[Zn]}changeData(i){const{gpuDevice:g}=this;if(Array.isArray(i)&&(i=new Uint32Array(i)),this[Wn]){this.targetResourceManagedState.videoMemory-=this[Zn].byteLength||0;let i=this[Wn];requestAnimationFrame(()=>{i.destroy()}),this[Wn]=null}this[Zn]=i,this.#vi=i.length;const x={size:this[Zn].byteLength,usage:this.usage,label:this.name};this[Wn]=g.createBuffer(x),this.targetResourceManagedState.videoMemory+=this[Zn].byteLength||0,this.#bi=this.#vi/3,g.queue.writeBuffer(this[Wn],0,this[Zn])}}Object.freeze(IndexBuffer);class ResourceStateVertexBuffer{static dirtyList=[];buffer;label;uuid;#Zt=0;constructor(i){this.buffer=i,this.label=i.name,this.uuid=i.uuid}get useNum(){return this.#Zt}set useNum(i){this.#Zt=i,ResourceStateVertexBuffer.dirtyList.push(this)}}class VertexBuffer extends ABaseBuffer{[Zn];#yi=0;#Si=0;#Ti;#bi=0;constructor(i,g,x,_=GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE,v=""){super(i,"managedVertexBufferState",_);const{table:b}=this.targetResourceManagedState,y=b.get(v);if(y)return y.buffer;this.#Ti=x,v&&(this.name=v,this[er]=v),this.changeData(g,this.#Ti),this.redGPUContext.resourceManager.registerManagementResource(this,new ResourceStateVertexBuffer(this))}get data(){return this[Zn]}get stride(){return this.#Si}get interleavedStruct(){return this.#Ti}get vertexCount(){return this.#yi}get triangleCount(){return this.#bi}changeData(i,g){const{gpuDevice:x}=this;if(Array.isArray(i)&&(i=new Float32Array(i)),this[Zn]=i,g&&this.#Mi(g),this[Wn]){this.targetResourceManagedState.videoMemory-=this[Zn].byteLength||0;let i=this[Wn];requestAnimationFrame(()=>{i.destroy()}),this[Wn]=null}const _={size:this[Zn].byteLength,usage:this.usage,label:this.name};this[Wn]=x.createBuffer(_),this.targetResourceManagedState.videoMemory+=this[Zn].byteLength||0,this.#bi=this[Zn].length/this.#Si,x.queue.writeBuffer(this[Wn],0,this[Zn])}updateData(i,g=0){i instanceof Array&&(i=new Float32Array(i));const{gpuDevice:x}=this;x.queue.writeBuffer(this[Wn],g,i)}updateAllData(i){const{gpuDevice:g}=this;g.queue.writeBuffer(this[Wn],0,this[Zn])}#Mi(i){this.#Ti=i,this.#yi=0,this.#Si=0;for(const i in this.#Ti.define){const g=this.#Ti.define[i].attributeStride/Float32Array.BYTES_PER_ELEMENT;this.#yi+=g,this.#Si+=g}this.#yi=this[Zn].length/this.#yi}}Object.freeze(VertexBuffer);class VertexInterleavedStructElement{attributeName;attributeStride;interleaveType;constructor(i,g,x){this.attributeName=i,this.attributeStride=g,this.interleaveType=x}}class VertexInterleavedStruct{#wi;#h="";#Ci=[];#Pi=0;constructor(i,g=""){this.#h=g,this.#Ri(i),this.#Bi()}get label(){return this.#h}get attributes(){return this.#Ci}get arrayStride(){return this.#Pi}get define(){return{...this.#wi}}#Ri(i){let g={};for(const x in i){const _=i[x],v=_.stride;g[x]=new VertexInterleavedStructElement(x,v,_),v%4!=0&&consoleAndThrowError(`Invalid attribute stride:${v}`)}this.#wi=g}#Bi(){this.#Pi=0,this.#Ci=[];for(const[i,{attributeStride:g,interleaveType:x}]of Object.entries(this.#wi))this.#Ci.push({attributeName:i,shaderLocation:this.#Ci.length,offset:this.#Pi,format:x.gpuVertexFormat}),this.#Pi+=g}}class VertexInterleaveType{static get float32(){return{numElements:1,stride:Float32Array.BYTES_PER_ELEMENT,gpuVertexFormat:"float32",offset:0}}static get float32x2(){return{numElements:2,stride:2*Float32Array.BYTES_PER_ELEMENT,gpuVertexFormat:"float32x2",offset:0}}static get float32x3(){return{numElements:3,stride:3*Float32Array.BYTES_PER_ELEMENT,gpuVertexFormat:"float32x3",offset:0}}static get float32x4(){return{numElements:4,stride:4*Float32Array.BYTES_PER_ELEMENT,gpuVertexFormat:"float32x4",offset:0}}}Object.freeze(VertexInterleaveType);class Primitive{#Ii;#fi;#di;#mi;constructor(i){validateRedGPUContext(i)}static get primitiveInterleaveStruct(){return new VertexInterleavedStruct({vertexPosition:VertexInterleaveType.float32x3,vertexNormal:VertexInterleaveType.float32x3,texcoord:VertexInterleaveType.float32x2},"primitiveInterleaveStruct")}get gpuRenderInfo(){return this.#Ii}get vertexBuffer(){return this.#fi}get indexBuffer(){return this.#di}get volume(){return this.#mi||(this.#mi=calculateGeometryAABB(this.#fi)),this.#mi}_setData(i){if(this.#fi=i.vertexBuffer,this.#di=i.indexBuffer,this.#fi){const{interleavedStruct:i}=this.#fi;this.#Ii=new GeometryGPURenderInfo([{arrayStride:i.arrayStride,attributes:i.attributes}])}}}Object.freeze(Primitive);const createPrimitiveGeometry=(i,g,x,_)=>new Geometry(i,new VertexBuffer(i,new Float32Array(g),Primitive.primitiveInterleaveStruct,void 0,`VertexBuffer_${_}`),new IndexBuffer(i,new Uint32Array(x),void 0,`IndexBuffer_${_}`));class Plane extends Primitive{#Ei=function(){const i=[],g=[];return function(x,_,v,b,y,S,w,L){const k=v/2,z=b/2,H=Math.floor(y)||1,q=Math.floor(S)||1,W=H+1,be=q+1,Ke=v/H,Xe=b/q;i.length=0,g.length=0;for(let x=0;x<be;x++){const _=x*Xe-z,v=L?(1-x/q)*w:x/q*w;for(let b=0;b<W;b++){const y=b*Ke-k,S=b/H*w;if(i.push(y,-_,0,0,0,1,S,v),x<q&&b<H){const i=b+W*x,_=b+W*(x+1),v=b+1+W*(x+1),y=b+1+W*x;g.push(i,_,y),g.push(_,v,y)}}}return createPrimitiveGeometry(_,i,g,x)}}();constructor(i,g=1,x=1,_=1,v=1,b=1,y=!1){super(i);const S=`PRIMITIVE_PLANE_W${g}_H${x}_WS${_}_HS${v}_UV${b}_FY${y}`,w=i.resourceManager.cachedBufferState;let L=w[S];L||(L=w[S]=this.#Ei(S,i,g,x,_,v,b,y)),this._setData(L)}}class PerspectiveCamera{#f;#Di=new Float32Array([0,1,0]);#Ot=create$4();#Nt=0;#Ft=0;#Vt=0;#Ui=0;#Li=0;#Ai=0;#Gi=60;#ki=.01;#Oi=1e4;#h;constructor(){}get rotationX(){return this.#Ui}set rotationX(i){this.#Ui=i}get rotationY(){return this.#Li}set rotationY(i){this.#Li=i}get rotationZ(){return this.#Ai}set rotationZ(i){this.#Ai=i}get fieldOfView(){return this.#Gi}set fieldOfView(i){validateNumber(i),this.#Gi=i}get nearClipping(){return this.#ki}set nearClipping(i){validateNumber(i),this.#ki=i}get farClipping(){return this.#Oi}set farClipping(i){validateNumber(i),this.#Oi=i}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get modelMatrix(){return this.#Ot}get x(){return this.#Nt}set x(i){this.#Nt=i,this.#Ot[12]=i}get y(){return this.#Vt}set y(i){this.#Vt=i,this.#Ot[13]=i}get z(){return this.#Ft}set z(i){this.#Ft=i,this.#Ot[14]=i}get position(){return[this.#Nt,this.#Vt,this.#Ft]}setPosition(i,g,x){Array.isArray(i)?[this.#Nt,this.#Vt,this.#Ft]=i:(this.#Nt=i,this.#Vt=g,this.#Ft=x),[this.#Ot[12],this.#Ot[13],this.#Ot[14]]=[this.#Nt,this.#Vt,this.#Ft]}lookAt(i,g,x){const _=[this.#Nt,this.#Vt,this.#Ft],v=[i,g,x],b=[this.#Di[0],this.#Di[1],this.#Di[2]],y=[v[0]-_[0],v[1]-_[1],v[2]-_[2]],S=Math.sqrt(y[0]*y[0]+y[1]*y[1]+y[2]*y[2]);y[0]/=S,y[1]/=S,y[2]/=S;const w=[y[1]*b[2]-y[2]*b[1],y[2]*b[0]-y[0]*b[2],y[0]*b[1]-y[1]*b[0]];Math.sqrt(w[0]*w[0]+w[1]*w[1]+w[2]*w[2])<1e-4&&(b[2]=y[1]>0?1:-1,b[0]=0,b[1]=0),lookAt(this.#Ot,_,v,b)}}class OrthographicCamera extends PerspectiveCamera{#f;#h;#Ni=1;#Vi=-1;#Fi=-1;#zi=1;#Hi=1;#$i=.1;#Ki=10;constructor(){super(),this.nearClipping=.01,this.farClipping=1e4}get top(){return this.#Ni}set top(i){validateNumber(i),this.#Ni=i}get bottom(){return this.#Vi}set bottom(i){validateNumber(i),this.#Vi=i}get left(){return this.#Fi}set left(i){validateNumber(i),this.#Fi=i}get right(){return this.#zi}set right(i){validateNumber(i),this.#zi=i}get zoom(){return this.#Hi}set zoom(i){validateNumberRange(i,this.#$i,this.#Ki),this.#Hi=i}get minZoom(){return this.#$i}set minZoom(i){validateNumberRange(i,.01),this.#$i=i}get maxZoom(){return this.#Ki}set maxZoom(i){validateNumberRange(i,.01),this.#Ki=i}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}setZoom(i){this.zoom=i}}class AController{static#Xi=null;static#ji=null;#f;#h;#l;#Yi;#qi;#Wi=-1;#Zi=0;#Ji=new Set;#Qi=!1;#ea=null;#ta=!1;#na;#ra=0;#ia=0;#aa=0;#sa=!1;constructor(i,g){this.#l=i,this.#qi=g||{},this.#Yi=g.camera||new PerspectiveCamera;const x=this.#l.detector.isMobile;this.#na={moveKey:x?"touchmove":"mousemove",upKey:x?"touchend":"mouseup",downKey:x?"touchstart":"mousedown"},this.#oa()}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get redGPUContext(){return this.#l}get camera(){return this.#Yi}get x(){return this.camera.x}get y(){return this.camera.y}get z(){return this.camera.z}get hoveredView(){return this.#ea}get keyboardActiveView(){return AController.#Xi}set keyboardActiveView(i){AController.#Xi=i,AController.#ji=null===i?null:this}get isKeyboardActiveController(){return AController.#ji===this}get keyboardProcessedThisFrame(){return this.#Qi}set keyboardProcessedThisFrame(i){this.#Qi=i}destroy(){const{moveKey:i,upKey:g,downKey:x}=this.#na,{htmlCanvas:_}=this.redGPUContext;_.removeEventListener(x,this.#ua),_.removeEventListener(i,this.#la),_.removeEventListener(i,this.#ca),window.removeEventListener(g,this.#ha),this.#qi.HD_Wheel&&_.removeEventListener("wheel",this.#fa)}update(i,g,x){this.#Wi!==g&&(this.#Zi=-1===this.#Wi?0:(g-this.#Wi)/1e3,this.#Wi=g,this.#Ji.clear(),this.#Qi=!1),this.#Ji.has(i)||(this.#Ji.add(i),this.#qi.useKeyboard&&this.keyboardActiveView&&this.keyboardActiveView!==i||x?.(this.#Zi))}checkKeyboardInput(i,g){if(this.keyboardProcessedThisFrame)return!1;const{keyboardKeyBuffer:x}=i.redGPUContext;let _=!1;for(const i in g)if(x[g[i]]){_=!0;break}if(!_)return this.keyboardActiveView=null,!1;if(!this.keyboardActiveView){if(this.hoveredView!==i)return!1;this.keyboardActiveView=i}return this.keyboardActiveView===i&&(this.keyboardProcessedThisFrame=!0,!0)}getCanvasEventPoint=(i,g)=>{g.htmlCanvas;const x=g.detector.isMobile,_=g.boundingClientRect,v="clientX",b="clientY";let y,S;if(x){const g=i instanceof WheelEvent?i:i.changedTouches[0];y=g[v],S=g[b]}else{const g=i;y=g[v],S=g[b]}return{x:y-_.left,y:S-_.top}};findTargetViewByInputEvent=i=>{const g=this.#l;g.detector.isMobile;const{x:x,y:_}=this.getCanvasEventPoint(i,g),v=window.devicePixelRatio*g.renderScale,b=x*v,y=_*v;let S=null;for(const i of this.redGPUContext.viewList){const g=i.pixelRectObject;g.x<b&&b<g.x+g.width&&g.y<y&&y<g.y+g.height&&(S=i)}return S};#da=i=>{if(i.length<2)return 0;const g=i[0].clientX-i[1].clientX,x=i[0].clientY-i[1].clientY;return Math.sqrt(g*g+x*x)};#oa(){const{redGPUContext:i}=this,{htmlCanvas:g}=i,{downKey:x,moveKey:_}=this.#na;g.addEventListener(x,this.#ua),g.addEventListener(_,this.#la),this.#qi.HD_Wheel&&g.addEventListener("wheel",this.#fa,{passive:!1}),this.#qi.HD_TouchPinch&&g.addEventListener("touchmove",this.#ma,{passive:!1})}#la=i=>{AController.#Xi||this.#ta||(this.#ea=this.findTargetViewByInputEvent(i))};#ua=i=>{const g=this.findTargetViewByInputEvent(i);if(!g)return;AController.#Xi||this.#ta||(this.#ea=g);const{redGPUContext:x}=this,{moveKey:_,upKey:v}=this.#na,{x:b,y:y}=this.getCanvasEventPoint(i,x);this.#ra=b,this.#ia=y,i instanceof TouchEvent&&(i.touches.length>=2?(this.#sa=!0,this.#aa=this.#da(i.touches)):(this.#sa=!1,this.#aa=0)),this.#Ji.has(g)&&(this.#ta=!0,AController.#Xi=g,x.htmlCanvas.addEventListener(_,this.#ca),window.addEventListener(v,this.#ha))};#ca=i=>{if(i instanceof TouchEvent&&i.touches.length>=2)return void(this.#sa=!0);this.#sa=!1;const{x:g,y:x}=this.getCanvasEventPoint(i,this.#l),_=g-this.#ra,v=x-this.#ia;this.#ra=g,this.#ia=x,this.#qi.HD_Move?.(_,v)};#ma=i=>{if(i.touches.length<2||!this.#qi.HD_TouchPinch)return;if(!this.#sa)return;i.preventDefault();const g=this.#da(i.touches);if(0===this.#aa)return void(this.#aa=g);if(this.findTargetViewByInputEvent(i).rawCamera!==this.#Yi)return;const x=g/this.#aa;this.#qi.HD_TouchPinch?.(x),this.#aa=g};#ha=()=>{const{htmlCanvas:i}=this.#l,{moveKey:g,upKey:x}=this.#na;this.#sa=!1,this.#aa=0,this.#ta=!1,i.removeEventListener(g,this.#ca),window.removeEventListener(x,this.#ha)};#fa=i=>{const g=this.findTargetViewByInputEvent(i);g&&g.rawCamera===this.#Yi&&(i.stopPropagation(),i.preventDefault(),this.#qi.HD_Wheel?.(i))}}const Ur=Math.PI/180;class IsometricController extends AController{#pa=45;#ga=1;#xa=1;#_a=.1;#va=.1;#$i=.5;#Ki=3;#ba=15;#ya=15;#Sa=.1;#Ta=null;#Ma=0;#wa=0;#Ca=50;#Pa=.1;#Ra={moveUp:"w",moveDown:"s",moveLeft:"a",moveRight:"d"};#Ba=1;#Ia=.1;constructor(i){super(i,{camera:new OrthographicCamera,HD_Wheel:i=>{this.#xa-=i.deltaY/100*this.#va,this.#xa=Math.max(this.#$i,Math.min(this.#Ki,this.#xa))},HD_Move:(g,x)=>{if(!this.#Ta)return;const _=this.#pa*Ur,v=Math.cos(_),b=Math.sin(_),y=this.#ba/this.#ga/i.boundingClientRect.height,S=g*y,w=x*y,L=-S*v-w*b,k=-S*-b-w*v;this.#Ma+=L,this.#wa+=k},HD_TouchPinch:i=>{this.#xa/=i,this.#xa=Math.max(this.#$i,Math.min(this.#Ki,this.#xa))},useKeyboard:!0}),this.#Ta=new Mesh(i),this.#Ta.setIgnoreFrustumCullingRecursively(!0)}get zoom(){return this.#xa}set zoom(i){validateNumberRange(i),this.#xa=Math.max(this.#$i,Math.min(this.#Ki,i))}get zoomInterpolation(){return this.#_a}set zoomInterpolation(i){validateNumberRange(i,1e-4,1),this.#_a=i}get speedZoom(){return this.#va}set speedZoom(i){validateNumberRange(i,.01),this.#va=i}get minZoom(){return this.#$i}set minZoom(i){validateNumberRange(i,.01),this.#$i=i,this.zoom=this.#xa}get maxZoom(){return this.#Ki}set maxZoom(i){validateNumberRange(i,.01),this.#Ki=i,this.zoom=this.#xa}get viewHeight(){return this.#ya}set viewHeight(i){validateNumberRange(i,.1),this.#ya=i}get viewHeightInterpolation(){return this.#Sa}set viewHeightInterpolation(i){validateNumberRange(i,1e-4,1),this.#Sa=i}get moveSpeed(){return this.#Ca}set moveSpeed(i){validateNumberRange(i,.01),this.#Ca=i}get moveSpeedInterpolation(){return this.#Pa}set moveSpeedInterpolation(i){validateNumberRange(i,1e-4,1),this.#Pa=i}get mouseMoveSpeed(){return this.#Ba}set mouseMoveSpeed(i){validateNumberRange(i,.01),this.#Ba=i}get mouseMoveSpeedInterpolation(){return this.#Ia}set mouseMoveSpeedInterpolation(i){validateNumberRange(i,1e-4,1),this.#Ia=i}get keyNameMapper(){return{...this.#Ra}}get targetX(){return this.#Ta.x}get targetY(){return this.#Ta.y}get targetZ(){return this.#Ta.z}setMoveUpKey(i){this.#Ra.moveUp=i}setMoveDownKey(i){this.#Ra.moveDown=i}setMoveLeftKey(i){this.#Ra.moveLeft=i}setMoveRightKey(i){this.#Ra.moveRight=i}update(i,g){super.update(i,g,g=>{this.#Ea(i,g)})}#Ea(i,g){if(this.#Da(i,g),this.#ga=this.#xa+(this.#ga-this.#xa)*Math.pow(this.#_a,g),this.#ba=this.#ya+(this.#ba-this.#ya)*Math.pow(this.#Sa,g),!this.#Ta)return;const x=Math.pow(this.#Pa,g);this.#Ta.x=this.#Ma+(this.#Ta.x-this.#Ma)*x,this.#Ta.z=this.#wa+(this.#Ta.z-this.#wa)*x;const _=this.#Ta.position,v=this.#pa*Ur,{width:b,height:y}=i.pixelRectObject,S=b/y,w=this.#ba/this.#ga,L=w*S,k=this.#ba/15,z=15*k/this.#ga,H=12*k/this.#ga,q=_[0]+Math.cos(v)*z,W=_[1]+H,be=_[2]+Math.sin(v)*z;this.camera.setPosition(q,W,be),this.camera.lookAt(_[0],_[1],_[2]);const Ke=this.camera;Ke.left=-L/2,Ke.right=L/2,Ke.top=w/2,Ke.bottom=-w/2}#Da(i,g){if(!this.checkKeyboardInput(i,this.#Ra))return!1;if(!this.#Ta)return!1;const{keyboardKeyBuffer:x}=i.redGPUContext,_=this.#Ra,v=this.#Ca*g;let b=0,y=0,S=0,w=0;x[_.moveUp]&&(b=v),x[_.moveDown]&&(y=v),x[_.moveLeft]&&(S=v),x[_.moveRight]&&(w=v);const L=this.#pa*Ur,k=Math.cos(L),z=Math.sin(L),H=(y-b)*k+(w-S)*k,q=(y-b)*z+(w-S)*-z;return this.#Ma+=H,this.#wa+=q,!0}}class DrawBufferManager{static#Ua;static#La=5;#l;#Aa=[];#Ga=[];#ka;#Oa=0;#Na=0;#Va;#Fa=new Set;constructor(i){this.#l=i,this.#za()}static getInstance(i){return DrawBufferManager.#Ua||(DrawBufferManager.#Ua=new DrawBufferManager(i)),DrawBufferManager.#Ua}allocateDrawCommand(i){this.#Na>=this.#ka&&(this.#Oa=this.#Ha(),this.#Na=0),this.#Fa.add(this.#Oa);const g={bufferIndex:this.#Oa,commandOffset:this.#Na*DrawBufferManager.#La,buffer:this.#Aa[this.#Oa],dataArray:this.#Ga[this.#Oa]};return this.#Na++,g}setIndexedIndirectCommand(i,g,x=1,_=0,v=0,b=0){const y=i.commandOffset,S=i.dataArray;S[y]=g,S[y+1]=x,S[y+2]=_,S[y+3]=v,S[y+4]=b}setInstanceNum(i,g=0){const x=i.commandOffset;i.dataArray[x+1]=g}setIndirectCommand(i,g,x=1,_=0,v=0){const b=i.commandOffset,y=i.dataArray;y[b]=g,y[b+1]=x,y[b+2]=_,y[b+3]=v}updateSingleCommand(i){const g=this.#Aa[i.bufferIndex],x=this.#Ga[i.bufferIndex],_=DrawBufferManager.#La,v=4*i.commandOffset,b=_;this.#l.gpuDevice.queue.writeBuffer(g,v,x,i.commandOffset,b)}getTotalCommandCount(){let i=0;for(const g of this.#Fa)g===this.#Oa?i+=this.#Na:i+=this.#ka;return i}getMemoryUsage(){const i=this.#Aa.length,g=this.#Fa.size,x=i*this.#Va,_=g*this.#Va;return{totalBuffers:i,usedBuffers:g,maxCommandsPerBuffer:this.#ka,totalMemory:formatBytes(x),usedMemory:formatBytes(_),totalCommands:this.getTotalCommandCount()}}flushAllCommands(i){performance.now();for(const i of this.#Fa){const g=this.#Aa[i],x=this.#Ga[i],_=(i===this.#Oa?this.#Na:this.#ka)*DrawBufferManager.#La*4;this.#l.gpuDevice.queue.writeBuffer(g,0,x,0,_/4)}performance.now()}#za(){this.#$a(),this.#Ka()}#$a(){this.#l.gpuDevice.limits,this.#Va=Math.floor(.9*Math.min(268435456,134217728)),this.#ka=Math.floor(this.#Va/(4*DrawBufferManager.#La))}#Ka(){this.#Ha()}#Ha(){const i=this.#ka*DrawBufferManager.#La*4,g=this.#l.gpuDevice.createBuffer({size:i,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.COPY_DST,label:`DrawBuffer_${this.#Aa.length}`}),x=new Uint32Array(this.#ka*DrawBufferManager.#La);return this.#Aa.push(g),this.#Ga.push(x),this.#Aa.length-1}}create$3(),create$3();const calculateMeshAABB=i=>{if(!i||!i._geometry){const g=i.modelMatrix;return g[12],g[13],g[14],new AABB(0,0,0,0,0,0)}const g=i._geometry.volume,{minX:x,maxX:_,minY:v,maxY:b,minZ:y,maxZ:S}=g;let w=1/0,L=1/0,k=1/0,z=-1/0,H=-1/0,q=-1/0;const W=i.modelMatrix;for(let i=0;i<8;i++){const g=1&i?_:x,be=2&i?b:v,Ke=4&i?S:y,Xe=W[0]*g+W[4]*be+W[8]*Ke+W[12],je=W[1]*g+W[5]*be+W[9]*Ke+W[13],Ye=W[2]*g+W[6]*be+W[10]*Ke+W[14];Xe<w&&(w=Xe),je<L&&(L=je),Ye<k&&(k=Ye),Xe>z&&(z=Xe),je>H&&(H=je),Ye>q&&(q=Ye)}return new AABB(w,z,L,H,k,q)},calculateMeshCombinedAABB=i=>{const g=[];return collectRecursive(i,g),0===g.length?new AABB(0,0,0,0,0,0):calculateCombinedAABBFromAABBs(g)},collectRecursive=(i,g)=>{if(i._geometry){const x=i.boundingAABB;g.push(x)}if(i.children)for(let x=0;x<i.children.length;x++){const _=i.children[x];_ instanceof Mesh&&collectRecursive(_,g)}},calculateCombinedAABBFromAABBs=i=>{if(0===i.length)return new AABB(0,0,0,0,0,0);if(1===i.length)return i[0];let g=1/0,x=1/0,_=1/0,v=-1/0,b=-1/0,y=-1/0;for(let S=0;S<i.length;S++){const w=i[S];w.minX<g&&(g=w.minX),w.minY<x&&(x=w.minY),w.minZ<_&&(_=w.minZ),w.maxX>v&&(v=w.maxX),w.maxY>b&&(b=w.maxY),w.maxZ>y&&(y=w.maxZ)}return new AABB(g,v,x,b,_,y)};class OBB{centerX;centerY;centerZ;halfExtentX;halfExtentY;halfExtentZ;orientation;center;halfExtents;geometryRadius;constructor(i,g,x){this.centerX=i[0],this.centerY=i[1],this.centerZ=i[2],this.halfExtentX=g[0],this.halfExtentY=g[1],this.halfExtentZ=g[2],this.center=[this.centerX,this.centerY,this.centerZ],this.halfExtents=[this.halfExtentX,this.halfExtentY,this.halfExtentZ],this.orientation=clone$4(x),this.geometryRadius=Math.sqrt(this.halfExtentX**2+this.halfExtentY**2+this.halfExtentZ**2)}intersects(i){i instanceof OBB||consoleAndThrowError("allow only OBB instance");const g=subtract$2(create$3(),this.center,i.center);if(length$3(g)>this.geometryRadius+i.geometryRadius)return!1;const x=[...this.#Xa(),...i.#Xa()];for(const _ of x){const x=this.#ja(_),v=i.#ja(_);if(Math.abs(dot$3(g,_))>x+v)return!1}return!0}contains(i,g,x){let _;_=Array.isArray(i)?fromValues$3(i[0],i[1],i[2]):fromValues$3(i,g,x);const v=subtract$2(create$3(),_,this.center),b=this.#Xa();for(let i=0;i<3;i++){const g=dot$3(v,b[i]);if(Math.abs(g)>this.halfExtents[i])return!1}return!0}clone(){return new OBB([this.centerX,this.centerY,this.centerZ],[this.halfExtentX,this.halfExtentY,this.halfExtentZ],this.orientation)}#Xa(){return[fromValues$3(this.orientation[0],this.orientation[1],this.orientation[2]),fromValues$3(this.orientation[4],this.orientation[5],this.orientation[6]),fromValues$3(this.orientation[8],this.orientation[9],this.orientation[10])]}#ja(i){const g=this.#Xa();return Math.abs(dot$3(g[0],i))*this.halfExtentX+Math.abs(dot$3(g[1],i))*this.halfExtentY+Math.abs(dot$3(g[2],i))*this.halfExtentZ}}const calculateMeshOBB=i=>{if(!i||!i._geometry){const i=create$4();return new OBB([0,0,0],[0,0,0],i)}const g=i._geometry.volume;if(0===g.minX&&0===g.maxX&&0===g.minY&&0===g.maxY&&0===g.minZ&&0===g.maxZ){const i=create$4();return new OBB([0,0,0],[0,0,0],i)}const x=[g.centerX,g.centerY,g.centerZ],_=[(g.maxX-g.minX)/2,(g.maxY-g.minY)/2,(g.maxZ-g.minZ)/2],v=create$3();transformMat4$2(v,x,i.modelMatrix);const b=create$4();copy$4(b,i.modelMatrix),b[12]=0,b[13]=0,b[14]=0;const y=[create$3(),create$3(),create$3()],S=[0,0,0];for(let i=0;i<3;i++){const g=[0,0,0];g[i]=_[i],transformMat4$2(y[i],g,b),S[i]=length$3(y[i]),normalize$3(y[i],y[i])}const w=create$4();return w[0]=y[0][0],w[1]=y[0][1],w[2]=y[0][2],w[3]=0,w[4]=y[1][0],w[5]=y[1][1],w[6]=y[1][2],w[7]=0,w[8]=y[2][0],w[9]=y[2][1],w[10]=y[2][2],w[11]=0,w[12]=0,w[13]=0,w[14]=0,w[15]=1,new OBB([v[0],v[1],v[2]],S,w)},mat4ToEuler=(i,g,x)=>{g=g||[0,0,0],x=x||"XYZ";let _=i[0],v=i[4],b=i[8],y=i[1],S=i[5],w=i[9],L=i[2],k=i[6],z=i[10];return"XYZ"===x?(g[1]=Math.asin(clamp(b,-1,1)),Math.abs(b)<.99999?(g[0]=Math.atan2(-w,z),g[2]=Math.atan2(-v,_)):(g[0]=Math.atan2(k,S),g[2]=0)):"YXZ"===x?(g[0]=Math.asin(-clamp(w,-1,1)),Math.abs(w)<.99999?(g[1]=Math.atan2(b,z),g[2]=Math.atan2(y,S)):(g[1]=Math.atan2(-L,_),g[2]=0)):"ZXY"===x?(g[0]=Math.asin(clamp(k,-1,1)),Math.abs(k)<.99999?(g[1]=Math.atan2(-L,z),g[2]=Math.atan2(-v,S)):(g[1]=0,g[2]=Math.atan2(y,_))):"ZYX"===x?(g[1]=Math.asin(-clamp(L,-1,1)),Math.abs(L)<.99999?(g[0]=Math.atan2(k,z),g[2]=Math.atan2(y,_)):(g[0]=0,g[2]=Math.atan2(-v,S))):"YZX"===x?(g[2]=Math.asin(clamp(y,-1,1)),Math.abs(y)<.99999?(g[0]=Math.atan2(-w,S),g[1]=Math.atan2(-L,_)):(g[0]=0,g[1]=Math.atan2(b,z))):"XZY"===x&&(g[2]=Math.asin(-clamp(v,-1,1)),Math.abs(v)<.99999?(g[0]=Math.atan2(k,S),g[1]=Math.atan2(b,_)):(g[0]=Math.atan2(-w,z),g[1]=0)),g};let clamp=function(i,g,x){return Math.max(g,Math.min(x,i))};const Lr={POINT_LIST:"point-list",LINE_LIST:"line-list",LINE_STRIP:"line-strip",TRIANGLE_LIST:"triangle-list",TRIANGLE_STRIP:"triangle-strip"};Object.freeze(Lr);const Ar=parseWGSL("#redgpu_include drawPicking;\n#redgpu_include calcTintBlendMode;\n#redgpu_include FragmentOutput;\n#redgpu_include calculateMotionVector;\nstruct Uniforms { color:vec3<f32>, opacity:f32, useTint:u32, tint:vec4<f32>, tintBlendMode:u32,\n};\nstruct InputData { @builtin(position) position:vec4<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n}\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\n@fragment\nfn main(inputData:InputData) -> FragmentOutput { var output:FragmentOutput; var finalColor=vec4<f32>( uniforms.color.r,uniforms.color.g,uniforms.color.b,uniforms.opacity * inputData.combinedOpacity); #redgpu_if useTint finalColor=calcTintBlendMode(finalColor,uniforms.tintBlendMode,uniforms.tint); #redgpu_endIf if (finalColor.a==0.0) { discard; } output.color=finalColor; output.gBufferMotionVector=vec4<f32>(calculateMotionVector(inputData.currentClipPos,inputData.prevClipPos),0.0,1.0 ); return output;\n}\n");class ColorMaterial extends ABaseMaterial{constructor(i,g="#fff"){super(i,"COLOR_MATERIAL",Ar,2),this.initGPURenderInfos(),this.color.setColorByHEX(g)}}dr.defineByPreset(ColorMaterial,[dr.PRESET_COLOR_RGB.COLOR]),Object.freeze(ColorMaterial);class DrawDebuggerMesh{#l;#Ya;#fi;#qa;#Wa;#Za="AABB";#Ja;#Qa;#es=null;#ts=null;constructor(i,g){this.#l=i,this.#Ya=g;const x=this.#ns(i);this.#fi=x.vertexBuffer,this.#qa=new ColorMaterial(i),this.#qa.color.setColorByRGB(255,0,0),this.#Wa=new Mesh(i,x,this.#qa),this.#Wa.primitiveState.cullMode="none",this.#Wa.primitiveState.topology=Lr.LINE_LIST;const _=this.#ns(i);this.#Ja=new ColorMaterial(i),this.#Ja.color.setColorByRGB(0,255,0),this.#Qa=new Mesh(i,_,this.#Ja),this.#Qa.primitiveState.cullMode="none",this.#Qa.primitiveState.topology=Lr.LINE_LIST}get debugMode(){return this.#Za}set debugMode(i){this.#Za=i,"OBB"===i?this.#qa.color.setColorByRGB(255,0,0):"AABB"===i||"COMBINED_AABB"===i?this.#qa.color.setColorByRGB(0,255,0):"BOTH"===i&&(this.#qa.color.setColorByRGB(255,0,0),this.#Ja.color.setColorByRGB(0,255,0)),this.#es=null,this.#ts=null}render(i){if(!this.#Ya.enableDebugger)return;if("OBB"===this.#Za){const i=this.#Ya.boundingOBB;this.#rs(i)&&(this.#is(i,this.#fi),this.#as(i)),this.#Wa.setPosition(0,0,0),this.#Wa.setRotation(0,0,0),this.#Wa.setScale(1,1,1)}else if("AABB"===this.#Za||"COMBINED_AABB"===this.#Za){const i="COMBINED_AABB"===this.#Za?this.#Ya.combinedBoundingAABB:this.#Ya.boundingAABB;this.#ss(i)&&(this.#os(i,this.#fi),this.#us(i)),this.#Wa.setPosition(0,0,0),this.#Wa.setRotation(0,0,0),this.#Wa.setScale(1,1,1)}else if("BOTH"===this.#Za){const i=this.#Ya.boundingOBB,g=this.#Ya.boundingAABB;this.#rs(i)&&(this.#is(i,this.#fi),this.#as(i)),this.#Wa.setPosition(0,0,0),this.#Wa.setRotation(0,0,0),this.#Wa.setScale(1,1,1),this.#ss(g)&&(this.#os(g,this.#Qa.geometry.vertexBuffer),this.#us(g)),this.#Qa.setPosition(0,0,0),this.#Qa.setRotation(0,0,0),this.#Qa.setScale(1,1,1)}let g=!0,x=!0;{const{frustumPlanes:_}=i,v=_[0],b=_[1],y=_[2],S=_[3],w=_[4],L=_[5];{const i=this.#Ya.boundingAABB,x=i.centerX,_=i.centerY,k=i.centerZ,z=i.geometryRadius;(v[0]*x+v[1]*_+v[2]*k+v[3]<=-z||b[0]*x+b[1]*_+b[2]*k+b[3]<=-z||y[0]*x+y[1]*_+y[2]*k+y[3]<=-z||S[0]*x+S[1]*_+S[2]*k+S[3]<=-z||w[0]*x+w[1]*_+w[2]*k+w[3]<=-z||L[0]*x+L[1]*_+L[2]*k+L[3]<=-z)&&(g=!1)}{const i=this.#Ya.boundingOBB,g=i.centerX,_=i.centerY,k=i.centerZ,z=i.geometryRadius;(v[0]*g+v[1]*_+v[2]*k+v[3]<=-z||b[0]*g+b[1]*_+b[2]*k+b[3]<=-z||y[0]*g+y[1]*_+y[2]*k+y[3]<=-z||S[0]*g+S[1]*_+S[2]*k+S[3]<=-z||w[0]*g+w[1]*_+w[2]*k+w[3]<=-z||L[0]*g+L[1]*_+L[2]*k+L[3]<=-z)&&(x=!1)}}"OBB"===this.#Za?x&&this.#Wa.render(i):"AABB"===this.#Za||"COMBINED_AABB"===this.#Za?g&&this.#Wa.render(i):"BOTH"===this.#Za&&(x&&this.#Wa.render(i),g&&this.#Qa.render(i))}#ns(i){const g=new Float32Array(192),x=new VertexInterleavedStruct({vertexPosition:VertexInterleaveType.float32x3,vertexNormal:VertexInterleaveType.float32x3,texcoord:VertexInterleaveType.float32x2},`wireframeBoxStruct_${Math.random()}`),_=new VertexBuffer(i,g,x);return new Geometry(i,_)}#rs(i){if(!this.#es)return!0;const g=this.#es;return g.center[0]!==i.center[0]||g.center[1]!==i.center[1]||g.center[2]!==i.center[2]||g.halfExtents[0]!==i.halfExtents[0]||g.halfExtents[1]!==i.halfExtents[1]||g.halfExtents[2]!==i.halfExtents[2]||!this.#ls(g.orientation,i.orientation)}#ss(i){if(!this.#ts)return!0;const g=this.#ts;return g.minX!==i.minX||g.maxX!==i.maxX||g.minY!==i.minY||g.maxY!==i.maxY||g.minZ!==i.minZ||g.maxZ!==i.maxZ}#ls(i,g){if(i.length!==g.length)return!1;for(let x=0;x<i.length;x++)if(Math.abs(i[x]-g[x])>1e-4)return!1;return!0}#as(i){this.#es=new OBB(i.center,i.halfExtents,i.orientation)}#us(i){this.#ts=i.clone()}#is(i,g){const{center:x,halfExtents:_,orientation:v}=i,b=[[-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1],[-1,-1,1],[1,-1,1],[1,1,1],[-1,1,1]].map(i=>{const g=[i[0]*_[0],i[1]*_[1],i[2]*_[2]],b=[v[0]*g[0]+v[4]*g[1]+v[8]*g[2],v[1]*g[0]+v[5]*g[1]+v[9]*g[2],v[2]*g[0]+v[6]*g[1]+v[10]*g[2]];return[b[0]+x[0],b[1]+x[1],b[2]+x[2]]});this.#pi(b,g)}#os(i,g){const{minX:x,maxX:_,minY:v,maxY:b,minZ:y,maxZ:S}=i,w=[[x,v,y],[_,v,y],[_,b,y],[x,b,y],[x,v,S],[_,v,S],[_,b,S],[x,b,S]];this.#pi(w,g)}#pi(i,g){const x=g.data;let _=0;[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]].forEach(([g,v])=>{x[_++]=i[g][0],x[_++]=i[g][1],x[_++]=i[g][2],x[_++]=0,x[_++]=0,x[_++]=1,x[_++]=0,x[_++]=0,x[_++]=i[v][0],x[_++]=i[v][1],x[_++]=i[v][2],x[_++]=0,x[_++]=0,x[_++]=1,x[_++]=0,x[_++]=0}),g.updateAllData(x)}}Object.freeze(DrawDebuggerMesh);const Gr={MESH:"mesh",PARTICLE:"particle",INSTANCED_MESH:"instancedMesh"};Object.freeze(Gr);const createMeshVertexUniformBuffers=(i,g=!1)=>{const{gpuRenderInfo:x,redGPUContext:_}=i,{resourceManager:v}=_,b=v.getGPUBindGroupLayout(g?ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_SKIN:ResourceManager.PRESET_VERTEX_GPUBindGroupLayout),y=new ArrayBuffer(x.vertexUniformInfo.arrayBufferByteLength),S=new UniformBuffer(_,y,i.name);x.vertexBindGroupLayout=b,x.vertexUniformBuffer=S};const kr=[{textureList:["baseColorTexture"],vec4List:[["baseColorFactor",[1,1,1,1]]]},{textureList:["normalTexture"]},{textureList:["metallicRoughnessTexture"],positiveNumberList:["metallicFactor","roughnessFactor"]},{textureList:["emissiveTexture"],vec3List:["emissiveFactor"]},{textureList:["occlusionTexture"],positiveNumberList:["occlusionStrength"]},{extensionName:"KHR_materials_clearcoat",textureList:["KHR_clearcoatTexture","KHR_clearcoatNormalTexture","KHR_clearcoatRoughnessTexture"],positiveNumberList:[["KHR_clearcoatFactor",0],["KHR_clearcoatRoughnessFactor",0],"KHR_clearcoatNormalScale"]},{extensionName:"KHR_materials_sheen",textureList:["KHR_sheenColorTexture","KHR_sheenRoughnessTexture"],positiveNumberList:[["KHR_sheenRoughnessFactor",0]],vec3List:[["KHR_sheenColorFactor",[0,0,0]]]},{extensionName:"KHR_materials_specular",textureList:["KHR_specularTexture","KHR_specularColorTexture"],positiveNumberList:["KHR_specularFactor"],vec3List:[["KHR_specularColorFactor",[1,1,1]]]},{extensionName:"KHR_materials_transmission",textureList:["KHR_transmissionTexture"],positiveNumberList:[["KHR_transmissionFactor",0]]},{extensionName:"KHR_materials_volume",textureList:["KHR_thicknessTexture"],positiveNumberList:[["KHR_thicknessFactor",0],["KHR_attenuationDistance",1]],vec3List:[["KHR_attenuationColor",[1,1,1]]]},{extensionName:"KHR_materials_diffuse_transmission",textureList:["KHR_diffuseTransmissionTexture","KHR_diffuseTransmissionColorTexture"],positiveNumberList:[["KHR_diffuseTransmissionFactor",0]],vec3List:[["KHR_diffuseTransmissionColorFactor",[1,1,1]]]},{extensionName:"KHR_materials_anisotropy",textureList:["KHR_anisotropyTexture"],positiveNumberList:[["KHR_anisotropyStrength",0],["KHR_anisotropyRotation",0]]},{extensionName:"KHR_materials_iridescence",textureList:["KHR_iridescenceTexture","KHR_iridescenceThicknessTexture"],positiveNumberList:[["KHR_iridescenceFactor",0],["KHR_iridescenceIor",1.3],["KHR_iridescenceThicknessMinimum",100],["KHR_iridescenceThicknessMaximum",400]]}],Or=parseWGSL((i=>{const g=kr.map(i=>{const{textureList:g,positiveNumberList:x}=i,_=g?.map(i=>` use${i.charAt(0).toUpperCase()}${i.substring(1)}:u32, ${i}_texCoord_index:u32, use_${i}_KHR_texture_transform:u32, ${i}_KHR_texture_transform_offset:vec2<f32>, ${i}_KHR_texture_transform_scale:vec2<f32>, ${i}_KHR_texture_transform_rotation:f32,`).join("");return[_].join("\n")}).join("");return i.replace(/#redgpu_include KHR_texture_transform/g,g)})("#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include calcDirectionalShadowVisibility;\n#redgpu_include calcTintBlendMode;\n#redgpu_include normalFunctions;\n#redgpu_include drawPicking;\n#redgpu_include calcPrePathBackground\n#redgpu_include FragmentOutput\n#redgpu_include calculateMotionVector;\nstruct Uniforms { useVertexColor:u32, useCutOff:u32, cutOff:f32, alphaBlend:u32, doubleSided:u32, useVertexTangent:u32, opacity:f32, useTint:u32, tint:vec4<f32>, tintBlendMode:u32, baseColorFactor:vec4<f32>, emissiveFactor:vec3<f32>, emissiveStrength:f32, occlusionStrength:f32, metallicFactor:f32, roughnessFactor:f32, normalScale:f32, useKHR_materials_unlit:u32, KHR_materials_ior:f32, useKHR_materials_transmission:u32, KHR_transmissionFactor:f32, useKHR_materials_diffuse_transmission:u32, KHR_diffuseTransmissionFactor:f32, KHR_diffuseTransmissionColorFactor:vec3<f32>, KHR_dispersion:f32, useKHR_materials_volume:u32, KHR_thicknessFactor:f32, KHR_attenuationDistance:f32, KHR_attenuationColor:vec3<f32>, useKHR_materials_specular:u32, KHR_specularFactor:f32, KHR_specularColorFactor:vec3<f32>, useKHR_materials_anisotropy:u32, KHR_anisotropyStrength:f32, KHR_anisotropyRotation:f32, useKHR_materials_iridescence:u32, KHR_iridescenceFactor:f32, KHR_iridescenceIor:f32, KHR_iridescenceThicknessMinimum:f32, KHR_iridescenceThicknessMaximum:f32, useKHR_materials_sheen:u32, KHR_sheenColorFactor:vec3<f32>, KHR_sheenRoughnessFactor:f32, useKHR_materials_clearcoat:u32, KHR_clearcoatFactor:f32, KHR_clearcoatRoughnessFactor:f32, KHR_clearcoatNormalScale:f32, #redgpu_include KHR_texture_transform\n};\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\n@group(2) @binding(1) var baseColorTextureSampler:sampler;\n#redgpu_if baseColorTexture\n@group(2) @binding(2) var baseColorTexture:texture_2d<f32>;\n#redgpu_endIf\n#redgpu_if emissiveTexture\n@group(2) @binding(3) var emissiveTextureSampler:sampler;\n@group(2) @binding(4) var emissiveTexture:texture_2d<f32>;\n#redgpu_endIf\n#redgpu_if normalTexture\n@group(2) @binding(5) var normalTextureSampler:sampler;\n@group(2) @binding(6) var normalTexture:texture_2d<f32>;\n#redgpu_endIf\n#redgpu_if packedORMTexture\n@group(2) @binding(7) var packedORMTexture:texture_2d<f32>;\n#redgpu_endIf\n#redgpu_if useKHR_materials_specular\n@group(2) @binding(8) var KHR_specularTextureSampler:sampler;\n@group(2) @binding(9) var KHR_specularTexture:texture_2d<f32>;\n@group(2) @binding(10) var KHR_specularColorTextureSampler:sampler;\n@group(2) @binding(11) var KHR_specularColorTexture:texture_2d<f32>;\n#redgpu_endIf\n@group(2) @binding(12) var KHR_clearcoatNormalTexture:texture_2d<f32>;\n@group(2) @binding(13) var packedKHR_clearcoatTexture_transmission:texture_2d<f32>;\n#redgpu_if useKHR_materials_diffuse_transmission\n@group(2) @binding(14) var packedKHR_diffuse_transmission:texture_2d<f32>;\n#redgpu_endIf\n#redgpu_if useKHR_materials_sheen\n@group(2) @binding(15) var packedKHR_sheen:texture_2d<f32>;\n#redgpu_endIf\n#redgpu_if useKHR_materials_anisotropy\n@group(2) @binding(16) var KHR_anisotropyTexture:texture_2d<f32>;\n#redgpu_endIf\n#redgpu_if useKHR_materials_iridescence\n@group(2) @binding(17) var packedKHR_iridescence:texture_2d<f32>;\n#redgpu_endIf\nstruct InputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(3) uv1:vec2<f32>, @location(4) vertexColor_0:vec4<f32>, @location(5) vertexTangent:vec4<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(10) localNodeScale_volumeScale:vec2<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(14) @interpolate(flat) receiveShadow:f32, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n}\n@fragment\nfn main(inputData:InputData) -> FragmentOutput { var output:FragmentOutput; let input_vertexNormal=(inputData.vertexNormal.xyz); let input_vertexPosition=inputData.vertexPosition.xyz; let input_vertexColor_0=inputData.vertexColor_0; let input_vertexTangent=inputData.vertexTangent; let input_ndcPosition=inputData.position.xyz/inputData.position.w; let input_uv=inputData.uv; let input_uv1=inputData.uv1; let u_ambientLight=systemUniforms.ambientLight; let u_ambientLightColor=u_ambientLight.color; let u_ambientLightIntensity=u_ambientLight.intensity; let u_directionalLightCount=systemUniforms.directionalLightCount; let u_directionalLights=systemUniforms.directionalLights; let u_shadowDepthTextureSize=systemUniforms.shadowDepthTextureSize; let u_bias=systemUniforms.bias; let u_usePrefilterTexture=systemUniforms.usePrefilterTexture==1u; let receiveShadowYn=inputData.receiveShadow !=.0; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_opacity=uniforms.opacity; let u_cutOff=uniforms.cutOff; let u_useVertexColor=uniforms.useVertexColor==1u; let u_useVertexTangent=uniforms.useVertexTangent==1u; let u_baseColorFactor=uniforms.baseColorFactor; let u_metallicFactor=uniforms.metallicFactor; let u_roughnessFactor=uniforms.roughnessFactor; let u_normalScale=uniforms.normalScale; let u_occlusionStrength=uniforms.occlusionStrength; let u_emissiveFactor=uniforms.emissiveFactor; let u_emissiveStrength=uniforms.emissiveStrength; let u_useKHR_materials_unlit=uniforms.useKHR_materials_unlit==1u; let u_KHR_materials_ior=uniforms.KHR_materials_ior; let u_KHR_dispersion=uniforms.KHR_dispersion; let u_KHR_transmissionFactor=uniforms.KHR_transmissionFactor; var u_useKHR_materials_volume=uniforms.useKHR_materials_volume==1u; var u_KHR_thicknessFactor=uniforms.KHR_thicknessFactor; var u_KHR_attenuationColor=uniforms.KHR_attenuationColor; var u_KHR_attenuationDistance=uniforms.KHR_attenuationDistance; let u_useKHR_materials_diffuse_transmission=uniforms.useKHR_materials_diffuse_transmission==1u; let u_KHR_diffuseTransmissionFactor=uniforms.KHR_diffuseTransmissionFactor; let u_KHR_diffuseTransmissionColorFactor=uniforms.KHR_diffuseTransmissionColorFactor; let u_KHR_specularFactor=uniforms.KHR_specularFactor; let u_KHR_specularColorFactor=uniforms.KHR_specularColorFactor; let u_KHR_anisotropyStrength=uniforms.KHR_anisotropyStrength; let u_KHR_anisotropyRotation=uniforms.KHR_anisotropyRotation; let u_useKHR_anisotropyTexture=uniforms.useKHR_anisotropyTexture==1u; let u_KHR_sheenColorFactor=uniforms.KHR_sheenColorFactor; let u_KHR_sheenRoughnessFactor=uniforms.KHR_sheenRoughnessFactor; let u_useKHR_materials_iridescence=uniforms.useKHR_materials_iridescence==1u; let u_KHR_iridescenceFactor=uniforms.KHR_iridescenceFactor; let u_KHR_iridescenceIor=uniforms.KHR_iridescenceIor; let u_KHR_iridescenceThicknessMinimum=uniforms.KHR_iridescenceThicknessMinimum; let u_KHR_iridescenceThicknessMaximum=uniforms.KHR_iridescenceThicknessMaximum; let u_KHR_clearcoatFactor=uniforms.KHR_clearcoatFactor; let u_KHR_clearcoatRoughnessFactor=uniforms.KHR_clearcoatRoughnessFactor; let u_KHR_clearcoatNormalScale=uniforms.KHR_clearcoatNormalScale; let diffuseUV=get_transformed_uv( input_uv,input_uv1, uniforms.baseColorTexture_texCoord_index, uniforms.use_baseColorTexture_KHR_texture_transform, uniforms.baseColorTexture_KHR_texture_transform_offset, uniforms.baseColorTexture_KHR_texture_transform_rotation, uniforms.baseColorTexture_KHR_texture_transform_scale ); let emissiveUV=get_transformed_uv( input_uv,input_uv1, uniforms.emissiveTexture_texCoord_index, uniforms.use_emissiveTexture_KHR_texture_transform, uniforms.emissiveTexture_KHR_texture_transform_offset, uniforms.emissiveTexture_KHR_texture_transform_rotation, uniforms.emissiveTexture_KHR_texture_transform_scale ); let occlusionUV=get_transformed_uv( input_uv,input_uv1, uniforms.occlusionTexture_texCoord_index, uniforms.use_occlusionTexture_KHR_texture_transform, uniforms.occlusionTexture_KHR_texture_transform_offset, uniforms.occlusionTexture_KHR_texture_transform_rotation, uniforms.occlusionTexture_KHR_texture_transform_scale ); let metallicRoughnessUV=get_transformed_uv( input_uv,input_uv1, uniforms.metallicRoughnessTexture_texCoord_index, uniforms.use_metallicRoughnessTexture_KHR_texture_transform, uniforms.metallicRoughnessTexture_KHR_texture_transform_offset, uniforms.metallicRoughnessTexture_KHR_texture_transform_rotation, uniforms.metallicRoughnessTexture_KHR_texture_transform_scale ); let normalUV=get_transformed_uv( input_uv,input_uv1, uniforms.normalTexture_texCoord_index, uniforms.use_normalTexture_KHR_texture_transform, uniforms.normalTexture_KHR_texture_transform_offset, uniforms.normalTexture_KHR_texture_transform_rotation, uniforms.normalTexture_KHR_texture_transform_scale ); let KHR_clearcoatUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_clearcoatTexture_texCoord_index, uniforms.use_KHR_clearcoatTexture_KHR_texture_transform, uniforms.KHR_clearcoatTexture_KHR_texture_transform_offset, uniforms.KHR_clearcoatTexture_KHR_texture_transform_rotation, uniforms.KHR_clearcoatTexture_KHR_texture_transform_scale ); #redgpu_if useKHR_materials_clearcoat let KHR_clearcoatNormalUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_clearcoatNormalTexture_texCoord_index, uniforms.use_KHR_clearcoatNormalTexture_KHR_texture_transform, uniforms.KHR_clearcoatNormalTexture_KHR_texture_transform_offset, uniforms.KHR_clearcoatNormalTexture_KHR_texture_transform_rotation, uniforms.KHR_clearcoatNormalTexture_KHR_texture_transform_scale ); #redgpu_endIf let KHR_clearcoatRoughnessUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_clearcoatRoughnessTexture_texCoord_index, uniforms.use_KHR_clearcoatRoughnessTexture_KHR_texture_transform, uniforms.KHR_clearcoatRoughnessTexture_KHR_texture_transform_offset, uniforms.KHR_clearcoatRoughnessTexture_KHR_texture_transform_rotation, uniforms.KHR_clearcoatRoughnessTexture_KHR_texture_transform_scale ); let KHR_sheenColorUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_sheenColorTexture_texCoord_index, uniforms.use_KHR_sheenColorTexture_KHR_texture_transform, uniforms.KHR_sheenColorTexture_KHR_texture_transform_offset, uniforms.KHR_sheenColorTexture_KHR_texture_transform_rotation, uniforms.KHR_sheenColorTexture_KHR_texture_transform_scale ); let KHR_sheenRoughnessUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_sheenRoughnessTexture_texCoord_index, uniforms.use_KHR_sheenRoughnessTexture_KHR_texture_transform, uniforms.KHR_sheenRoughnessTexture_KHR_texture_transform_offset, uniforms.KHR_sheenRoughnessTexture_KHR_texture_transform_rotation, uniforms.KHR_sheenRoughnessTexture_KHR_texture_transform_scale ); let KHR_specularTextureUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_specularTexture_texCoord_index, uniforms.use_KHR_specularTexture_KHR_texture_transform, uniforms.KHR_specularTexture_KHR_texture_transform_offset, uniforms.KHR_specularTexture_KHR_texture_transform_rotation, uniforms.KHR_specularTexture_KHR_texture_transform_scale ); let KHR_specularColorTextureUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_specularColorTexture_texCoord_index, uniforms.use_KHR_specularColorTexture_KHR_texture_transform, uniforms.KHR_specularColorTexture_KHR_texture_transform_offset, uniforms.KHR_specularColorTexture_KHR_texture_transform_rotation, uniforms.KHR_specularColorTexture_KHR_texture_transform_scale ); let KHR_iridescenceTextureUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_iridescenceTexture_texCoord_index, uniforms.use_KHR_iridescenceTexture_KHR_texture_transform, uniforms.KHR_iridescenceTexture_KHR_texture_transform_offset, uniforms.KHR_iridescenceTexture_KHR_texture_transform_rotation, uniforms.KHR_iridescenceTexture_KHR_texture_transform_scale ); let KHR_iridescenceThicknessTextureUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_iridescenceThicknessTexture_texCoord_index, uniforms.use_KHR_iridescenceThicknessTexture_KHR_texture_transform, uniforms.KHR_iridescenceThicknessTexture_KHR_texture_transform_offset, uniforms.KHR_iridescenceThicknessTexture_KHR_texture_transform_rotation, uniforms.KHR_iridescenceThicknessTexture_KHR_texture_transform_scale ); let KHR_transmissionUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_transmissionTexture_texCoord_index, uniforms.use_KHR_transmissionTexture_KHR_texture_transform, uniforms.KHR_transmissionTexture_KHR_texture_transform_offset, uniforms.KHR_transmissionTexture_KHR_texture_transform_rotation, uniforms.KHR_transmissionTexture_KHR_texture_transform_scale ); let KHR_diffuseTransmissionUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_diffuseTransmissionTexture_texCoord_index, uniforms.use_KHR_diffuseTransmissionTexture_KHR_texture_transform, uniforms.KHR_diffuseTransmissionTexture_KHR_texture_transform_offset, uniforms.KHR_diffuseTransmissionTexture_KHR_texture_transform_rotation, uniforms.KHR_diffuseTransmissionTexture_KHR_texture_transform_scale ); let KHR_diffuseTransmissionColorUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_diffuseTransmissionColorTexture_texCoord_index, uniforms.use_KHR_diffuseTransmissionColorTexture_KHR_texture_transform, uniforms.KHR_diffuseTransmissionColorTexture_KHR_texture_transform_offset, uniforms.KHR_diffuseTransmissionColorTexture_KHR_texture_transform_rotation, uniforms.KHR_diffuseTransmissionColorTexture_KHR_texture_transform_scale ); let KHR_anisotropyUV=get_transformed_uv( input_uv,input_uv1, uniforms.KHR_anisotropyTexture_texCoord_index, uniforms.use_KHR_anisotropyTexture_KHR_texture_transform, uniforms.KHR_anisotropyTexture_KHR_texture_transform_offset, uniforms.KHR_anisotropyTexture_KHR_texture_transform_rotation, uniforms.KHR_anisotropyTexture_KHR_texture_transform_scale ); var N:vec3<f32>=normalize(input_vertexNormal.xyz); var backFaceYn:bool=false; #redgpu_if doubleSided { var fdx:vec3<f32>=dpdx(input_vertexPosition); var fdy:vec3<f32>=dpdy(input_vertexPosition); var faceNormal:vec3<f32>=normalize(cross(fdy,fdx)); if (dot(N,faceNormal) < 0.0) { N=-N; backFaceYn=true; }; } #redgpu_endIf #redgpu_if normalTexture { var targetUv=select(normalUV,1.0 - normalUV,backFaceYn); let normalSamplerColor=textureSample(normalTexture,normalTextureSampler,normalUV).rgb; N=perturb_normal( N, input_vertexPosition, targetUv, vec3<f32>(normalSamplerColor.r,1.0 - normalSamplerColor.g,normalSamplerColor.b), u_normalScale ); N=select(N,select(N,-N,backFaceYn),u_useVertexTangent); } #redgpu_else { N=N * u_normalScale; } #redgpu_endIf let V:vec3<f32>=normalize(u_cameraPosition - input_vertexPosition); let NdotV=max(dot(N,V),0.04); let VdotN=max(dot(V,N),0.0); var visibility:f32=1.0; visibility=calcDirectionalShadowVisibility( directionalShadowMap, directionalShadowMapSampler, u_shadowDepthTextureSize, u_bias, inputData.shadowPos ); if(!receiveShadowYn){ visibility=1.0; } var finalColor:vec4<f32>; var ior:f32=u_KHR_materials_ior; var baseColor=u_baseColorFactor; var resultAlpha:f32=u_opacity * baseColor.a; baseColor *=select(vec4<f32>(1.0),input_vertexColor_0,u_useVertexColor); #redgpu_if baseColorTexture let diffuseSampleColor=(textureSample(baseColorTexture,baseColorTextureSampler,diffuseUV)); baseColor *=diffuseSampleColor; resultAlpha *=diffuseSampleColor.a; #redgpu_endIf let albedo:vec3<f32>=baseColor.rgb; #redgpu_if useKHR_materials_unlit if(u_useKHR_materials_unlit){ output.color=baseColor; return output; } #redgpu_endIf var occlusionParameter:f32=1; #redgpu_if useOcclusionTexture occlusionParameter=textureSample(packedORMTexture,packedTextureSampler,occlusionUV).r * u_occlusionStrength; #redgpu_endIf var metallicParameter:f32=u_metallicFactor; var roughnessParameter:f32=u_roughnessFactor; #redgpu_if useMetallicRoughnessTexture let metallicRoughnessSample=(textureSample(packedORMTexture,packedTextureSampler,metallicRoughnessUV)); metallicParameter=metallicRoughnessSample.b * metallicParameter; roughnessParameter=metallicRoughnessSample.g * roughnessParameter; #redgpu_endIf roughnessParameter=max(roughnessParameter,0.045); if (abs(ior - 1.0) < 0.0001) { roughnessParameter=0;} var clearcoatParameter=u_KHR_clearcoatFactor; var clearcoatRoughnessParameter=u_KHR_clearcoatRoughnessFactor; var clearcoatNormal:vec3<f32>=N; #redgpu_if useKHR_materials_clearcoat { if(clearcoatParameter !=0.0){ #redgpu_if useKHR_clearcoatTexture let clearcoatSample=textureSample(packedKHR_clearcoatTexture_transmission,packedTextureSampler,KHR_clearcoatUV); clearcoatParameter *=clearcoatSample.r; #redgpu_endIf #redgpu_if useKHR_clearcoatRoughnessTexture let clearcoatRoughnesstSample=textureSample(packedKHR_clearcoatTexture_transmission,packedTextureSampler,KHR_clearcoatRoughnessUV); clearcoatRoughnessParameter *=clearcoatRoughnesstSample.g; #redgpu_endIf var clearcoatNormalSampler=textureSample(KHR_clearcoatNormalTexture,baseColorTextureSampler,KHR_clearcoatNormalUV); #redgpu_if useKHR_clearcoatNormalTexture { var targetUv=KHR_clearcoatNormalUV; if(backFaceYn){ targetUv=1.0 - targetUv; } clearcoatNormal=clearcoatNormalSampler.rgb; clearcoatNormal=perturb_normal( N, input_vertexPosition, targetUv, clearcoatNormal, u_normalScale ); if(u_useVertexTangent){ if(backFaceYn ){ clearcoatNormal=-clearcoatNormal;} } clearcoatNormal=normalize(clearcoatNormal); } #redgpu_endIf } } #redgpu_endIf var specularParameter=u_KHR_specularFactor; var specularColor=u_KHR_specularColorFactor; #redgpu_if useKHR_materials_specular #redgpu_if KHR_specularColorTexture let specularColorTextureSample=textureSample( KHR_specularColorTexture, KHR_specularColorTextureSampler, KHR_specularColorTextureUV ); specularColor *=specularColorTextureSample.rgb; #redgpu_endIf #redgpu_if KHR_specularTexture let specularTextureSample=textureSample( KHR_specularTexture, KHR_specularTextureSampler, KHR_specularTextureUV ); specularParameter *=specularTextureSample.a; #redgpu_endIf #redgpu_endIf var transmissionParameter:f32=u_KHR_transmissionFactor; var thicknessParameter:f32=u_KHR_thicknessFactor; #redgpu_if useKHR_materials_transmission #redgpu_if useKHR_transmissionTexture let transmissionSample:vec4<f32>=textureSample( packedKHR_clearcoatTexture_transmission, packedTextureSampler, KHR_transmissionUV ); transmissionParameter *=transmissionSample.b; #redgpu_endIf #redgpu_if useKHR_thicknessTexture let thicknessSample:vec4<f32>=textureSample( packedKHR_clearcoatTexture_transmission, packedTextureSampler, KHR_transmissionUV ); thicknessParameter *=thicknessSample.a; #redgpu_endIf #redgpu_endIf var diffuseTransmissionColor:vec3<f32>=u_KHR_diffuseTransmissionColorFactor; var diffuseTransmissionParameter:f32=u_KHR_diffuseTransmissionFactor; #redgpu_if useKHR_materials_diffuse_transmission #redgpu_if useKHR_diffuseTransmissionTexture let diffuseTransmissionTextureSample=textureSample( packedKHR_diffuse_transmission, packedTextureSampler, KHR_diffuseTransmissionUV ); diffuseTransmissionParameter *=diffuseTransmissionTextureSample.a; #redgpu_endIf #redgpu_if useKHR_diffuseTransmissionColorTexture let diffuseTransmissionColorTextureSample=textureSample( packedKHR_diffuse_transmission, packedTextureSampler, KHR_diffuseTransmissionColorUV ); diffuseTransmissionColor *=diffuseTransmissionColorTextureSample.rgb; #redgpu_endIf #redgpu_endIf var sheenColor=u_KHR_sheenColorFactor; var sheenRoughnessParameter=u_KHR_sheenRoughnessFactor; #redgpu_if useKHR_materials_sheen #redgpu_if useKHR_sheenColorTexture let sheenColorSample=(textureSample(packedKHR_sheen,packedTextureSampler,KHR_sheenColorUV)); sheenColor *=sheenColorSample.rgb; #redgpu_endIf #redgpu_if useKHR_sheenRoughnessTexture let sheenRoughnessSample=(textureSample(packedKHR_sheen,packedTextureSampler,KHR_sheenRoughnessUV)); sheenRoughnessParameter *=sheenRoughnessSample.a; #redgpu_endIf #redgpu_endIf var iridescenceParameter=u_KHR_iridescenceFactor; var iridescenceThickness=u_KHR_iridescenceThicknessMaximum; #redgpu_if useKHR_materials_iridescence #redgpu_if useKHR_iridescenceTexture let iridescenceTextureSample:vec4<f32>=textureSample( packedKHR_iridescence, packedTextureSampler, KHR_iridescenceTextureUV ); iridescenceParameter *=iridescenceTextureSample.r; #redgpu_endIf #redgpu_if useKHR_iridescenceThicknessTexture let iridescenceThicknessTextureSample:vec4<f32>=textureSample( packedKHR_iridescence, packedTextureSampler, KHR_iridescenceThicknessTextureUV ); iridescenceThickness=mix(u_KHR_iridescenceThicknessMinimum,u_KHR_iridescenceThicknessMaximum,iridescenceThicknessTextureSample.g); #redgpu_endIf #redgpu_endIf var anisotropy:f32=u_KHR_anisotropyStrength; var anisotropicT:vec3<f32>=vec3<f32>(1.0); var anisotropicB:vec3<f32>=vec3<f32>(1.0); #redgpu_if useKHR_materials_anisotropy { var T:vec3<f32>; var B:vec3<f32>; if (u_useVertexTangent && length(input_vertexTangent.xyz) > 0.0) { T=normalize(input_vertexTangent.xyz); B=normalize(cross(N,T) * input_vertexTangent.w); } else { T=normalize(select(vec3<f32>(1.0,0.0,0.0),vec3<f32>(0.0,1.0,0.0),abs(N.x) > 0.9)); T=normalize(T - N * dot(T,N)); B=normalize(cross(N,T)); } var anisotropicDirection:vec2<f32>=vec2<f32>(1.0,0.0); if(u_useKHR_anisotropyTexture){ let anisotropyTex=textureSample(KHR_anisotropyTexture,baseColorTextureSampler,KHR_anisotropyUV).rgb; anisotropicDirection=anisotropyTex.rg * 2.0 - vec2<f32>(1.0,1.0); anisotropy *=anisotropyTex.b; } var cosR=cos(u_KHR_anisotropyRotation); var sinR=sin(u_KHR_anisotropyRotation); let rotationMtx:mat2x2<f32>=mat2x2<f32>( cosR,sinR, -sinR,cosR ); anisotropicDirection=rotationMtx * anisotropicDirection; anisotropicT=normalize(T * anisotropicDirection.x + B * anisotropicDirection.y); anisotropicB=normalize(cross(N,anisotropicT)); } #redgpu_endIf var prePathBackground=vec3<f32>(0.0); #redgpu_if useKHR_materials_transmission prePathBackground=calcPrePathBackground( u_useKHR_materials_volume,thicknessParameter * inputData.localNodeScale_volumeScale[1],u_KHR_dispersion,u_KHR_attenuationDistance,u_KHR_attenuationColor, ior,roughnessParameter,albedo, systemUniforms.projectionCameraMatrix,input_vertexPosition,input_ndcPosition, V,N, renderPath1ResultTexture,renderPath1ResultTextureSampler ); #redgpu_endIf let F0_dielectric_base=vec3(pow((1.0 - ior)/(1.0 + ior),2.0)); var F0_dielectric=F0_dielectric_base * specularColor; var F0_metal=baseColor.rgb; #redgpu_if useKHR_materials_iridescence if (iridescenceParameter > 0.0) { F0_dielectric=iridescent_fresnel(1.0,u_KHR_iridescenceIor,F0_dielectric,iridescenceThickness,iridescenceParameter,NdotV); F0_metal=iridescent_fresnel(1.0,u_KHR_iridescenceIor,baseColor.rgb,iridescenceThickness,iridescenceParameter,NdotV); } #redgpu_endIf let F0=mix(F0_dielectric,F0_metal,metallicParameter); var totalDirectLighting=vec3<f32>(0.0); for (var i=0u;i < u_directionalLightCount;i++) { totalDirectLighting +=calcLight( u_directionalLights[i].color,u_directionalLights[i].intensity * visibility, N,V,-normalize(u_directionalLights[i].direction), VdotN, roughnessParameter,metallicParameter,albedo, F0,ior, prePathBackground, specularColor,specularParameter, u_useKHR_materials_diffuse_transmission,diffuseTransmissionParameter,diffuseTransmissionColor, transmissionParameter, sheenColor,sheenRoughnessParameter, anisotropy,anisotropicT,anisotropicB, clearcoatParameter,clearcoatRoughnessParameter,clearcoatNormal ); } { let clusterIndex=getClusterLightClusterIndex(inputData.position); let lightOffset=clusterLightGroup.lights[clusterIndex].offset; let lightCount:u32=clusterLightGroup.lights[clusterIndex].count; for (var lightIndex=0u;lightIndex < lightCount;lightIndex=lightIndex + 1u) { let i=clusterLightGroup.indices[lightOffset + lightIndex]; let targetLight=clusterLightList.lights[i]; let u_clusterLightPosition=targetLight.position; let u_clusterLightRadius=targetLight.radius; let u_isSpotLight=targetLight.isSpotLight; let lightDistance=length(u_clusterLightPosition - input_vertexPosition); if (lightDistance > u_clusterLightRadius) { continue; } let lightDir=normalize(u_clusterLightPosition - input_vertexPosition);\nlet Lvec=u_clusterLightPosition - input_vertexPosition;\nlet dist2=max(dot(Lvec,Lvec),0.0001);\nlet d=sqrt(dist2);\nlet rangePart=pow(clamp(1.0 - d/u_clusterLightRadius,0.0,1.0),2.0);\nlet invSquare=(u_clusterLightRadius * u_clusterLightRadius)/dist2;\nlet attenuation=rangePart * invSquare; var finalAttenuation=attenuation; if (u_isSpotLight > 0.0) { let u_clusterLightDirection=normalize(vec3<f32>( targetLight.directionX, targetLight.directionY, targetLight.directionZ )); let u_clusterLightInnerAngle=targetLight.innerCutoff; let u_clusterLightOuterCutoff=targetLight.outerCutoff; let lightToVertex=normalize(-lightDir); let cosTheta=dot(lightToVertex,u_clusterLightDirection); let cosOuter=cos(radians(u_clusterLightOuterCutoff)); let cosInner=cos(radians(u_clusterLightInnerAngle)); if (cosTheta < cosOuter) { continue; } let epsilon=cosInner - cosOuter; let spotIntensity=clamp((cosTheta - cosOuter)/epsilon,0.0,1.0); finalAttenuation *=spotIntensity; } totalDirectLighting +=calcLight( targetLight.color,targetLight.intensity * finalAttenuation, N,V,lightDir, VdotN, roughnessParameter,metallicParameter,albedo, F0,ior, prePathBackground, specularColor,specularParameter, u_useKHR_materials_diffuse_transmission,diffuseTransmissionParameter,diffuseTransmissionColor, transmissionParameter, sheenColor,sheenRoughnessParameter, anisotropy,anisotropicT,anisotropicB, clearcoatParameter,clearcoatRoughnessParameter,clearcoatNormal ); } } if (u_usePrefilterTexture) { var R=(reflect(-V,N)); let NdotV=max(dot(N,V),1e-4); #redgpu_if useKHR_materials_anisotropy { var bentNormal=cross(anisotropicB,V); bentNormal=normalize(cross(bentNormal,anisotropicB)); let temp=1.0 - anisotropy * (1.0 - roughnessParameter); let tempSquared=temp * temp; var a=tempSquared * tempSquared; bentNormal=normalize(mix(bentNormal,N,a)); var reflectVec=reflect(-V,bentNormal); reflectVec=normalize(mix(reflectVec,bentNormal,roughnessParameter * roughnessParameter)); let roughnessT=roughnessParameter * (1.0 + anisotropy); let roughnessB=roughnessParameter * (1.0 - anisotropy); let TdotR=dot(anisotropicT,reflectVec); let BdotR=dot(anisotropicB,reflectVec); let TdotV=dot(anisotropicT,V); let BdotV=dot(anisotropicB,V); R=normalize(reflectVec - anisotropy * (TdotR * anisotropicT - BdotR * anisotropicB)); let VdotN=max(1e-4,dot(V,N)); let oneMinusVdotN=1.0 - VdotN; let directionFactor=oneMinusVdotN * oneMinusVdotN * oneMinusVdotN; let VdotT_abs=abs(TdotV); let VdotB_abs=abs(BdotV); let totalWeight=max(1e-4,VdotT_abs + VdotB_abs); let weightedRoughness=(roughnessT * VdotT_abs + roughnessB * VdotB_abs)/totalWeight; roughnessParameter=weightedRoughness; } #redgpu_endIf let iblMipmapCount:f32=f32(textureNumLevels(ibl_environmentTexture) - 1); var mipLevel=roughnessParameter * iblMipmapCount; var reflectedColor=textureSampleLevel( ibl_environmentTexture,prefilterTextureSampler,R,mipLevel ).rgb; let envBRDF=textureSampleLevel(ibl_brdfLUTTexture,prefilterTextureSampler,vec2<f32>(NdotV,roughnessParameter),0.0).rg; var F_IBL_dielectric=F0_dielectric * envBRDF.x + envBRDF.y; var F_IBL_metal=F0_metal * envBRDF.x + envBRDF.y; var F_IBL=F0 * envBRDF.x + envBRDF.y; let a2=roughnessParameter * roughnessParameter; let G_smith=NdotV/(NdotV * (1.0 - a2) + a2); let effectiveTransmission=transmissionParameter * (1.0 - metallicParameter); let iblDiffuseColor=textureSampleLevel(ibl_irradianceTexture,prefilterTextureSampler,N,0).rgb; var envIBL_DIFFUSE:vec3<f32>=albedo * iblDiffuseColor* (vec3<f32>(1.0) - F_IBL_dielectric); #redgpu_if useKHR_materials_diffuse_transmission { var backScatteringColor=textureSampleLevel(ibl_environmentTexture,prefilterTextureSampler,-N,mipLevel).rgb; let transmittedIBL=backScatteringColor * diffuseTransmissionColor * (vec3<f32>(1.0) - F_IBL_dielectric); envIBL_DIFFUSE=mix(envIBL_DIFFUSE,transmittedIBL,diffuseTransmissionParameter); } #redgpu_endIf var envIBL_SPECULAR:vec3<f32>; envIBL_SPECULAR=reflectedColor * F_IBL * specularParameter; var envIBL_SPECULAR_BTDF=vec3<f32>(0.0); #redgpu_if useKHR_materials_transmission var refractedDir:vec3<f32>; let eta=1.0/ior; if (abs(ior - 1.0) < 0.0001) { refractedDir=V;} else { refractedDir=refract(-V,-N,eta);} if(length(refractedDir) > 0.0001) { let NdotT=abs(dot(N,normalize(refractedDir))); let F_transmission=vec3<f32>(1.0) - mix(F_IBL_dielectric,F_IBL_metal,metallicParameter); var attenuatedBackground=prePathBackground; if (u_useKHR_materials_volume) { let localNodeScale=inputData.localNodeScale_volumeScale[0]; let volumeScale=inputData.localNodeScale_volumeScale[1]; let scaledThickness=thicknessParameter * localNodeScale; let safeAttenuationColor=clamp(u_KHR_attenuationColor,vec3<f32>(0.0001),vec3<f32>(1.0)); let safeAttenuationDistance=max(u_KHR_attenuationDistance,0.0001); let attenuationCoefficient=-log(safeAttenuationColor)/safeAttenuationDistance; let cosTheta=max(NdotT,0.001); let pathLength=scaledThickness/cosTheta; let transmittance=exp(-attenuationCoefficient * pathLength); attenuatedBackground *=transmittance; }else{ attenuatedBackground *=albedo; } envIBL_SPECULAR_BTDF=attenuatedBackground * F_transmission * transmissionParameter + reflectedColor * G_smith * mix(F_IBL_dielectric,F_IBL_metal,metallicParameter) * NdotT; } #redgpu_endIf let envIBL_DIELECTRIC=mix(envIBL_DIFFUSE,envIBL_SPECULAR_BTDF,transmissionParameter) + envIBL_SPECULAR; var envIBL_SHEEN=vec3<f32>(0.0); var sheen_albedo_scaling:f32=1.0; let maxSheenColor=max(sheenColor.x,max(sheenColor.y,sheenColor.z)); #redgpu_if useKHR_materials_sheen let sheenResult=calcIBLSheen( N, V, sheenColor, maxSheenColor, sheenRoughnessParameter, iblMipmapCount ); envIBL_SHEEN=sheenResult.envIBL_SHEEN; sheen_albedo_scaling=sheenResult.sheen_albedo_scaling; #redgpu_endIf let envIBL_METAL=reflectedColor * F_IBL_metal; let metallicPart=envIBL_METAL * metallicParameter; let dielectricPart=envIBL_DIELECTRIC * (1.0 - metallicParameter); var indirectLighting=(metallicPart + dielectricPart) * sheen_albedo_scaling + envIBL_SHEEN; #redgpu_if useKHR_materials_clearcoat if (clearcoatParameter > 0.0) { let clearcoatR=reflect(-V,clearcoatNormal); let clearcoatNdotV=max(dot(clearcoatNormal,V),0.04); let clearcoatMipLevel=clearcoatRoughnessParameter * iblMipmapCount; let clearcoatPrefilteredColor=textureSampleLevel(ibl_environmentTexture,prefilterTextureSampler,clearcoatR,clearcoatMipLevel).rgb; let clearcoatEnvBRDF=textureSampleLevel(ibl_brdfLUTTexture,prefilterTextureSampler,vec2<f32>(clearcoatNdotV,clearcoatRoughnessParameter),0.0).rg; let clearcoatF0=vec3<f32>(0.04); let clearcoatF=clearcoatF0 * clearcoatEnvBRDF.x + clearcoatEnvBRDF.y; let clearcoatSpecularIBL=clearcoatPrefilteredColor * clearcoatF * clearcoatParameter; indirectLighting=clearcoatSpecularIBL + (1.0 - max(clearcoatF.x,max(clearcoatF.y,clearcoatF.z)) * clearcoatParameter) * indirectLighting; } #redgpu_endIf let environmentIntensity=1.0; let surfaceColor=totalDirectLighting + indirectLighting * environmentIntensity * occlusionParameter; finalColor=vec4<f32>(surfaceColor,resultAlpha); } else { let ambientContribution=albedo * u_ambientLightColor * u_ambientLightIntensity * occlusionParameter; finalColor=vec4<f32>(totalDirectLighting + ambientContribution,resultAlpha); } var emissiveSamplerColor=vec3<f32>(1.0); #redgpu_if emissiveTexture emissiveSamplerColor=textureSample(emissiveTexture,emissiveTextureSampler,emissiveUV).rgb; #redgpu_endIf finalColor +=vec4<f32>( emissiveSamplerColor.rgb * u_emissiveFactor * u_emissiveStrength,0); #redgpu_if useCutOff if (resultAlpha <=u_cutOff) { discard;} #redgpu_endIf output.color=finalColor; { let smoothness=1.0 - roughnessParameter; let smoothnessCurved=smoothness * smoothness * (3.0 - 2.0 * smoothness); let metallicWeight=metallicParameter * metallicParameter; let baseReflection=0.04 + 0.96 * metallicWeight; let baseReflectionStrength=smoothnessCurved * baseReflection; output.gBufferNormal=vec4<f32>(N * 0.5 + 0.5,baseReflectionStrength); } output.gBufferMotionVector=vec4<f32>(calculateMotionVector(inputData.currentClipPos,inputData.prevClipPos),0.0,1.0 ); return output;\n};\nstruct SheenResult { envIBL_SHEEN:vec3<f32>, sheen_albedo_scaling:f32\n}\nfn calcIBLSheen( N:vec3<f32>, V:vec3<f32>, sheenColor:vec3<f32>, maxSheenColor:f32, sheenRoughness:f32, iblMipmapCount:f32,\n) -> SheenResult { let NdotV=clamp(dot(N,V),0.0001,1.0); let R=reflect(-V,N); let mipLevel=sheenRoughness * iblMipmapCount; let sheenRadiance=textureSampleLevel( ibl_irradianceTexture,prefilterTextureSampler,R,mipLevel ).rgb; let sheenDFG=charlieSheenDFG(NdotV,sheenRoughness); let envIBL_SHEEN=sheenRadiance * sheenColor * sheenDFG; let E=charlieSheenE(NdotV,sheenRoughness); let sheen_albedo_scaling=1.0 - maxSheenColor * E; return SheenResult(envIBL_SHEEN,sheen_albedo_scaling);\n}\nfn charlieSheenDFG(NdotV:f32,roughness:f32) -> f32 { if (roughness < 0.01) { return 0.0; } let r=clamp(roughness,0.01,1.0); let grazingFactor=1.0 - NdotV; let roughnessExp=1.0/max(r,0.1); let distribution=pow(grazingFactor,roughnessExp); let intensity=pow(roughnessExp,0.5); return distribution * intensity * 0.5;\n}\nfn charlieSheenE(NdotV:f32,roughness:f32) -> f32 { if (roughness < 0.01) { return 0.0; } let r=clamp(roughness,0.01,1.0); let grazingFactor=1.0 - NdotV; let roughnessExp=1.0/max(r,0.1); return pow(grazingFactor,roughnessExp) * pow(r,0.5);\n}\nfn calcLight( lightColor:vec3<f32>,lightIntensity:f32, N:vec3<f32>,V:vec3<f32>,L:vec3<f32>, VdotN:f32, roughnessParameter:f32,metallicParameter:f32,albedo:vec3<f32>, F0:vec3<f32>,ior:f32, prePathBackground:vec3<f32>, specularColor:vec3<f32>,specularParameter:f32, u_useKHR_materials_diffuse_transmission:bool,diffuseTransmissionParameter:f32,diffuseTransmissionColor:vec3<f32>, transmissionParameter:f32, sheenColor:vec3<f32>,sheenRoughnessParameter:f32, anisotropy:f32,anisotropicT:vec3<f32>,anisotropicB:vec3<f32>, clearcoatParameter:f32,clearcoatRoughnessParameter:f32,clearcoatNormal:vec3<f32>\n) -> vec3<f32>{ let dLight=lightColor * lightIntensity; let NdotL=max(dot(N,L),0.04); let NdotV=max(dot(N,V),0.04); let H=normalize(L + V); let LdotH=max(dot(L,H),0.0); let NdotH=max(dot(N,H),0.0); let VdotH=max(dot(V,H),0.0); var DIFFUSE_BRDF:vec3<f32>=diffuse_brdf_disney(NdotL,NdotV,LdotH,roughnessParameter,albedo); #redgpu_if useKHR_materials_diffuse_transmission DIFFUSE_BRDF=mix(DIFFUSE_BRDF,diffuse_btdf(N,L,diffuseTransmissionColor),diffuseTransmissionParameter); #redgpu_endIf var SPECULAR_BRDF:vec3<f32>; if (anisotropy > 0.0) { #redgpu_if useKHR_materials_anisotropy var TdotL=dot(anisotropicT,L); var TdotV=dot(anisotropicT,V); var BdotL=dot(anisotropicB,L); var TdotH=dot(anisotropicT,H); var BdotH=dot(anisotropicB,H); var BdotV=dot(anisotropicB,V); SPECULAR_BRDF=BRDF_specularAnisotropicGGX( albedo, vec3<f32>(1.0), roughnessParameter * roughnessParameter, VdotH,NdotL,NdotV,NdotH,BdotV,TdotV,TdotL,BdotL,TdotH,BdotH, anisotropy ); #redgpu_endIf }else{ SPECULAR_BRDF=specular_brdf( albedo,roughnessParameter,NdotH,NdotV,NdotL,LdotH); } let METAL_BRDF=conductor_fresnel( albedo,SPECULAR_BRDF,VdotH);; var SPECULAR_BTDF=vec3<f32>(0.0); #redgpu_if useKHR_materials_transmission if(transmissionParameter > 0.0){ SPECULAR_BTDF=specular_btdf( NdotV,NdotL,NdotH,VdotH,LdotH,roughnessParameter,albedo,ior); } #redgpu_endIf let DIELECTRIC_BRDF=fresnel_mix( F0, specularParameter, mix(DIFFUSE_BRDF,SPECULAR_BTDF,transmissionParameter), SPECULAR_BRDF, VdotH ); var SHEEN_BRDF:vec3<f32>=vec3<f32>(0.0); var sheen_albedo_scaling:f32=1.0; #redgpu_if useKHR_materials_sheen let maxSheenColor=max(sheenColor.x,max(sheenColor.y,sheenColor.z)); if(sheenRoughnessParameter > 0.0 && maxSheenColor > 0.001 && dot(N,V) > 0) { let NdotV=dot(N,V); let sheenRoughnessAlpha=sheenRoughnessParameter * sheenRoughnessParameter; let invR=1/sheenRoughnessAlpha; let cos2h=NdotH * NdotH; let sin2h=1 - cos2h; let sheenDistribution=(2 + invR) * pow(sin2h,invR * 0.5)/(2 * pi); let sheen_visibility=1.0/((1.0 + lambda_sheen(NdotV,sheenRoughnessAlpha) + lambda_sheen(NdotL,sheenRoughnessAlpha)) * (4.0 * NdotV * NdotL)); let LdotN=max(dot(L,N),0.04); let E_LdotN=1.0 - pow(1.0 - LdotN,5.0); let E_VdotN=1.0 - pow(1.0 - VdotN,5.0); sheen_albedo_scaling=max(min(1.0 - maxSheenColor * E_VdotN,1.0 - maxSheenColor * E_LdotN),0.04); SHEEN_BRDF=sheenColor * sheenDistribution * sheen_visibility; } #redgpu_endIf let metallicPart=METAL_BRDF * metallicParameter * sheen_albedo_scaling; let dielectricPart=DIELECTRIC_BRDF * sheen_albedo_scaling; let sheenPart=SHEEN_BRDF; var directLighting=(metallicPart + dielectricPart + sheenPart); #redgpu_if useKHR_materials_transmission if(transmissionParameter > 0.0) { let transmissionWeight=transmissionParameter * (vec3<f32>(1.0) - F0); directLighting=mix(directLighting,prePathBackground,transmissionWeight); } #redgpu_endIf #redgpu_if useKHR_materials_clearcoat if(clearcoatParameter > 0.0){ let clearcoatNdotL=max(dot(clearcoatNormal,L),0.04); let clearcoatNdotV=max(dot(clearcoatNormal,V),0.04); let clearcoatNdotH=max(dot(clearcoatNormal,H),0.0); let CLEARCOAT_BRDF=specular_brdf( F0,clearcoatRoughnessParameter,clearcoatNdotH,clearcoatNdotV,clearcoatNdotL,LdotH); directLighting=fresnel_coat(clearcoatNdotV,ior,clearcoatParameter,directLighting,CLEARCOAT_BRDF); } #redgpu_endIf var lightDirection:f32; #redgpu_if useKHR_materials_diffuse_transmission lightDirection=mix(abs(dot(N,L)),1.0,diffuseTransmissionParameter); #redgpu_else lightDirection=NdotL; #redgpu_endIf let lightContribution=directLighting * dLight * lightDirection; return lightContribution;\n}\nconst pi:f32=3.14159265359;\nfn BRDF_specularAnisotropicGGX( f0:vec3<f32>,f90:vec3<f32>,alphaRoughness:f32,VdotH:f32,NdotL:f32,NdotV:f32,NdotH:f32,BdotV:f32,TdotV:f32,TdotL:f32,BdotL:f32,TdotH:f32,BdotH:f32,anisotropy:f32 ) -> vec3<f32> { var at=mix(alphaRoughness,1.0,anisotropy * anisotropy); var ab=alphaRoughness; var F:vec3<f32>=fresnel_schlick(VdotH,f0); var V:f32=V_GGX_anisotropic(NdotL,NdotV,BdotV,TdotV,TdotL,BdotL,at,ab); var D:f32=D_GGX_anisotropic(NdotH,TdotH,BdotH,at,ab); return F * (V * D);\n}\nfn D_GGX_anisotropic( NdotH:f32,TdotH:f32,BdotH:f32,at:f32,ab:f32 ) -> f32 { let a2:f32=at * ab; let f:vec3<f32>=vec3<f32>(ab * TdotH,at * BdotH,a2 * NdotH); let denominator:f32=dot(f,f); let w2:f32=a2/denominator; return a2 * w2 * w2/pi;\n}\nfn V_GGX_anisotropic( NdotL:f32,NdotV:f32,BdotV:f32,TdotV:f32,TdotL:f32,BdotL:f32,at:f32,ab:f32 ) -> f32 { let GGXV=NdotL * length(vec3<f32>(at * TdotV,ab * BdotV,NdotV)); let GGXL=NdotV * length(vec3<f32>(at * TdotL,ab * BdotL,NdotL)); let v=0.5/(GGXV + GGXL); return clamp(v,0.0,1.0);\n}\nfn iridescent_fresnel(outside_ior:f32,iridescence_ior:f32,base_f0:vec3<f32>, iridescence_thickness:f32,iridescence_factor:f32,cos_theta1:f32) -> vec3<f32> { if (iridescence_thickness <=0.0 || iridescence_factor <=0.0) { return base_f0; } let cos_theta1_abs=abs(cos_theta1); let safe_iridescence_ior=max(iridescence_ior,1.01); let sin_theta1=sqrt(max(0.0,1.0 - cos_theta1_abs * cos_theta1_abs)); let sin_theta2=(outside_ior/safe_iridescence_ior) * sin_theta1; if (sin_theta2 >=1.0) { return base_f0 + iridescence_factor * (vec3<f32>(1.0) - base_f0); } let cos_theta2=sqrt(max(0.0,1.0 - sin_theta2 * sin_theta2)); let wavelengths=vec3<f32>(650.0,510.0,475.0); let effective_thickness=max(iridescence_thickness,10.0); let ior_scale=max(1.0,1.5 - 0.5 * (safe_iridescence_ior/1.5)); let optical_thickness=2.0 * effective_thickness * safe_iridescence_ior * cos_theta2 * ior_scale; let phase=(2.0 * 3.14159265359 * optical_thickness)/wavelengths; let cos_phase=cos(phase); let sin_phase=sin(phase); let outside_cos1=outside_ior * cos_theta1_abs; let iridescence_cos2=safe_iridescence_ior * cos_theta2; let iridescence_cos1=safe_iridescence_ior * cos_theta1_abs; let outside_cos2=outside_ior * cos_theta2; let r12_s=(outside_cos1 - iridescence_cos2)/(outside_cos1 + iridescence_cos2); let r12_p=(iridescence_cos1 - outside_cos2)/(iridescence_cos1 + outside_cos2); let sqrt_f0=sqrt(clamp(base_f0,vec3<f32>(0.01),vec3<f32>(0.99))); let safe_n3=max((1.0 + sqrt_f0)/(1.0 - sqrt_f0),vec3<f32>(1.2)); let iridescence_cos2_vec=vec3<f32>(iridescence_cos2); let cos_theta1_abs_vec=vec3<f32>(cos_theta1_abs); let iridescence_cos1_vec=vec3<f32>(iridescence_cos1); let cos_theta2_vec=vec3<f32>(cos_theta2); let r23_s=(iridescence_cos2_vec - safe_n3 * cos_theta1_abs_vec)/ (iridescence_cos2_vec + safe_n3 * cos_theta1_abs_vec); let r23_p=(safe_n3 * cos_theta2_vec - iridescence_cos1_vec)/ (safe_n3 * cos_theta2_vec + iridescence_cos1_vec); let r12_s_vec=vec3<f32>(r12_s); let r12_p_vec=vec3<f32>(r12_p); let num_s_real=r12_s_vec + r23_s * cos_phase; let num_s_imag=r23_s * sin_phase; let den_s_real=vec3<f32>(1.0) + r12_s_vec * r23_s * cos_phase; let den_s_imag=r12_s_vec * r23_s * sin_phase; let num_p_real=r12_p_vec + r23_p * cos_phase; let num_p_imag=r23_p * sin_phase; let den_p_real=vec3<f32>(1.0) + r12_p_vec * r23_p * cos_phase; let den_p_imag=r12_p_vec * r23_p * sin_phase; let den_s_squared=den_s_real * den_s_real + den_s_imag * den_s_imag + vec3<f32>(0.001); let rs_real=(num_s_real * den_s_real + num_s_imag * den_s_imag)/den_s_squared; let rs_imag=(num_s_imag * den_s_real - num_s_real * den_s_imag)/den_s_squared; let Rs=rs_real * rs_real + rs_imag * rs_imag; let den_p_squared=den_p_real * den_p_real + den_p_imag * den_p_imag + vec3<f32>(0.001); let rp_real=(num_p_real * den_p_real + num_p_imag * den_p_imag)/den_p_squared; let rp_imag=(num_p_imag * den_p_real - num_p_real * den_p_imag)/den_p_squared; let Rp=rp_real * rp_real + rp_imag * rp_imag; let reflectance=0.5 * (Rs + Rp); let ior_influence=smoothstep(1.0,2.0,safe_iridescence_ior); let enhanced_reflectance=mix( pow(reflectance,vec3<f32>(0.8)) * 1.2, reflectance, ior_influence ); let clamped_reflectance=clamp(enhanced_reflectance,vec3<f32>(0.0),vec3<f32>(1.0)); return mix(base_f0,clamped_reflectance,iridescence_factor);\n}\nfn specular_btdf( NdotV:f32, NdotL:f32, NdotH:f32, VdotH:f32, LdotH:f32, roughness:f32, F0:vec3<f32>, ior:f32\n) -> vec3<f32> { let eta:f32=1.0/ior; let D_rough:f32=distribution_ggx(NdotH,roughness * roughness); let t:f32=clamp((ior - 1.0) * 100.0,0.0,1.0); let D:f32=mix(1.0,D_rough,t); let G:f32=min(1.0,min((2.0 * NdotH * NdotV)/VdotH,(2.0 * NdotH * NdotL)/VdotH)); let F:vec3<f32>=fresnel_schlick(VdotH,F0); let denom:f32=(eta * VdotH + LdotH) * (eta * VdotH + LdotH); let btdf:vec3<f32>= (vec3<f32>(1.0) - F) *  abs(VdotH * LdotH) *  (eta * eta) *  D *  G/ (NdotV * denom + 0.001); return btdf;\n}\nfn lambda_sheen_calc_l(x:f32,alpha_g:f32) -> f32 { let one_minus_alpha_sq=(1.0 - alpha_g) * (1.0 - alpha_g); let a=mix(21.5473,25.3245,one_minus_alpha_sq); let b=mix(3.82987,3.32435,one_minus_alpha_sq); let c=mix(0.19823,0.16801,one_minus_alpha_sq); let d=mix(-1.97760,-1.27393,one_minus_alpha_sq); let e=mix(-4.32054,-4.85967,one_minus_alpha_sq); return a/(1.0 + b * pow(x,c)) + d * x + e;\n}\nfn lambda_sheen(cos_theta:f32,alpha_g:f32) -> f32 { if (abs(cos_theta) < 0.5) { return exp(lambda_sheen_calc_l(cos_theta,alpha_g)); } else { return exp(2.0 * lambda_sheen_calc_l(0.5,alpha_g) - lambda_sheen_calc_l(1.0 - cos_theta,alpha_g)); }\n}\nfn fresnel_coat(NdotV:f32,ior:f32,weight:f32,base:vec3<f32>,layer:vec3<f32>) -> vec3<f32> { let f0:f32=pow((1.0 - ior)/(1.0 + ior),2.0); let fr:f32=f0 + (1.0 - f0) * pow(1.0 - abs(NdotV),5.0); return mix(base,layer,weight * fr);\n}\nfn conductor_fresnel(F0:vec3<f32>,bsdf:vec3<f32>,VdotH:f32) -> vec3<f32> { let fresnel=F0 + (vec3<f32>(1.0) - F0) * pow(1.0 - abs(VdotH),5.0); return bsdf * fresnel;\n}\nfn fresnel_mix( F0:vec3<f32>, weight:f32, base:vec3<f32>, layer:vec3<f32>, VdotH:f32\n) -> vec3<f32> { var f0=F0; f0=min(f0,vec3<f32>(1.0)); let fr=f0 + (1.0 - f0) * pow(1.0 - abs(VdotH),5.0); return (1 - weight * max(max(fr.x,fr.y),fr.z)) * base + weight * fr * layer;\n}\nfn fresnel_mix_ibl( F0:vec3<f32>, weight:f32, base:vec3<f32>, layer:vec3<f32>, NdotV:f32\n) -> vec3<f32> { var f0=F0; f0=min(f0,vec3<f32>(1.0)); let fr=f0 + (1.0 - f0) * pow(1.0 - max(NdotV,0.0),5.0); return base * (1.0 - fr * weight) + layer * fr * weight;\n}\nfn diffuse_brdf_disney(NdotL:f32,NdotV:f32,LdotH:f32,roughness:f32,albedo:vec3<f32>) -> vec3<f32> { if (NdotL <=0.0) { return vec3<f32>(0.0);} let energyBias=mix(0.0,0.5,roughness); let energyFactor=mix(1.0,1.0/1.51,roughness); let fd90=energyBias + 2.0 * LdotH * LdotH * roughness; let f0=1.0; let lightScatter=f0 + (fd90 - f0) * pow(1.0 - NdotL,5.0); let viewScatter=f0 + (fd90 - f0) * pow(1.0 - NdotV,5.0); return albedo * NdotL * lightScatter * viewScatter * energyFactor/pi;\n}\nfn diffuse_brdf(NdotL:f32,albedo:vec3<f32>) -> vec3<f32> { return albedo * NdotL/pi;\n}\nfn diffuse_btdf(N:vec3<f32>,L:vec3<f32>,Albedo:vec3<f32>) -> vec3<f32> { let cos_theta=max(-dot(N,L),0.0); return Albedo * cos_theta/pi;\n}\nfn specular_brdf( F0:vec3<f32>, roughness:f32, NdotH:f32, NdotV:f32, NdotL:f32, LdotH:f32\n) -> vec3<f32> { let D=distribution_ggx(NdotH,roughness); let G=geometry_smith(NdotV,NdotL,roughness); let F=fresnel_schlick(LdotH,F0); let numerator=D * G * F; let denominator=4.0 * NdotV * NdotL + 0.04; return (numerator/denominator);\n}\nfn distribution_ggx(NdotH:f32,roughness:f32) -> f32 { let alpha=roughness * roughness; let alpha2=alpha * alpha; let NdotH2=NdotH * NdotH; let nom=alpha2; let denom=(NdotH2 * (alpha2 - 1.0) + 1.0); let denom_squared=denom * denom; return nom/(denom_squared * 3.14159265359);\n}\nfn geometry_smith(NdotV:f32,NdotL:f32,roughness:f32) -> f32 { let alpha=roughness * roughness; let k=alpha/2.0; let ggx1=NdotV/(NdotV * (1.0 - k) + k); let ggx2=NdotL/(NdotL * (1.0 - k) + k); return ggx1 * ggx2;\n}\nfn fresnel_schlick(cosTheta:f32,F0:vec3<f32>) -> vec3<f32> { return F0 + (vec3<f32>(1.0) - F0) * pow(1.0 - cosTheta,5.0);\n}\nfn get_transformed_uv( input_uv:vec2<f32>, input_uv1:vec2<f32>, texCoord_index:u32, use_transform:u32, transform_offset:vec2<f32>, transform_rotation:f32, transform_scale:vec2<f32>\n) -> vec2<f32> { var result_uv=select(input_uv,input_uv1,texCoord_index==1); if (use_transform==1) { let translation=mat3x3<f32>( 1.0,0.0,0.0, 0.0,1.0,0.0, transform_offset.x,transform_offset.y,1.0 ); let cos_rot=cos(transform_rotation); let sin_rot=sin(transform_rotation); let rotation_matrix=mat3x3<f32>( cos_rot,-sin_rot,0.0, sin_rot,cos_rot,0.0, 0.0,0.0,1.0 ); let scale_matrix=mat3x3<f32>( transform_scale.x,0.0,0.0, 0.0,transform_scale.y,0.0, 0.0,0.0,1.0 ); let result_matrix=translation * rotation_matrix * scale_matrix; result_uv=(result_matrix * vec3<f32>(result_uv,1.0)).xy; } return result_uv;\n}\nfn linear_to_srgb(linearColor:vec4<f32>) -> vec4<f32> { let cutoff=vec4<f32>(0.0031308); let higher=vec4<f32>(1.055) * pow(linearColor,vec4<f32>(1.0/2.4)) - vec4<f32>(0.055); let lower=linearColor * vec4<f32>(12.92); return vec4<f32>( mix(higher.r,lower.r,step(linearColor.r,cutoff.r)), mix(higher.g,lower.g,step(linearColor.g,cutoff.g)), mix(higher.b,lower.b,step(linearColor.b,cutoff.b)), linearColor.a  );\n}\n"));class PBRMaterial extends ABitmapBaseMaterial{#cs;#hs;#fs;#ds;#ms;constructor(i){super(i,"PBR_MATERIAL",Or,2),this.initGPURenderInfos(),this.__packingList=[()=>{this.setupPackORMTexture(),this.setupPackedKHR_clearcoatTexture_transmission(),this.setupPackedKHR_diffuse_transmission(),this.setupPackedKHR_sheen(),this.setupPackedKHR_iridescence()}]}get packedKHR_clearcoatTexture_transmission(){return this.#ms}get packedKHR_iridescence(){return this.#ds}get packedORMTexture(){return this.#cs}get packedKHR_sheen(){return this.#fs}get packedKHR_diffuse_transmission(){return this.#hs}async setupPackORMTexture(){if(!this.occlusionTexture&&!this.metallicRoughnessTexture)return;this.#cs||(this.#cs=new PackedTexture(this.redGPUContext));const i=Math.max(this.occlusionTexture?.gpuTexture?.width||1,this.metallicRoughnessTexture?.gpuTexture?.width||1),g=Math.max(this.occlusionTexture?.gpuTexture?.height||1,this.metallicRoughnessTexture?.gpuTexture?.height||1);await this.#cs.packing({r:this.occlusionTexture?.gpuTexture,g:this.metallicRoughnessTexture?.gpuTexture,b:this.metallicRoughnessTexture?.gpuTexture},i,g,"packedORMTexture")}async setupPackedKHR_clearcoatTexture_transmission(){this.#ms||(this.#ms=new PackedTexture(this.redGPUContext));const i=Math.max(this.KHR_clearcoatTexture?.gpuTexture?.width||1,this.KHR_clearcoatRoughnessTexture?.gpuTexture?.width||1),g=Math.max(this.KHR_clearcoatTexture?.gpuTexture?.height||1,this.KHR_clearcoatRoughnessTexture?.gpuTexture?.height||1),x=Math.max(this.KHR_transmissionTexture?.gpuTexture?.width||1,this.KHR_thicknessTexture?.gpuTexture?.width||1),_=Math.max(this.KHR_transmissionTexture?.gpuTexture?.height||1,this.KHR_thicknessTexture?.gpuTexture?.height||1),v=Math.max(i,x),b=Math.max(g,_);await this.#ms.packing({r:this.KHR_clearcoatTexture?.gpuTexture,g:this.KHR_clearcoatRoughnessTexture?.gpuTexture,b:this.KHR_transmissionTexture?.gpuTexture,a:this.KHR_thicknessTexture?.gpuTexture},v,b,"packedKHR_clearcoatTexture_transmission",{b:"r",a:"g"})}async setupPackedKHR_diffuse_transmission(){if(!this.KHR_diffuseTransmissionColorTexture&&!this.KHR_diffuseTransmissionTexture)return;this.#hs||(this.#hs=new PackedTexture(this.redGPUContext));const i=Math.max(this.KHR_diffuseTransmissionColorTexture?.gpuTexture?.width||1,this.KHR_diffuseTransmissionTexture?.gpuTexture?.width||1),g=Math.max(this.KHR_diffuseTransmissionColorTexture?.gpuTexture?.height||1,this.KHR_diffuseTransmissionTexture?.gpuTexture?.height||1);await this.#hs.packing({r:this.KHR_diffuseTransmissionColorTexture?.gpuTexture,g:this.KHR_diffuseTransmissionColorTexture?.gpuTexture,b:this.KHR_diffuseTransmissionColorTexture?.gpuTexture,a:this.KHR_diffuseTransmissionTexture?.gpuTexture},i,g,"packedKHR_diffuse_transmission")}async setupPackedKHR_sheen(){if(!this.KHR_sheenColorTexture&&!this.KHR_sheenRoughnessTexture)return;this.#fs||(this.#fs=new PackedTexture(this.redGPUContext));const i=Math.max(this.KHR_sheenColorTexture?.gpuTexture?.width||1,this.KHR_sheenRoughnessTexture?.gpuTexture?.width||1),g=Math.max(this.KHR_sheenColorTexture?.gpuTexture?.height||1,this.KHR_sheenRoughnessTexture?.gpuTexture?.height||1);await this.#fs.packing({r:this.KHR_sheenColorTexture?.gpuTexture,g:this.KHR_sheenColorTexture?.gpuTexture,b:this.KHR_sheenColorTexture?.gpuTexture,a:this.KHR_sheenRoughnessTexture?.gpuTexture},i,g,"packedKHR_sheen")}async setupPackedKHR_iridescence(){if(!this.KHR_iridescenceTexture&&!this.KHR_iridescenceThicknessTexture)return;this.#ds||(this.#ds=new PackedTexture(this.redGPUContext));const i=Math.max(this.KHR_iridescenceTexture?.gpuTexture?.width||1,this.KHR_iridescenceThicknessTexture?.gpuTexture?.width||1),g=Math.max(this.KHR_iridescenceTexture?.gpuTexture?.height||1,this.KHR_iridescenceThicknessTexture?.gpuTexture?.height||1);await this.#ds.packing({r:this.KHR_iridescenceTexture?.gpuTexture,g:this.KHR_iridescenceThicknessTexture?.gpuTexture},i,g,"packedKHR_iridescence")}}dr.defineByPreset(PBRMaterial,[dr.PRESET_POSITIVE_NUMBER.EMISSIVE_STRENGTH,dr.PRESET_POSITIVE_NUMBER.NORMAL_SCALE]);kr.forEach(i=>{const{extensionName:g,textureList:x,useSampler:_}=i,{positiveNumberList:v,vec3List:b,vec4List:y}=i;g&&dr.defineBoolean(PBRMaterial,[`use${g}`]),((i,g)=>{i?.forEach(i=>{dr.defineBoolean(PBRMaterial,[`use${i.charAt(0).toUpperCase()}${i.substring(1)}`]),dr.definePositiveNumber(PBRMaterial,[[`${i}_KHR_texture_transform_rotation`,0]]),dr.defineBoolean(PBRMaterial,[`use_${i}_KHR_texture_transform`]),dr.defineVec2(PBRMaterial,[`${i}_KHR_texture_transform_offset`,[`${i}_KHR_texture_transform_scale`,[1,1]]]),dr.defineUint(PBRMaterial,[`${i}_texCoord_index`]),dr.defineTexture(PBRMaterial,[i]),g&&dr.defineSampler(PBRMaterial,[`${i}Sampler`])})})(x,!_),v?.forEach(i=>{dr.definePositiveNumber(PBRMaterial,[i])}),b?.forEach(i=>{dr.defineVec3(PBRMaterial,[i])}),y?.forEach(i=>{dr.defineVec4(PBRMaterial,[i])})}),dr.definePositiveNumber(PBRMaterial,[["cutOff",0],["KHR_materials_ior",1.5],["KHR_dispersion",0]]),dr.defineUint(PBRMaterial,["alphaBlend"]),dr.defineBoolean(PBRMaterial,["doubleSided","useCutOff","useVertexColor","useVertexTangent","useKHR_materials_unlit",["useSSR",!0]]),Object.freeze(PBRMaterial);var Nr="struct InputData { @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(3) uv1:vec2<f32>, @location(4) vertexColor_0:vec4<f32>, @location(5) vertexTangent:vec4<f32>,\n};",Vr="struct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(3) uv1:vec2<f32>, @location(4) vertexColor_0:vec4<f32>, @location(5) vertexTangent:vec4<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(10) localNodeScale_volumeScale:vec2<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(14) @interpolate(flat) receiveShadow:f32, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};",Fr="struct InputData { @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>,\n};\n",zr="struct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(14) @interpolate(flat) receiveShadow:f32, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};",Hr="#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include drawDirectionalShadowDepth;\n#redgpu_include picking;\n#redgpu_include calcDisplacements;\n#redgpu_include meshVertexBasicUniform;\nconst maxDistance:f32=1000.0;\nconst maxMipLevel:f32=10.0;\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\n@group(1) @binding(1) var displacementTextureSampler:sampler;\n@group(1) @binding(2) var displacementTexture:texture_2d<f32>;\n@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; #redgpu_if disableJitter { let u_projectionMatrix=systemUniforms.noneJitterProjectionCameraMatrix; } #redgpu_else { let u_projectionMatrix=systemUniforms.projectionMatrix; } #redgpu_endIf let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_noneJitterProjectionCameraMatrix=systemUniforms.noneJitterProjectionCameraMatrix; let u_prevNoneJitterProjectionCameraMatrix=systemUniforms.prevNoneJitterProjectionCameraMatrix; let u_resolution=systemUniforms.resolution; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_matrixList=vertexUniforms.matrixList; let u_modelMatrix=u_matrixList.modelMatrix; let u_prevModelMatrix=u_matrixList.prevModelMatrix; let u_normalModelMatrix=u_matrixList.normalModelMatrix; let u_displacementScale=vertexUniforms.displacementScale; let u_useDisplacementTexture=vertexUniforms.useDisplacementTexture==1u; let u_receiveShadow=vertexUniforms.receiveShadow; let u_directionalLightCount=systemUniforms.directionalLightCount; let u_directionalLights=systemUniforms.directionalLights; let u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix; let input_position=inputData.position; let input_position_vec4=vec4<f32>(input_position,1.0); let input_vertexNormal=inputData.vertexNormal; let input_uv=inputData.uv; var position:vec4<f32>; var normalPosition:vec4<f32>; #redgpu_if useDisplacementTexture let tempPosition=u_modelMatrix * input_position_vec4; let distance=distance(tempPosition.xyz,u_cameraPosition); let mipLevel=(distance/maxDistance) * maxMipLevel; let displacedPosition=calcDisplacementPosition( input_position, input_vertexNormal, displacementTexture, displacementTextureSampler, u_displacementScale, input_uv, mipLevel ); position=u_modelMatrix * vec4<f32>(displacedPosition,1.0); let worldUV=input_uv; let displacedNormal=calcDisplacementNormal( normalize((u_normalModelMatrix * vec4<f32>(input_vertexNormal,0.0)).xyz), displacementTexture, displacementTextureSampler, u_displacementScale, worldUV, mipLevel ); normalPosition=vec4<f32>(displacedNormal,0.0); #redgpu_else position=u_modelMatrix * input_position_vec4; normalPosition=u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0); #redgpu_endIf output.position=u_projectionCameraMatrix * position; output.vertexPosition=position.xyz; output.vertexNormal=normalPosition.xyz; output.uv=input_uv * vertexUniforms.uvTransform.zw + vertexUniforms.uvTransform.xy; output.combinedOpacity=vertexUniforms.combinedOpacity; #redgpu_if receiveShadow { let posFromLight=u_directionalLightProjectionViewMatrix * vec4(position.xyz,1.0); output.shadowPos=vec3(posFromLight.xy * vec2(0.5,-0.5) + vec2(0.5),posFromLight.z); output.receiveShadow=vertexUniforms.receiveShadow; } #redgpu_endIf { output.currentClipPos=u_noneJitterProjectionCameraMatrix * position; output.prevClipPos=u_prevNoneJitterProjectionCameraMatrix * u_prevModelMatrix * input_position_vec4; } return output;\n}\n";const $r={SHADER_INFO_PBR:parseWGSL([Nr,Vr,"#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include drawDirectionalShadowDepth;\n#redgpu_include picking;\n#redgpu_include meshVertexBasicUniform;\nconst maxDistance:f32=1000.0;\nconst maxMipLevel:f32=10.0;\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\n@group(1) @binding(1) var displacementTextureSampler:sampler;\n@group(1) @binding(2) var displacementTexture:texture_2d<f32>;\n@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; let input_position=inputData.position; let input_position_vec4=vec4<f32>(input_position,1.0); let input_vertexNormal=inputData.vertexNormal; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_noneJitterProjectionCameraMatrix=systemUniforms.noneJitterProjectionCameraMatrix; let u_prevNoneJitterProjectionCameraMatrix=systemUniforms.prevNoneJitterProjectionCameraMatrix; let u_resolution=systemUniforms.resolution; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_matrixList=vertexUniforms.matrixList; let u_localMatrix=u_matrixList.localMatrix; let u_modelMatrix=u_matrixList.modelMatrix; let u_normalModelMatrix=u_matrixList.normalModelMatrix; let u_prevModelMatrix=u_matrixList.prevModelMatrix; let u_receiveShadow=vertexUniforms.receiveShadow; let u_directionalLightCount=systemUniforms.directionalLightCount; let u_directionalLights=systemUniforms.directionalLights; let u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix; var position:vec4<f32>; var normalPosition:vec4<f32>; position=u_modelMatrix * input_position_vec4; normalPosition=u_normalModelMatrix * vec4<f32>(input_vertexNormal,0.0); output.position=u_projectionCameraMatrix * position; output.vertexPosition=position.xyz; output.vertexNormal=normalize(normalPosition.xyz); output.uv=inputData.uv; output.uv1=inputData.uv1; output.vertexColor_0=inputData.vertexColor_0; let transformedTangentXYZ=(u_normalModelMatrix * vec4<f32>(inputData.vertexTangent.xyz,0.0)).xyz; output.vertexTangent=vec4<f32>( normalize(transformedTangentXYZ),inputData.vertexTangent.w ); #redgpu_if receiveShadow { let posFromLight=u_directionalLightProjectionViewMatrix * vec4(position.xyz,1.0); output.shadowPos=vec3(posFromLight.xy * vec2(0.5,-0.5) + vec2(0.5),posFromLight.z); output.receiveShadow=vertexUniforms.receiveShadow; } #redgpu_endIf { output.currentClipPos=u_noneJitterProjectionCameraMatrix * position; output.prevClipPos=u_prevNoneJitterProjectionCameraMatrix * u_prevModelMatrix * input_position_vec4; } let nodeScaleX=length(u_localMatrix[0].xyz); let nodeScaleY=length(u_localMatrix[1].xyz); let nodeScaleZ=length(u_localMatrix[2].xyz); let volumeScaleX=length(u_modelMatrix[0].xyz); let volumeScaleY=length(u_modelMatrix[1].xyz); let volumeScaleZ=length(u_modelMatrix[2].xyz); output.localNodeScale_volumeScale=vec2<f32>( pow(nodeScaleX * nodeScaleY * nodeScaleZ,1.0/3.0), pow(volumeScaleX * volumeScaleY * volumeScaleZ,1.0/3.0) ); return output;\n}\n"].join("\n")),SHADER_INFO_BASIC:parseWGSL([Fr,zr,Hr].join("\n")),SHADER_INFO_ONLY_FRAGMENT_PBR:parseWGSL([Fr,Vr,Hr].join("\n")),SHADER_INFO_ONLY_VERTEX_PBR:parseWGSL([Nr,zr,Hr].join("\n"))};Object.freeze($r);const{SHADER_INFO_PBR:Kr,SHADER_INFO_BASIC:Xr,SHADER_INFO_ONLY_FRAGMENT_PBR:jr,SHADER_INFO_ONLY_VERTEX_PBR:Yr}=$r,qr=Kr.shaderSourceVariant.getVariant("none"),Wr=Xr.shaderSourceVariant.getVariant("none"),Zr=jr.shaderSourceVariant.getVariant("none"),Jr=Yr.shaderSourceVariant.getVariant("none");class LODManager{#ps=[];#gs;#xs=!1;constructor(i,g){"InstancingMesh"===i.constructor.name&&(this.#xs=!0),this.#gs=g}get LODList(){return[...this.#ps]}addLOD(i,g,x){if(validatePositiveNumberRange(i,1),this.#ps.length>=8)throw new Error("Maximum of 8 LOD levels allowed.");if(this.#ps.some(g=>g.distance===i))throw new Error(`LOD with distance ${i} already exists.`);const _="PBR"===g.vertexBuffer.interleavedStruct.label,v=x instanceof PBRMaterial,b={distance:i,distanceSquared:i*i,geometry:g,material:x,geometryIsPBR:_,materialIsPBR:v};this.#ps.push({...b,...this.#xs?{}:{label:`vertex_${_?"pbr":"noPbr"}_fragment_${v?"pbr":"noPbr"}`,source:this.#_s(g,x)}}),this.#ps.sort((i,g)=>i.distance-g.distance),this.#gs?.()}getLOD(i){for(const g of this.#ps)if(i<g.distance)return g;return this.#ps.at(-1)}removeLOD(i){this.#ps=this.#ps.filter(g=>g.distance!==i),this.#gs?.()}clearLOD(){this.#ps.length=0,this.#gs?.()}#_s(i,g){const x="PBR"===i.vertexBuffer.interleavedStruct.label,_=g instanceof PBRMaterial;return x&&_?qr:!x&&_?Zr:x&&!_?Jr:Wr}}const Qr=Object.values(Tn);class DepthStencilState{#vs;#F="depth32float";#bs=["r8unorm","r8snorm","r8uint","r8sint","r16uint","r16sint","r16float","rg8unorm","rg8snorm","rg8uint","rg8sint","r32uint","r32sint","r32float","rg16uint","rg16sint","rg16float","rgba8unorm","rgba8unorm-srgb","rgba8snorm","rgba8uint","rgba8sint","bgra8unorm","bgra8unorm-srgb","rgb9e5ufloat","rgb10a2uint","rgb10a2unorm","rg11b10ufloat","rg32uint","rg32sint","rg32float","rgba16uint","rgba16sint","rgba16float","rgba32uint","rgba32sint","rgba32float","stencil8","depth16unorm","depth24plus","depth24plus-stencil8","depth32float","depth32float-stencil8","bc1-rgba-unorm","bc1-rgba-unorm-srgb","bc2-rgba-unorm","bc2-rgba-unorm-srgb","bc3-rgba-unorm","bc3-rgba-unorm-srgb","bc4-r-unorm","bc4-r-snorm","bc5-rg-unorm","bc5-rg-snorm","bc6h-rgb-ufloat","bc6h-rgb-float","bc7-rgba-unorm","bc7-rgba-unorm-srgb","etc2-rgb8unorm","etc2-rgb8unorm-srgb","etc2-rgb8a1unorm","etc2-rgb8a1unorm-srgb","etc2-rgba8unorm","etc2-rgba8unorm-srgb","eac-r11unorm","eac-r11snorm","eac-rg11unorm","eac-rg11snorm","astc-4x4-unorm","astc-4x4-unorm-srgb","astc-5x4-unorm","astc-5x4-unorm-srgb","astc-5x5-unorm","astc-5x5-unorm-srgb","astc-6x5-unorm","astc-6x5-unorm-srgb","astc-6x6-unorm","astc-6x6-unorm-srgb","astc-8x5-unorm","astc-8x5-unorm-srgb","astc-8x6-unorm","astc-8x6-unorm-srgb","astc-8x8-unorm","astc-8x8-unorm-srgb","astc-10x5-unorm","astc-10x5-unorm-srgb","astc-10x6-unorm","astc-10x6-unorm-srgb","astc-10x8-unorm","astc-10x8-unorm-srgb","astc-10x10-unorm","astc-10x10-unorm-srgb","astc-12x10-unorm","astc-12x10-unorm-srgb","astc-12x12-unorm","astc-12x12-unorm-srgb"];#ys=!0;#Ss=Tn.LESS_EQUAL;#Ts;#Ms;#ws;#Cs;#Ps=1;#Rs=1;#Bs=1;constructor(i){this.#vs=i}get format(){return this.#F}set format(i){this.#bs.includes(i)?(this.#F=i,this.#vs.dirtyPipeline=!0):consoleAndThrowError(`Invalid value for format. Received ${i}. Expected one of:${this.#bs.join(",")}`)}get depthWriteEnabled(){return this.#ys}set depthWriteEnabled(i){this.#ys=i,this.#vs.dirtyPipeline=!0}get depthCompare(){return this.#Ss}set depthCompare(i){Qr.includes(i)?(this.#Ss=i,this.#vs.dirtyPipeline=!0):consoleAndThrowError(`Invalid value for depthCompare. Received ${i}. Expected one of:${Qr.join(",")}`)}get stencilFront(){return this.#Ts}set stencilFront(i){this.#Ts=i,this.#vs.dirtyPipeline=!0}get stencilBack(){return this.#Ms}set stencilBack(i){this.#Ms=i,this.#vs.dirtyPipeline=!0}get stencilReadMask(){return this.#ws}set stencilReadMask(i){this.#ws=i,this.#vs.dirtyPipeline=!0}get stencilWriteMask(){return this.#Cs}set stencilWriteMask(i){this.#Cs=i,this.#vs.dirtyPipeline=!0}get depthBias(){return this.#Ps}set depthBias(i){this.#Ps=i,this.#vs.dirtyPipeline=!0}get depthBiasSlopeScale(){return this.#Rs}set depthBiasSlopeScale(i){this.#Rs=i,this.#vs.dirtyPipeline=!0}get depthBiasClamp(){return this.#Bs}set depthBiasClamp(i){this.#Bs=i,this.#vs.dirtyPipeline=!0}get state(){let i=!1;if(this.#vs?.primitiveState){const{topology:g}=this.#vs.primitiveState;i=g===Lr.TRIANGLE_LIST||g===Lr.TRIANGLE_STRIP}return{format:this.#F,depthWriteEnabled:this.#ys,depthCompare:this.#Ss,stencilFront:this.#Ts,stencilBack:this.#Ms,stencilReadMask:this.#ws,stencilWriteMask:this.#Cs,depthBias:i?this.#Ps:null,depthBiasSlopeScale:i?this.#Rs:null,depthBiasClamp:i?this.#Bs:null}}}const ei={NONE:"none",FRONT:"front",BACK:"back"};Object.freeze(ei);const ti={CW:"cw",CCW:"ccw"};Object.freeze(ti);const ni=Object.values(Dr),ri=Object.values(ti),ii=Object.values(ei),ai=["point-list","line-list","line-strip","triangle-list","triangle-strip"];class PrimitiveState{dirtyPipeline=!1;state;#vs;#Is=Lr.TRIANGLE_LIST;#Es;#Ds=ti.CCW;#Us=ei.BACK;#Ls=!1;constructor(i){this.#vs=i,this.#an()}get topology(){return this.#Is}set topology(i){ai.includes(i)?(this.#Is=i,this.#an()):consoleAndThrowError(`Invalid value for topology. Received ${i}. Expected one of:${ai.join(",")}`)}get stripIndexFormat(){return this.#Es}set stripIndexFormat(i){ni.includes(i)?(this.#Es=i,this.#an()):consoleAndThrowError(`Invalid value for stripIndexFormat. Received ${i}. Expected one of:${ni.join(",")}`)}get frontFace(){return this.#Ds}set frontFace(i){ri.includes(i)?(this.#Ds=i,this.#an()):consoleAndThrowError(`Invalid value for frontFace. Received ${i}. Expected one of:${ri.join(",")}`)}get cullMode(){return this.#Us}set cullMode(i){ii.includes(i)?(this.#Us=i,this.#an()):consoleAndThrowError(`Invalid value for cullMode. Received ${i}. Expected one of:${ii.join(",")}`)}get unclippedDepth(){return this.#Ls}set unclippedDepth(i){"boolean"==typeof i?(this.#Ls=i,this.#an()):consoleAndThrowError(`Invalid type for unclippedDepth. Received ${typeof i}. Expected type:boolean.`)}#an(){this.state={topology:this.#Is,stripIndexFormat:this.#Es,frontFace:this.#Ds,cullMode:this.#Us,unclippedDepth:this.#Ls},this.#vs.dirtyPipeline=!0}}const si=create$4(),oi={x:0,y:0,z:0,w:0},getScreenPoint=(i,g)=>{"View3D"!==i?.constructor?.name&&consoleAndThrowError("allow only View3D instance"),identity$1(si);const{noneJitterProjectionMatrix:x,rawCamera:_,pixelRectArray:v}=i;return multiply$4(si,x,_.modelMatrix),multiply$4(si,si,g),oi.z=si[14],oi.w=si[15],oi.x=.5*si[12]/oi.w+.5,oi.y=.5*si[13]/oi.w+.5,[(v[0]+oi.x*v[2])/window.devicePixelRatio,(v[1]+(1-oi.y)*v[3])/window.devicePixelRatio]},ui=create$4(),localToWorld=(i,g,x,_)=>(validateNumber(g),validateNumber(x),validateNumber(_),identity$1(ui),translate(ui,ui,[g,x,_]),multiply$4(ui,i,ui),[ui[12],ui[13],ui[14]]),li=create$4(),ci=create$3(),worldToLocal=(i,g,x,_)=>(validateNumber(g),validateNumber(x),validateNumber(_),invert$1(li,i),set$3(ci,g,x,_),transformMat4$2(ci,ci,li),[ci[0],ci[1],ci[2]]);class Object3DContainer{modelMatrix=create$4();#As=[];constructor(){}get children(){return this.#As}get numChildren(){return this.#As.length}contains(i){return this.#Gs(i),this.#As.includes(i)}addChild(i){return this.#Gs(i),this.#ks(i)?(this.#As.push(i),i.dirtyTransform=!0,i):null}addChildAt(i,g){if(validateUintRange(g),this.#As.length<g&&(g=this.#As.length),!(g<0||g>this.#As.length)&&this.#ks(i))return this.#As.splice(g,0,i),i.dirtyTransform=!0,this}getChildAt(i){if(validateUintRange(i),!(i>=this.#As.length||i<0))return this.#As[i]}getChildIndex(i){this.#Gs(i);const g=this.#As.indexOf(i);return-1===g?-1:g}setChildIndex(i,g){this.#Gs(i),validateUintRange(g);const x=this.#As.length,_=g>=x,v=this.#As.indexOf(i);-1!==v?_?consoleAndThrowError(`Invalid index. Index ${g} is out of bounds. Index should be between 0 and ${x-1}.`):(this.#As.splice(v,1),this.#As.splice(g,0,i)):consoleAndThrowError(`The provided is not a child of the Object3DContainer.:${i}`)}swapChildren(i,g){if(this.#Gs(i),this.#Gs(g),i===g)return void consoleAndThrowError("Error:child1 and child2 are the same. Cannot swap a child with itself.");const x=this.#As.indexOf(i),_=this.#As.indexOf(g);-1!==x&&-1!==_||consoleAndThrowError(`Error:${-1===x?"child1":"child2"} is not a child of this Object3DContainer.`),this.swapChildrenAt(x,_)}swapChildrenAt(i,g){validateUintRange(i),validateUintRange(g),i===g&&consoleAndThrowError("Error:index1 and index2 are identical. Cannot swap a child with itself.");const x=this.#As.length;(i>=x||g>=x)&&consoleAndThrowError(`Error:Both index1 and index2 should be less than the number of children. Provided index1:${i},index2:${g},number of children:${x}`);let _=this.#As[i];this.#As[i]=this.#As[g],this.#As[g]=_}removeChild(i){this.#Gs(i);const g=this.#As.indexOf(i);if(g>-1)return i.parent=null,this.#As.splice(g,1)[0];consoleAndThrowError("Error:Child not found within parent.")}removeChildAt(i){validateUintRange(i);const g=this.#As[i];if(g)return g.parent=null,this.#As.splice(i,1)[0];throw new Error(`Error:No child found at provided index:${i}.`)}removeAllChildren(){let i=this.#As.length;for(;i--;)this.#As[i].parent=null;return this.#As.length=0,this}#Gs(i){i instanceof Object3DContainer||consoleAndThrowError("allow only Object3DContainer instance.")}#ks=i=>(this.#Gs(i),i.parent?!!i.parent?.removeChild(i)&&(i.parent=this,!0):(i.parent=this,!0))}class MeshBase extends Object3DContainer{gpuRenderInfo;animationInfo={skinInfo:null,morphInfo:null,weightBuffer:null,jointBuffer:null,animationsList:null};gltfLoaderInfo;dirtyPipeline=!0;dirtyTransform=!0;dirtyOpacity=!0;modelMatrix=create$4();localMatrix=create$4();normalModelMatrix=create$4();#l;#c;#Os;#Ns;#Vs;#m=[];#u=createUUID();constructor(i){super(),validateRedGPUContext(i),this.#l=i,this.#c=i.gpuDevice,this.#Os=new PrimitiveState(this),this.#Ns=new DepthStencilState(this)}get uuid(){return this.#u}get currentShaderModuleName(){return this.#Vs}set currentShaderModuleName(i){this.#Vs=i}get primitiveState(){return this.#Os}get depthStencilState(){return this.#Ns}get gpuDevice(){return this.#c}get redGPUContext(){return this.#l}worldToLocal(i,g,x){return worldToLocal(this.modelMatrix,i,g,x)}localToWorld(i,g,x){return localToWorld(this.modelMatrix,i,g,x)}getScreenPoint(i){return getScreenPoint(i,this.modelMatrix)}__fireListenerList(i=!1){for(const i of this.#m)i(this);i&&(this.#m.length=0)}}const hi="shadow",fi="picking",createBasePipeline=(i,g,x,_)=>{const{redGPUContext:v}=i,{gpuDevice:b,resourceManager:y}=v,S=i.material.gpuRenderInfo;let w,L;switch(_){case hi:w="drawDirectionalShadowDepth",L=`${g.label}_shadow_pipeline`;break;case fi:w="picking",L=`${g.label}_picking_pipeline`;break;default:w="main",L=`${g.label}_pipeline`}const k={module:g,entryPoint:w,buffers:i.vertexStateBuffers},z=[y.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),x];_!==hi&&z.push(S.fragmentBindGroupLayout);const H={bindGroupLayouts:z,label:`${L}_${S.fragmentBindGroupLayout.label}`},q={label:L,layout:y.createGPUPipelineLayout(`${H.label}`,H),vertex:k,primitive:i.primitiveState.state};switch(_){case hi:q.depthStencil={depthWriteEnabled:!0,depthCompare:Tn.LESS_EQUAL,format:"depth32float"};break;case fi:i.material&&(q.fragment={module:i.material.gpuRenderInfo.fragmentShaderModule,entryPoint:"picking",targets:[{format:navigator.gpu.getPreferredCanvasFormat()}]},q.depthStencil=i.depthStencilState.state);break;default:q.fragment=S.fragmentState,q.depthStencil=i.depthStencilState.state,q.multisample={count:v.antialiasingManager.useMSAA?4:1}}return b.createRenderPipeline(q)};const getBasicMeshVertexBindGroupDescriptor=(i,g=!1)=>{const{redGPUContext:x,gpuRenderInfo:_,material:v}=i,{resourceManager:b}=x,{vertexUniformBuffer:y,vertexBindGroupLayout:S}=_,{basicSampler:w,emptyBitmapTextureView:L,emptyCubeTextureView:k}=b,{gpuSampler:z}=w;return{layout:S,label:g?"VERTEX_BIND_GROUP_DESCRIPTOR_MESH_SKIN":"VERTEX_BIND_GROUP_DESCRIPTOR_MESH",entries:g?[{binding:0,resource:{buffer:y.gpuBuffer,offset:0,size:y.size}},{binding:1,resource:getGPUResourceSampler(v?.displacementTextureSampler)||z},{binding:2,resource:b.getGPUResourceBitmapTextureView(v?.displacementTexture)||L},{binding:3,resource:{buffer:i.animationInfo.skinInfo.vertexStorageBuffer,offset:0,size:i.animationInfo.skinInfo.vertexStorageBuffer.size}},{binding:4,resource:{buffer:i.animationInfo.skinInfo.prevVertexStorageBuffer,offset:0,size:i.animationInfo.skinInfo.prevVertexStorageBuffer.size}}]:[{binding:0,resource:{buffer:y.gpuBuffer,offset:0,size:y.size}},{binding:1,resource:getGPUResourceSampler(v?.displacementTextureSampler)||z},{binding:2,resource:b.getGPUResourceBitmapTextureView(v?.displacementTexture)||L}]}},getGPUResourceSampler=i=>i?.gpuSampler,{SHADER_INFO_PBR:di,SHADER_INFO_BASIC:mi,SHADER_INFO_ONLY_FRAGMENT_PBR:pi,SHADER_INFO_ONLY_VERTEX_PBR:gi}=$r,xi=di.uniforms.vertexUniforms,_i=mi.uniforms.vertexUniforms,createMeshVertexShaderModule=i=>{const{material:g}=i;let x,_="basic";switch(g instanceof PBRMaterial&&i.animationInfo?.skinInfo?_="skin":i.createCustomMeshVertexShaderModule&&(_="custom"),_){case"basic":{const g=(i=>{const{geometry:g,material:x}=i,_="PBR"===g.vertexBuffer.interleavedStruct.label,v=x instanceof PBRMaterial,b=_&&!v,y=!_&&v;return _&&v?{name:"VERTEX_MODULE_MESH_PBR",shaderInfo:di,source:di.defaultSource,uniformStruct:xi}:y?{name:"VERTEX_MODULE_MESH_ONLY_FRAGMENT_PBR",shaderInfo:pi,source:pi.defaultSource,uniformStruct:_i}:b?{name:"VERTEX_MODULE_MESH_ONLY_VERTEX_PBR",shaderInfo:gi,source:gi.defaultSource,uniformStruct:_i}:{name:"VERTEX_MODULE_MESH",shaderInfo:mi,source:mi.defaultSource,uniformStruct:_i}})(i);x=i.createMeshVertexShaderModuleBASIC(g.name,g.shaderInfo,g.uniformStruct,g.source);break}case"skin":x=((i,g)=>{const{redGPUContext:x,currentShaderModuleName:_}=g,{resourceManager:v,gpuDevice:b}=x,{gpuRenderInfo:y}=g,S=`${g.animationInfo.skinInfo.joints.length}`,w=`${i}_${S}`,L="#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include meshVertexBasicUniform;\nconst maxDistance:f32=1000.0;\nconst maxMipLevel:f32=10.0;\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\n@group(1) @binding(1) var displacementTextureSampler:sampler;\n@group(1) @binding(2) var displacementTexture:texture_2d<f32>;\n@group(1) @binding(3) var<storage,read> vertexStorages:array<mat4x4<f32>>;\n@group(1) @binding(4) var<storage,read> prevVertexStorages:array<mat4x4<f32>>;\nstruct InputDataSkin { @builtin(vertex_index) idx:u32, @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(3) uv1:vec2<f32>, @location(4) vertexColor_0:vec4<f32>, @location(5) vertexTangent:vec4<f32>,\n};\nstruct OutputDataSkin { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(3) uv1:vec2<f32>, @location(4) vertexColor_0:vec4<f32>, @location(5) vertexTangent:vec4<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(10) localNodeScale_volumeScale:vec2<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(14) @interpolate(flat) receiveShadow:f32, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\nstruct OutputShadowData { @builtin(position) position:vec4<f32>,\n};\n@vertex\nfn main(inputData:InputDataSkin) -> OutputDataSkin { var output:OutputDataSkin; let input_position=inputData.position; let input_position_vec4=vec4<f32>(input_position,1.0); let input_vertexNormal=inputData.vertexNormal; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_noneJitterProjectionCameraMatrix=systemUniforms.noneJitterProjectionCameraMatrix; let u_prevNoneJitterProjectionCameraMatrix=systemUniforms.prevNoneJitterProjectionCameraMatrix; let u_resolution=systemUniforms.resolution; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_matrixList=vertexUniforms.matrixList; let u_localMatrix=u_matrixList.localMatrix; let u_modelMatrix=u_matrixList.modelMatrix; let u_prevModelMatrix=u_matrixList.prevModelMatrix; let u_normalModelMatrix=u_matrixList.normalModelMatrix; let u_receiveShadow=vertexUniforms.receiveShadow; let u_directionalLightCount=systemUniforms.directionalLightCount; let u_directionalLights=systemUniforms.directionalLights; let u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix; let skinMat=vertexStorages[inputData.idx]; let prevSkinMat=prevVertexStorages[inputData.idx]; let skinnedPosition=(skinMat * vec4<f32>(inputData.position,1.0)); let position=u_modelMatrix * skinnedPosition; let skinnedNormal=(skinMat * vec4<f32>(input_vertexNormal,0.0)).xyz; let transformedNormal=normalize((u_normalModelMatrix * vec4<f32>(skinnedNormal,0.0)).xyz); output.vertexNormal=transformedNormal; let skinnedTangent=(skinMat * vec4<f32>(inputData.vertexTangent.xyz,0.0)).xyz; let transformedTangentXYZ=(u_normalModelMatrix * vec4<f32>(skinnedTangent,0.0)).xyz; output.vertexTangent=vec4<f32>(normalize(transformedTangentXYZ),inputData.vertexTangent.w); output.position=u_projectionCameraMatrix * position; output.vertexPosition=position.xyz; output.uv=inputData.uv; output.uv1=inputData.uv1; output.vertexColor_0=inputData.vertexColor_0; #redgpu_if receiveShadow { let posFromLight=u_directionalLightProjectionViewMatrix * vec4(position.xyz,1.0); output.shadowPos=vec3(posFromLight.xy * vec2(0.5,-0.5) + vec2(0.5),posFromLight.z); output.receiveShadow=vertexUniforms.receiveShadow; } #redgpu_endIf { output.currentClipPos=u_noneJitterProjectionCameraMatrix * position; output.prevClipPos=u_prevNoneJitterProjectionCameraMatrix * u_prevModelMatrix * (prevSkinMat * input_position_vec4); } let nodeScaleX=length(u_localMatrix[0].xyz); let nodeScaleY=length(u_localMatrix[1].xyz); let nodeScaleZ=length(u_localMatrix[2].xyz); let volumeScaleX=length(u_modelMatrix[0].xyz); let volumeScaleY=length(u_modelMatrix[1].xyz); let volumeScaleZ=length(u_modelMatrix[2].xyz); output.localNodeScale_volumeScale=vec2<f32>( pow(nodeScaleX * nodeScaleY * nodeScaleZ,1.0/3.0), pow(volumeScaleX * volumeScaleY * volumeScaleZ,1.0/3.0) ); return output;\n}\n@vertex\nfn drawDirectionalShadowDepth(inputData:InputDataSkin) -> OutputShadowData { var output:OutputShadowData; let u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let input_position=inputData.position;\nlet skinMat=vertexStorages[inputData.idx]; let position=u_modelMatrix * skinMat * vec4<f32>(input_position,1.0); output.position=u_directionalLightProjectionViewMatrix * position; return output;\n}\n@vertex\nfn picking(inputData:InputDataSkin) -> OutputDataSkin { var output:OutputDataSkin; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix;\nlet skinMat=vertexStorages[inputData.idx]; let position=u_modelMatrix * skinMat * vec4<f32>(inputData.position,1.0); output.position=u_projectionCameraMatrix * position; output.pickingId=unpack4x8unorm(vertexUniforms.pickingId); return output;\n}\n",k={code:L};if(_===w)return v.getGPUShaderModule(w);k.code=L.replaceAll("#JOINT_NUM",S),y.vertexUniformInfo=parseWGSL(k.code).uniforms.vertexUniforms,g.animationInfo.skinInfo?(createMeshVertexUniformBuffers(g,!0),g.animationInfo.skinInfo.vertexStorageInfo=parseWGSL(k.code).storage.vertexStorages,g.animationInfo.skinInfo.vertexStorageBuffer=b.createBuffer({size:16*g.geometry.vertexBuffer.vertexCount*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),g.animationInfo.skinInfo.prevVertexStorageBuffer=b.createBuffer({size:16*g.geometry.vertexBuffer.vertexCount*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),y.vertexUniformBindGroup=x.gpuDevice.createBindGroup(getBasicMeshVertexBindGroupDescriptor(g,!0))):(createMeshVertexUniformBuffers(g),y.vertexUniformBindGroup=x.gpuDevice.createBindGroup(getBasicMeshVertexBindGroupDescriptor(g)));const z=v.createGPUShaderModule(w,k);return g.gpuRenderInfo.vertexShaderModule=z,g.gpuRenderInfo.vertexShaderModule})("VERTEX_MODULE_MESH_PBR_SKIN",i);break;case"custom":x=i.createCustomMeshVertexShaderModule()}return i.currentShaderModuleName=x.label,x},updateMeshDirtyPipeline=(i,g)=>{const{material:x,gpuRenderInfo:_,redGPUContext:v}=i,{resourceManager:b}=v;i.dirtyTransform=!0,x.dirtyPipeline&&x._updateFragmentState();const y=createMeshVertexShaderModule(i),S=b.getGPUBindGroupLayout(i.animationInfo.skinInfo?ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_SKIN:ResourceManager.PRESET_VERTEX_GPUBindGroupLayout);_.vertexShaderModule=y,_.pipeline=createBasePipeline(i,y,S),_.shadowPipeline=null,_.pickingPipeline=null;const{vertexUniformInfo:w}=i.gpuRenderInfo,{members:L}=w;for(const g in L)"pickingId"!==g&&"pixelSize"!==g&&(i[g]=i[g]);i.gpuRenderInfo.vertexUniformInfo.members.pickingId&&i.gpuRenderInfo.vertexUniformBuffer.writeOnlyBuffer(i.gpuRenderInfo.vertexUniformInfo.members.pickingId,i.pickingId),x.dirtyPipeline=!1,i.dirtyPipeline=!1,g&&g.numDirtyPipelines++};class VertexGPURenderInfo{vertexShaderModule;vertexShaderSourceVariant;vertexShaderVariantConditionalBlocks;vertexStructInfo;vertexUniformInfo;vertexBindGroupLayout;vertexUniformBindGroup;vertexUniformBuffer;pipeline;shadowPipeline;pickingPipeline;constructor(i,g,x,_,v,b,y,S,w,L){this.vertexShaderModule=i,this.vertexShaderSourceVariant=g,this.vertexShaderVariantConditionalBlocks=x,this.vertexUniformInfo=_,this.vertexBindGroupLayout=v,this.vertexUniformBindGroup=y,this.vertexUniformBuffer=b,this.pipeline=S,this.shadowPipeline=w,this.pickingPipeline=L}}Object.freeze(VertexGPURenderInfo);const vi="VERTEX_MODULE_MESH_PBR_SKIN",bi=Math.PI/180,yi=3.141592653589793,Si=6.283185307179586,Ti=.225,Mi=1.27323954,wi=.405284735,Ci=1.5707963267948966,Pi=new Float32Array(1),Ri=new Float32Array(4),Bi=new Float32Array([0,1,0]);class Mesh extends MeshBase{displacementTexture;castShadow=!1;dirtyLOD=!1;passFrustumCulling=!0;createCustomMeshVertexShaderModule;#f;#h;#Fs;#Nt=0;#Vt=0;#Ft=0;#zs=new Float32Array([0,0,0]);#Hs=0;#$s=0;#Ks=0;#Xs;#js=1;#Ys=1;#qs=1;#Ws=new Float32Array([1,1,1]);#Ui=0;#Li=0;#Ai=0;#Zs=new Float32Array([0,0,0]);#Js={};#Qs=0;#eo=!1;#to=1;#no;#ro=!1;#io;#ao;#so;#oo;#uo;#lo=[];#co=[];#ho;#fo=null;#do=[];#mo=null;#po=!0;#go=!0;#xo;#_o;#vo;#bo=[];#yo=-1;constructor(i,g,x,_){super(i),_&&(this.name=_),this._geometry=g,this._material=x,this.#Xs=uuidToUint(this.uuid),this.#mo=DrawBufferManager.getInstance(i),this.#So(),this.#vo=new LODManager(this,()=>{this.dirtyLOD=!0})}get LODManager(){return this.#vo}get enableDebugger(){return this.#ro}set enableDebugger(i){this.#ro=i,i&&!this.#no&&(this.#no=new DrawDebuggerMesh(this.redGPUContext,this))}get drawDebugger(){return this.#no}_material;get material(){return this._material}set material(i){this._material=i,this.dirtyPipeline=!0,"blendMode"in this&&(this.blendMode=this.blendMode)}_geometry;get geometry(){return this._geometry}set geometry(i){this._geometry=i,this.dirtyPipeline=!0,this.dirtyTransform=!0}get opacity(){return this.#to}set opacity(i){validatePositiveNumberRange(i,0,1),this.#to=i,this.dirtyOpacity=!0}get ignoreFrustumCulling(){return this.#eo}set ignoreFrustumCulling(i){this.#eo=i}get pickingId(){return this.#Xs}get events(){return this.#Js}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get vertexStateBuffers(){return this._geometry.gpuRenderInfo.buffers}get parent(){return this.#Fs}set parent(i){this.#Fs=i}get pivotX(){return this.#Hs}set pivotX(i){this.#Hs=i,this.dirtyTransform=!0}get pivotY(){return this.#$s}set pivotY(i){this.#$s=i,this.dirtyTransform=!0}get pivotZ(){return this.#Ks}set pivotZ(i){this.#Ks=i,this.dirtyTransform=!0}get x(){return this.#Nt}set x(i){this.#Nt=this.#zs[0]=i,this.dirtyTransform=!0}get y(){return this.#Vt}set y(i){this.#Vt=this.#zs[1]=i,this.dirtyTransform=!0}get z(){return this.#Ft}set z(i){this.#Ft=this.#zs[2]=i,this.dirtyTransform=!0}get position(){return this.#zs}get scaleX(){return this.#js}set scaleX(i){this.#js=this.#Ws[0]=i,this.dirtyTransform=!0}get scaleY(){return this.#Ys}set scaleY(i){this.#Ys=this.#Ws[1]=i,this.dirtyTransform=!0}get scaleZ(){return this.#qs}set scaleZ(i){this.#qs=this.#Ws[2]=i,this.dirtyTransform=!0}get scale(){return this.#Ws}get rotationX(){return this.#Ui}set rotationX(i){this.#Ui=this.#Zs[0]=i%360,this.dirtyTransform=!0}get rotationY(){return this.#Li}set rotationY(i){this.#Li=this.#Zs[1]=i%360,this.dirtyTransform=!0}get rotationZ(){return this.#Ai}set rotationZ(i){this.#Ai=this.#Zs[2]=i%360,this.dirtyTransform=!0}get rotation(){return this.#Zs}get boundingOBB(){return this.#ao&&!this.dirtyTransform||(this.#ao=null,this.#io=null,this.#ao=calculateMeshOBB(this)),this.#ao}get boundingAABB(){return this.#io&&!this.dirtyTransform||(this.#ao=null,this.#io=null,this.#io=calculateMeshAABB(this)),this.#io}get combinedBoundingAABB(){return calculateMeshCombinedAABB(this)}setEnableDebuggerRecursively(i=!1){"enableDebugger"in this&&(this.enableDebugger=i),this.children&&this.children.forEach(g=>{g.setEnableDebuggerRecursively(i)})}setCastShadowRecursively(i=!1){"castShadow"in this&&(this.castShadow=i),this.children&&this.children.forEach(g=>{g.setCastShadowRecursively(i)})}setReceiveShadowRecursively(i=!1){"receiveShadow"in this&&(this.receiveShadow=i),this.children&&this.children.forEach(g=>{g.setReceiveShadowRecursively(i)})}setIgnoreFrustumCullingRecursively(i=!1){"ignoreFrustumCulling"in this&&(this.ignoreFrustumCulling=i),this.children&&this.children.forEach(g=>{g.setIgnoreFrustumCullingRecursively(i)})}getCombinedOpacity(){if(this.is2DMeshType){const i=this.parent;return this.#to*(i?.getCombinedOpacity?i.getCombinedOpacity():1)}return 1}addListener(i,g){this.#Js[i]=g,this.#Qs=Object.keys(this.#Js).length}lookAt(i,g,x){var _,v=[];v[0]=i,v[1]=g,v[2]=x,identity$1(this.localMatrix),targetTo(this.localMatrix,[this.#Nt,this.#Vt,this.#Ft],v,Bi),_=mat4ToEuler(this.localMatrix,[]),this.rotationX=180*_[0]/Math.PI,this.rotationY=180*_[1]/Math.PI,this.rotationZ=180*_[2]/Math.PI}setScale(i,g,x){g=g??i,x=x??i;const _=this.#Ws;this.#js=_[0]=i,this.#Ys=_[1]=g,this.#qs=_[2]=x,this.dirtyTransform=!0}setPosition(i,g,x){g=g??i,x=x??i;const _=this.#zs;this.#Nt=_[0]=i,this.#Vt=_[1]=g,this.#Ft=_[2]=x,this.dirtyTransform=!0}setRotation(i,g,x){g=g??i,x=x??i;const _=this.#Zs;this.#Ui=_[0]=i,this.#Li=_[1]=g,this.#Ai=_[2]=x,this.dirtyTransform=!0}clone(){const i=new Mesh(this.redGPUContext,this._geometry,this._material);i.setPosition(this.#Nt,this.#Vt,this.#Ft),i.setRotation(this.#Ui,this.#Li,this.#Ai),i.setScale(this.#js,this.#Ys,this.#qs);let g=this.children.length;for(;g--;)i.addChild(this.children[g].clone());return i}render(i){const{redGPUContext:g}=this,{view:x,isScene2DMode:_,frustumPlanes:v,dirtyVertexUniformFromMaterial:b,useDistanceCulling:y,cullingDistanceSquared:S}=i,{antialiasingManager:w,gpuDevice:L}=g,{scene:k}=x,{shadowManager:z}=k,{directionalShadowManager:H}=z,{pickingManager:q}=x,{castingList:W}=H,be=this._geometry,Ke=this._material,{uuid:Xe}=Ke||{};let je,Ye,Ze=this.dirtyPipeline;const{skinInfo:Je}=this.animationInfo;if(_&&(this.#Ft=0,this.#Ks=0,this.depthStencilState.depthWriteEnabled&&(this.depthStencilState.depthWriteEnabled=!1)),this.dirtyTransform){je=!0,this.#po=!0,this.#go=!0;{const{pixelRectObject:i}=x,g=this.parent,v=this.localMatrix;let b,y,S,w,L,k,z,H,q,W,be,Ke,Xe,je,Ye,Ze,Je,Qe,et,tt,it,ft,pt,xt,vt,bt,yt,St,Tt,Mt,wt,Ct,Pt,Rt,Bt,It,Et,Dt,Ut;v[12]=this.#Nt,v[13]=this.#Vt,v[14]=this.#Ft,v[15]=1,b=this.#Ui*bi,y=this.#Li*bi,S=this.#Ai*bi,pt=1,xt=0,vt=0,yt=0,St=1,Tt=0,wt=0,Ct=0,Pt=1,Ut=b%Si,Ut<-yi?Ut+=Si:Ut>yi&&(Ut-=Si),Ut=Ut<0?Mi*Ut+wi*Ut*Ut:Mi*Ut-wi*Ut*Ut,w=Ut<0?Ti*(Ut*-Ut-Ut)+Ut:Ti*(Ut*Ut-Ut)+Ut,Ut=(b+Ci)%Si,Ut<-yi?Ut+=Si:Ut>yi&&(Ut-=Si),Ut=Ut<0?Mi*Ut+wi*Ut*Ut:Mi*Ut-wi*Ut*Ut,z=Ut<0?Ti*(Ut*-Ut-Ut)+Ut:Ti*(Ut*Ut-Ut)+Ut,Ut=y%Si,Ut<-yi?Ut+=Si:Ut>yi&&(Ut-=Si),Ut=Ut<0?Mi*Ut+wi*Ut*Ut:Mi*Ut-wi*Ut*Ut,L=Ut<0?Ti*(Ut*-Ut-Ut)+Ut:Ti*(Ut*Ut-Ut)+Ut,Ut=(y+Ci)%Si,Ut<-yi?Ut+=Si:Ut>yi&&(Ut-=Si),Ut=Ut<0?Mi*Ut+wi*Ut*Ut:Mi*Ut-wi*Ut*Ut,H=Ut<0?Ti*(Ut*-Ut-Ut)+Ut:Ti*(Ut*Ut-Ut)+Ut,Ut=S%Si,Ut<-yi?Ut+=Si:Ut>yi&&(Ut-=Si),Ut=Ut<0?Mi*Ut+wi*Ut*Ut:Mi*Ut-wi*Ut*Ut,k=Ut<0?Ti*(Ut*-Ut-Ut)+Ut:Ti*(Ut*Ut-Ut)+Ut,Ut=(S+Ci)%Si,Ut<-yi?Ut+=Si:Ut>yi&&(Ut-=Si),Ut=Ut<0?Mi*Ut+wi*Ut*Ut:Mi*Ut-wi*Ut*Ut,q=Ut<0?Ti*(Ut*-Ut-Ut)+Ut:Ti*(Ut*Ut-Ut)+Ut,je=H*q,Ye=z*k+w*L*q,Ze=w*k-z*L*q,Je=-H*k,Qe=z*q-w*L*k,et=w*q+z*L*k,tt=L,it=-w*H,ft=z*H;let Lt=this.#js,At=this.#Ys,Gt=this.#qs;if(this.renderTextureWidth&&(Lt*=this.renderTextureWidth,At*=this.renderTextureHeight),v[0]=je*Lt,v[1]=Ye*Lt,v[2]=Ze*Lt,v[3]=0,v[4]=Je*At,v[5]=Qe*At,v[6]=et*At,v[7]=0,v[8]=tt*Gt,v[9]=it*Gt,v[10]=ft*Gt,v[11]=0,(this.#Hs||this.#$s||this.#Ks)&&(pt=v[0],xt=v[1],vt=v[2],bt=v[3],yt=v[4],St=v[5],Tt=v[6],Mt=v[7],wt=v[8],Ct=v[9],Pt=v[10],Rt=v[11],Bt=v[12],It=v[13],Et=v[14],Dt=v[15],W=1,be=0,Ke=0,Xe=0,v[0]=W*pt+be*yt+Ke*wt+Xe*Bt,v[1]=W*xt+be*St+Ke*Ct+Xe*It,v[2]=W*vt+be*Tt+Ke*Pt+Xe*Et,v[3]=W*bt+be*Mt+Ke*Rt+Xe*Dt,W=0,be=1,Ke=0,Xe=0,v[4]=W*pt+be*yt+Ke*wt+Xe*Bt,v[5]=W*xt+be*St+Ke*Ct+Xe*It,v[6]=W*vt+be*Tt+Ke*Pt+Xe*Et,v[7]=W*bt+be*Mt+Ke*Rt+Xe*Dt,W=0,be=0,Ke=1,Xe=0,v[8]=W*pt+be*yt+Ke*wt+Xe*Bt,v[9]=W*xt+be*St+Ke*Ct+Xe*It,v[10]=W*vt+be*Tt+Ke*Pt+Xe*Et,v[11]=W*bt+be*Mt+Ke*Rt+Xe*Dt,_?g?.modelMatrix?(W=-this.#Hs,be=-this.#$s,Ke=-this.#Ks,Xe=1):(W=-this.#Hs/b,be=-this.#$s/y,Ke=-this.#Ks,Xe=1):(W=-this.#Hs,be=-this.#$s,Ke=-this.#Ks,Xe=1),v[12]=W*pt+be*yt+Ke*wt+Xe*Bt,v[13]=W*xt+be*St+Ke*Ct+Xe*It,v[14]=W*vt+be*Tt+Ke*Pt+Xe*Et,v[15]=W*bt+be*Mt+Ke*Rt+Xe*Dt),g?.modelMatrix){const i=g.modelMatrix,x=this.localMatrix,_=this.modelMatrix,v=i[0],b=i[1],y=i[2],S=i[3],w=i[4],L=i[5],k=i[6],z=i[7],H=i[8],q=i[9],W=i[10],be=i[11],Ke=i[12],Xe=i[13],je=i[14],Ye=i[15];let Ze=x[0],Je=x[1],Qe=x[2],et=x[3];_[0]=Ze*v+Je*w+Qe*H+et*Ke,_[1]=Ze*b+Je*L+Qe*q+et*Xe,_[2]=Ze*y+Je*k+Qe*W+et*je,_[3]=Ze*S+Je*z+Qe*be+et*Ye,Ze=x[4],Je=x[5],Qe=x[6],et=x[7],_[4]=Ze*v+Je*w+Qe*H+et*Ke,_[5]=Ze*b+Je*L+Qe*q+et*Xe,_[6]=Ze*y+Je*k+Qe*W+et*je,_[7]=Ze*S+Je*z+Qe*be+et*Ye,Ze=x[8],Je=x[9],Qe=x[10],et=x[11],_[8]=Ze*v+Je*w+Qe*H+et*Ke,_[9]=Ze*b+Je*L+Qe*q+et*Xe,_[10]=Ze*y+Je*k+Qe*W+et*je,_[11]=Ze*S+Je*z+Qe*be+et*Ye,Ze=x[12],Je=x[13],Qe=x[14],et=x[15],_[12]=Ze*v+Je*w+Qe*H+et*Ke,_[13]=Ze*b+Je*L+Qe*q+et*Xe,_[14]=Ze*y+Je*k+Qe*W+et*je,_[15]=Ze*S+Je*z+Qe*be+et*Ye}else{const{modelMatrix:i,localMatrix:g}=this;i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7],i[8]=g[8],i[9]=g[9],i[10]=g[10],i[11]=g[11],i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15]}}be||(this.#go=!1),this.dirtyTransform=!1,this.#io=null,this.#ao=null}if(w.useTAA&&this.#xo){const{gpuRenderInfo:i}=this,{vertexUniformBuffer:x,vertexUniformInfo:_}=i,{members:v}=_,{members:b}=v.matrixList;this.#so&&b.prevModelMatrix&&(this.#xo.set(this.#so,b.prevModelMatrix.uniformOffsetForData/Float32Array.BYTES_PER_ELEMENT),this.#go||g.gpuDevice.queue.writeBuffer(x.gpuBuffer,b.prevModelMatrix.uniformOffset,this.#so));{this.#so||(this.#so=new Float32Array(16));const i=this.#so,g=this.modelMatrix;i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7],i[8]=g[8],i[9]=g[9],i[10]=g[10],i[11]=g[11],i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15]}}else this.#so=null;let Qe=this.passFrustumCulling=!0,et=0;const tt=this.#vo.LODList,it=tt.length;if(y&&be||this.#vo.LODList.length){const{rawCamera:i}=x,g=this.boundingAABB,_=i.x-g.centerX,v=i.y-g.centerY,b=i.z-g.centerZ;et=_*_+v*v+b*b}if(y&&be){const i=this.boundingAABB.geometryRadius;et>S+i*i&&(Qe=!1)}if(v&&Qe&&!this.#eo){const{rawCamera:i}=x,g=this.boundingAABB;if(i instanceof IsometricController){const{centerX:x,centerY:_,centerZ:v,geometryRadius:b}=g,y=i,{left:S,right:w,top:L,bottom:k,nearClipping:z,farClipping:H}=y,{x:q,y:W,z:be}=y;{const i=x-q,g=_-W,y=v-be,Ke=45*(Math.PI/180),Xe=Math.cos(Ke),je=Math.sin(Ke),Ye=i*Xe+y*je,Ze=-i*je+y*Xe;(Ye+b<S||Ye-b>w||g+b<k||g-b>L||Ze+b<z||Ze-b>H)&&(Qe=!1)}}else{const i=v[0],x=v[1],_=v[2],b=v[3],y=v[4],S=v[5],w=g.centerX,L=g.centerY,k=g.centerZ,z=g.geometryRadius;(i[0]*w+i[1]*L+i[2]*k+i[3]<=-z||x[0]*w+x[1]*L+x[2]*k+x[3]<=-z||_[0]*w+_[1]*L+_[2]*k+_[3]<=-z||b[0]*w+b[1]*L+b[2]*k+b[3]<=-z||y[0]*w+y[1]*L+y[2]*k+y[3]<=-z||S[0]*w+S[1]*L+S[2]*k+S[3]<=-z)&&(Qe=!1)}}Qe&&(this.gltfLoaderInfo?.activeAnimations?.length&&(i.animationList[i.animationList.length]=this.gltfLoaderInfo?.activeAnimations),Je&&(this.currentShaderModuleName.includes(vi)||(Ze=!0),this.currentShaderModuleName===`${vi}_${Je.joints?.length}`&&(i.skinList[i.skinList.length]=this,je=!1))),this.passFrustumCulling=Qe;const{displacementTexture:ft,displacementScale:pt}=Ke||{};if((Ze||Ke?.dirtyPipeline||b[Xe])&&(b[Xe]=!0),be){i.num3DObjects++,w.changedMSAA&&(Ze=!0,this.dirtyLOD=!0),this.gpuRenderInfo||this.initGPURenderInfos();const g=!!ft;this.useDisplacementTexture!==g&&(this.useDisplacementTexture=g,Ze=!0),(Ze||b[Xe])&&(updateMeshDirtyPipeline(this,i),this.#oo=null,this.#uo=null);{const{gpuRenderInfo:i}=this,{vertexUniformBuffer:g,vertexUniformInfo:x}=i,{members:_}=x,{gpuBuffer:v}=g;if(this.#xo||(this.#xo=new Float32Array(_.matrixList.endOffset/Float32Array.BYTES_PER_ELEMENT)),_.uvTransform&&(Ke.dirtyTextureTransform||b[Xe])){const i=Ke,g=i.textureOffset,x=i.textureScale;g&&(b[Xe]=!0,Ri[0]=g[0],Ri[1]=g[1],Ri[2]=x[0],Ri[3]=x[1],L.queue.writeBuffer(v,_.uvTransform.uniformOffset,Ri),Ke.dirtyTextureTransform=!1)}}}else i.num3DGroups++;if(be&&Qe){const{gpuRenderInfo:g}=this,{vertexUniformBuffer:_,vertexUniformInfo:v}=g,{members:b}=v,{members:y}=b.matrixList,{gpuBuffer:S}=_;if(this.#xo||(this.#xo=new Float32Array(b.matrixList.endOffset/Float32Array.BYTES_PER_ELEMENT)),void 0!==b.displacementScale&&this.#_o!==pt&&(this.#_o=pt,Pi[0]=pt,L.queue.writeBuffer(S,b.displacementScale.uniformOffset,Pi)),this.#go){{const i=this.is2DMeshType?multiply$4(create$4(),this.modelMatrix,fromValues$4(this.width,0,0,0,0,this.height,0,0,0,0,1,0,0,0,0,1)):this.modelMatrix;this.#xo.set(i,y.modelMatrix.uniformOffsetForData/Float32Array.BYTES_PER_ELEMENT)}if(this.#po&&y.normalModelMatrix){this.#po=!1;const i=this.modelMatrix,g=this.normalModelMatrix,x=i[0],_=i[1],v=i[2],b=i[4],y=i[5],S=i[6],w=i[8],L=i[9],k=i[10],z=x*(y*k-S*L)-_*(b*k-S*w)+v*(b*L-y*w);if(0===z)g[0]=1,g[1]=0,g[2]=0,g[3]=0,g[4]=0,g[5]=1,g[6]=0,g[7]=0,g[8]=0,g[9]=0,g[10]=1,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1;else{const i=1/z;g[0]=(y*k-S*L)*i,g[1]=(S*w-b*k)*i,g[2]=(b*L-y*w)*i,g[3]=0,g[4]=(v*L-_*k)*i,g[5]=(x*k-v*w)*i,g[6]=(_*w-x*L)*i,g[7]=0,g[8]=(_*S-v*y)*i,g[9]=(v*b-x*S)*i,g[10]=(x*y-_*b)*i,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1}}this.#xo.set(this.normalModelMatrix,y.normalModelMatrix.uniformOffsetForData/Float32Array.BYTES_PER_ELEMENT),y.localMatrix&&this.#xo.set(this.localMatrix,y.localMatrix.uniformOffsetForData/Float32Array.BYTES_PER_ELEMENT),je=!0,this.#go=!1,L.queue.writeBuffer(S,b.matrixList.startOffset,this.#xo)}this.dirtyOpacity&&(Ye=!0,b.combinedOpacity&&(Pi[0]=this.getCombinedOpacity(),L.queue.writeBuffer(S,b.combinedOpacity.uniformOffset,Pi)),this.dirtyOpacity=!1);const{bundleListRender2PathLayer:w,bundleListParticleLayer:k,bundleListTransparentLayer:z,bundleListAlphaLayer:H,bundleListBasicList:W}=i;{const{fragmentUniformBindGroup:g}=Ke.gpuRenderInfo;if((!this.#oo||Ze||this.#ho!==g||this.#co[i.viewIndex]!==x.systemUniform_Vertex_UniformBindGroup||this.dirtyLOD)&&this.#To(i),i.numDrawCalls++,be.indexBuffer){const{indexBuffer:g}=be,{indexCount:x,triangleCount:_}=g;i.numTriangles+=_,i.numPoints+=x}else{const{vertexBuffer:g}=be,{vertexCount:x,triangleCount:_}=g;i.numTriangles+=_,i.numPoints+=x}let _=this.#uo;if(it){let i=this.#yo;(i<0||i>=it)&&(i=-1);let g=!1;if(-1===i)et>=tt[0].distanceSquared&&(g=!0);else if(i===it-1)et<tt[i].distanceSquared&&(g=!0);else{const x=tt[i].distanceSquared,_=tt[i+1].distanceSquared;(et<x||et>=_)&&(g=!0)}if(g){let g=-1;for(let i=0;i<it&&et>=tt[i].distanceSquared;i++)g=i;g!==i&&(this.#yo=g,g>=0&&g<it&&(_=this.#lo[g]))}else i>=0&&i<it&&(_=this.#lo[i])}Ke.use2PathRender?w[w.length]=_:this.meshType===Gr.PARTICLE?k[k.length]=_:Ke.transparent?(z[z.length]=_,_.mesh=this):2===Ke.alphaBlend||Ke.opacity<1||!this.depthStencilState.depthWriteEnabled?H[H.length]=_:W[W.length]=_}this.#Qs&&(q.castingList[q.castingList.length]=this)}(this.castShadow||this.castShadow&&!be)&&(W[W.length]=this),this.#ro&&this.#no.render(i);const{children:xt}=this;let vt=0;const bt=xt.length;for(this.dirtyTransform=!1;vt<bt;vt++){const g=xt[vt];je&&(g.dirtyTransform=je),Ye&&(g.dirtyOpacity=Ye),g.render(i)}}initGPURenderInfos(){this.gpuRenderInfo=new VertexGPURenderInfo(null,null,null,null,null,null,null,null),updateMeshDirtyPipeline(this)}createMeshVertexShaderModuleBASIC=(i,g,x,_)=>{const{redGPUContext:v}=this,{gpuRenderInfo:b}=this;return b.vertexUniformInfo!==x&&(b.vertexUniformInfo=x,b.vertexStructInfo=g,createMeshVertexUniformBuffers(this)),b.vertexShaderSourceVariant=g.shaderSourceVariant,b.vertexShaderVariantConditionalBlocks=g.conditionalBlocks,b.vertexUniformBindGroup=v.gpuDevice.createBindGroup(getBasicMeshVertexBindGroupDescriptor(this)),this.#En(i),this.gpuRenderInfo.vertexShaderModule};#Mo(i,g){let x=g-i;for(;x>180;)x-=360;for(;x<-180;)x+=360;return i+x}#wo=()=>{const{gpuDevice:i,redGPUContext:g}=this,{resourceManager:x}=g;this.#bo.length=0;const _=x.getGPUBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout);this.LODManager.LODList.forEach((i,v)=>{const b={code:i.source},y=x.createGPUShaderModule(i.label,b);this.#bo[v]={pipeline:createBasePipeline({vertexStateBuffers:i.geometry.gpuRenderInfo.buffers,primitiveState:this.primitiveState,depthStencilState:this.depthStencilState,geometry:i.geometry,material:i.material||this.material,redGPUContext:g,gpuRenderInfo:this.gpuRenderInfo},y,_),vertexUniformBindGroup:g.gpuDevice.createBindGroup(getBasicMeshVertexBindGroupDescriptor({redGPUContext:g,material:i.material||this.material,gpuRenderInfo:{vertexBindGroupLayout:_,vertexUniformBuffer:this.gpuRenderInfo.vertexUniformBuffer}}))}}),this.#yo=-1};#To(i){const{view:g}=i;this.#uo=this.#Co(g,this._geometry,this._material),this.dirtyLOD&&(this.#wo(),this.dirtyLOD=!1),this.#lo.length=0,this.LODManager.LODList.forEach((i,x)=>{this.#lo[x]=this.#Co(g,i.geometry,i.material||this._material,x)})}#Co(i,g,x,_=null){const{gpuDevice:v}=this.redGPUContext,{renderViewStateData:b}=i,{vertexBuffer:y,indexBuffer:S}=g,{fragmentUniformBindGroup:w}=x.gpuRenderInfo;this.#Po(g,_);const L=null!==_,k=v.createRenderBundleEncoder({...i.basicRenderBundleEncoderDescriptor,label:this.uuid});L||(this.#oo=k,this.#co[b.viewIndex]=i.systemUniform_Vertex_UniformBindGroup,this.#ho=w);const{gpuBuffer:z}=y,H=L?this.#bo[_].pipeline:this.gpuRenderInfo.pipeline,q=L?this.#bo[_].vertexUniformBindGroup:this.gpuRenderInfo.vertexUniformBindGroup;k.setPipeline(H),k.setVertexBuffer(0,z),this.particleBuffers?.length&&this.particleBuffers.forEach((i,g)=>{k.setVertexBuffer(g+1,i)}),k.setBindGroup(0,i.systemUniform_Vertex_UniformBindGroup),k.setBindGroup(1,q),k.setBindGroup(2,w);let W=this.#fo;if(null!==_&&(W=this.#do[_]),S){const{gpuBuffer:i,format:g}=S;k.setIndexBuffer(i,g),k.drawIndexedIndirect(W.buffer,4*W.commandOffset)}else k.drawIndirect(W.buffer,4*W.commandOffset);const be=k.finish({label:`${this.name}_LOD${_||0}`});return be.mesh=null,be}#So(){this.#fo||(this.#fo=this.#mo.allocateDrawCommand(this.name))}#Po(i,g=null){const{vertexBuffer:x,indexBuffer:_}=i,v=this.#mo;let b=this.#fo;if(null!==g&&(this.#do[g]||(this.#do[g]=this.#mo.allocateDrawCommand(`${this.name}_LOD${g}`)),b=this.#do[g]),this.#So(),_){const{indexCount:i}=_;this.particleBuffers?v.setIndexedIndirectCommand(b,i,this.particleNum,0,0,0):v.setIndexedIndirectCommand(b,i,1,0,0,0)}else{const{vertexCount:i}=x;v.setIndirectCommand(b,i,1,0,0)}}#En(i){const{gpuDevice:g,resourceManager:x}=this.redGPUContext,_=this.#Dn(),v=`${i}_${_}`;let b=x.getGPUShaderModule(v);if(!b){let i=this.gpuRenderInfo.vertexShaderSourceVariant.getVariant(_);if(i)if(this.animationInfo?.skinInfo){const g=`${this.animationInfo.skinInfo.joints.length}`;i=i.replaceAll("#JOINT_NUM",g),this.gpuRenderInfo.vertexShaderSourceVariant.getVariant(_),b=x.createGPUShaderModule(`${v}_${g}`,{code:i})}else b=x.createGPUShaderModule(v,{code:i});else console.warn("⚠️ 버텍스 바리안트 소스를 찾을 수 없음:",_),b=this.gpuRenderInfo.vertexShaderModule}this.gpuRenderInfo.vertexShaderModule=b}#Dn(){const{vertexShaderVariantConditionalBlocks:i}=this.gpuRenderInfo,g=new Set;for(const x of i)this[x]&&g.add(x);const x=g.size>0?Array.from(g).sort().join("+"):"none";return g.size,x}}Object.defineProperty(Mesh.prototype,"meshType",{value:Gr.MESH,writable:!1}),Er.defineByPreset(Mesh,[Er.PRESET_BOOLEAN.RECEIVE_SHADOW]),Er.defineBoolean(Mesh,[["useDisplacementTexture",!1],["disableJitter",!1]]),Object.freeze(Mesh);const Ii=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include calcTintBlendMode;\n#redgpu_include drawPicking;\n#redgpu_include FragmentOutput;\nstruct Uniforms { useDiffuseTexture:u32, opacity:f32, useTint:u32, tint:vec4<f32>, tintBlendMode:u32,\n};\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\n@group(2) @binding(1) var diffuseTextureSampler:sampler;\n@group(2) @binding(2) var diffuseTexture:texture_2d<f32>;\nstruct InputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(11) combinedOpacity:f32, @location(13) shadowPos:vec3<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\n@fragment\nfn main(inputData:InputData) -> FragmentOutput { var output:FragmentOutput; var finalColor:vec4<f32>=textureSample(diffuseTexture,diffuseTextureSampler,inputData.uv); finalColor=vec4<f32>(finalColor.rgb/finalColor.a,finalColor.a * uniforms.opacity * inputData.combinedOpacity); #redgpu_if useTint finalColor=calcTintBlendMode(finalColor,uniforms.tintBlendMode,uniforms.tint); #redgpu_endIf if (finalColor.a==0.0) { discard; } output.color=finalColor; output.gBufferMotionVector=vec4<f32>( 0.0,0.0,1.0,1.0 ); return output;\n};\n");class TextFieldMaterial extends ABitmapBaseMaterial{dirtyPipeline=!1;constructor(i,g,x){super(i,"TEXT_FILED_MATERIAL",Ii,2),x&&(this.name=x),this.diffuseTexture=g,this.diffuseTextureSampler=new Sampler(this.redGPUContext),this.initGPURenderInfos()}}dr.defineByPreset(TextFieldMaterial,[dr.PRESET_TEXTURE.DIFFUSE_TEXTURE,dr.PRESET_SAMPLER.DIFFUSE_TEXTURE_SAMPLER]),Object.freeze(TextFieldMaterial);const Ei=";box-sizing:content-box;white-space:nowrap;",Di={padding:0,background:"transparent",color:"#fff",fontFamily:"Arial",fontSize:24,fontWeight:"normal",fontStyle:"normal",letterSpacing:0,wordBreak:"keep-all",verticalAlign:"middle",textAlign:"center",borderRadius:0,lineHeight:1.4,border:"",boxShadow:"none",boxSizing:"border-box",filter:""};class ATextField extends Mesh{#Ro;#Bo;#Io;#Eo;#Do;#Uo;#Lo;#Ao=!0;#l;#Go;#ko=!1;#Oo=1;#No=1;constructor(i,g,x=!0){super(i),this.#l=i,this.#Ao=x,this.#Lo=g,this._material=new TextFieldMaterial(i),this._material.transparent=!0,this._material.diffuseTextureSampler=new Sampler(i,x?{minFilter:v.LINEAR,magFilter:v.LINEAR,mipmapFilter:b.LINEAR}:{minFilter:v.NEAREST,magFilter:v.NEAREST,mipmapFilter:null}),this.depthStencilState.depthWriteEnabled=!1,this.#Vo(),this.#Fo(),this.#zo(),this.#Ho(),this.#$o()}get text(){return this.#Uo}set text(i){if(this.#Uo===i)return;this.#Uo=i;const g=this.#Io.querySelector("foreignObject div"),x=this.#Ko(i);this.#Eo.innerHTML=x,g.innerHTML=x,this.#ko=!0}render(i){this.#Lo(this.#Oo,this.#No),this.#Xo(),super.render(i)}#Ko(i){return i.toString().replace(/\<br\/>/gi,"<div/>")}#Vo(){"undefined"!=typeof OffscreenCanvas?this.#Ro=new OffscreenCanvas(100,100):this.#Ro=document.createElement("canvas"),this.#Bo=this.#Ro.getContext("2d")}#jo(){const i=this.#Eo.getBoundingClientRect();const g=i.width+3+3,x=i.height+3+3;return{width:-2&Math.ceil(g),height:-2&Math.ceil(x),extraTop:3,extraRight:3,extraBottom:3,extraLeft:3}}#Yo(){const i=this.#Io,g=i.querySelector("foreignObject"),{width:x,height:_,extraTop:v,extraRight:b,extraBottom:y,extraLeft:S}=this.#jo();g.setAttribute("width",x.toString()),g.setAttribute("height",_.toString()),g.style.padding=`${v}px ${b}px ${y}px ${S}px`,i.setAttribute("width",x.toString()),i.setAttribute("height",_.toString()),this.#Do.src="data:image/svg+xml;charset=utf-8,"+encodeURIComponent(i.outerHTML)}#Ho(){this.#Do=new Image,this.#Do.style.cssText="position:absolute;bottom:0px;left:0;",this.#Do.onload=i=>{let g,x;const{width:_,height:v}=this.#jo(),b=1===window.devicePixelRatio?2:window.devicePixelRatio;g=_*b,x=v*b,this.#Do.width=_,this.#Do.height=v,this.#Ro.width=g,this.#Ro.height=x,this.#Ro instanceof OffscreenCanvas||(this.#Ro.style.width=`${_}px`,this.#Ro.style.height=`${v}px`),this.#Bo.imageSmoothingEnabled=!0,this.#Bo.imageSmoothingQuality="high",this.#Bo.clearRect(0,0,g,x),this.#Bo.fillStyle="rgba(0,0,0,0)",this.#Bo.fillRect(0,0,g,x),this.#Bo.drawImage(this.#Do,0,0,g,x),this.dirtyTransform=!0;const callback=i=>{if(this.material.diffuseTexture){const i=this.material.diffuseTexture.src,g="string"==typeof i&&i?.startsWith?.("blob:");this.material.diffuseTexture.destroy(),this.material.diffuseTexture=null,g&&URL.revokeObjectURL(i)}this.material.diffuseTexture=new BitmapTexture(this.#l,URL.createObjectURL(i),!0,i=>{this.#Oo=_,this.#No=v},null,null,!0)};this.#Ro instanceof OffscreenCanvas?this.#Ro.convertToBlob({type:"image/png"}).then(callback):this.#Ro.toBlob(callback,"image/png")}}#Xo(){this.#ko&&(this.#Go&&cancelAnimationFrame(this.#Go),this.#Go=requestAnimationFrame(()=>{this.#Yo()})),this.#ko=!1}#qo=(i,g)=>{const x=this.#Io.querySelector("foreignObject > div").style,_=this.#Eo.style,v=`_${i}`;this[v]=g,Object.defineProperty(this,i,{get:()=>this[v],set:g=>{const b=this[v];this[v]=g;const y=(i=>"number"==typeof i)(g)&&(i=>!["lineHeight","fontWeight"].includes(i))(i)?`${g}px`:g;x[i]=y,_[i]=y,b!==g&&(this.#ko=!0)},configurable:!0}),this[i]=g};#Fo(){this.#Eo=document.createElement("div"),this.#Eo.style.cssText=Ei+";position:absolute;top:200px;left:0;visibility:hidden;text-rendering:optimizeLegibility",document.body.appendChild(this.#Eo)}#zo(){const i=this.#Io=document.createElementNS("http://www.w3.org/2000/svg","svg");i.setAttribute("xmlns","http://www.w3.org/2000/svg"),i.setAttribute("text-rendering","optimizeLegibility"),i.style.cssText="position:absolute;top:0px;left:0px;z-index:1;margin:0;padding:0;overflow:visible;background:transparent",i.innerHTML=` <rect x="0" y="0" width="100%" height="100%" fill="rgba(0,0,0,0)"/> <foreignObject width="100%" height="100%" style="margin:0;padding:0;" overflow="visible"> <div xmlns="http://www.w3.org/1999/xhtml" style="${Ei}"></div> </foreignObject>`}#$o(){for(const[i,g]of Object.entries(Di))this.#qo(i,g);this.#ko=!0}}Object.freeze(ATextField);var Ui="#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include getBillboardMatrix;\n#redgpu_include calcBillboard;\n#redgpu_include billboardPicking;\n#redgpu_include billboardShadow;\nstruct MatrixList{ modelMatrix:mat4x4<f32>, normalModelMatrix:mat4x4<f32>,\n}\nstruct VertexUniforms { pickingId:u32, matrixList:MatrixList, normalModelMatrix:mat4x4<f32>, useSizeAttenuation:u32, useBillboard:u32, usePixelSize:u32, pixelSize:f32, _renderRatioX:f32, _renderRatioY:f32, combinedOpacity:f32,\n};\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\nstruct InputData { @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>,\n};\nstruct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(11) combinedOpacity:f32, @location(13) shadowPos:vec3<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\n@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; let billboardResult=calcBillboard( inputData.position, inputData.vertexNormal, vertexUniforms.matrixList.modelMatrix, systemUniforms.camera.cameraMatrix, systemUniforms.noneJitterProjectionMatrix, systemUniforms.resolution, vertexUniforms.useBillboard, vertexUniforms.usePixelSize, vertexUniforms.pixelSize, vertexUniforms._renderRatioX, vertexUniforms._renderRatioY ); output.position=billboardResult.position; output.vertexPosition=billboardResult.vertexPosition; output.vertexNormal=billboardResult.vertexNormal; output.uv=inputData.uv; output.combinedOpacity=vertexUniforms.combinedOpacity; return output;\n}";const Li=parseWGSL(Ui),Ai=Li.uniforms.vertexUniforms;class TextField3D extends ATextField{#Wo=1;#Zo=1;#Jo=1;#Qo=!1;constructor(i,g){super(i,(i,g)=>{i&&g&&(i===this.#Wo&&g===this.#Zo||(this.#Wo=i,this.#Zo=g,this.gpuRenderInfo&&this.redGPUContext.gpuDevice.queue.writeBuffer(this.gpuRenderInfo.vertexUniformBuffer.gpuBuffer,this.gpuRenderInfo.vertexUniformInfo.members.pixelSize.uniformOffset,new Float32Array([g*window.devicePixelRatio])),this.#eu()))}),this._geometry=new Plane(i),this.disableJitter=!0,g&&(this.text=g)}get worldSize(){return this.#Jo}set worldSize(i){this.#Jo!==i&&(this.#Jo=i,this.#eu())}get usePixelSize(){return this.#Qo}get pixelSize(){return this.#Zo}set usePixelSize(i){if(this.gpuRenderInfo){const{vertexUniformBuffer:g,vertexUniformInfo:x}=this.gpuRenderInfo;this.redGPUContext.gpuDevice.queue.writeBuffer(g.gpuBuffer,x.members.usePixelSize.uniformOffset,new Uint32Array([i?1:0])),this.redGPUContext.gpuDevice.queue.writeBuffer(g.gpuBuffer,x.members.pixelSize.uniformOffset,new Float32Array([this.#Zo*window.devicePixelRatio]))}this.#Qo!==i&&(this.#Qo=i,this.#eu())}#eu(){if(this.#Zo){const i=this._renderRatioX,g=this._renderRatioY;this.usePixelSize?(this._renderRatioY=1,this._renderRatioX=this.#Wo/this.#Zo):(this._renderRatioY=this.#Jo,this._renderRatioX=this.#Wo/this.#Zo*this.#Jo),i===this._renderRatioX&&g===this._renderRatioY||(this.dirtyTransform=!0)}}render(i){super.render(i)}get geometry(){return this._geometry}set geometry(i){console.error("TextField3D can not change geometry")}get material(){return this._material}set material(i){console.error("TextField3D can not change material")}createCustomMeshVertexShaderModule=()=>this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_TEXT_FIELD_3D",Li,Ai,Ui)}Er.definePositiveNumber(TextField3D,[["_renderRatioX",1],["_renderRatioY",1]]),Er.defineByPreset(TextField3D,[[Er.PRESET_BOOLEAN.USE_BILLBOARD,!0]]),Object.freeze(TextField3D);class ADrawDebuggerLight{#l;#tu;#nu;constructor(i,g,x=32){this.#l=i;const _=this.createLightDebugGeometry(i,x);this.#tu=new ColorMaterial(i),this.#tu.color.setColorByRGB(g[0],g[1],g[2]),this.#nu=new Mesh(i,_,this.#tu),this.#nu.primitiveState.cullMode="none",this.#nu.primitiveState.topology=Lr.LINE_LIST}get lightMaterial(){return this.#tu}get lightDebugMesh(){return this.#nu}updateVertexBuffer(i,g){const x=g.data;let _=0;const v=Math.min(i.length,Math.floor(x.length/16));for(let g=0;g<v;g++){const[v,b]=i[g];x[_++]=v[0],x[_++]=v[1],x[_++]=v[2],x[_++]=0,x[_++]=0,x[_++]=1,x[_++]=0,x[_++]=0,x[_++]=b[0],x[_++]=b[1],x[_++]=b[2],x[_++]=0,x[_++]=0,x[_++]=1,x[_++]=0,x[_++]=0}g.updateAllData(x)}createLightDebugGeometry(i,g){const x=new Float32Array(2*g*8),_=new VertexInterleavedStruct({vertexPosition:VertexInterleaveType.float32x3,vertexNormal:VertexInterleaveType.float32x3,texcoord:VertexInterleaveType.float32x2},`lightDebugStruct_${Math.random()}`),v=new VertexBuffer(i,x,_);return new Geometry(i,v)}}class DrawDebuggerDirectionalLight extends ADrawDebuggerLight{#Ya;#ru;#iu=[0,10,0];constructor(i,g){super(i,[255,255,0],8),this.#Ya=g,this.#ru=new TextField3D(i),this.#ru.useBillboard=!0,this.#ru.fontSize=40,this.#ru.text="☀️",this.lightDebugMesh.addChild(this.#ru)}render(i){if(!i.view.systemUniform_Vertex_UniformBindGroup)return;if(!this.#Ya.enableDebugger)return;this.#au(this.#Ya,this.lightDebugMesh.geometry.vertexBuffer),this.lightDebugMesh.setPosition(0,0,0),this.lightDebugMesh.setRotation(0,0,0),this.lightDebugMesh.setScale(1,1,1),this.lightDebugMesh.render(i);const g=this.#Ya.direction,x=this.#iu,_=Math.sqrt(g[0]*g[0]+g[1]*g[1]+g[2]*g[2]),v=[g[0]/_,g[1]/_,g[2]/_];this.#ru.setPosition(x[0]-0*v[0],x[1]-0*v[1],x[2]-0*v[2])}#au(i,g){const x=this.#iu,_=i.direction||[0,-1,0],v=Math.sqrt(_[0]*_[0]+_[1]*_[1]+_[2]*_[2]),b=[_[0]/v,_[1]/v,_[2]/v],y=[x[0]+3*b[0],x[1]+3*b[1],x[2]+3*b[2]],S=.3;let w=[0,1,0];Math.abs(b[1])>.99&&(w=[1,0,0]);const L=[b[1]*w[2]-b[2]*w[1],b[2]*w[0]-b[0]*w[2],b[0]*w[1]-b[1]*w[0]],k=Math.sqrt(L[0]*L[0]+L[1]*L[1]+L[2]*L[2]),z=[L[0]/k,L[1]/k,L[2]/k],H=[z[1]*b[2]-z[2]*b[1],z[2]*b[0]-z[0]*b[2],z[0]*b[1]-z[1]*b[0]],q=[[x,y],[y,[y[0]+-.5*b[0]+z[0]*S,y[1]+-.5*b[1]+z[1]*S,y[2]+-.5*b[2]+z[2]*S]],[y,[y[0]+-.5*b[0]-z[0]*S,y[1]+-.5*b[1]-z[1]*S,y[2]+-.5*b[2]-z[2]*S]],[y,[y[0]+-.5*b[0]+H[0]*S,y[1]+-.5*b[1]+H[1]*S,y[2]+-.5*b[2]+H[2]*S]],[y,[y[0]+-.5*b[0]-H[0]*S,y[1]+-.5*b[1]-H[1]*S,y[2]+-.5*b[2]-H[2]*S]],[[x[0]-.3,x[1],x[2]],[x[0]+.3,x[1],x[2]]],[[x[0],x[1]-.3,x[2]],[x[0],x[1]+.3,x[2]]],[[x[0],x[1],x[2]-.3],[x[0],x[1],x[2]+.3]]];this.updateVertexBuffer(q,g)}}Object.freeze(DrawDebuggerDirectionalLight);class DrawDebuggerPointLight extends ADrawDebuggerLight{#Ya;#ru;constructor(i,g){super(i,[0,255,255],51),this.#Ya=g,this.#ru=new TextField3D(i),this.#ru.useBillboard=!0,this.#ru.fontSize=40,this.#ru.text="💡",this.lightDebugMesh.addChild(this.#ru)}render(i){i.view.systemUniform_Vertex_UniformBindGroup&&this.#Ya.enableDebugger&&(this.#su(this.#Ya,this.lightDebugMesh.geometry.vertexBuffer),this.lightDebugMesh.setPosition(0,0,0),this.lightDebugMesh.setRotation(0,0,0),this.lightDebugMesh.setScale(1,1,1),this.lightDebugMesh.render(i),this.#ru.setPosition(...this.#Ya.position))}#su(i,g){const x=i.position||[0,0,0],_=i.radius||1,v=16,b=[];for(let i=0;i<v;i++){const g=i/v*Math.PI*2,y=(i+1)/v*Math.PI*2,S=x[0]+Math.cos(g)*_,w=x[1]+Math.sin(g)*_,L=x[2],k=x[0]+Math.cos(y)*_,z=x[1]+Math.sin(y)*_,H=x[2];b.push([[S,w,L],[k,z,H]])}for(let i=0;i<v;i++){const g=i/v*Math.PI*2,y=(i+1)/v*Math.PI*2,S=x[0]+Math.cos(g)*_,w=x[1],L=x[2]+Math.sin(g)*_,k=x[0]+Math.cos(y)*_,z=x[1],H=x[2]+Math.sin(y)*_;b.push([[S,w,L],[k,z,H]])}for(let i=0;i<v;i++){const g=i/v*Math.PI*2,y=(i+1)/v*Math.PI*2,S=x[0],w=x[1]+Math.cos(g)*_,L=x[2]+Math.sin(g)*_,k=x[0],z=x[1]+Math.cos(y)*_,H=x[2]+Math.sin(y)*_;b.push([[S,w,L],[k,z,H]])}const y=.2*_;b.push([[x[0]-y,x[1],x[2]],[x[0]+y,x[1],x[2]]]),b.push([[x[0],x[1]-y,x[2]],[x[0],x[1]+y,x[2]]]),b.push([[x[0],x[1],x[2]-y],[x[0],x[1],x[2]+y]]),this.updateVertexBuffer(b,g)}}Object.freeze(DrawDebuggerPointLight);class DrawDebuggerSpotLight extends ADrawDebuggerLight{#Ya;#ru;constructor(i,g){super(i,[255,255,0],80),this.#Ya=g,this.#ru=new TextField3D(i),this.#ru.useBillboard=!0,this.#ru.fontSize=40,this.#ru.text="🔦",this.lightDebugMesh.addChild(this.#ru)}render(i){i.view.systemUniform_Vertex_UniformBindGroup&&this.#Ya.enableDebugger&&(this.#ou(this.#Ya,this.lightDebugMesh.geometry.vertexBuffer),this.lightDebugMesh.setPosition(0,0,0),this.lightDebugMesh.setRotation(0,0,0),this.lightDebugMesh.setScale(1,1,1),this.lightDebugMesh.render(i),this.#ru.setPosition(...this.#Ya.position))}#ou(i,g){const x=i.position||[0,0,0],_=i.direction||[0,-1,0],v=i.radius||5,b=i.outerCutoff||22.5,y=i.innerCutoff||15,S=[],w=Math.sqrt(_[0]*_[0]+_[1]*_[1]+_[2]*_[2]),L=[_[0]/w,_[1]/w,_[2]/w],k=[x[0]+L[0]*v,x[1]+L[1]*v,x[2]+L[2]*v],z=v*Math.tan(b*Math.PI/180),H=v*Math.tan(y*Math.PI/180);let q=[0,1,0];Math.abs(L[1])>.99&&(q=[1,0,0]);const W=[L[1]*q[2]-L[2]*q[1],L[2]*q[0]-L[0]*q[2],L[0]*q[1]-L[1]*q[0]],be=Math.sqrt(W[0]*W[0]+W[1]*W[1]+W[2]*W[2]),Ke=[W[0]/be,W[1]/be,W[2]/be],Xe=[Ke[1]*L[2]-Ke[2]*L[1],Ke[2]*L[0]-Ke[0]*L[2],Ke[0]*L[1]-Ke[1]*L[0]],je=16;for(let i=0;i<je;i++){const g=i/je*Math.PI*2,_=(i+1)/je*Math.PI*2,v=Math.cos(g),b=Math.sin(g),y=Math.cos(_),w=Math.sin(_),L=[k[0]+(Ke[0]*v+Xe[0]*b)*z,k[1]+(Ke[1]*v+Xe[1]*b)*z,k[2]+(Ke[2]*v+Xe[2]*b)*z],H=[k[0]+(Ke[0]*y+Xe[0]*w)*z,k[1]+(Ke[1]*y+Xe[1]*w)*z,k[2]+(Ke[2]*y+Xe[2]*w)*z];S.push([L,H]),S.push([x,L])}for(let i=0;i<je;i++){const g=i/je*Math.PI*2,x=(i+1)/je*Math.PI*2,_=Math.cos(g),v=Math.sin(g),b=Math.cos(x),y=Math.sin(x),w=[k[0]+(Ke[0]*_+Xe[0]*v)*H,k[1]+(Ke[1]*_+Xe[1]*v)*H,k[2]+(Ke[2]*_+Xe[2]*v)*H],L=[k[0]+(Ke[0]*b+Xe[0]*y)*H,k[1]+(Ke[1]*b+Xe[1]*y)*H,k[2]+(Ke[2]*b+Xe[2]*y)*H];S.push([w,L])}S.push([x,k]);const Ye=.3;S.push([[x[0]-Ye,x[1],x[2]],[x[0]+Ye,x[1],x[2]]]),S.push([[x[0],x[1]-Ye,x[2]],[x[0],x[1]+Ye,x[2]]]),S.push([[x[0],x[1],x[2]-Ye],[x[0],x[1],x[2]+Ye]]);for(let i=0;i<4;i++){const g=i/4*Math.PI*2,_=Math.cos(g),v=Math.sin(g),b=[k[0]+(Ke[0]*_+Xe[0]*v)*z,k[1]+(Ke[1]*_+Xe[1]*v)*z,k[2]+(Ke[2]*_+Xe[2]*v)*z];S.push([x,b])}this.updateVertexBuffer(S,g)}}Object.freeze(DrawDebuggerSpotLight);class PickingEvent{pickingId;mouseX;mouseY;target;time;type;movementX=0;movementY=0;point=create$3();distance=0;localPoint=create$3();localX=0;localY=0;localZ=0;uv=create();ray;faceIndex=-1;altKey=!1;ctrlKey=!1;shiftKey=!1;constructor(i,g,x,_,v,b,y,S){this.pickingId=i,this.mouseX=g,this.mouseY=x,this.target=_,this.time=v,this.type=b,this.altKey=y.altKey,this.ctrlKey=y.ctrlKey,this.shiftKey=y.shiftKey,S&&(this.point=S.point,this.localPoint=S.localPoint,this.localX=S.localPoint[0],this.localY=S.localPoint[1],this.localZ=S.localPoint[2],this.distance=S.distance,this.faceIndex=S.faceIndex,this.uv=S.uv,this.ray=S.ray)}}class Ray{origin;direction;constructor(i=create$3(),g=fromValues$3(0,0,-1)){this.origin=clone$3(i),this.direction=clone$3(g)}clone(){return new Ray(this.origin,this.direction)}applyMatrix4(i){transformMat4$2(this.origin,this.origin,i);const g=create$3();copy$3(g,this.direction);const x=clone$4(i);return x[12]=x[13]=x[14]=0,transformMat4$2(this.direction,g,x),normalize$3(this.direction,this.direction),this}intersectBox(i){let g=-1/0,x=1/0;for(let _=0;_<3;_++){const v=1/this.direction[_],b=0===_?i.minX:1===_?i.minY:i.minZ,y=0===_?i.maxX:1===_?i.maxY:i.maxZ;let S=(b-this.origin[_])*v,w=(y-this.origin[_])*v;if(S>w){const i=S;S=w,w=i}g=Math.max(g,S),x=Math.min(x,w)}return x>=g&&x>=0}intersectTriangle(i,g,x,_=!0){const v=create$3(),b=create$3(),y=create$3(),S=create$3(),w=create$3();subtract$2(v,g,i),subtract$2(b,x,i),cross$2(y,this.direction,b);const L=dot$3(v,y);if(_){if(L<1e-5)return null}else if(L>-1e-5&&L<1e-5)return null;const k=1/L;subtract$2(S,this.origin,i);const z=k*dot$3(S,y);if(z<0||z>1)return null;cross$2(w,S,v);const H=k*dot$3(this.direction,w);if(H<0||z+H>1)return null;const q=k*dot$3(b,w);if(q>1e-5){const i=create$3();return scaleAndAdd$2(i,this.origin,this.direction,q),i}return null}intersectTriangleBarycentric(i,g,x,_=!0){const v=create$3(),b=create$3(),y=create$3(),S=create$3(),w=create$3();subtract$2(v,g,i),subtract$2(b,x,i),cross$2(y,this.direction,b);const L=dot$3(v,y);if(_){if(L<1e-5)return null}else if(L>-1e-5&&L<1e-5)return null;const k=1/L;subtract$2(S,this.origin,i);const z=k*dot$3(S,y);if(z<0||z>1)return null;cross$2(w,S,v);const H=k*dot$3(this.direction,w);if(H<0||z+H>1)return null;const q=k*dot$3(b,w);if(q>1e-5){const i=create$3();return scaleAndAdd$2(i,this.origin,this.direction,q),{point:i,t:q,u:z,v:H}}return null}}class Raycaster3D{ray;near=0;far=1/0;#uu=create$4();#lu=create$4();#cu=create$4();#hu=create$3();#fu=create$3();#zt;#du=create();constructor(){this.ray=new Ray}setFromCamera(i,g,x){const{rawCamera:_}=x,v=fromValues$3(_.x,_.y,_.z),b=x.screenToWorld(i,g),y=create$3();subtract$2(y,b,v),normalize$3(y,y),copy$3(this.ray.origin,v),copy$3(this.ray.direction,y),this.#zt=x;const{pixelRectObject:S}=x,w=i*devicePixelRatio/S.width*2-1,L=-g*devicePixelRatio/S.height*2+1;set(this.#du,w,L),"nearClipping"in _&&(this.near=_.nearClipping),"farClipping"in _&&(this.far=_.farClipping)}intersectObject(i,g=!0){const x=[];return this.#mu(i,g,x),x.sort((i,g)=>i.distance-g.distance)}intersectObjects(i,g=!0){const x=[];for(const _ of i)this.#mu(_,g,x);return x.sort((i,g)=>i.distance-g.distance)}#mu(i,g,x){const _=i.useBillboard,v=i._renderRatioX||1,b=i._renderRatioY||1;if(_&&this.#zt){i.usePixelSize?this.#pu(i,x):this.#gu(i,x)}else if(i.geometry){const g=this.#lu;if(copy$4(g,i.modelMatrix),1!==v||1!==b)scale$4(g,g,[v,b,1]),this.#xu(i,g,x,!0);else{const g=i.boundingAABB;this.ray.intersectBox(g)&&this.#xu(i,i.modelMatrix,x,!0)}}if(g&&i.children)for(const _ of i.children)this.#mu(_,g,x)}#pu(i,x){const _=this.#zt,v=i.modelMatrix,b=i.pixelSize;g(i.fontSize);const y=i._renderRatioX||1,S=i._renderRatioY||1,{rawCamera:w,projectionMatrix:L,pixelRectObject:k}=_,z=fromValues$3(v[12],v[13],v[14]),H=transformMat4$2(this.#hu,z,w.modelMatrix),q=transformMat4$1(this.#uu,fromValues$2(H[0],H[1],H[2],1),L);if(q[3]<=0)return;const W=q[0]/q[3],be=q[1]/q[3],Ke=this.#du[0],Xe=this.#du[1],je=b*window.devicePixelRatio,Ye=je/k.width*2*(y/S),Ze=je/k.height*2;if(Math.abs(Ke-W)<=.5*Ye&&Math.abs(Xe-be)<=.5*Ze){const g=distance$2(this.ray.origin,z);if(g>=this.near&&g<=this.far){const _=(Ke-W)/Ye+.5,v=(Xe-be)/Ze+.5;x.push({distance:g,point:z,localPoint:fromValues$3(0,0,0),object:i,faceIndex:0,uv:fromValues(_,1-v),ray:this.ray.clone()})}}}#gu(i,g){const x=this.#zt,_=i.modelMatrix,v=i._renderRatioX||1,b=i._renderRatioY||1,y=invert$1(this.#lu,x.rawCamera.modelMatrix),S=this.#cu;copy$4(S,y),S[12]=_[12],S[13]=_[13],S[14]=_[14];scale$4(S,S,[Math.hypot(_[0],_[1],_[2])*v,Math.hypot(_[4],_[5],_[6])*b,Math.hypot(_[8],_[9],_[10])]),this.#xu(i,S,g,!1)}#xu(i,g,x,_){const v=new Ray;copy$3(v.origin,this.ray.origin),copy$3(v.direction,this.ray.direction);const b=invert$1(this.#uu,g);if(b){v.applyMatrix4(b);const y=i.geometry,S=y.vertexBuffer,w=y.indexBuffer,L=S.data,k=S.interleavedStruct.arrayStride/4;if(w){const b=w.data;for(let y=0;y<b.length;y+=3)this.#_u(v,i,g,L,k,b[y],b[y+1],b[y+2],x,_)}else{const b=S.vertexCount;for(let y=0;y<b;y+=3)this.#_u(v,i,g,L,k,y,y+1,y+2,x,_)}}}#_u(i,g,x,_,v,b,y,S,w,L){const k=fromValues$3(_[b*v],_[b*v+1],_[b*v+2]),z=fromValues$3(_[y*v],_[y*v+1],_[y*v+2]),H=fromValues$3(_[S*v],_[S*v+1],_[S*v+2]),q=i.intersectTriangleBarycentric(k,z,H,L);if(q){const{point:i,u:L,v:k}=q,z=create$3();transformMat4$2(z,i,x);const H=distance$2(this.ray.origin,z);if(H>=this.near&&H<=this.far){const x=fromValues(_[b*v+6],_[b*v+7]),q=fromValues(_[y*v+6],_[y*v+7]),W=fromValues(_[S*v+6],_[S*v+7]),be=create();scaleAndAdd(be,be,x,1-L-k),scaleAndAdd(be,be,q,L),scaleAndAdd(be,be,W,k),w.push({distance:H,point:z,localPoint:i,object:g,faceIndex:Math.floor(b/3),uv:be,ray:this.ray.clone()})}}}}class Raycaster2D{ray;#zt;#vu=create$3();#uu=create$4();#lu=create$4();#hu=create$3();constructor(){this.ray=new Ray}setFromCamera(i,g,x){this.#zt=x;const{pixelRectObject:_}=x,v=i*devicePixelRatio/_.width*2-1,b=1-g*devicePixelRatio/_.height*2;set$3(this.#vu,v,b,0);const y=x.screenToWorld(i,g);set$3(this.ray.origin,y[0],y[1],y[2]),set$3(this.ray.direction,0,0,-1)}intersectObject(i,g=!0){const x=[];return this.#mu(i,g,x),x.sort((i,g)=>i.distance-g.distance)}intersectObjects(i,g=!0){const x=[];for(const _ of i)this.#mu(_,g,x);return x.sort((i,g)=>i.distance-g.distance)}#mu(i,g,x){if(i.geometry){const g=this.#zt,_=g.projectionMatrix,v=g.rawCamera.modelMatrix,b=multiply$4(this.#uu,_,v);multiply$4(b,b,i.modelMatrix);const y=invert$1(this.#lu,b);if(y){const g=transformMat4$2(this.#hu,this.#vu,y);let b=!1,S=1,w=1;if(i.is2DMeshType?(S=i.width,w=i.height,g[0]>=-S/2&&g[0]<=S/2&&g[1]>=-w/2&&g[1]<=w/2&&(b=!0)):g[0]>=-.5&&g[0]<=.5&&g[1]>=-.5&&g[1]<=.5&&(b=!0),b){const b=invert$1(create$4(),multiply$4(create$4(),_,v)),y=transformMat4$2(create$3(),this.#vu,b),L=g[0]/S>g[1]/w?1:0;x.push({distance:0,point:y,localPoint:clone$3(g),object:i,uv:fromValues(g[0]/S+.5,g[1]/w+.5),ray:this.ray.clone(),faceIndex:L})}}}if(g&&i.children)for(const _ of i.children)this.#mu(_,g,x)}}class PickingManager{lastMouseEvent;lastMouseClickEvent;#bu;#yu;#Su;#Tu;#l;#zt;#Mu=[];#wu=0;#Cu=0;#Pu;#Ru;#N=0;#Bu=new Raycaster3D;#Iu=new Raycaster2D;get videoMemorySize(){return this.#N}get mouseX(){return this.#wu}set mouseX(i){this.#wu=i}get mouseY(){return this.#Cu}set mouseY(i){this.#Cu=i}get castingList(){return this.#Mu}get pickingGPUTexture(){return this.#Su}get pickingGPUTextureView(){return this.#Tu}get pickingDepthGPUTextureView(){return this.#yu}resetCastingList(){this.#Mu.length=0}destroy(){this.#Su&&(this.#Su.destroy(),this.#bu.destroy(),this.#Su=null,this.#Tu=null,this.#bu=null,this.#yu=null)}checkTexture(i){const{redGPUContext:g}=i,{resourceManager:x}=g;this.#zt=i,this.#l=g,this.#Su?.width===this.#zt.pixelRectObject.width&&this.#Su?.height===this.#zt.pixelRectObject.height||(this.destroy(),this.#Su=this.#Eu("picking",navigator.gpu.getPreferredCanvasFormat()),this.#Tu=x.getGPUResourceBitmapTextureView(this.#Su),this.#bu=this.#Eu("pickingDepth","depth32float"),this.#yu=x.getGPUResourceBitmapTextureView(this.#bu),this.#pr())}checkEvents(i,g){this.castingList.length&&(this.#Du(i,g),this.resetCastingList())}#pr(){const i=this.#Su;if(!i)return 0;this.#N=calculateTextureByteSize(i)+calculateTextureByteSize(this.#bu)}#Eu(i,g){const{resourceManager:x}=this.#l;return x.createManagedTexture({size:[this.#zt.pixelRectObject.width,this.#zt.pixelRectObject.height,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC,format:g,sampleCount:1,label:`${this.#zt.name}_${i}_${this.#zt.pixelRectObject.width}x${this.#zt.pixelRectObject.height}`})}#Du=async(i,g,x=1,_=1)=>{const{gpuDevice:v}=i.redGPUContext,{pixelRectArray:b}=i,y=this.#wu,S=this.#Cu;if(y<=0||y>=b[2]||S<=0||S>=b[3])return;const w=this.#Uu();let L=this.#Lu(v,x,_,y,S);const k=await this.#Au(L);L.destroy(),L=null,k?(this.#Gu(k,y,S,g,w),this.#ku(k,y,S,g,w)):this.#Ou(),this.lastMouseEvent=null,this.lastMouseClickEvent=null};#Uu=()=>this.#Mu.reduce((i,g)=>(i[g.pickingId]=g,i),{});#Lu=(i,g,x,_,v)=>{const b=i.createCommandEncoder({label:"PickingManager_ReadPixel_CommandEncoder"}),y=i.createBuffer({size:4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:"readPixelBuffer"}),S={texture:this.#Su,origin:{x:_,y:v,z:0}},w={buffer:y,bytesPerRow:256,rowsPerImage:1};return b.copyTextureToBuffer(S,w,{width:1,height:1,depthOrArrayLayers:1}),i.queue.submit([b.finish()]),y};#Nu(i,g,x,_,v,b,y){const S="Camera2D"===this.#zt.rawCamera.constructor.name?this.#Iu:this.#Bu;let w;if(S.setFromCamera(this.#wu/devicePixelRatio,this.#Cu/devicePixelRatio,this.#zt),_){w=S.intersectObject(_)[0]}const L=new PickingEvent(i,g,x,_,v,b,y,w);return L.ray||(L.ray=S.ray.clone()),L}#Gu=(g,x,_,v,b)=>{const y=b[g],S=this.lastMouseClickEvent?.type;if(S===i.CLICK){const i=this.#Nu(g,x,_,y,v,S,this.lastMouseClickEvent);this.#Vu(S,i)}};#ku=(g,x,_,v,b)=>{const y=b[g],S=this.lastMouseEvent?.type;if(S){const b=this.#Nu(g,x,_,y,v,S,this.lastMouseEvent);switch(this.#Pu&&(b.movementX=x-this.#Pu.mouseX,b.movementY=_-this.#Pu.mouseY),S){case i.DOWN:case i.UP:this.#Vu(S,b);break;case i.MOVE:this.#Fu(g,y,b)}this.#Pu=b}};#Fu=(g,x,_)=>{const v=this.#Pu?.pickingId;v!==g?(this.#Pu&&v&&v!==g&&this.#Ou(),this.#Ru!==x&&(this.#Vu(i.OVER,_),document.body.style.cursor="pointer"),this.#Ru=x):this.#Vu(i.MOVE,_)};#Ou=()=>{this.#Pu&&this.#Vu(i.OUT,this.#Pu),this.#Pu=null,this.#Ru=null,document.body.style.cursor="default"};async#Au(i){await i.mapAsync(GPUMapMode.READ);const g=new DataView(i.getMappedRange()),x="rgba8unorm"==this.#Su.format?[0,1,2,3]:[2,1,0,3],_=g.getUint8(x[0]),v=g.getUint8(x[1]),b=g.getUint8(x[2]);return(g.getUint8(x[3])<<24|b<<16|v<<8|_)>>>0}#Vu(i,g){g.target&&g.target.events[i]&&g.target.events[i](g)}}Object.freeze(PickingManager);class FXAA extends ASinglePassPostEffect{#zu=.75;#Hu=.166;#$u=.0833;constructor(i){super(i);this.init(i,"POST_EFFECT_FXAA",createBasicPostEffectCode(this,"\nlet index=vec2<u32>(global_id.xy);\nlet dims=textureDimensions(sourceTexture);\nlet i_index=vec2<i32>(index);\n\n//1. 현재 픽셀 및 주변 4방향 루마(Luma) 및 알파 샘플링\nlet colorM4=textureLoad(sourceTexture,index);\nlet colorM=colorM4.rgb;\nlet lumaM=getLuma(colorM);\n\nlet colorN4=fetchColor4(i_index + vec2<i32>(0,-1),dims);\nlet colorS4=fetchColor4(i_index + vec2<i32>(0,1),dims);\nlet colorW4=fetchColor4(i_index + vec2<i32>(-1,0),dims);\nlet colorE4=fetchColor4(i_index + vec2<i32>(1,0),dims);\n\nlet lumaN=getLuma(colorN4.rgb);\nlet lumaS=getLuma(colorS4.rgb);\nlet lumaW=getLuma(colorW4.rgb);\nlet lumaE=getLuma(colorE4.rgb);\n\n//2. 로컬 대비(Contrast) 분석을 통한 조기 종료 결정\nlet lumaMin=min(lumaM,min(min(lumaN,lumaS),min(lumaW,lumaE)));\nlet lumaMax=max(lumaM,max(max(lumaN,lumaS),max(lumaW,lumaE)));\nlet range=lumaMax - lumaMin;\n\nif (range < max(uniforms.edgeThresholdMin,lumaMax * uniforms.edgeThreshold)) { textureStore(outputTexture,index,colorM4); return;\n}\n\n//3. 대각선 루마 샘플링 (3x3 영역 완성)\nlet lumaNW=getLuma(fetchColor4(i_index + vec2<i32>(-1,-1),dims).rgb);\nlet lumaNE=getLuma(fetchColor4(i_index + vec2<i32>(1,-1),dims).rgb);\nlet lumaSW=getLuma(fetchColor4(i_index + vec2<i32>(-1,1),dims).rgb);\nlet lumaSE=getLuma(fetchColor4(i_index + vec2<i32>(1,1),dims).rgb);\n\n//4. 엣지 방향 판단 (수직 vs 수평)\nlet edgeVer=abs(lumaNW + lumaSW - 2.0 * lumaW) + abs(lumaN + lumaS - 2.0 * lumaM) * 2.0 + abs(lumaNE + lumaSE - 2.0 * lumaE);\nlet edgeHor=abs(lumaNW + lumaNE - 2.0 * lumaN) + abs(lumaW + lumaE - 2.0 * lumaM) * 2.0 + abs(lumaSW + lumaSE - 2.0 * lumaS);\nlet isHorizontal=edgeHor >=edgeVer;\n\n//5. 엣지 방향에 따른 기울기 및 오프셋 설정\nlet luma1=select(lumaW,lumaN,isHorizontal);\nlet luma2=select(lumaE,lumaS,isHorizontal);\nlet gradient1=luma1 - lumaM;\nlet gradient2=luma2 - lumaM;\nlet is1Steeper=abs(gradient1) >=abs(gradient2);\nlet gradientScaled=0.25 * max(abs(gradient1),abs(gradient2));\n\nvar lumaLocalAverage=0.0;\nvar edgeStep=vec2<i32>(0,0);\nif (is1Steeper) { edgeStep=select(vec2<i32>(-1,0),vec2<i32>(0,-1),isHorizontal); lumaLocalAverage=0.5 * (luma1 + lumaM);\n} else { edgeStep=select(vec2<i32>(1,0),vec2<i32>(0,1),isHorizontal); lumaLocalAverage=0.5 * (luma2 + lumaM);\n}\n\n//6. 언리얼급 품질을 위한 엣지 탐색 루프 (Edge Search Iteration)\nvar posP=i_index + edgeStep;\nvar posN=i_index + edgeStep;\nlet searchStep=select(vec2<i32>(1,0),vec2<i32>(0,1),isHorizontal);\n\nvar doneP=false;\nvar doneN=false;\nfor (var i=0;i < 10;i++) { if (!doneP) { if (abs(getLuma(fetchColor4(posP,dims).rgb) - lumaLocalAverage) >=gradientScaled) { doneP=true;} else { posP +=searchStep;} } if (!doneN) { if (abs(getLuma(fetchColor4(posN,dims).rgb) - lumaLocalAverage) >=gradientScaled) { doneN=true;} else { posN -=searchStep;} } if (doneP && doneN) { break;}\n}\n\n//7. 탐색된 끝점까지의 거리를 기반으로 한 엣지 블렌딩 계산\nlet distP=select(f32(posP.x - i_index.x),f32(posP.y - i_index.y),isHorizontal);\nlet distN=select(f32(i_index.x - posN.x),f32(i_index.y - posN.y),isHorizontal);\nlet distMin=min(abs(distP),abs(distN));\nlet edgeBlend=saturate(0.5 - distMin/(abs(distP) + abs(distN)));\n\n//8. 서브픽셀 필터링 (고주파 노이즈 제거용)\nlet lumaL=(lumaN + lumaS + lumaW + lumaE) * 2.0;\nlet lumaCorners=lumaNW + lumaNE + lumaSW + lumaSE;\nlet subpixFilter=saturate(abs((lumaL + lumaCorners)/12.0 - lumaM)/range);\nlet subpixBlend=smoothstep(0.0,1.0,subpixFilter) * uniforms.subpix;\n\n//9. 최종 블렌딩 및 알파 채널 보존 합성\nlet finalBlend=max(edgeBlend,subpixBlend);\nlet colorTarget4=fetchColor4(i_index + edgeStep,dims);\n\n//RGBA 전체를 보간하여 투명도 유지\nlet finalColor4=mix(colorM4,colorTarget4,finalBlend);\n\ntextureStore(outputTexture,index,finalColor4);\n","\nstruct Uniforms { subpix:f32, edgeThreshold:f32, edgeThresholdMin:f32, padding:f32\n};\n\nfn getLuma(rgb:vec3<f32>) -> f32 { return dot(rgb,vec3<f32>(0.299,0.587,0.114));\n}\n\nfn fetchColor4(pos:vec2<i32>,dims:vec2<u32>) -> vec4<f32> { let p=vec2<u32>(clamp(vec2<u32>(pos),vec2<u32>(0),dims - 1)); return textureLoad(sourceTexture,p);\n}\n")),this.subpix=this.#zu,this.edgeThreshold=this.#Hu,this.edgeThresholdMin=this.#$u}get subpix(){return this.#zu}set subpix(i){validateNumberRange(i,0,1),this.#zu=i,this.updateUniform("subpix",i)}get edgeThreshold(){return this.#Hu}set edgeThreshold(i){validateNumberRange(i,1e-4,.25),this.#Hu=i,this.updateUniform("edgeThreshold",i)}get edgeThresholdMin(){return this.#$u}set edgeThresholdMin(i){validateNumberRange(i,1e-5,.1),this.#$u=i,this.updateUniform("edgeThresholdMin",i)}}Object.freeze(FXAA);class TAA{#l;#or;#Gn;#kn;#On;#Nn;#Xn;#jn;#Yn;#qn;#Wn;#h;#Zn;#Jn;#Qn;#Ku=new Map;#Xu=new Map;#ju=new Map;#Yu=null;#qu;#Wu;#Zu;#Ju;#Qu;#el;#nr=8;#rr=8;#ir=1;#ur=[];#N=0;#tl=0;#nl=.5;#lr;#cr;#rl=[0,0];#il=create$4();constructor(i){this.#l=i,this.#or=i.antialiasingManager;const g=this.#al();this.#ne(i,"POST_EFFECT_TAA",{msaa:g.msaa,nonMsaa:g.nonMsaa}),this.jitterStrength=this.#nl}get prevNoneJitterProjectionCameraMatrix(){return this.#il}get frameIndex(){return this.#tl}get videoMemorySize(){return this.#N}get jitterStrength(){return this.#nl}set jitterStrength(i){this.#nl=i}render(i,g,x,_){const v=_.textureView;_.texture;const{gpuDevice:b,antialiasingManager:y}=this.#l,{useMSAA:S,msaaID:w}=y;this.#tl++,this.#jn&&(this.updateUniform("frameIndex",this.#tl),this.updateUniform("currJitterOffset",i.jitterOffset),this.updateUniform("prevJitterOffset",this.#rl),copy$4(this.#il,i.noneJitterProjectionCameraMatrix),this.#rl=[...i.jitterOffset]);const L=this.#hr(i),k=this.#lr!==S||this.#cr!==w,z=this.#fr([v]);(L||k||z)&&this.#sl(i,[v],S,this.#l,b),this.#ol(b,g,x);{const i=b.createCommandEncoder({label:"TAA_CopyTexture_CommandEncoder_compute"});i.copyTextureToTexture({texture:this.#qu},{texture:this.#Zu},[g,x,1]),b.queue.submit([i.finish()])}return this.#tl<=20||this.#tl,this.#lr=S,this.#cr=w,{texture:this.#qu,textureView:this.#Wu}}clear(){this.#Zu&&(this.#Zu.destroy(),this.#Zu=null,this.#Ju=null),this.#qu&&(this.#qu.destroy(),this.#qu=null,this.#Wu=null),this.#Ku.clear(),this.#Xu.clear(),this.#ju.clear(),this.#Yu=null}updateUniform(i,g){this.#jn.writeOnlyBuffer(this.#Yn.members[i],g)}#al(){const createCode=i=>` \nstruct Uniforms { frameIndex:f32, currJitterOffset:vec2<f32>, prevJitterOffset:vec2<f32>,\n};\nstruct NeighborhoodStats { minColor:vec3<f32>, maxColor:vec3<f32>, mean:vec3<f32>, stdDev:vec3<f32>, minAlpha:f32, maxAlpha:f32, meanAlpha:f32,\n};\nstruct SampledColor { rgb:vec3<f32>, ycocg:vec3<f32>, alpha:f32,\n};\nfn rgb_to_ycocg(rgb:vec3<f32>) -> vec3<f32> { let y=dot(rgb,vec3<f32>(0.25,0.5,0.25)); let co=dot(rgb,vec3<f32>(0.5,0.0,-0.5)); let cg=dot(rgb,vec3<f32>(-0.25,0.5,-0.25)); return vec3<f32>(y,co,cg);\n}\nfn ycocg_to_rgb(ycocg:vec3<f32>) -> vec3<f32> { let y=ycocg.x; let co=ycocg.y; let cg=ycocg.z; return vec3<f32>(y + co - cg,y + cg,y - co - cg);\n}\nfn get_depth_confidence(currDepth:f32,prevDepth:f32) -> f32 { let depthDiff=abs(currDepth - prevDepth); return 1.0 - clamp((depthDiff - 0.01)/0.02,0.0,1.0);\n}\nfn fetch_depth_bilinear(tex:texture_depth_2d,uv:vec2<f32>,screenSize:vec2<f32>) -> f32 { let samplePos=uv * screenSize - 0.5; let f=fract(samplePos); let base=vec2<i32>(floor(samplePos)); let size=vec2<i32>(textureDimensions(tex)); let d00=textureLoad(tex,clamp(base + vec2<i32>(0,0),vec2<i32>(0),size - 1),0); let d10=textureLoad(tex,clamp(base + vec2<i32>(1,0),vec2<i32>(0),size - 1),0); let d01=textureLoad(tex,clamp(base + vec2<i32>(0,1),vec2<i32>(0),size - 1),0); let d11=textureLoad(tex,clamp(base + vec2<i32>(1,1),vec2<i32>(0),size - 1),0); return mix(mix(d00,d10,f.x),mix(d01,d11,f.x),f.y);\n}\nfn calculate_neighborhood_stats_ycocg(pixelCoord:vec2<i32>,screenSizeU:vec2<u32>) -> NeighborhoodStats { let screenSize=vec2<f32>(screenSizeU); var m1=vec3<f32>(0.0); var m2=vec3<f32>(0.0); var m1A=0.0; var minC=vec3<f32>(1e5); var maxC=vec3<f32>(-1e5); var minA=1e5; var maxA=-1e5; for (var y:i32=-1;y <=1;y++) { for (var x:i32=-1;x <=1;x++) { let sampleCoord=clamp(pixelCoord + vec2<i32>(x,y),vec2<i32>(0),vec2<i32>(screenSizeU) - 1); let colorRGBA=textureLoad(sourceTexture,sampleCoord,0); let colorYCoCg=rgb_to_ycocg(colorRGBA.rgb); let alpha=colorRGBA.a; m1 +=colorYCoCg; m2 +=colorYCoCg * colorYCoCg; m1A +=alpha; minC=min(minC,colorYCoCg); maxC=max(maxC,colorYCoCg); minA=min(minA,alpha); maxA=max(maxA,alpha); } } let sampleCount=9.0; var stats:NeighborhoodStats; stats.mean=m1/sampleCount; stats.stdDev=sqrt(max((m2/sampleCount) - (stats.mean * stats.mean),vec3<f32>(0.0))); stats.minColor=minC; stats.maxColor=maxC; stats.minAlpha=minA; stats.maxAlpha=maxA; stats.meanAlpha=m1A/sampleCount; return stats;\n}\nfn get_color_discrepancy_weight(stats:NeighborhoodStats,histYCoCg:vec3<f32>) -> f32 { let diff=abs(stats.mean.x - histYCoCg.x); let threshold=max(stats.stdDev.x * 0.45,0.01); return smoothstep(threshold,threshold * 2.0,diff);\n}\nfn sample_texture_catmull_rom_antiflicker(tex:texture_2d<f32>,smp:sampler,uv:vec2<f32>,texSize:vec2<f32>) -> SampledColor { let samplePos=uv * texSize; let texPos1=floor(samplePos - 0.5) + 0.5; let f=samplePos - texPos1; let w0=f * (-0.5 + f * (1.0 - 0.5 * f)); let w1=1.0 + f * f * (-2.5 + 1.5 * f); let w2=f * (0.5 + f * (2.0 - 1.5 * f)); let w3=f * f * (-0.5 + 0.5 * f); let w12=w1 + w2; let offset12=w2/w12; let invTexSize=1.0/texSize; let coords=array<vec2<f32>,5>( (texPos1 + vec2<f32>(offset12.x,-1.0)) * invTexSize, (texPos1 + vec2<f32>(-1.0,offset12.y)) * invTexSize, (texPos1 + offset12) * invTexSize, (texPos1 + vec2<f32>(2.0,offset12.y)) * invTexSize, (texPos1 + vec2<f32>(offset12.x,2.0)) * invTexSize ); let weights=array<f32,5>( w12.x * w0.y,w0.x * w12.y,w12.x * w12.y,w3.x * w12.y,w12.x * w3.y ); var sumRGB=vec3<f32>(0.0); var sumYCoCg=vec3<f32>(0.0); var sumAlpha=0.0; var sumW=0.0; for(var i=0;i < 5;i++) { let sampleRGBA=textureSampleLevel(tex,smp,coords[i],0.0); let sampleRGB=max(sampleRGBA.rgb,vec3<f32>(0.0)); let sampleYCoCg=rgb_to_ycocg(sampleRGB); let w=weights[i] * (1.0/(1.0 + sampleYCoCg.x)); sumRGB +=sampleRGB * w; sumYCoCg +=sampleYCoCg * w; sumAlpha +=sampleRGBA.a * w; sumW +=w; } var result:SampledColor; let invSumW=1.0/max(sumW,0.0001); result.rgb=sumRGB * invSumW; result.ycocg=sumYCoCg * invSumW; result.alpha=sumAlpha * invSumW; return result;\n}\nfn clip_history_ycocg(historyYCoCg:vec3<f32>,stats:NeighborhoodStats,motion:f32) -> vec3<f32> { let gamma=mix(0.2,0.7,motion); let v_min=min(stats.minColor,stats.mean - stats.stdDev * gamma); let v_max=max(stats.maxColor,stats.mean + stats.stdDev * gamma); return clamp(historyYCoCg,v_min,v_max);\n}\n  @group(0) @binding(0) var sourceTexture:texture_2d<f32>; @group(0) @binding(1) var historyTexture:texture_2d<f32>; @group(0) @binding(2) var motionVectorTexture:texture_2d<f32>; @group(0) @binding(3) var taaTextureSampler:sampler; @group(0) @binding(4) var depthTexture:texture_depth_2d; @group(0) @binding(5) var historyDepthTexture:texture_depth_2d;  @group(1) @binding(0) var outputTexture:texture_storage_2d<rgba16float,write>; ${tr} @group(1) @binding(2) var<uniform> uniforms:Uniforms;  @compute @workgroup_size(${this.#nr},${this.#rr},${this.#ir}) fn main(@builtin(global_invocation_id) global_id:vec3<u32>) { { let pixelCoord=vec2<i32>(global_id.xy); let screenSizeU=textureDimensions(sourceTexture); let screenSize=vec2<f32>(screenSizeU); let yFlipVec2=vec2<f32>(1.0,-1.0); if (any(pixelCoord >=vec2<i32>(screenSizeU))) { return; } let currentUV=(vec2<f32>(pixelCoord) + 0.5 - uniforms.currJitterOffset * yFlipVec2)/screenSize; let stats=calculate_neighborhood_stats_ycocg(pixelCoord,screenSizeU); let currentRGBA=textureSampleLevel(sourceTexture,taaTextureSampler,currentUV,0.0); let currentRGB=currentRGBA.rgb; let currentAlpha=currentRGBA.a; let currentYCoCg=rgb_to_ycocg(currentRGB); let currentDepth=textureLoad(depthTexture,pixelCoord,0); var closestDepth=1.0; var closestCoord=pixelCoord; for(var y:i32=-1;y <=1;y++) { for(var x:i32=-1;x <=1;x++) { let sc=clamp(pixelCoord + vec2<i32>(x,y),vec2<i32>(0),vec2<i32>(screenSizeU) - 1); let d=textureLoad(depthTexture,sc,0); if(d < closestDepth) { closestDepth=d; closestCoord=sc; } } } let motionData=textureLoad(motionVectorTexture,closestCoord,0); let velocity=motionData.xy; let jitterDisabled=motionData.z > 0.5; if (jitterDisabled) { textureStore(outputTexture,pixelCoord,vec4<f32>(currentRGB,currentAlpha)); return; } let historyUV=(vec2<f32>(pixelCoord) + 0.5 - uniforms.currJitterOffset * yFlipVec2 + uniforms.prevJitterOffset * yFlipVec2)/screenSize - velocity; var finalRGB:vec3<f32>; var finalAlpha:f32; if (any(historyUV < vec2<f32>(0.0)) || any(historyUV > vec2<f32>(1.0))) { finalRGB=currentRGB; finalAlpha=currentAlpha; } else { let prevDepth=fetch_depth_bilinear(historyDepthTexture,historyUV,screenSize); let historyData=sample_texture_catmull_rom_antiflicker(historyTexture,taaTextureSampler,historyUV,screenSize); let motionLen=length(velocity * screenSize); let motionSoft=smoothstep(0.0,1.0,motionLen); let clippedYCoCg=clip_history_ycocg(historyData.ycocg,stats,motionSoft); let clippedAlpha=clamp(historyData.alpha,stats.minAlpha,stats.maxAlpha); let clippedHistoryRGB=ycocg_to_rgb(clippedYCoCg); let lumaWeight=get_color_discrepancy_weight(stats,clippedYCoCg); var blendFactor=mix(0.08,0.4,motionSoft); let depthConfidence=get_depth_confidence(currentDepth,prevDepth); blendFactor=max(blendFactor,1.0 - depthConfidence * depthConfidence); blendFactor=max(blendFactor,lumaWeight * 0.5); let currentRGBA=vec4<f32>(currentRGB,currentAlpha); let clippedHistoryRGBA=vec4<f32>(clippedHistoryRGB,clippedAlpha); let finalRGBA=mix(clippedHistoryRGBA,currentRGBA,blendFactor); finalRGB=finalRGBA.rgb; finalAlpha=finalRGBA.a; } textureStore(outputTexture,pixelCoord,vec4<f32>(finalRGB,finalAlpha));\n} } `;return{msaa:createCode(),nonMsaa:createCode()}}#ne(i,g,x){this.#h=g;const{resourceManager:_}=i;this.#Gn=_.createGPUShaderModule(`${g}_MSAA`,{code:x.msaa}),this.#kn=_.createGPUShaderModule(`${g}_NonMSAA`,{code:x.nonMsaa}),this.#Zn=parseWGSL(x.msaa),this.#Jn=parseWGSL(x.nonMsaa);const v=this.#Zn.storage,b=this.#Zn.uniforms;if(this.#Wn=v,this.#Yn=b.uniforms,this.#qn=b.systemUniforms,this.#Yn){const g=new ArrayBuffer(this.#Yn.arrayBufferByteLength);this.#jn=new UniformBuffer(i,g,"TAA_UniformBuffer")}}#ol(i,g,x){const _=i.createCommandEncoder({label:"TAA_Execute_CommandEncoder_compute"}),v=_.beginComputePass();v.setPipeline(this.#Xn),v.setBindGroup(0,this.#Qu),v.setBindGroup(1,this.#el),v.dispatchWorkgroups(Math.ceil(g/this.#nr),Math.ceil(x/this.#rr)),v.end(),i.queue.submit([_.finish()])}#sl(i,g,x,_,v){const b=[],y=[];b.push({binding:0,resource:g[0]}),b.push({binding:1,resource:this.#Ju}),b.push({binding:4,resource:i.viewRenderTextureManager.depthTextureView}),b.push({binding:5,resource:i.viewRenderTextureManager.prevDepthTextureView});const S=x?i.viewRenderTextureManager.gBufferMotionVectorResolveTextureView:i.viewRenderTextureManager.gBufferMotionVectorTextureView;b.push({binding:2,resource:S}),b.push({binding:3,resource:i.redGPUContext.resourceManager.basicSampler.gpuSampler}),y.push({binding:0,resource:this.#Wu}),this.#qn&&y.push({binding:this.#qn.binding,resource:{buffer:i.postEffectManager.postEffectSystemUniformBuffer.gpuBuffer,offset:0,size:i.postEffectManager.postEffectSystemUniformBuffer.size}}),this.#jn&&this.#Yn&&y.push({binding:this.#Yn.binding,resource:{buffer:this.#jn.gpuBuffer,offset:0,size:this.#jn.size}}),this.#dr(b,y,x,_,v),this.#ul(x,_,v)}#dr(i,g,x,_,v){const b=x?this.#Zn:this.#Jn,y=`${this.#h}_BIND_GROUP_LAYOUT_0_USE_MSAA_${x}`,S=`${this.#h}_BIND_GROUP_LAYOUT_1_USE_MSAA_${x}`;if(!this.#Ku.has(y)){const i=_.resourceManager.getGPUBindGroupLayout(y)||_.resourceManager.createBindGroupLayout(y,getComputeBindGroupLayoutDescriptorFromShaderInfo(b,0,x));this.#Ku.set(y,i)}if(!this.#Ku.has(S)){const i=_.resourceManager.getGPUBindGroupLayout(S)||_.resourceManager.createBindGroupLayout(S,getComputeBindGroupLayoutDescriptorFromShaderInfo(b,1,x));this.#Ku.set(S,i)}this.#On=this.#Ku.get(y),this.#Nn=this.#Ku.get(S),this.#Qu=v.createBindGroup({label:`${this.#h}_FRAME_BIND_GROUP_0_USE_MSAA_${x}`,layout:this.#On,entries:i}),this.#el=v.createBindGroup({label:`${this.#h}_FRAME_BIND_GROUP_1_USE_MSAA_${x}`,layout:this.#Nn,entries:g})}#ul(i,g,x){const _=`${this.#h}_COMPUTE_PIPELINE_USE_MSAA_${i}`,v=`${this.#h}_PIPELINE_LAYOUT_USE_MSAA_${i}`;if(this.#Yu!==i||!this.#ju.has(_)){if(!this.#Xu.has(v)){const g=x.createPipelineLayout({label:`${this.#h}_PIPELINE_LAYOUT_USE_MSAA_${i}`,bindGroupLayouts:[this.#On,this.#Nn]});this.#Xu.set(v,g)}const g=i?this.#Gn:this.#kn,b=x.createComputePipeline({label:_,layout:this.#Xu.get(v),compute:{module:g,entryPoint:"main"}});this.#ju.set(_,b),this.#Yu=i}this.#Xn=this.#ju.get(_)}#hr(i){const{redGPUContext:x,viewRenderTextureManager:_,name:v}=i,{gBufferColorTexture:b}=_,{resourceManager:y}=x,{width:S,height:w}=b,L=S!==this.#Qn?.width||w!==this.#Qn?.height||!this.#qu||!this.#Zu||!this.#qu;return L&&(g(`TAA 텍스처 재생성:${S}x${w},이전 프레임 히스토리 리셋`),this.#tl=0,this.clear(),this.#qu=y.createManagedTexture({size:{width:S,height:w},format:"rgba16float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,label:`${v}_${this.#h}_currentFrame_${S}x${w}`}),this.#Wu=y.getGPUResourceBitmapTextureView(this.#qu,{dimension:"2d",format:"rgba16float",label:`${this.#h}_currentFrame_View`}),this.#Zu=y.createManagedTexture({size:{width:S,height:w},format:"rgba16float",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST,label:`${v}_${this.#h}_previousFrame_${S}x${w}`}),this.#Ju=y.getGPUResourceBitmapTextureView(this.#Zu,{dimension:"2d",format:"rgba16float",label:`${this.#h}_previousFrame`})),this.#Qn={width:S,height:w},this.#pr(),L}#pr(){this.#N=0,this.#qu&&(this.#N+=calculateTextureByteSize(this.#qu)),this.#Zu&&(this.#N+=calculateTextureByteSize(this.#Zu))}#fr(i){if(!this.#ur||this.#ur.length!==i.length)return this.#ur=[...i],!0;for(let g=0;g<i.length;g++)if(this.#ur[g]!==i[g])return this.#ur=[...i],!0;return!1}}let Gi,ki,Oi,Ni,Vi;Object.freeze(TAA);let Fi,zi=create$3(),Hi=create$4(),$i=create$4();const screenToWorld=(i,g,x)=>{const{rawCamera:_,pixelRectArray:v}=x;return Gi=2*(i*window.devicePixelRatio+v[0])/v[2]-1,ki=-2*(g*window.devicePixelRatio+v[1])/v[3]+1,Oi=1,multiply$4($i,x.noneJitterProjectionMatrix,_.modelMatrix),Fi=clone$4($i),invert$1(Fi,Fi),zi=fromValues$3(Gi,ki,1),identity$1(Hi),translate(Hi,Hi,zi),multiply$4(Fi,Fi,Hi),zi[0]=Fi[12],zi[1]=Fi[13],zi[2]=Fi[14],Ni=$i[12]*Gi+$i[13]*ki+$i[15],0!==Ni&&(Vi=1/Ni,zi[0]/=Vi,zi[1]/=Vi,zi[2]/=Vi,zi[0]=zi[0]+_.x,zi[1]=zi[1]+_.y,zi[2]=zi[2]+_.z),[zi[0],zi[1],zi[2]]};class Box extends Primitive{#Ei=function(){let i,g;return g=function(g,x,_,v,b,y,S,w,L,k,z,H,q){let W,be,Ke=w/z,Xe=L/H,je=w/2,Ye=L/2,Ze=k/2,Je=z+1,Qe=H+1,et=0,tt=[];for(be=0;be<Qe;be++){let i=be*Xe-Ye;for(W=0;W<Je;W++){let x=W*Ke-je;tt[_]=x*y,tt[v]=i*S,tt[b]=Ze,g.push(tt.x,tt.y,tt.z),tt[_]=0,tt[v]=0,tt[b]=k>0?1:-1,g.push(tt.x,tt.y,tt.z),g.push(W/z*q,be/H*q),et+=1}}for(be=0;be<H;be++)for(W=0;W<z;W++){let g=i+W+Je*be,_=i+W+Je*(be+1),v=i+(W+1)+Je*(be+1),b=i+(W+1)+Je*be;x.push(g,_,b,_,v,b)}i+=et},function(x,_,v,b,y,S,w,L,k){let z=[],H=[];return i=0,g(z,H,"z","y","x",-1,-1,y,b,v,L,w,k),g(z,H,"z","y","x",1,-1,y,b,-v,L,w,k),g(z,H,"x","z","y",1,1,v,y,b,S,L,k),g(z,H,"x","z","y",1,-1,v,y,-b,S,L,k),g(z,H,"x","y","z",1,-1,v,b,y,S,w,k),g(z,H,"x","y","z",-1,-1,v,b,-y,S,w,k),createPrimitiveGeometry(_,z,H,x)}}();constructor(i,g=1,x=1,_=1,v=1,b=1,y=1,S=1){super(i);const w=`PRIMITIVE_BOX_W${g}_H${x}_D${_}_WS${v}_HS${b}_DS${y}_UV${S}`,L=i.resourceManager.cachedBufferState;let k=L[w];k||(k=L[w]=this.#Ei(w,i,g,x,_,v,b,y,S)),this._setData(k)}}class Cylinder extends Primitive{#Ei=function(){let i,g;return function(x,_,v,b,y,S,w,L,k,z){const H=[],q=[];let W=0;const be=[],Ke=y/2;return i=function(){let i,g;const x=[],_=[],L=(b-v)/y;for(g=0;g<=w;g++){const q=[],Xe=g/w,je=Xe*(b-v)+v;for(i=0;i<=S;i++){const g=i/S,v=g*z+k,b=Math.sin(v),w=Math.cos(v);_[0]=je*b,_[1]=-Xe*y+Ke,_[2]=je*w,H.push(_[0],_[1],_[2]),x[0]=b,x[1]=L,x[2]=w,normalize$3(x,x),H.push(x[0],x[1],x[2]),H.push(g,Xe),q.push(W++)}be.push(q)}for(i=0;i<S;i++)for(g=0;g<w;g++){const x=be[g][i],_=be[g+1][i],v=be[g+1][i+1],b=be[g][i+1];q.push(x,_,b),q.push(_,v,b)}},g=function(i){let g,x,_;const y=[],w=[],L=!0===i?v:b,be=!0===i?1:-1;for(x=W,g=1;g<=S;g++)H.push(0,Ke*be,0),H.push(0,be,0),H.push(.5,.5),W++;for(_=W,g=0;g<=S;g++){const i=g/S*z+k,x=Math.cos(i),_=Math.sin(i);w[0]=L*_,w[1]=Ke*be,w[2]=L*x,H.push(w[0],w[1],w[2]),H.push(0,be,0),y[0]=.5*x+.5,y[1]=.5*_*be+.5,H.push(y[0],1-y[1]),W++}for(g=0;g<S;g++){const v=x+g,b=_+g;!0===i?q.push(b,b+1,v):q.push(b+1,b,v)}},i(),!1===L&&(v>0&&g(!0),b>0&&g(!1)),createPrimitiveGeometry(_,H,q,x)}}();constructor(i,g=1,x=1,_=1,v=8,b=8,y=!1,S=0,w=2*Math.PI){super(i);const L=`PRIMITIVE_CYLINDER_RT${g}_RB${x}_H${_}_RS${v}_HS${b}_TS${y}_TS${S}_TL${w}`,k=i.resourceManager.cachedBufferState;let z=k[L];z||(z=k[L]=this.#Ei(L,i,g,x,_,v,b,y,S,w)),this._setData(z)}}class Sphere extends Primitive{#Ei=function(){let i,g,x,_,v,b,y,S,w=[];const L=new Float32Array(3),k=new Float32Array(3);return function(z,H,q,W,be,Ke,Xe,je,Ye,Ze){i=je+Ye,_=0,w.length=0;const Je=[],Qe=[];for(x=0;x<=be;x++){const i=[],v=x/be;for(g=0;g<=W;g++){const x=g/W;L[0]=-q*Math.cos(Ke+x*Xe)*Math.sin(je+v*Ye),L[1]=q*Math.cos(je+v*Ye),L[2]=q*Math.sin(Ke+x*Xe)*Math.sin(je+v*Ye),Je.push(L[0],L[1],L[2]),k[0]=L[0],k[1]=L[1],k[2]=L[2],normalize$3(k,k),Je.push(k[0],k[1],k[2]),Je.push(x*Ze,v*Ze),i.push(_++)}w.push(i)}for(x=0;x<be;x++)for(g=0;g<W;g++)v=w[x][g+1],b=w[x][g],y=w[x+1][g],S=w[x+1][g+1],(0!==x||je>0)&&Qe.push(v,b,S),(x!==be-1||i<Math.PI)&&Qe.push(b,y,S);return createPrimitiveGeometry(H,Je,Qe,z)}}();constructor(i,g=1,x=16,_=16,v=0,b=2*Math.PI,y=0,S=Math.PI,w=1){super(i);const L=`PRIMITIVE_SPHERE_R${g}_WS${x}_HS${_}_PS${v}_PL${b}_TS${y}_TL${S}_UV${w}`,k=i.resourceManager.cachedBufferState;let z=k[L];z||(z=k[L]=this.#Ei(L,i,g,x,_,v,b,y,S,w)),this._setData(z)}}class DrawDebuggerAxis extends Mesh{constructor(i){super(i,null,null);const g=new Mesh(i,new Sphere(i,.5),new ColorMaterial(i));this.addChild(g);const x=new Box(i);this.addChild(this.#ll(x,"#ff0000",[5,.1,.1],[2.5,0,0])),this.addChild(this.#cl(i,"#ff0000",[.5,1.25],[5.5,0,0],[0,0,90])),this.addChild(this.#ll(x,"#00ff00",[.1,5,.1],[0,2.5,0])),this.addChild(this.#cl(i,"#00ff00",[.5,1.25],[0,5.5,0],[180,0,0])),this.addChild(this.#ll(x,"#0000ff",[.1,.1,5],[0,0,2.5])),this.addChild(this.#cl(i,"#0000ff",[.5,1.25],[0,0,5.5],[-90,0,0]))}#ll(i,g,x,_){const{redGPUContext:v}=this,b=new Mesh(v,i,new ColorMaterial(v,g));return b.setScale(...x),b.setPosition(..._),b}#cl(i,g,x,_,v){const b=new Mesh(i,new Cylinder(i,x[0],.001,x[1],32,1),new ColorMaterial(i,g));return b.setScale(x[0],x[1],x[0]),b.setPosition(..._),b.setRotation(...v),b}}var Ki="#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include FragmentOutput;\n#redgpu_include calculateMotionVector;\nstruct VertexIn { @location(0) position:vec4<f32>, @location(1) color:vec4<f32>,\n}\nstruct VertexOut { @builtin(position) position:vec4<f32>, @location(0) color:vec4<f32>, @location(1) worldPos:vec3<f32>, @location(2) currentClipPos:vec4<f32>, @location(3) prevClipPos:vec4<f32>,\n}\nstruct GridArgs { lineColor:vec4<f32>,\n}\n@group(1) @binding(0) var<uniform> gridArgs:GridArgs;\nconst FADE_START:f32=20.0;\nconst FADE_END:f32=80.0;\nconst AXIS_THRESHOLD:f32=0.8;\nconst AXIS_ALPHA:f32=0.8;\n@vertex\nfn vertexMain(inputData:VertexIn) -> VertexOut { var output:VertexOut; let modelPos=inputData.position; let viewProj=systemUniforms.noneJitterProjectionCameraMatrix; let prevViewProj=systemUniforms.prevNoneJitterProjectionCameraMatrix; output.position=viewProj * modelPos; output.worldPos=modelPos.xyz; output.color=inputData.color; output.currentClipPos=output.position; output.prevClipPos=prevViewProj * modelPos; return output;\n}\n@fragment\nfn fragmentMain(inputData:VertexOut) -> FragmentOutput { var output:FragmentOutput; let distanceToCamera=length(inputData.worldPos - systemUniforms.camera.cameraPosition); let distanceFade=clamp(1.0 - saturate((distanceToCamera - FADE_START)/(FADE_END - FADE_START)),0.5,1.0); var finalColor:vec3<f32>; var baseAlpha:f32; let isXAxis=inputData.color.r > AXIS_THRESHOLD; let isZAxis=inputData.color.b > AXIS_THRESHOLD; if (isXAxis) { finalColor=vec3<f32>(1.0,0.0,0.0); baseAlpha=AXIS_ALPHA; } else if (isZAxis) { finalColor=vec3<f32>(0.0,0.0,1.0); baseAlpha=AXIS_ALPHA; } else { finalColor=gridArgs.lineColor.rgb; baseAlpha=gridArgs.lineColor.a; } output.color=vec4<f32>(finalColor,baseAlpha * distanceFade); let motion=calculateMotionVector(inputData.currentClipPos,inputData.prevClipPos); output.gBufferMotionVector=vec4<f32>(motion,0.0,1.0); return output;\n}\n";const Xi=parseWGSL(Ki),ji=Xi.uniforms.gridArgs;class DrawDebuggerGrid{#fi;#di;#jn;#hl;#Q;#fl;#mn;#pn;#dl;#en=100;#f;#h;#mo;#fo;#oo;#uo;#ml;constructor(i){validateRedGPUContext(i),this.#mo=DrawBufferManager.getInstance(i),this.#f=InstanceIdGenerator.getNextId(this.constructor);const{resourceManager:g,gpuDevice:x}=i,_={code:Ki},v=g.createGPUShaderModule("VERTEX_MODULE_GRID",_);this.#mn=new BlendState(this,mr.SRC_ALPHA,mr.ONE_MINUS_SRC_ALPHA,pr.ADD),this.#pn=new BlendState(this,mr.SRC_ALPHA,mr.ONE_MINUS_SRC_ALPHA,pr.ADD),this.#dl=new ColorRGBA(128,128,128,.25);const b=g.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),y=i.resourceManager.getGPUBindGroupLayout("GRID_MATERIAL_BIND_GROUP_LAYOUT")||i.resourceManager.createBindGroupLayout("GRID_MATERIAL_BIND_GROUP_LAYOUT",getFragmentBindGroupLayoutDescriptorFromShaderInfo(Xi,1));this.#pl(i),this.#hl=x.createBindGroup({label:"FRAGMENT_BIND_GROUP_DESCRIPTOR_GRID",layout:y,entries:[{binding:0,resource:{buffer:this.#jn.gpuBuffer,offset:0,size:this.#jn.size}}]});const S={label:"PIPELINE_DESCRIPTOR_GRID",layout:x.createPipelineLayout({label:"DRAW_DEBUGGER_GRID_PIPELINE_LAYOUT",bindGroupLayouts:[b,y]}),vertex:{module:v,entryPoint:"vertexMain",buffers:[{arrayStride:this.#fi.interleavedStruct.arrayStride,attributes:this.#fi.interleavedStruct.attributes}]},primitive:{topology:"line-list"},fragment:{module:v,entryPoint:"fragmentMain",targets:[{format:"rgba16float",blend:{color:this.#mn.state,alpha:this.#pn.state}},{format:navigator.gpu.getPreferredCanvasFormat(),blend:void 0},{format:"rgba16float",blend:void 0}]},depthStencil:{format:"depth32float",depthWriteEnabled:!0,depthCompare:Tn.LESS_EQUAL}};this.#Q=x.createRenderPipeline(S),this.#fl=x.createRenderPipeline({...S,multisample:{count:4}});const w=this.#mo;this.#fo||(this.#fo=w.allocateDrawCommand(this.name),w.setIndexedIndirectCommand(this.#fo,this.#di.indexCount,1,0,0,0))}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get size(){return this.#en}set size(i){this.#en=i}get lineColor(){return this.#dl}render(i){const{view:g,currentRenderPassEncoder:x}=i,{redGPUContext:_}=g,{gpuDevice:v,antialiasingManager:b}=_,{useMSAA:y,changedMSAA:S}=b;set$3(create$3(),g.rawCamera.x,g.rawCamera.y,g.rawCamera.z),i.num3DObjects++,i.numDrawCalls++;const w=g.systemUniform_Vertex_UniformBindGroup!==this.#ml;if(this.#Q){const _=2*(2*(this.#en+1));(!this.#oo||S||w)&&(this.#oo=v.createRenderBundleEncoder({...g.basicRenderBundleEncoderDescriptor,label:this.name}),this.#oo.setPipeline(g.redGPUContext.antialiasingManager.useMSAA?this.#fl:this.#Q),this.#oo.setBindGroup(0,g.systemUniform_Vertex_UniformBindGroup),this.#oo.setBindGroup(1,this.#hl),this.#oo.setVertexBuffer(0,this.#fi.gpuBuffer),this.#oo.setIndexBuffer(this.#di.gpuBuffer,this.#di.format),this.#oo.drawIndexedIndirect(this.#fo.buffer,4*this.#fo.commandOffset),this.#uo=this.#oo.finish()),i.numTriangles+=0,i.numPoints+=_,x.executeBundles([this.#uo])}this.#ml=g.systemUniform_Vertex_UniformBindGroup}#gl(i){const g=[],x=[],_=i/2;let v=0;for(let i=-_;i<=_;i+=1){const b=0===i?[0,0,1,1]:[.5,.5,.5,1];g.push(i,0,-_,...b,i,0,_,...b),x.push(v,v+1),v+=2}for(let i=-_;i<=_;i+=1){const b=0===i?[1,0,0,1]:[.5,.5,.5,1];g.push(-_,0,i,...b,_,0,i,...b),x.push(v,v+1),v+=2}return{interleaveData:g,indexData:x}}#pl(i){const g=this.#en,{resourceManager:x}=i,{cachedBufferState:_}=x;{const x=`VertexBuffer_Grid_${g}`;let v=_[x];if(!v){const{interleaveData:b}=this.#gl(g);v=new VertexBuffer(i,b,new VertexInterleavedStruct({position:VertexInterleaveType.float32x3,color:VertexInterleaveType.float32x4}),void 0,x),_[x]=v}this.#fi=v}{const x=`IndexBuffer_Grid_${g}`;let v=_[x];if(!v){const{indexData:b}=this.#gl(g);v=new IndexBuffer(i,b,void 0,x),_[x]=v}this.#di=v}{const g="UniformBuffer_Grid";let x=_[g];if(!x){const v=new ArrayBuffer(ji.arrayBufferByteLength);x=new UniformBuffer(i,v),_[g]=x}this.#jn=x}this.#jn.writeOnlyBuffer(ji.members.lineColor,this.#dl.rgbaNormalLinear)}}class ABaseLight{drawDebugger;#xl;#_r;#ro=!1;constructor(i,g=1){this.#xl=i,this.#_r=g}get enableDebugger(){return this.#ro}set enableDebugger(i){this.#ro=i}get color(){return this.#xl}set color(i){this.#xl=i}get intensity(){return this.#_r}set intensity(i){this.#_r=i}}Object.freeze(ABaseLight);class AmbientLight extends ABaseLight{constructor(i="#ADD8E6",g=.1){super(new ColorRGB(...convertHexToRgb(i,!0)),g)}}Object.freeze(AmbientLight);class DirectionalLight extends ABaseLight{#_l=-1;#vl=-1;#bl=-1;constructor(i=[-1,-1,-1],g="#fff",x=1){super(new ColorRGB(...convertHexToRgb(g,!0)),x),this.#_l=i[0],this.#vl=i[1],this.#bl=i[2]}get directionX(){return this.#_l}set directionX(i){this.#_l=i}get directionY(){return this.#vl}set directionY(i){this.#vl=i}get directionZ(){return this.#bl}set directionZ(i){this.#bl=i}get direction(){return[this.#_l,this.#vl,this.#bl]}set direction(i){this.#_l=i[0],this.#vl=i[1],this.#bl=i[2]}}Object.freeze(DirectionalLight);class PointLight extends ABaseLight{#xr=1;#Nt=0;#Vt=0;#Ft=0;constructor(i="#fff",g=1){super(new ColorRGB(...convertHexToRgb(i,!0)),g)}get x(){return this.#Nt}set x(i){this.#Nt=i}get y(){return this.#Vt}set y(i){this.#Vt=i}get z(){return this.#Ft}set z(i){this.#Ft=i}get position(){return[this.#Nt,this.#Vt,this.#Ft]}get radius(){return this.#xr}set radius(i){this.#xr=i}setPosition(i,g,x){Array.isArray(i)?[this.#Nt,this.#Vt,this.#Ft]=i:(this.#Nt=i,this.#Vt=g,this.#Ft=x)}}Object.freeze(PointLight);class SpotLight extends ABaseLight{#xr=1;#Nt=0;#Vt=2;#Ft=0;#_l=0;#vl=-1;#bl=0;#yl=15;#Sl=22.5;constructor(i="#fff",g=1){super(new ColorRGB(...convertHexToRgb(i,!0)),g)}get x(){return this.#Nt}set x(i){this.#Nt=i}get y(){return this.#Vt}set y(i){this.#Vt=i}get z(){return this.#Ft}set z(i){this.#Ft=i}get position(){return[this.#Nt,this.#Vt,this.#Ft]}get radius(){return this.#xr}set radius(i){this.#xr=i}get directionX(){return this.#_l}set directionX(i){this.#_l=i}get directionY(){return this.#vl}set directionY(i){this.#vl=i}get directionZ(){return this.#bl}set directionZ(i){this.#bl=i}get direction(){return[this.#_l,this.#vl,this.#bl]}set direction(i){this.#_l=i[0],this.#vl=i[1],this.#bl=i[2]}get innerCutoff(){return this.#yl}set innerCutoff(i){this.#yl=i}get outerCutoff(){return this.#Sl}set outerCutoff(i){this.#Sl=i}get innerCutoffCos(){return Math.cos(this.#yl*Math.PI/180)}get outerCutoffCos(){return Math.cos(this.#Sl*Math.PI/180)}setPosition(i,g,x){Array.isArray(i)?[this.#Nt,this.#Vt,this.#Ft]=i:(this.#Nt=i,this.#Vt=g,this.#Ft=x)}lookAt(i,g,x){let _,v,b;Array.isArray(i)?[_,v,b]=i:(_=i,v=g,b=x);const y=_-this.#Nt,S=v-this.#Vt,w=b-this.#Ft,L=Math.sqrt(y*y+S*S+w*w);L>0&&(this.#_l=y/L,this.#vl=S/L,this.#bl=w/L)}}Object.freeze(SpotLight);class LightManager{#Tl=3;#Ml=q.MAX_CLUSTER_LIGHTS;#wl=[];#Cl=[];#Pl=[];#Rl;#Bl=create$4();get spotLights(){return this.#Pl}get spotLightCount(){return this.#Pl.length}get limitClusterLightCount(){return this.#Ml}get pointLights(){return this.#Cl}get pointLightCount(){return this.#Cl.length}get limitDirectionalLightCount(){return this.#Tl}get directionalLightCount(){return this.#wl.length}get directionalLights(){return this.#wl}get ambientLight(){return this.#Rl}set ambientLight(i){i instanceof AmbientLight||consoleAndThrowError("allow only AmbientLight instance"),this.#Rl=i}addSpotLight(i){i instanceof SpotLight||consoleAndThrowError("allow only SpotLight instance");this.#Pl.length+this.#Cl.length>this.#Ml&&consoleAndThrowError("Cannot add more cluster lights. The limit has been reached."),this.#Pl.push(i)}addPointLight(i){i instanceof PointLight||consoleAndThrowError("allow only PointLight instance");this.#Pl.length+this.#Cl.length>this.#Ml&&consoleAndThrowError("Cannot add more cluster lights. The limit has been reached."),this.#Cl.push(i)}addDirectionalLight(i){i instanceof DirectionalLight||consoleAndThrowError("allow only DirectionalLight instance");this.#wl.length>this.#Tl&&consoleAndThrowError("Cannot add more directional lights. The limit has been reached."),this.#wl.push(i)}removeSpotLight(i){const g=this.#Pl.indexOf(i);-1!==g&&this.#Pl.splice(g,1)}removePointLight(i){const g=this.#Cl.indexOf(i);-1!==g&&this.#Cl.splice(g,1)}removeDirectionalLight(i){const g=this.#wl.indexOf(i);-1!==g&&this.#wl.splice(g,1)}removeAllSpotLight(){this.#Pl=[]}removeAllPointLight(){this.#Cl=[]}removeAllDirectionalLight(){this.#wl=[]}removeAllLight(){this.removeAllPointLight(),this.removeAllSpotLight(),this.removeAllDirectionalLight(),this.#Rl=null}getDirectionalLightProjectionViewMatrix(i){return multiply$4(create$4(),this.getDirectionalLightProjectionMatrix(i),this.getDirectionalLightViewMatrix(i))}getDirectionalLightProjectionMatrix(i){const g=create$4(),x=i.rawCamera instanceof Camera2D?fromValues$3(0,0,0):fromValues$3(i.rawCamera.x,i.rawCamera.y,i.rawCamera.z),_=Math.max(distance$2(x,create$3()),1);return bt(g,-_,_,-_,_,3*-_,3*_),g}getDirectionalLightViewMatrix(i){identity$1(this.#Bl);const g=i.rawCamera instanceof Camera2D?fromValues$3(0,0,0):fromValues$3(i.rawCamera.x,i.rawCamera.y,i.rawCamera.z),x=Math.max(distance$2(g,create$3()),1),_=fromValues$3(0,1,0),v=fromValues$3(0,0,0),b=i.scene.lightManager.directionalLights.length?fromValues$3(-i.scene.lightManager.directionalLights[0].direction[0]*x,-i.scene.lightManager.directionalLights[0].direction[1]*x,-i.scene.lightManager.directionalLights[0].direction[2]*x):create$3(),y=create$4();return lookAt(y,b,v,_),y}}Object.freeze(LightManager);class DirectionalShadowManager{#Il=2048;#vr=.005;#El;#Dl;#Ul;#l;#Mu=[];#N=0;get videoMemorySize(){return this.#N}get castingList(){return this.#Mu}get shadowDepthTextureView(){return this.#Dl}get shadowDepthTextureViewEmpty(){return this.#Ul}get bias(){return this.#vr}set bias(i){validatePositiveNumberRange(i,0,1),this.#vr=i}get shadowDepthTextureSize(){return this.#Il}set shadowDepthTextureSize(i){validateUintRange(i,1),this.#Il=i}reset(){this.destroy()}resetCastingList(){this.#Mu.length=0}update(i){this.#l=i,this.#Ll()}destroy(){this.#El&&(this.#El.destroy(),this.#El=null,this.#Dl=null)}#pr(){const i=this.#El;if(!i)return 0;this.#N=calculateTextureByteSize(i)}#Ll(){this.#El?.width!==this.#Il&&(this.destroy(),this.#Al(),this.#pr())}#Gl(i){const g=i.createTexture({size:[1,1,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,format:"depth32float",label:`DirectionalShadowManager_EmptyDepthTexture_1x1_${Date.now()}`});this.#Ul=g.createView({label:g.label})}#Al(){const{gpuDevice:i,resourceManager:g}=this.#l;this.#El=g.createManagedTexture({size:[this.#Il,this.#Il,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,format:"depth32float",label:`DirectionalShadowManager_shadowDepthTextureSize_${this.#Il}x${this.#Il}_${Date.now()}`}),this.#Dl=this.#El.createView({label:this.#El.label}),this.#Ul||this.#Gl(i)}}Object.freeze(DirectionalShadowManager);class ShadowManager{#kl=new DirectionalShadowManager;constructor(){}get directionalShadowManager(){return this.#kl}update(i){this.#kl.update(i)}}Object.freeze(ShadowManager);class Scene extends Object3DContainer{#f;#h;#Ol=new ColorRGBA;#Nl=!1;#Vl=new LightManager;#Fl=new ShadowManager;#zl;constructor(i){super(),this.#f=InstanceIdGenerator.getNextId(this.constructor),this.#h=i}get lightManager(){return this.#Vl}get shadowManager(){return this.#Fl}get physicsEngine(){return this.#zl}set physicsEngine(i){this.#zl=i}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get backgroundColor(){return this.#Ol}set backgroundColor(i){i instanceof ColorRGBA||consoleAndThrowError("allow only ColorRGBA instance"),this.#Ol=i}get useBackgroundColor(){return this.#Nl}set useBackgroundColor(i){this.#Nl=i}}const Yi=create$4(),computeViewFrustumPlanes=(i,g)=>{multiply$4(Yi,i,g);const x=[[Yi[3]-Yi[0],Yi[7]-Yi[4],Yi[11]-Yi[8],Yi[15]-Yi[12]],[Yi[3]+Yi[0],Yi[7]+Yi[4],Yi[11]+Yi[8],Yi[15]+Yi[12]],[Yi[3]+Yi[1],Yi[7]+Yi[5],Yi[11]+Yi[9],Yi[15]+Yi[13]],[Yi[3]-Yi[1],Yi[7]-Yi[5],Yi[11]-Yi[9],Yi[15]-Yi[13]],[Yi[3]-Yi[2],Yi[7]-Yi[6],Yi[11]-Yi[10],Yi[15]-Yi[14]],[Yi[3]+Yi[2],Yi[7]+Yi[6],Yi[11]+Yi[10],Yi[15]+Yi[14]]];for(let i=0;i<6;i++){const g=x[i],_=Math.sqrt(g[0]*g[0]+g[1]*g[1]+g[2]*g[2]);g[0]/=_,g[1]/=_,g[2]/=_,g[3]/=_}return x};class ViewTransform{onResize=null;#l;#Hl=create$4();#$l=create$4();#Yi;#Nt=0;#Vt=0;#It;#Et;#Dt=[0,0,0,0];#Kl=0;#Xl=0;constructor(i){validateRedGPUContext(i),this.#l=i,this.setSize("100%","100%")}get redGPUContext(){return this.#l}get camera(){return this.#Yi}set camera(i){i instanceof PerspectiveCamera||i instanceof Camera2D||i instanceof OrthographicCamera||i instanceof AController||consoleAndThrowError("allow PerspectiveCamera or OrthographicCamera or AController instance"),this.#Yi=i}get x(){return this.#Nt}set x(i){this.setPosition(i,this.y)}get y(){return this.#Vt}set y(i){this.setPosition(this.x,i)}get width(){return this.#It}set width(i){this.setSize(i,this.#Et)}get height(){return this.#Et}set height(i){this.setSize(this.#It,i)}get pixelRectArray(){return this.#Dt}get pixelRectObject(){return{x:this.#Dt[0],y:this.#Dt[1],width:this.#Dt[2],height:this.#Dt[3]}}get screenRectObject(){return{x:this.#Dt[0]/devicePixelRatio,y:this.#Dt[1]/devicePixelRatio,width:this.#Dt[2]/devicePixelRatio,height:this.#Dt[3]/devicePixelRatio}}get aspect(){return this.#Dt[2]/this.#Dt[3]}get frustumPlanes(){return this.#Yi instanceof AController?computeViewFrustumPlanes(this.projectionMatrix,this.#Yi.camera.modelMatrix):computeViewFrustumPlanes(this.projectionMatrix,this.#Yi.modelMatrix)}get rawCamera(){return this.#Yi instanceof AController?this.#Yi.camera:this.#Yi}get noneJitterProjectionMatrix(){const{pixelRectObject:i,redGPUContext:g}=this;if(this.rawCamera instanceof OrthographicCamera){const{nearClipping:i,farClipping:g}=this.rawCamera;orthoZO(this.#$l,this.rawCamera.left,this.rawCamera.right,this.rawCamera.bottom,this.rawCamera.top,i,g)}else if(this.rawCamera instanceof Camera2D)bt(this.#$l,-.5,.5,-.5,.5,-1e5,1e5),scale$4(this.#$l,this.#$l,[g.renderScale,g.renderScale,1]),translate(this.#$l,this.#$l,[-.5,.5,0]),scale$4(this.#$l,this.#$l,[1/i.width*window.devicePixelRatio,-1/i.height*window.devicePixelRatio,1]);else{const{fieldOfView:i,nearClipping:g,farClipping:x}=this.rawCamera;vt(this.#$l,Math.PI/180*i,this.aspect,g,x)}return this.#$l}get projectionMatrix(){const{redGPUContext:i}=this,{antialiasingManager:g}=i;this.#Hl=clone$4(this.noneJitterProjectionMatrix);if("View3D"===this.constructor.name&&!(this.camera instanceof IsometricController)&&g.useTAA&&this.rawCamera instanceof PerspectiveCamera&&(0!==this.#Kl||0!==this.#Xl)){const i=this.#Kl/this.pixelRectObject.width*2,g=this.#Xl/this.pixelRectObject.height*2;this.#Hl[8]+=i,this.#Hl[9]+=g}return this.#Hl}get inverseProjectionMatrix(){return invert$1(create$4(),this.#Hl)}get jitterOffset(){return[this.#Kl,this.#Xl]}setJitterOffset(i,g){this.#Kl=i,this.#Xl=g}clearJitterOffset(){this.#Kl=0,this.#Xl=0}setPosition(i=this.#Nt,g=this.#Vt){const{sizeManager:x}=this.#l;RedGPUContextSizeManager.validatePositionValue(i),RedGPUContextSizeManager.validatePositionValue(g),this.#Nt=i,this.#Vt=g;const _=x.pixelRectObject,v=RedGPUContextSizeManager.getPixelDimension(_,"width",i),b=RedGPUContextSizeManager.getPixelDimension(_,"height",g);this.#Dt[0]=Math.floor(v*(this.#Nt.toString().includes("%")?1:x.renderScale*window.devicePixelRatio)),this.#Dt[1]=Math.floor(b*(this.#Vt.toString().includes("%")?1:x.renderScale*window.devicePixelRatio))}setSize(i=this.#It,g=this.#Et){const{sizeManager:x}=this.#l;RedGPUContextSizeManager.validateSizeValue(i),RedGPUContextSizeManager.validateSizeValue(g),this.#It=i,this.#Et=g;const _=x.pixelRectObject,v=RedGPUContextSizeManager.getPixelDimension(_,"width",i),b=RedGPUContextSizeManager.getPixelDimension(_,"height",g);this.#Dt[2]=Math.max(1,Math.floor(v*(this.#It.toString().includes("%")?1:x.renderScale*window.devicePixelRatio))),this.#Dt[3]=Math.max(1,Math.floor(b*(this.#Et.toString().includes("%")?1:x.renderScale*window.devicePixelRatio))),this.onResize&&this.onResize({target:this,screenRectObject:this.screenRectObject,pixelRectObject:this.pixelRectObject})}}Object.freeze(ViewTransform);class AView extends ViewTransform{#h;#jl;#f;#Yl=new PickingManager;#ql=!0;#Wl=!1;#Zl=50;#Jl;#Ql;#ec;#tc;constructor(i,g,x,_){super(i),this.scene=g,this.camera=x,_&&(this.name=_)}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get scene(){return this.#jl}set scene(i){i instanceof Scene||consoleAndThrowError("allow only Scene instance"),this.#jl=i}get pickingManager(){return this.#Yl}get useFrustumCulling(){return this.#ql}set useFrustumCulling(i){this.#ql=i}get useDistanceCulling(){return this.#Wl}set useDistanceCulling(i){this.#Wl=i}get distanceCulling(){return this.#Zl}set distanceCulling(i){this.#Zl=i}get grid(){return this.#Jl}set grid(i){if("boolean"==typeof i)i=!0===i?new DrawDebuggerGrid(this.redGPUContext):null;else if(!(i instanceof DrawDebuggerGrid)&&null!==i)throw new TypeError("grid must be of type 'DrawDebuggerGrid','boolean',or 'null'.");this.#Jl=i}get axis(){return this.#Ql}set axis(i){if("boolean"==typeof i)i=!0===i?new DrawDebuggerAxis(this.redGPUContext):null;else if(!(i instanceof DrawDebuggerAxis)&&null!==i)throw new TypeError("axis must be of type 'DrawDebuggerAxis','boolean',or 'null'.");this.#Ql=i}get fxaa(){return this.#tc||(this.#tc=new FXAA(this.redGPUContext)),this.#tc}get taa(){return this.#ec||(this.#ec=new TAA(this.redGPUContext)),this.#ec}screenToWorld(i,g){return screenToWorld(i,g,this)}checkMouseInViewBounds(){const{pixelRectObject:i,pickingManager:g}=this,{mouseX:x,mouseY:_}=g;return 0<x&&x<i.width&&0<_&&_<i.height}}Object.freeze(AView);class RenderViewStateData{useDistanceCulling;cullingDistanceSquared;distanceCulling;num3DGroups;num3DObjects;numDrawCalls;numDirtyPipelines;numInstances;numTriangles;numPoints;viewRenderTime;viewportSize;viewIndex;swapBufferIndex=1;usedVideoMemory;currentRenderPassEncoder;frustumPlanes;prevVertexGpuBuffer;prevFragmentUniformBindGroup;dirtyVertexUniformFromMaterial={};bundleListAlphaLayer=[];bundleListTransparentLayer=[];bundleListParticleLayer=[];bundleListRender2PathLayer=[];skinList=[];animationList=[];bundleListBasicList=[];timestamp;prevTimestamp=0;startTime;isScene2DMode=!1;needResetRenderLayer=!1;#zt;#nc;constructor(i){this.#zt=i}get view(){return this.#zt}reset(i,g){if(!g||!this.#zt)throw new Error("Invalid parameters provided");const x=this.#zt,{useFrustumCulling:_,frustumPlanes:v,scene:b,postEffectManager:y,pickingManager:S,viewRenderTextureManager:w}=x,{gBufferColorTexture:L,depthTexture:k}=x.viewRenderTextureManager,{shadowManager:z}=b;if(!L||!k)throw new Error("Invalid view properties");this.useDistanceCulling=x.useDistanceCulling,this.distanceCulling=x.distanceCulling,this.cullingDistanceSquared=this.distanceCulling*this.distanceCulling,this.num3DGroups=0,this.num3DObjects=0,this.numDrawCalls=0,this.numInstances=0,this.numDirtyPipelines=0,this.numTriangles=0,this.numPoints=0,this.viewRenderTime=0,this.currentRenderPassEncoder=i,this.timestamp=g,this.prevVertexGpuBuffer=null,this.prevFragmentUniformBindGroup=null,this.dirtyVertexUniformFromMaterial={},this.bundleListAlphaLayer.length=0,this.bundleListTransparentLayer.length=0,this.bundleListParticleLayer.length=0,this.bundleListRender2PathLayer.length=0,this.bundleListBasicList.length=0,this.needResetRenderLayer=!1,this.#nc=this.#zt.redGPUContext.antialiasingManager.msaaID,this.skinList.length=0,this.animationList.length=0,this.startTime=performance.now(),this.isScene2DMode=x.camera instanceof Camera2D,this.viewIndex=x.redGPUContext.getViewIndex(x),this.swapBufferIndex=this.swapBufferIndex?0:1,this.viewportSize={x:x.x,y:x.y,width:x.width,height:x.height,pixelRectArray:x.pixelRectArray};try{this.usedVideoMemory=w.videoMemorySize+z.directionalShadowManager.videoMemorySize+y.videoMemorySize+S.videoMemorySize}catch(i){throw new Error("Could not calculate texture size:"+i.message)}this.frustumPlanes=_?v:null}}class ViewRenderTextureManager{#rc;#ic;#ac;#sc;#oc;#uc;#lc;#N=0;#l;#zt;#cc=new Map;#hc={};#fc;constructor(i){validateRedGPUContext(i.redGPUContext),this.#l=i.redGPUContext,this.#zt=i}get videoMemorySize(){return this.#N}get renderPath1ResultTextureDescriptor(){return this.#ac}get depthTexture(){return this.#zt.renderViewStateData.swapBufferIndex?this.#oc:this.#sc}get depthTextureView(){return this.#Al(),this.#zt.renderViewStateData.swapBufferIndex?this.#lc:this.#uc}get prevDepthTextureView(){return this.#Al(),this.#zt.renderViewStateData.swapBufferIndex?this.#uc:this.#lc}get renderPath1ResultTextureView(){return this.#ic}get renderPath1ResultTexture(){return this.#dc("rgba16float"),this.#rc}get gBufferColorTexture(){return this.#cc.get("gBufferColor")?.texture}get gBufferColorResolveTexture(){return this.#cc.get("gBufferColor")?.resolveTexture}get gBufferColorTextureView(){return this.#mc("gBufferColor","rgba16float"),this.#cc.get("gBufferColor")?.textureView}get gBufferColorResolveTextureView(){return this.#cc.get("gBufferColor")?.resolveTextureView}get gBufferNormalTexture(){return this.#cc.get("gBufferNormal")?.texture}get gBufferNormalResolveTexture(){return this.#cc.get("gBufferNormal")?.resolveTexture}get gBufferNormalTextureView(){return this.#mc("gBufferNormal"),this.#cc.get("gBufferNormal")?.textureView}get gBufferNormalResolveTextureView(){return this.#cc.get("gBufferNormal")?.resolveTextureView}get gBufferMotionVectorTexture(){return this.#cc.get("gBufferMotionVector")?.texture}get gBufferMotionVectorResolveTexture(){return this.#cc.get("gBufferMotionVector")?.resolveTexture}get gBufferMotionVectorTextureView(){return this.#mc("gBufferMotionVector","rgba16float"),this.#cc.get("gBufferMotionVector")?.textureView}get gBufferMotionVectorResolveTextureView(){return this.#cc.get("gBufferMotionVector")?.resolveTextureView}#pc(){const i=[this.#cc.get("gBufferColor")?.texture,this.#cc.get("gBufferColor")?.resolveTexture,this.#sc,this.#rc,this.#cc.get("gBufferNormal")?.texture,this.#cc.get("gBufferNormal")?.resolveTexture].filter(Boolean);this.#N=i.reduce((i,g)=>i+calculateTextureByteSize(g),0)}#mc(i,x){const{antialiasingManager:_,resourceManager:v}=this.#l,{useMSAA:b}=_,y=this.#cc.get(i),S=y?.texture,{pixelRectObject:w,name:L}=this.#zt,{width:k,height:z}=w,H=S?.width!==k||S?.height!==z,q=this.#hc[i]!==b,W=!S||H||q;if(this.#hc[i]=b,W){g(`새 텍스처 생성 중:${i}`),S&&(S?.destroy(),y.texture=null,y.textureView=null,y.resolveTexture?.destroy(),y.resolveTexture=null,y.resolveTextureView=null,this.#cc.delete(i));const _={texture:null,textureView:null,resolveTexture:null,resolveTextureView:null},w=v.createManagedTexture({size:[Math.max(k,1),Math.max(z,1),1],sampleCount:b?4:1,label:`${L}_${i}_texture_${k}x${z}`,format:x||navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});if(_.texture=w,_.textureView=v.getGPUResourceBitmapTextureView(w),b){const g=v.createManagedTexture({size:{width:Math.max(k,1),height:Math.max(z,1),depthOrArrayLayers:1},sampleCount:1,label:`${L}_${i}_resolveTexture_${k}x${z}`,format:x||navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});_.resolveTexture=g,_.resolveTextureView=v.getGPUResourceBitmapTextureView(g)}this.#cc.set(i,_),this.#pc()}}#dc(i){const{resourceManager:g}=this.#l,x=this.#rc,{pixelRectObject:_,name:v}=this.#zt,{width:b,height:y}=_;(!x||(x?.width!==b||x?.height!==y))&&(x&&(this.#rc=null,this.#ic=null),this.#ac={size:{width:Math.max(1,b),height:Math.max(1,y),depthOrArrayLayers:1},format:i,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,mipLevelCount:getMipLevelCount(b,y),label:`${v}_renderPath1ResultTexture_${b}x${y}`},this.#rc=g.createManagedTexture(this.#ac),this.#ic=g.getGPUResourceBitmapTextureView(this.#rc),this.#pc(),requestAnimationFrame(()=>{x?.destroy()}))}#Al(){const{antialiasingManager:i,resourceManager:g}=this.#l,{useMSAA:x}=i,_=this.#sc,{pixelRectObject:v,name:b}=this.#zt,{width:y,height:S}=v,w=_?.width!==y||_?.height!==S,L=this.#hc.depth!==x,k=!_||w||L;if(this.#hc.depth=x,k){_&&(_?.destroy(),this.#oc?.destroy(),this.#sc=null,this.#oc=null,this.#uc=null,this.#lc=null);const i=g.createManagedTexture({size:[Math.max(y,1),Math.max(S,1),1],sampleCount:x?4:1,label:`${b}_depth0_${y}x${S}`,format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});this.#sc=i,this.#uc=g.getGPUResourceBitmapTextureView(i);{const i=g.createManagedTexture({size:[Math.max(y,1),Math.max(S,1),1],sampleCount:x?4:1,label:`${b}_depth1_${y}x${S}`,format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});this.#oc=i,this.#lc=g.getGPUResourceBitmapTextureView(i)}this.#pc()}}}Object.freeze(ViewRenderTextureManager);const qi={LINEAR:"linear",KHRONOS_PBR_NEUTRAL:"khronosPBRNeutral",ACES_FILMIC_HILL:"ACESFilmicHill",ACES_FILMIC_NARKOWICZ:"ACESFilmicNarkowicz"};Object.freeze(qi);var Wi="struct Uniforms { exposure:f32, contrast:f32, brightness:f32, _pad:f32,\n};\nfn linearToSRGB(linearColor:vec3<f32>) -> vec3<f32> { let a=0.055; let cutoff=0.0031308; let gamma=2.4; var srgb:vec3<f32>; for (var i=0;i < 3;i++) { let c=linearColor[i]; if (c <=cutoff) { srgb[i]=12.92 * c; } else { srgb[i]=(1.0 + a) * pow(c,1.0/gamma) - a; } } return srgb;\n}\nfn linearToneMapping(color:vec3<f32>,exposure:f32) -> vec3<f32> { let exposed=color * exposure; return exposed;\n}\nfn khronosPBRNeutralToneMapping(color:vec3<f32>,exposure:f32) -> vec3<f32> { let startCompression:f32=0.8 - 0.04; let desaturation:f32=0.15; var col=color * exposure; let x=min(col.r,min(col.g,col.b)); var offset:f32; if (x < 0.08) { offset=x - 6.25 * x * x; } else { offset=0.04; } col=col - vec3<f32>(offset); let peak=max(col.r,max(col.g,col.b)); if (peak < startCompression) { return clamp(col,vec3<f32>(0.0),vec3<f32>(1.0)); } let d=1.0 - startCompression; let newPeak=1.0 - d * d/(peak + d - startCompression); col=col * (newPeak/peak); let g=1.0 - 1.0/(desaturation * (peak - newPeak) + 1.0); return clamp(mix(col,vec3<f32>(newPeak),g),vec3<f32>(0.0),vec3<f32>(1.0));\n}\nfn acesFilmicNarkowiczToneMapping(color:vec3<f32>,exposure:f32) -> vec3<f32> { let x=color * exposure; let a=2.51; let b=0.03; let c=2.43; let d=0.59; let e=0.14; return clamp((x * (a * x + b))/(x * (c * x + d) + e),vec3<f32>(0.0),vec3<f32>(1.0));\n}\nfn acesFilmicHillToneMapping(color:vec3<f32>,exposure:f32) -> vec3<f32> { let v=color * exposure; let a1=v.r * 0.59719 + v.g * 0.35458 + v.b * 0.04823; let a2=v.r * 0.07600 + v.g * 0.90834 + v.b * 0.01566; let a3=v.r * 0.02840 + v.g * 0.13383 + v.b * 0.83777; let a=vec3<f32>(a1,a2,a3); let b=(a * (a + 0.0245786) - 0.000090537)/(a * (0.983729 * a + 0.4329510) + 0.238081); let r=b.r * 1.60475 - b.g * 0.53108 - b.b * 0.07367; let g=b.r * -0.10208 + b.g * 1.10813 - b.b * 0.00605; let bl=b.r * -0.00327 - b.g * 0.07276 + b.b * 1.07602; return clamp(vec3<f32>(r,g,bl),vec3<f32>(0.0),vec3<f32>(1.0));\n}\nfn getFinalSRGB(toneMappedColor:vec3<f32>,contrast:f32,brightness:f32) -> vec3<f32> { let contrastRGB=applyContrast(toneMappedColor,uniforms.contrast); let finalLinearRGB=applyBrightness(contrastRGB,uniforms.brightness); let finalSRGB=clamp(linearToSRGB(finalLinearRGB),vec3<f32>(0.0),vec3<f32>(1.0)); return finalSRGB;\n}\nfn applyContrast(color:vec3<f32>,contrast:f32) -> vec3<f32> { return 0.5 + contrast * (color - 0.5);\n}\nfn applyBrightness(color:vec3<f32>,brightness:f32) -> vec3<f32> { return color + brightness;\n}";class AToneMappingEffect extends ASinglePassPostEffect{#gc=1;#Tr=1;#xc=0;constructor(i){super(i)}get exposure(){return this.#gc}set exposure(i){this.#gc=Math.max(.1,Math.min(5,i)),this.updateUniform("exposure",this.#gc)}get contrast(){return this.#Tr}set contrast(i){this.#Tr=Math.max(.5,Math.min(2,i)),this.updateUniform("contrast",this.#Tr)}get brightness(){return this.#xc}set brightness(i){this.#xc=Math.max(-1,Math.min(1,i)),this.updateUniform("brightness",this.#xc)}updateUniforms(){this.updateUniform("exposure",this.#gc),this.updateUniform("contrast",this.#Tr),this.updateUniform("brightness",this.#xc)}}Object.freeze(AToneMappingEffect);class ToneLinear extends AToneMappingEffect{constructor(i){super(i),this.init(i,"POST_EFFECT_TONE_MAPPING_LINEAR",createBasicPostEffectCode(this,"{ let index=vec2<i32>(global_id.xy); let inputColor=textureLoad(sourceTexture,index); let toneMappedColor=linearToneMapping(inputColor.rgb,uniforms.exposure); let finalSRGB=getFinalSRGB( toneMappedColor,uniforms.contrast,uniforms.brightness ); textureStore(outputTexture,index,vec4<f32>(finalSRGB,inputColor.a));\n}",Wi)),this.updateUniforms()}}Object.freeze(ToneLinear);class ToneKhronosPBRNeutral extends AToneMappingEffect{constructor(i){super(i),this.init(i,"POST_EFFECT_TONE_MAPPING_KHRONOS_PBR_NEUTRAL",createBasicPostEffectCode(this,"{ let index=vec2<i32>(global_id.xy); let inputColor=textureLoad(sourceTexture,index); let toneMappedColor=khronosPBRNeutralToneMapping(inputColor.rgb,uniforms.exposure); let finalSRGB=getFinalSRGB( toneMappedColor,uniforms.contrast,uniforms.brightness ); textureStore(outputTexture,index,vec4<f32>(finalSRGB,inputColor.a));\n}",Wi)),this.updateUniforms()}}Object.freeze(ToneKhronosPBRNeutral);class ToneACESFilmicNarkowicz extends AToneMappingEffect{constructor(i){super(i),this.init(i,"POST_EFFECT_TONE_MAPPING_ACES_FILMIC_NARKOWICZ",createBasicPostEffectCode(this,"{ let index=vec2<i32>(global_id.xy); let inputColor=textureLoad(sourceTexture,index); let toneMappedColor=acesFilmicNarkowiczToneMapping(inputColor.rgb,uniforms.exposure); let finalSRGB=getFinalSRGB( toneMappedColor,uniforms.contrast,uniforms.brightness ); textureStore(outputTexture,index,vec4<f32>(finalSRGB,inputColor.a));\n}",Wi)),this.updateUniforms()}}Object.freeze(ToneACESFilmicNarkowicz);class ToneACESFilmicHill extends AToneMappingEffect{constructor(i){super(i),this.init(i,"POST_EFFECT_TONE_MAPPING_ACES_FILMIC_HILL",createBasicPostEffectCode(this,"{ let index=vec2<i32>(global_id.xy); let inputColor=textureLoad(sourceTexture,index); let toneMappedColor=acesFilmicHillToneMapping(inputColor.rgb,uniforms.exposure); let finalSRGB=getFinalSRGB( toneMappedColor,uniforms.contrast,uniforms.brightness ); textureStore(outputTexture,index,vec4<f32>(finalSRGB,inputColor.a));\n}",Wi)),this.updateUniforms()}}Object.freeze(ToneACESFilmicHill);class ToneMappingManager{#l;#zt;#_c;#vc=qi.KHRONOS_PBR_NEUTRAL;#gc=1;#Tr=1;#xc=0;constructor(i){this.#l=i.redGPUContext,this.#zt=i}get toneMapping(){return this.#bc(),this.#_c}get mode(){return this.#vc}set mode(i){this.#vc!==i&&(this.#vc=i,this.#_c&&(this.#_c.clear(),this.#_c=void 0))}get exposure(){return this.#gc}set exposure(i){validatePositiveNumberRange(i,0),this.#gc=i,this.#_c&&(this.#_c.exposure=i)}get contrast(){return this.#Tr}set contrast(i){validatePositiveNumberRange(i,0,2),this.#Tr=i,this.#_c&&(this.#_c.contrast=i)}get brightness(){return this.#xc}set brightness(i){validateNumberRange(i,-1,1),this.#xc=i,this.#_c&&(this.#_c.brightness=i)}render(i,g,x){const _=this.toneMapping;return _?_.render(this.#zt,i,g,x):x}#bc(){if(!this.#_c){switch(this.#vc){case qi.LINEAR:this.#_c=new ToneLinear(this.#l);break;case qi.KHRONOS_PBR_NEUTRAL:this.#_c=new ToneKhronosPBRNeutral(this.#l);break;case qi.ACES_FILMIC_NARKOWICZ:this.#_c=new ToneACESFilmicNarkowicz(this.#l);break;case qi.ACES_FILMIC_HILL:this.#_c=new ToneACESFilmicHill(this.#l);break;default:this.#_c=new ToneKhronosPBRNeutral(this.#l)}this.#_c&&(this.#_c.exposure=this.#gc,this.#_c.contrast=this.#Tr,this.#_c.brightness=this.#xc)}}}const Zi=parseWGSL(Ke.SYSTEM_UNIFORM).uniforms.systemUniforms;let Ji=create$4(),Qi=create$4();create$4();class View3D extends AView{#yc=Zi;#Sc;#Tc;#Mc;#wc;#Cc;#Pc;#Rc;#Bc;#Ic;#Ec={};#Dc;#it;#Uc;#Wt;#Lc;#Ac;#Gc;#kc=void 0;#Oc=void 0;#Nc;#Vc;#jr;#Yr;#qr;#Fc=create$4();constructor(i,g,x,_){super(i,g,x,_),this.#ne(),this.#Ic=new ViewRenderTextureManager(this),this.#Pc=new RenderViewStateData(this),this.#Rc=new PostEffectManager(this),this.#Bc=new ToneMappingManager(this),this.#jr=new ArrayBuffer(this.systemUniform_Vertex_StructInfo.endOffset),this.#Yr=new Float32Array(this.#jr),this.#qr=new Uint32Array(this.#jr)}get viewRenderTextureManager(){return this.#Ic}get systemUniform_Vertex_StructInfo(){return this.#yc}get systemUniform_Vertex_UniformBindGroup(){return this.#Sc}get systemUniform_Vertex_UniformBuffer(){return this.#Tc}get passLightClustersBound(){return this.#Gc}get ibl(){return this.#Cc}set ibl(i){this.#Cc=i}get postEffectManager(){return this.#Rc}get toneMappingManager(){return this.#Bc}get renderViewStateData(){return this.#Pc}get skybox(){return this.#Mc}set skybox(i){const{resourceManager:g}=this.redGPUContext,x=this.#Mc?.skyboxTexture,_=i?.skyboxTexture;x&&x!==_&&this.#zc(g,x.cacheKey,!1),this.#Mc=i}get skyAtmosphere(){return this.#wc}set skyAtmosphere(i){this.#wc=i}get basicRenderBundleEncoderDescriptor(){const{antialiasingManager:i}=this.redGPUContext,{useMSAA:g}=i;return{colorFormats:["rgba16float",navigator.gpu.getPreferredCanvasFormat(),"rgba16float"],depthStencilFormat:"depth32float",sampleCount:g?4:1}}get noneJitterProjectionCameraMatrix(){return this.#Fc}update(i=!1,g=!1,x){const{scene:_,redGPUContext:v}=this,{shadowManager:b}=_;b.update(v);const{directionalShadowManager:y}=b,S=this.ibl,w=S?.prefilterTexture?.gpuTexture,L=S?.irradianceTexture?.gpuTexture;let k=i?y.shadowDepthTextureViewEmpty:y.shadowDepthTextureView;const z=this.redGPUContext.viewList.indexOf(this),H=`${z}_${i?"shadowRender":"basic"}_2path${!!x}`;if(z>-1){let i=!0,g=this.#Ec[H];g&&(i=g.ibl!==S||g.ibl_prefilterTexture!==w||g.ibl_irradianceTexture!==L||g.renderPath1ResultTextureView!==x||g.shadowDepthTextureView!==k||!this.#Ac),i?this.#Hc(H,k,this.ibl,x):this.#Sc=this.#Ec[H].vertexUniformBindGroup,this.#Ec[H]={ibl:S,ibl_prefilterTexture:w,ibl_irradianceTexture:L,renderPath1ResultTextureView:x,shadowDepthTextureView:k,vertexUniformBindGroup:this.#Sc}}this.#$c(g),this.#Kc()}#ai(i){i.forEach(({key:i,value:g,dataView:x,targetMembers:_})=>{const v=_[i];x.set("number"==typeof g?[g]:g,v.uniformOffset/v.View.BYTES_PER_ELEMENT)})}#Kc(){const{inverseProjectionMatrix:i,noneJitterProjectionMatrix:g,projectionMatrix:x,rawCamera:_}=this,{redGPUContext:v,systemUniform_Vertex_UniformBuffer:b}=this,{gpuDevice:y}=v,{lightManager:S,shadowManager:w}=this.scene,{modelMatrix:L,position:k}=_,z=this.systemUniform_Vertex_StructInfo,{gpuBuffer:H}=b,q=_ instanceof Camera2D,{members:W}=z;{const{members:b}=z,y=b.camera.members;this.#Fc=multiply$4(Qi,g,L),this.#ai([{key:"projectionMatrix",value:x,dataView:this.#Yr,targetMembers:b},{key:"projectionCameraMatrix",value:multiply$4(Ji,x,L),dataView:this.#Yr,targetMembers:b},{key:"noneJitterProjectionMatrix",value:g,dataView:this.#Yr,targetMembers:b},{key:"noneJitterProjectionCameraMatrix",value:this.#Fc,dataView:this.#Yr,targetMembers:b},{key:"inverseProjectionMatrix",value:i,dataView:this.#Yr,targetMembers:b},{key:"prevNoneJitterProjectionCameraMatrix",value:v.antialiasingManager.useTAA?this.taa.prevNoneJitterProjectionCameraMatrix:this.#Fc,dataView:this.#Yr,targetMembers:b},{key:"resolution",value:[this.pixelRectObject.width,this.pixelRectObject.height],dataView:this.#Yr,targetMembers:b},{key:"cameraMatrix",value:L,dataView:this.#Yr,targetMembers:y},{key:"cameraPosition",value:k,dataView:this.#Yr,targetMembers:y},{key:"nearClipping",value:q?0:_.nearClipping,dataView:this.#Yr,targetMembers:y},{key:"farClipping",value:q?0:_.farClipping,dataView:this.#Yr,targetMembers:y},{key:"usePrefilterTexture",value:this.ibl?.prefilterTexture?.gpuTexture?1:0,dataView:this.#qr,targetMembers:b},{key:"time",value:this.renderViewStateData.timestamp||0,dataView:this.#Yr,targetMembers:b},{key:"isView3D",value:this.constructor===View3D?1:0,dataView:this.#qr,targetMembers:b},{key:"shadowDepthTextureSize",value:w.directionalShadowManager.shadowDepthTextureSize,dataView:this.#qr,targetMembers:b},{key:"bias",value:w.directionalShadowManager.bias,dataView:this.#Yr,targetMembers:b},{key:"directionalLightCount",value:S.directionalLightCount,dataView:this.#qr,targetMembers:b},{key:"directionalLightProjectionViewMatrix",value:S.getDirectionalLightProjectionViewMatrix(this),dataView:this.#Yr,targetMembers:b},{key:"directionalLightProjectionMatrix",value:S.getDirectionalLightProjectionMatrix(this),dataView:this.#Yr,targetMembers:b},{key:"directionalLightViewMatrix",value:S.getDirectionalLightViewMatrix(this),dataView:this.#Yr,targetMembers:b}])}S.directionalLights.forEach((i,g)=>{const{directionalLights:x}=W;i.enableDebugger&&(i.drawDebugger||(i.drawDebugger=new DrawDebuggerDirectionalLight(v,i)),i.drawDebugger.render(this.renderViewStateData));const _=x.memberList[g];this.#ai([{key:"direction",value:i.direction,dataView:this.#Yr,targetMembers:_},{key:"color",value:i.color.rgbNormalLinear,dataView:this.#Yr,targetMembers:_},{key:"intensity",value:i.intensity,dataView:this.#Yr,targetMembers:_}])});{const i=S.ambientLight,{ambientLight:g}=W,x=g.members;i&&this.#ai([{key:"color",value:i.color.rgbNormalLinear,dataView:this.#Yr,targetMembers:x},{key:"intensity",value:i.intensity,dataView:this.#Yr,targetMembers:x}])}y.queue.writeBuffer(H,0,this.#jr)}#Hc(i,g,x,_){this.#$c(!0);const v=x?.prefilterTexture,b=x?.irradianceTexture,{redGPUContext:y}=this,{gpuDevice:S,resourceManager:w}=y,L={layout:w.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),label:`SYSTEM_UNIFORM_bindGroup_${i}`,entries:[{binding:0,resource:{buffer:this.#Tc.gpuBuffer,offset:0,size:this.#Tc.size}},{binding:1,resource:this.#Dc},{binding:2,resource:g},{binding:3,resource:this.#it},{binding:5,resource:{buffer:this.#Wt,offset:0,size:this.#Wt.size}},{binding:6,resource:{buffer:this.#Ac.clusterLightsBuffer,offset:0,size:this.#Ac.clusterLightsBuffer.size}},{binding:7,resource:this.#it},{binding:8,resource:_||w.emptyBitmapTextureView},{binding:9,resource:this.#Uc},{binding:10,resource:w.getGPUResourceCubeTextureView(v,v?.viewDescriptor||CubeTexture.defaultViewDescriptor)},{binding:11,resource:w.getGPUResourceCubeTextureView(b,b?.viewDescriptor||CubeTexture.defaultViewDescriptor)},{binding:12,resource:w.brdfGenerator.brdfLUTTexture?.createView()||w.emptyBitmapTextureView}]};this.#Sc=S.createBindGroup(L),this.#Xc(w,v,b)}#Xc(i,g,x){[[this.#Nc,g],[this.#Vc,x]].forEach(([g,x])=>{g&&g!==x&&this.#zc(i,g.cacheKey,!1),x&&g!==x&&this.#zc(i,x.cacheKey,!0)}),this.#Nc=g,this.#Vc=x}#zc(i,g,x){const _=i.managedCubeTextureState,v=_?.table.get(g);v&&(x?v.useNum++:v.useNum--)}#ne(){const i=new ArrayBuffer(Zi.arrayBufferByteLength);this.#Tc=new UniformBuffer(this.redGPUContext,i,"SYSTEM_UNIFORM_BUFFER_VERTEX","SYSTEM_UNIFORM_BUFFER_VERTEX"),this.#Lc=new Float32Array(16*q.MAX_CLUSTER_LIGHTS+4),this.#Wt=this.redGPUContext.resourceManager.createGPUBuffer("VIEW_CLUSTER_LIGHTS_BUFFER",{size:this.#Lc.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),this.redGPUContext.gpuDevice.queue.writeBuffer(this.#Wt,0,this.#Lc),this.#Dc=new Sampler(this.redGPUContext,{addressModeU:_.CLAMP_TO_EDGE,addressModeV:_.CLAMP_TO_EDGE,addressModeW:_.CLAMP_TO_EDGE,compare:Tn.LESS_EQUAL}).gpuSampler,this.#it=new Sampler(this.redGPUContext).gpuSampler,this.#Uc=new Sampler(this.redGPUContext,{addressModeU:_.REPEAT,addressModeV:_.REPEAT}).gpuSampler}#$c(i=!1){if(!i)return;const{redGPUContext:g,scene:x,renderViewStateData:_}=this;if(this.#Gc||(this.#Gc=new PassClusterLightBound(g,this)),this.#Ac&&(this.#Gc.render(),this.#kc=this.pixelRectArray[2],this.#Oc=this.pixelRectArray[3]),this.#Ac||(this.#Ac=new PassClustersLight(g,this)),x){const{pointLights:i,spotLights:v}=x.lightManager,b=i.length,y=v.length;if(b){let x=b;for(;x--;){const v=i[x],b=4+16*x;this.#Lc.set([...v.position,v.radius,...v.color.rgbNormalLinear,v.intensity,0],b),v.enableDebugger&&(v.drawDebugger||(v.drawDebugger=new DrawDebuggerPointLight(g,v)),v.drawDebugger.render(_))}}if(y){const i=16,x=b*i;let S=y;for(;S--;){const b=v[S],y=4+i*S+x;this.#Lc.set([...b.position,b.radius,...b.color.rgbNormalLinear,b.intensity,1,...b.direction,b.outerCutoff,b.innerCutoff],y),b.enableDebugger&&(b.drawDebugger||(b.drawDebugger=new DrawDebuggerSpotLight(g,b)),b.drawDebugger.render(_))}}this.#Lc.set([b,y,0,0],0),this.redGPUContext.gpuDevice.queue.writeBuffer(this.#Wt,0,this.#Lc),this.#Ac.render()}}}Object.freeze(View3D);class RedGPUContextViewContainer{#jc=[];constructor(){}get viewList(){return this.#jc}get numViews(){return this.#jc.length}contains(i){return this.#jc.includes(i)}addView(i){this.#Yc(i),this.#jc.push(i)}addViewAt(i,g){this.#Yc(i),validateUintRange(g);const x=this.#jc.length;x<g&&(g=x),this.#jc[g]=i}getViewAt(i){return validateUintRange(i),this.#jc[i]}getViewIndex(i){return this.#Yc(i),this.#jc.indexOf(i)}setViewIndex(i,g){this.#Yc(i),validateUintRange(g);const x=this.#jc.length,_=g>=x,v=this.#jc.indexOf(i);-1===v&&consoleAndThrowError("입력하신 View 는 RedGPUContext instance 에 등록되지 않은 View 입니다."),_&&consoleAndThrowError(`index must be smaller than the viewList length./index:${g}/this.#viewList.length:${x}`),this.#jc.splice(v,1),this.#jc.splice(g,0,i)}swapViews(i,g){this.#Yc(i),this.#Yc(g);const x=this.#jc.indexOf(i),_=this.#jc.indexOf(g);-1!==x&&-1!==_||consoleAndThrowError((-1===x?"view1":"view2")+" is not child of this RedGPUContext instance."),this.swapViewsAt(x,_)}swapViewsAt(i,g){i===g&&consoleAndThrowError("The indices to swap cannot be the same."),validateUintRange(i),validateUintRange(g);const x=this.#jc.length;(i>=x||g>=x)&&consoleAndThrowError(`index1,index2 must be smaller than the viewList length./index1:${i}/index2:${g}/this.#viewList.length:${x}`);const _=this.#jc[i];this.#jc[i]=this.#jc[g],this.#jc[g]=_}removeView(i){this.#Yc(i);const g=this.#jc.indexOf(i);g>-1?this.#jc.splice(g,1):consoleAndThrowError("View3D is not found in the view list.")}removeViewAt(i){validateUintRange(i);const g=this.#jc.length;i<g?this.#jc.splice(i,1):consoleAndThrowError(`Index ${i} is out of range. View list length is ${g}.`)}removeAllViews(){this.#jc.length=0}#Yc(i){i instanceof View3D||consoleAndThrowError("allow only View3D instance")}}class RedGPUContext extends RedGPUContextViewContainer{currentRequestAnimationFrame;onResize=null;currentTime;#qc;#Wc;#Zc;#Jc;#c;#Ut;#Qc;#eh;#xn;#Ol=new ColorRGBA(0,0,0,1);#th=!1;#nh={};#or;#rh;constructor(i,g,x,_,v){super(),this.#Wc=g,this.#c=x,this.#Jc=_,this.#Zc=v,this.#Ut=i,this.#Qc=new RedGPUContextSizeManager(this),this.#eh=new RedGPUContextDetector(this),this.#xn=new ResourceManager(this),this.#or=new AntialiasingManager(this),this.#ih()}get boundingClientRect(){return this.#rh}get antialiasingManager(){return this.#or}get useDebugPanel(){return this.#th}set useDebugPanel(i){this.#th=i}get backgroundColor(){return this.#Ol}set backgroundColor(i){i instanceof ColorRGBA||consoleAndThrowError("allow only ColorRGBA instance"),this.#Ol=i}get detector(){return this.#eh}get configurationDescription(){return this.#qc}get gpuAdapter(){return this.#Wc}get alphaMode(){return this.#Zc}set alphaMode(i){this.#Zc=i,this.#ah()}get gpuContext(){return this.#Jc}get gpuDevice(){return this.#c}get htmlCanvas(){return this.#Ut}get keyboardKeyBuffer(){return this.#nh}set keyboardKeyBuffer(i){this.#nh=i}get resourceManager(){return this.#xn}get sizeManager(){return this.#Qc}get width(){return this.#Qc.width}set width(i){this.#Qc.width=i}get height(){return this.#Qc.height}set height(i){this.#Qc.height=i}get screenRectObject(){return this.#Qc.screenRectObject}get pixelRectObject(){return this.#Qc.pixelRectObject}get renderScale(){return this.#Qc.renderScale}set renderScale(i){this.#Qc.renderScale=i,this.viewList.forEach(i=>{i.setPosition(),i.setSize()})}destroy(){this.#c.destroy()}setSize(i=this.width,g=this.height){this.sizeManager.setSize(i,g)}#ih(){this.#ah(),this.sizeManager.setSize("100%","100%"),window?.addEventListener("resize",()=>{this.#rh=this.#Ut.getBoundingClientRect(),this.sizeManager.setSize()}),this.#rh=this.#Ut.getBoundingClientRect();(this.detector.isMobile?["click","touchmove","touchstart","touchend"]:["click","mousemove","mousedown","mouseup"]).forEach(g=>{const x=this.detector.isMobile?{click:i.CLICK,touchmove:i.MOVE,touchstart:i.DOWN,touchend:i.UP}:{click:i.CLICK,mousemove:i.MOVE,mousedown:i.DOWN,mouseup:i.UP};this.#Ut.addEventListener(g,g=>{const _=x[g.type];this.viewList.forEach(x=>{this.detector.isMobile&&g instanceof TouchEvent&&g.touches.length>0?(x.pickingManager.mouseX=g.touches[0].clientX*devicePixelRatio-x.pixelRectObject.x,x.pickingManager.mouseY=g.touches[0].clientY*devicePixelRatio-x.pixelRectObject.y):g instanceof MouseEvent&&(x.pickingManager.mouseX=g.offsetX*devicePixelRatio-x.pixelRectObject.x,x.pickingManager.mouseY=g.offsetY*devicePixelRatio-x.pixelRectObject.y),_===i.CLICK?x.pickingManager.lastMouseClickEvent={...g,type:_}:x.pickingManager.lastMouseEvent={...g,type:_}})})});{const HD_keyDown=i=>{this.#nh[i.key]=!0},HD_keyUp=i=>{this.#nh[i.key]=!1};window?.addEventListener("keyup",HD_keyUp),window?.addEventListener("keydown",HD_keyDown)}new ResizeObserver(i=>{}).observe(this.#Ut)}#ah(){const i=navigator.gpu.getPreferredCanvasFormat();this.#qc={device:this.#c,format:i,alphaMode:this.#Zc},this.#Jc.configure(this.#qc)}}Object.freeze(RedGPUContext);const init=async(i,x,_,v,b="premultiplied",y={powerPreference:"high-performance",forceFallbackAdapter:!1})=>{if(isSearchEngineBot())return void g("🤖 Search engine bot detected - skipping WebGPU initialization");const{gpu:S}=navigator;if(!S){const i="WebGPU is not supported in this browser. Please use a modern browser with WebGPU enabled.";return void _?.(i)}const errorHandler=(i,g)=>{const x=generateErrorMessage(i,g);console.error("\n============\n",x,"\n============\n"),_?.(x)},validateAndRequestDevice=async g=>{const x=[];g?.features.has("texture-compression-astc")&&x.push("texture-compression-astc");const _={};["maxBufferSize","maxStorageBufferBindingSize","maxSampledTexturesPerShaderStage","maxSamplersPerShaderStage","maxStorageBuffersPerShaderStage","maxStorageTexturesPerShaderStage","maxUniformBuffersPerShaderStage","maxUniformBufferBindingSize","maxBindGroups","maxVertexAttributes","maxVertexBuffers","maxInterStageShaderComponents","maxComputeWorkgroupStorageSize","maxComputeInvocationsPerWorkgroup","maxComputeWorkgroupSizeX","maxComputeWorkgroupSizeY","maxComputeWorkgroupSizeZ","maxComputeWorkgroupsPerDimension"].forEach(i=>{g.limits[i]&&(_[i]=g.limits[i])});const v={requiredFeatures:x,requiredLimits:_};try{const x=await g.requestDevice(v);validateAndInitializeContext(i,g,x)}catch(i){errorHandler(null,`Failed to request device. Adapter was ${g},error message is ${i.message}`)}},validateAndInitializeContext=(i,_,y)=>{const S=i.getContext("webgpu");if(S)try{{const i=y.createShaderModule.bind(y);y.createShaderModule=function(g){g.code=ensureVertexIndexBuiltin(g.code);return i(g)}}const w=new RedGPUContext(i,_,y,S,b);x(w),y.addEventListener("uncapturederror",i=>{console.warn("TODO A WebGPU error was not captured:",i),console.warn(i.error?.message),window.cancelAnimationFrame(w.currentRequestAnimationFrame)}),y.lost.then(i=>{console.warn(i),console.warn(`Device lost occurred:${i.message}`),"destroyed"===i.reason&&v?.(i)});const clearDevice=()=>{if(w.gpuContext)try{w.gpuContext.unconfigure(),g("🧹 Canvas Context unconfigure 완료")}catch(i){g("⚠️ Canvas Context unconfigure 실패:",i)}window?.cancelAnimationFrame(w.currentRequestAnimationFrame),w.gpuDevice.destroy()};window?.addEventListener("beforeunload",()=>{w&&w.gpuDevice&&(g("🧹 페이지 종료 시 GPU 디바이스 정리"),clearDevice())}),window?.addEventListener("pageshow",i=>{i.persisted&&(g("🔄 bfcache에서 복원됨 (뒤로가기 또는 앞으로가기) - 페이지 재로드"),window.location.reload())}),window?.addEventListener("pagehide",i=>{i.persisted&&(g("💾 bfcache에 저장됨"),w&&w.gpuDevice&&clearDevice())})}catch(i){errorHandler(i,"")}else errorHandler(new Error(`Failed to get context from canvas:${i.id||i}`),"Failed to get webgpu initialize from canvas")},initializeWebGPU=async()=>{x instanceof Function?i instanceof HTMLCanvasElement?await(async i=>{i||errorHandler(null,"Cannot find navigator.gpu");try{const g=await i.requestAdapter(y);await validateAndRequestDevice(g)}catch(g){errorHandler(g,`Failed to request adapter or validate device with target GPU:${i},error message is ${g.message}`)}})(S):errorHandler(null,`Expected HTMLCanvasElement,but received:${i}`):errorHandler(null,`Expected onWebGPUInitialized,but received:${x}`)};try{await initializeWebGPU()}catch(i){errorHandler(i,`Unexpected error occurred during WebGPU initialization:${i.message}`)}},generateErrorMessage=(i,g)=>{let x=g;return i instanceof Error?(x=i.message??g,"string"==typeof i.stack&&(x+=`\nStack Trace:${i.stack}`)):console.warn("generateErrorMessage function expected an Error instance,but got:",i),x},isSearchEngineBot=()=>{if("undefined"==typeof navigator||"undefined"==typeof window)return!0;const i=navigator.userAgent.toLowerCase();return["googlebot","bingbot","slurp","duckduckbot","baiduspider","yandexbot","facebookexternalhit","twitterbot","rogerbot","linkedinbot","embedly","quora link preview","showyoubot","outbrain","pinterest/0.","developers.google.com/+/web/snippet","www.google.com/webmasters/tools/richsnippets","slackbot","vkshare","w3c_validator","redditbot","applebot","whatsapp","flipboard","tumblr","bitlybot","skypeuripreview","nuzzel","line","discordbot","telegrambot","crawler","spider","bot"].some(g=>i.includes(g))};class TextureLoaderData{src;texture;loadEnd;loadSuccess;srcInfo;idx;constructor(i,g,x){this.src=i,this.texture=null,this.loadEnd=!1,this.loadSuccess=!1,this.srcInfo=g,this.idx=x}}class TextureLoader{textures=[];#sh=0;#l;#oh;#gs;#uh;constructor(i,g=[],x,_){this.#l=i,this.#oh=g,this.#gs=x,this.#uh=_,this.#oh.length?this.#oh.forEach((i,g)=>this.#lh(i,g)):this.#ch()}getTextureByIndex(i){if(this.textures[i])return this.textures[i].texture}#lh(i,g){let x,_,v=BitmapTexture;_=i.hasOwnProperty("src")?i.src:i,_ instanceof Array&&(v=CubeTexture),x=new TextureLoaderData(_,i,g);const onLoadHandler=()=>{x.loadSuccess=!0,x.loadEnd=!0,this.#hh()},onErrorHandler=()=>{x.loadSuccess=!1,x.loadEnd=!0,this.#hh()};x.texture=v===BitmapTexture?new v(this.#l,{src:i.src,cacheKey:i.cacheKey},i.useMipmap,onLoadHandler,onErrorHandler,i.format,!1):new v(this.#l,{src:i.src,cacheKey:i.cacheKey},i.useMipmap,onLoadHandler,onErrorHandler,i.format),this.textures.push(x),this.#fh()}#fh(){const i=this.#oh.length,g=this.#sh;this.#uh&&this.#uh.call(this,{total:i,loaded:g,percent:Math.min(100,parseFloat((g/i*100).toFixed(2)))})}#hh(){this.#sh++,this.#fh(),this.#sh===this.#oh.length&&this.#ch()}#ch(){requestAnimationFrame(()=>{this.#gs&&this.#gs.call(this,this)})}}const checkProgress=(i,g,x)=>{const _=g.buffers.length;i.loadingProgressInfo.buffers={loaded:x,total:_,percent:Math.min(100,parseFloat((x/_*100).toFixed(2)))}},ea=new Map,ta=new Map,arrayBufferLoader=(i,g,x)=>{if(i=getAbsoluteURL(window.location.href,i),ea.has(i))return void g?.(ea.get(i));if(ta.has(i))return void ta.get(i).then(i=>g?.(i)).catch(i=>x?.(i));const _=fetch(i).then(i=>{if(!i.ok)throw new Error(`Network response was not ok:${i.statusText}`);return i.arrayBuffer()}).then(g=>(ea.set(i,g),g)).finally(()=>{ta.delete(i)});ta.set(i,_),_.then(i=>g?.(i)).catch(i=>x?.(i))},na={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array};Object.freeze(na);class AccessorInfo_GLTF{accessor;bufferView;bufferGlTfId;buffer;bufferURIDataView;componentType;componentType_BYTES_PER_ELEMENT;getMethod;accessorBufferOffset;bufferViewOffset;bufferViewByteStride;startIndex;constructor(i,g,x){switch(this.accessor=g.accessors[x],this.bufferView=g.bufferViews[this.accessor.bufferView],this.bufferGlTfId=this.bufferView.buffer,this.buffer=g.buffers[this.bufferGlTfId],this.bufferURIDataView=null,this.buffer.uri&&(this.bufferURIDataView=i.parsingResult.uris.buffers[this.bufferGlTfId]),this.componentType=na[this.accessor.componentType],this.componentType_BYTES_PER_ELEMENT=this.componentType.BYTES_PER_ELEMENT,this.componentType){case Float32Array:this.getMethod="getFloat32";break;case Uint32Array:this.getMethod="getUint32";break;case Uint16Array:this.getMethod="getUint16";break;case Int16Array:this.getMethod="getInt16";break;case Uint8Array:this.getMethod="getUint8";break;case Int8Array:this.getMethod="getInt8";break;default:consoleAndThrowError("파싱할수없는 타입",this.componentType)}this.accessorBufferOffset=this.accessor.byteOffset||0,this.bufferViewOffset=this.bufferView.byteOffset||0,this.bufferViewByteStride=this.bufferView.byteStride||0,this.startIndex=(this.bufferViewOffset+this.accessorBufferOffset)/this.componentType_BYTES_PER_ELEMENT}}class AnimationData_GLTF{gltfLoader;scenesData;accessorGlTfId;dataList;constructor(i,g,x){this.gltfLoader=i,this.scenesData=g,this.accessorGlTfId=x;const _=new AccessorInfo_GLTF(this.gltfLoader,this.scenesData,this.accessorGlTfId),{accessor:v,startIndex:b,componentType_BYTES_PER_ELEMENT:y,bufferURIDataView:S,getMethod:w}=_,{type:L,count:k}=v;let z=b,H=1;switch(L){case"SCALAR":H=1;break;case"VEC4":H=4;break;case"VEC3":H=3}const q=[];let W=0;for(;W<k*H;z++,W++)q[W]=S[w](z*y,!0);this.dataList=new Float32Array(q)}}class AniTrack_GLTF{lastPrevIdx;key;timeAnimationInfo;aniDataAnimationInfo;interpolation;weightMeshes;animationTargetMesh;cacheTable={};#dh;#Xn;#mh;#jn;#jr;#ph=new Map;constructor(i,g,x,_,v,b){this.key=i,this.timeAnimationInfo=g,this.aniDataAnimationInfo=x,this.interpolation=_,this.animationTargetMesh=v,this.weightMeshes=b,this.#jr=new Float32Array(8)}async renderWeight(i,g,x,_,v,b){const{gpuDevice:y}=i;this.#dh||this.#gh(i),this.#ph.has(x)||this.#xh(i,x);const S=this.#ph.get(x);this.#jr.set([_,v,b,x.animationInfo.morphInfo.morphInfoDataList.length,x.geometry.vertexBuffer.stride,x.geometry.vertexBuffer.vertexCount,0,0]),y.queue.writeBuffer(this.#jn,0,this.#jr),g.setPipeline(this.#Xn),g.setBindGroup(0,S.bindGroup);const w=Math.ceil(x.geometry.vertexBuffer.vertexCount/64);g.dispatchWorkgroups(w)}#gh(i){const{gpuDevice:g}=i;this.#dh=g.createShaderModule({code:"struct Uniforms { interpolation_value:f32, prev_time_data_index:f32, next_time_data_index:f32, morph_length:f32, vertex_stride:f32, vertex_count:f32, padding1:f32, padding2:f32,\n};\n@group(0) @binding(0) var<storage,read> animation_data_list:array<f32>;\n@group(0) @binding(1) var<uniform> uniforms:Uniforms;\n@group(0) @binding(2) var<storage,read_write> vertices:array<f32>;\n@group(0) @binding(3) var<storage,read> origin_data:array<f32>;\n@group(0) @binding(4) var<storage,read> morph_interleave_data:array<f32>;\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>) { let vertex_index=global_id.x; let vertex_count=u32(uniforms.vertex_count); let stride=u32(uniforms.vertex_stride); let morph_length=u32(uniforms.morph_length); let base_vertex_index=vertex_index * stride; let base_vertex_index2=vertex_index * 3u; let prev_time_offset=u32(uniforms.prev_time_data_index) * morph_length; let next_time_offset=u32(uniforms.next_time_data_index) * morph_length; var prev_weight=origin_data[base_vertex_index]; var next_weight=origin_data[base_vertex_index]; var prev_weight1=origin_data[base_vertex_index + 1u]; var next_weight1=origin_data[base_vertex_index + 1u]; var prev_weight2=origin_data[base_vertex_index + 2u]; var next_weight2=origin_data[base_vertex_index + 2u]; for (var morph_index=0u;morph_index < morph_length;morph_index++) { let prev_animation_data=animation_data_list[prev_time_offset + morph_index]; let next_animation_data=animation_data_list[next_time_offset + morph_index]; let morph_base_offset=morph_index * vertex_count * 3u; let temp_weight_x=morph_interleave_data[morph_base_offset + base_vertex_index2]; prev_weight +=prev_animation_data * temp_weight_x; next_weight +=next_animation_data * temp_weight_x; let temp_weight_y=morph_interleave_data[morph_base_offset + base_vertex_index2 + 1u]; prev_weight1 +=prev_animation_data * temp_weight_y; next_weight1 +=next_animation_data * temp_weight_y; let temp_weight_z=morph_interleave_data[morph_base_offset + base_vertex_index2 + 2u]; prev_weight2 +=prev_animation_data * temp_weight_z; next_weight2 +=next_animation_data * temp_weight_z; } let interpolation_diff_x=next_weight - prev_weight; let interpolation_diff_y=next_weight1 - prev_weight1; let interpolation_diff_z=next_weight2 - prev_weight2; let final_x=prev_weight + uniforms.interpolation_value * interpolation_diff_x; let final_y=prev_weight1 + uniforms.interpolation_value * interpolation_diff_y; let final_z=prev_weight2 + uniforms.interpolation_value * interpolation_diff_z; vertices[base_vertex_index]=final_x; vertices[base_vertex_index + 1u]=final_y; vertices[base_vertex_index + 2u]=final_z;\n}\n"}),this.#Xn=g.createComputePipeline({layout:"auto",compute:{module:this.#dh,entryPoint:"main"}}),this.#mh=g.createBuffer({size:4*this.aniDataAnimationInfo.dataList.length,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.#jn=g.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),g.queue.writeBuffer(this.#mh,0,this.aniDataAnimationInfo.dataList)}#xh(i,g){const{gpuDevice:x}=i,_=g.animationInfo.morphInfo,v=g.geometry.vertexBuffer,b=x.createBuffer({size:4*_.origin.length,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),y=_.morphInfoDataList.flatMap(i=>Array.from(i.interleaveData)),S=x.createBuffer({size:4*y.length,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});x.queue.writeBuffer(b,0,_.origin),x.queue.writeBuffer(S,0,new Float32Array(y));const w=x.createBindGroup({layout:this.#Xn.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.#mh}},{binding:1,resource:{buffer:this.#jn}},{binding:2,resource:{buffer:v.gpuBuffer}},{binding:3,resource:{buffer:b}},{binding:4,resource:{buffer:S}}]});this.#ph.set(g,{bindGroup:w,originBuffer:b,morphInterleavedBuffer:S})}}const parseAnimations=(i,g)=>new Promise(async x=>{g.animations||(g.animations=[]);const{parsingResult:_}=i,{animations:v}=_,{animations:b}=g;if(b.length){const x=b.map(async x=>{const{samplers:_,channels:b}=x,y=[];y.minTime=1e7,y.maxTime=-1,y.name=x.name,v.push(y),await Promise.all(b.map(async x=>((i,g,x,_,v)=>{let b,y;const{nodes:S,meshes:w}=v,L=[],{sampler:k,target:z}=x,H=_[k],{node:q,path:W}=z,be=S[q];if("mesh"in be){b=be.Mesh;const{primitives:i}=w[be.mesh];let g=i.length;for(;g--;)L.push(i[g].Mesh)}else{let g;if(!i.parsingResult.groups[q])return;g=i.parsingResult.groups[q],b=g}if("scale"!=W&&"rotation"!=W&&"translation"!=W&&"weights"!=W||(y=new AniTrack_GLTF(W,new AnimationData_GLTF(i,v,H.input),new AnimationData_GLTF(i,v,H.output),H.interpolation,b,L),g.push(y)),y){const{timeAnimationInfo:i}=y,{dataList:x}=i;g.minTime>x[0]&&(g.minTime=x[0]),g.maxTime<x[x.length-1]&&(g.maxTime=x[x.length-1])}})(i,y,x,_,g)))});await Promise.all(x),v.length&&v.forEach(g=>i.playAnimation(g))}x()});class ParsedSkinInfo_GLTF{joints;inverseBindMatrices;skeletonMesh;vertexStorageInfo;vertexStorageBuffer;prevVertexStorageBuffer;invertNodeGlobalTransform;usedJoints=null;WORK_SIZE=64;jointData;uniformBuffer;computeShader;computePipeline;bindGroup;constructor(){this.joints=[],this.inverseBindMatrices=null,this.skeletonMesh=null}getUsedJointIndices(i){const g=new Set,{jointBuffer:x}=i.animationInfo;if(!x.data.length)return[];const _=x.data,v=_.length;for(let i=0;i<v;i++){const x=i;for(let i=0;i<4;i++){const v=Math.floor(_[x+i]);v>=0&&v<this.joints.length&&g.add(v)}}return Array.from(g)}createCompute(i,g,x,_,v){const b=` struct Uniforms { invertNodeGlobalTransform: mat4x4<f32>, jointModelMatrices: array<mat4x4<f32>,${this.usedJoints.length}>, inverseBindMatrices: array<mat4x4<f32>,${this.joints.length}>, searchJointIndexTable: array<vec4<u32>,${this.joints.length}>, };  @group(0) @binding(0) var<storage,read> vertexWeight: array<vec4<f32>>; @group(0) @binding(1) var<storage,read> vertexJoint: array<vec4<u32>>; @group(0) @binding(2) var<storage,read_write> skinMatrixBuffer: array<mat4x4<f32>>; @group(0) @binding(3) var<storage,read_write> prevSkinMatrixBuffer: array<mat4x4<f32>>; @group(0) @binding(4) var<uniform> uniforms: Uniforms;  @compute @workgroup_size(${this.WORK_SIZE},1,1) fn main(@builtin(global_invocation_id) global_id:vec3<u32>) {  let idx=global_id.x; if (idx >=arrayLength(&vertexWeight)) { return; }  let weights=vertexWeight[idx]; let joints=vertexJoint[idx]; prevSkinMatrixBuffer[idx]=skinMatrixBuffer[idx]; skinMatrixBuffer[idx]=uniforms.invertNodeGlobalTransform * ( weights.x * ( \tuniforms.jointModelMatrices[uniforms.searchJointIndexTable[joints.x].x] * uniforms.inverseBindMatrices[joints.x] ) + weights.y * ( \tuniforms.jointModelMatrices[uniforms.searchJointIndexTable[joints.y].x] * uniforms.inverseBindMatrices[joints.y] ) + weights.z * ( \tuniforms.jointModelMatrices[uniforms.searchJointIndexTable[joints.z].x] * uniforms.inverseBindMatrices[joints.z] ) + weights.w * ( \tuniforms.jointModelMatrices[uniforms.searchJointIndexTable[joints.w].x] * uniforms.inverseBindMatrices[joints.w] ) ); } `;this.jointData=new Float32Array(16*(1+this.usedJoints.length)),this.computeShader=i.resourceManager.createGPUShaderModule(`calcSkinMatrix_${this.usedJoints.length}`,{code:b}),this.computePipeline=g.createComputePipeline({label:"calcSkinMatrix",layout:"auto",compute:{module:this.computeShader,entryPoint:"main"}}),this.uniformBuffer=g.createBuffer({size:this.jointData.byteLength+16*this.joints.length*4+4*this.joints.length*4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),g.queue.writeBuffer(this.uniformBuffer,this.jointData.byteLength,new Float32Array(this.inverseBindMatrices.map(i=>Array.from(i)).flat()));const y=new Uint32Array(4*this.joints.length);y.fill(0),this.usedJoints.forEach((i,g)=>{y[4*i]=g}),g.queue.writeBuffer(this.uniformBuffer,this.jointData.byteLength+16*this.joints.length*4,y),this.bindGroup=g.createBindGroup({layout:this.computePipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:_.gpuBuffer}},{binding:1,resource:{buffer:v.gpuBuffer}},{binding:2,resource:{buffer:this.vertexStorageBuffer}},{binding:3,resource:{buffer:this.prevVertexStorageBuffer}},{binding:4,resource:{buffer:this.uniformBuffer}}]})}}const parseJoint_GLTF=(i,g,x,_)=>{const{redGPUContext:v}=i,b=x[_].Mesh;b?g.joints.push(b):requestAnimationFrame(function(){parseJoint_GLTF(i,g,x,_)})},calculateNormals=(i,g)=>{let x,_,v=[],b=g;const y=i.length/3;if(!g||0===g.length){g=[];for(let i=0;i<y;i++)b.push(i)}for(x=0;x<i.length;x+=3)v[x+0]=0,v[x+1]=0,v[x+2]=0;for(x=0;x<b.length;x+=3){let g,y,S,w,L=[],k=[],z=[];for(g=3*b[x],y=3*b[x+1],S=3*b[x+2],L[0]=i[S+0]-i[y+0],L[1]=i[S+1]-i[y+1],L[2]=i[S+2]-i[y+2],k[0]=i[g+0]-i[y+0],k[1]=i[g+1]-i[y+1],k[2]=i[g+2]-i[y+2],z[0]=L[1]*k[2]-L[2]*k[1],z[1]=L[2]*k[0]-L[0]*k[2],z[2]=L[0]*k[1]-L[1]*k[0],_=0;_<3;_++)w=3*b[x+_],v[w+0]=v[w+0]+z[0],v[w+1]=v[w+1]+z[1],v[w+2]=v[w+2]+z[2]}for(x=0;x<i.length;x+=3){let i=[];i[0]=v[x+0],i[1]=v[x+1],i[2]=v[x+2];let g=Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]);0===g&&(g=1),i[0]=i[0]/g,i[1]=i[1]/g,i[2]=i[2]/g,v[x+0]=i[0],v[x+1]=i[1],v[x+2]=i[2]}return v},parseAttributeInfo_GLTF=function(i,g,x,_,v,b,y,S,w,L,k){const{accessor:z,startIndex:H,getMethod:q,bufferViewByteStride:W,bufferURIDataView:be,componentType_BYTES_PER_ELEMENT:Ke}=g,{type:Xe,count:je}=z;let Ye=0;const Ze=W/Ke;let Je,Qe=H;switch(Xe){case"VEC4":if(W)for(Je=Qe+je*(W/Ke);Qe<Je;Qe++)Ye%Ze<4&&("WEIGHTS_0"==i?S.push(be[q](Qe*Ke,!0)):"JOINTS_0"==i?w.push(be[q](Qe*Ke,!0)):"COLOR_0"==i?L.push(be[q](Qe*Ke,!0)):"TANGENT"==i?k.push(be[q](Qe*Ke,!0)):consoleAndThrowError("VEC4에서 현재 지원하고 있지 않는 키",i)),Ye++;else for(Je=Qe+4*je;Qe<Je;Qe++)"WEIGHTS_0"==i?S.push(be[q](Qe*Ke,!0)):"JOINTS_0"==i?w.push(be[q](Qe*Ke,!0)):"COLOR_0"==i?L.push(be[q](Qe*Ke,!0)):"TANGENT"==i?k.push(be[q](Qe*Ke,!0)):consoleAndThrowError("VEC4에서 현재 지원하고 있지 않는 키",i),Ye++;break;case"VEC3":if(W)for(Je=Qe+je*(W/Ke);Qe<Je;Qe++)Ye%Ze<3&&("NORMAL"==i?y.push(be[q](Qe*Ke,!0)):"POSITION"==i?x.push(be[q](Qe*Ke,!0)):"COLOR_0"==i?(L.push(be[q](Qe*Ke,!0)),Ye%Ze==2&&L.push(1)):"TANGENT"==i?k.push(be[q](Qe*Ke,!0)):consoleAndThrowError("VEC3에서 현재 지원하고 있지 않는 키",i)),Ye++;else for(Je=Qe+3*je;Qe<Je;Qe++)"NORMAL"==i?y.push(be[q](Qe*Ke,!0)):"POSITION"==i?x.push(be[q](Qe*Ke,!0)):"COLOR_0"==i?(L.push(be[q](Qe*Ke,!0)),Ye%3==2&&L.push(1)):"TANGENT"==i?k.push(be[q](Qe*Ke,!0)):consoleAndThrowError("VEC3에서 현재 지원하고 있지 않는 키",i),Ye++;break;case"VEC2":if(W)for(Je=Qe+je*(W/Ke);Qe<Je;Qe++)Ye%Ze<2&&("TEXCOORD_0"==i?_.push(be[q](Qe*Ke,!0)):"TEXCOORD_1"==i&&v.push(be[q](Qe*Ke,!0))),Ye++;else for(Je=Qe+2*je;Qe<Je;Qe++)"TEXCOORD_0"==i?_.push(be[q](Qe*Ke,!0)):"TEXCOORD_1"==i&&v.push(be[q](Qe*Ke,!0)),Ye++}},parseSparse_GLTF=(i,g,x,_,v)=>{const b=x.sparse;if(!b)return;const{values:y,indices:S,count:w}=b,L=_.bufferViews,k=L[y.bufferView],z=k.buffer,H=_.buffers,q=H[z],W=[],be=[],Ke=L[S.bufferView],Xe=Ke.buffer,je=H[Xe];let Ye;q.uri&&(Ye=i.parsingResult.uris.buffers[z]);const Ze=na[x.componentType],{BYTES_PER_ELEMENT:Je}=Ze;let Qe;switch(Ze){case Float32Array:Qe="getFloat32";break;case Uint32Array:Qe="getUint32";break;case Uint16Array:Qe="getUint16";break;case Int16Array:Qe="getInt16";break;case Uint8Array:Qe="getUint8";break;case Int8Array:Qe="getInt8"}const et=x.byteOffset||0;let tt,it,ft=((k.byteOffset||0)+et)/Je;switch(x.type){case"VEC3":for(tt=ft+Je*w/Je*3;ft<tt;ft++){const i=Ye[Qe](ft*Je,!0);"NORMAL"==g||"POSITION"==g&&W.push(i)}break;case"VEC2":for(tt=ft+Je*w/Je*2;ft<tt;ft++)"TEXCOORD_0"==g&&be.push(Ye[Qe](ft*Je,!0))}je.uri&&(it=i.parsingResult.uris.buffers[Xe]);const pt=na[S.componentType],xt=pt.BYTES_PER_ELEMENT,vt=pt===Uint16Array?"getUint16":"getUint8",bt=S.byteOffset||0;let yt=((Ke.byteOffset||0)+bt)/xt;const St=yt+xt*w/xt;let Tt=0;for(;yt<St;yt++){const i=it[vt](yt*xt,!0);v[3*i]=W[3*Tt],v[3*i+1]=W[3*Tt+1],v[3*i+2]=W[3*Tt+2],Tt++}};class MorphInfoData_GLTF{vertices=[];verticesColor_0=[];normals=[];uvs=[];uvs1=[];uvs2=[];jointWeights=[];joints=[];tangents=[];interleaveData;constructor(i=[],g=[],x=[],_=[],v=[],b=[],y=[],S=[],w=[]){this.vertices=i,this.verticesColor_0=g,this.normals=x,this.uvs=_,this.uvs1=v,this.uvs2=v,this.jointWeights=y,this.joints=S,this.tangents=w}}class MorphInfo_GLTF{morphInfoDataList=[];weights;cacheData={};origin;constructor(i,g,x,_){x.targets&&(this.morphInfoDataList=x.targets.map(x=>{const v=new MorphInfoData_GLTF;for(let _ in x){const{vertices:b,verticesColor_0:y,normals:S,uvs:w,uvs1:L,uvs2:k,jointWeights:z,joints:H,tangents:q}=v,W=x[_],be=new AccessorInfo_GLTF(i,g,W),{accessor:Ke}=be;parseAttributeInfo_GLTF(_,be,b,w,L,0,S,z,H,y,q),Ke.sparse&&parseSparse_GLTF(i,_,Ke,g,b)}return _.length&&(v.interleaveData=new Float32Array(v.vertices)),v})),this.weights=_||[],this.origin=null}}const parseMaterialTexture=(i,g,x,_,v,b=!0)=>{const{redGPUContext:y,gltfData:S}=i,{textureRawList:w}=i.parsingResult,L=x.index,k=S.textures[L],z=k.extensions?.EXT_texture_webp?.source||k.source,H=getURL(i,S,z);if(H){const L=k.sampler,q=getSamplerInfo(i,S,L),{parsedURI:W,cacheKey:be}=H,Ke=`${_}SourceGlTfId_${z}`;if(w[Ke]?(w[Ke].materialList.push(g),w[Ke].samplerList.push(new Sampler(y,q))):w[Ke]={src:W,cacheKey:be,targetTextureKey:_,targetSamplerKey:`${_}Sampler`,materialList:[g],samplerList:[new Sampler(y,q)],format:v||navigator.gpu.getPreferredCanvasFormat(),useMipmap:b},g[`${_}_texCoord_index`]=x.texCoord||0,"extensions"in x){const{extensions:i}=x,{KHR_texture_transform:v}=i;v&&((i,g,x)=>{i[`${g}_KHR_texture_transform_offset`]=x.offset||[0,0],i[`${g}_KHR_texture_transform_scale`]=x.scale||[1,1],i[`${g}_KHR_texture_transform_rotation`]=x.rotation||0,i[`use_${g}_KHR_texture_transform`]=!0})(g,_,v)}}},getURL=function(i,g,x){if(!g.images[x])return null;const{uri:_}=g.images[x];let v;const b=`${i.url}_${x}`;return v=_.indexOf("blob:http")>-1?_:(_.indexOf(";base64,")>-1?"":i.filePath)+_,{parsedURI:v,cacheKey:b}},getSamplerInfo=function(i,g,x){const v={magFilter:b.LINEAR,minFilter:b.LINEAR,mipmapFilter:b.LINEAR,addressModeU:_.REPEAT,addressModeV:_.REPEAT,addressModeW:_.REPEAT},y={33071:_.CLAMP_TO_EDGE,33648:_.MIRRORED_REPEAT,10497:_.REPEAT},S={9728:b.NEAREST,9729:b.LINEAR},w={9728:b.NEAREST,9729:b.LINEAR};if(g.samplers){let i=g.samplers[x];i&&("magFilter"in i&&(v.magFilter=S[i.magFilter]||b.LINEAR),"minFilter"in i&&(v.minFilter=w[i.minFilter]||b.LINEAR),"wrapS"in i&&(v.addressModeU=y[i.wrapS]),"wrapT"in i&&(v.addressModeV=y[i.wrapT]))}return v.string=JSON.stringify(v),v},parseMaterialInfo_GLTF=(i,g,x)=>{const{redGPUContext:_}=i;let v,b=!1,y="OPAQUE",S=.5;if("material"in x){v=new PBRMaterial(_);const w=x.material,L=g.materials[w];b=!!L.doubleSided,y=L.alphaMode??y,S=L.alphaCutoff??S;const{pbrMetallicRoughness:k,normalTexture:z,emissiveTexture:H,occlusionTexture:q}=L;if(v.emissiveFactor=L.emissiveFactor||[0,0,0],k){const{metallicRoughnessTexture:g,baseColorTexture:x}=k;let _,b;v.baseColorFactor=k.baseColorFactor||[1,1,1,1],"metallicFactor"in k&&(_=k.metallicFactor),"roughnessFactor"in k&&(b=k.roughnessFactor),v.metallicFactor=null!=_?_:1,v.roughnessFactor=null!=b?b:1,x&&parseMaterialTexture(i,v,x,"baseColorTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`),g&&parseMaterialTexture(i,v,g,"metallicRoughnessTexture",null,!1)}if(z){parseMaterialTexture(i,v,z,"normalTexture");const{scale:g}=z;v.normalScale=null!=g?g:1}if(H&&parseMaterialTexture(i,v,H,"emissiveTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`),q&&(parseMaterialTexture(i,v,q,"occlusionTexture",null,!1),v.occlusionStrength=L.occlusionTexture.strength||1),"extensions"in L){const{extensions:g}=L,{KHR_materials_clearcoat:x,KHR_materials_emissive_strength:_,KHR_materials_transmission:b,KHR_materials_diffuse_transmission:S,KHR_materials_volume:w,KHR_materials_unlit:k,KHR_materials_ior:z,KHR_materials_sheen:H,KHR_materials_specular:q,KHR_materials_dispersion:W,KHR_materials_anisotropy:be,KHR_materials_iridescence:Ke}=g;if(Ke&&((i,g,x)=>{i.useKHR_materials_iridescence=!0,i.KHR_iridescenceFactor=g.iridescenceFactor||0,i.KHR_iridescenceIor=g.iridescenceIor||1.3,i.KHR_iridescenceThicknessMinimum=g.iridescenceThicknessMinimum||100,i.KHR_iridescenceThicknessMaximum=g.iridescenceThicknessMaximum||400,i.transparent=!0;{const{iridescenceTexture:_,iridescenceThicknessTexture:v}=g;_&&parseMaterialTexture(x,i,_,"KHR_iridescenceTexture",null,!1),v&&parseMaterialTexture(x,i,v,"KHR_iridescenceThicknessTexture",null,!1)}})(v,Ke,i),be&&((i,g,x)=>{i.useKHR_materials_anisotropy=!0,i.KHR_anisotropyStrength=g.anisotropyStrength||0,i.KHR_anisotropyRotation=g.anisotropyRotation||0;const{anisotropyTexture:_}=g;_&&parseMaterialTexture(x,i,_,"KHR_anisotropyTexture")})(v,be,i),x&&((i,g,x)=>{i.KHR_clearcoatFactor=g.clearcoatFactor||0,i.KHR_clearcoatRoughnessFactor=g.clearcoatRoughnessFactor||0,i.useKHR_materials_clearcoat=!0;const{clearcoatTexture:_,clearcoatNormalTexture:v,clearcoatRoughnessTexture:b}=g;_&&parseMaterialTexture(x,i,_,"KHR_clearcoatTexture",null,!1),v&&parseMaterialTexture(x,i,v,"KHR_clearcoatNormalTexture"),b&&parseMaterialTexture(x,i,b,"KHR_clearcoatRoughnessTexture",null,!1)})(v,x,i),_){const{emissiveStrength:i}=_;v.emissiveStrength=null!=i?i:1}if(b&&(((i,g,x)=>{i.useKHR_materials_transmission=!0,i.KHR_transmissionFactor=g.transmissionFactor||0,i.use2PathRender=!0;{const _=g.transmissionTexture;_&&parseMaterialTexture(x,i,_,"KHR_transmissionTexture",null,!1)}})(v,b,i),v.transparent="BLEND"===y),S&&((i,g,x)=>{i.useKHR_materials_diffuse_transmission=!0,i.KHR_diffuseTransmissionFactor=g.diffuseTransmissionFactor||0,i.KHR_diffuseTransmissionColorFactor=g.diffuseTransmissionColorFactor||[1,1,1],i.transparent=!0;{const _=g.diffuseTransmissionTexture;_&&parseMaterialTexture(x,i,_,"KHR_diffuseTransmissionTexture",null,!1);const v=g.diffuseTransmissionColorTexture;v&&parseMaterialTexture(x,i,v,"KHR_diffuseTransmissionColorTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`,!1)}})(v,S,i),w&&(((i,g,x)=>{i.useKHR_materials_volume=!0,i.KHR_thicknessFactor=g.thicknessFactor||1,i.KHR_attenuationDistance=g.attenuationDistance||1,i.KHR_attenuationColor=g.attenuationColor||[1,1,1],i.use2PathRender=!0,i.transparent=!0;{const _=g.thicknessTexture;_&&parseMaterialTexture(x,i,_,"KHR_thicknessTexture",null,!1)}})(v,w,i),y="BLEND"),k&&(v.useKHR_materials_unlit=!0),z){const{ior:i}=z;v.KHR_materials_ior=null!=i?i:1.5,v.use2PathRender=!0,v.transparent=!0}if(W){const{dispersion:i}=W;v.KHR_dispersion=i||0,v.use2PathRender=!0,v.transparent=!0}H&&((i,g,x)=>{i.KHR_sheenColorFactor=g.sheenColorFactor||[0,0,0],i.KHR_sheenRoughnessFactor=g.sheenRoughnessFactor||0,i.useKHR_materials_sheen=!0;const{sheenColorTexture:_,sheenRoughnessTexture:v}=g;_&&parseMaterialTexture(x,i,_,"KHR_sheenColorTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`,!1),v&&parseMaterialTexture(x,i,v,"KHR_sheenRoughnessTexture",null,!1)})(v,H,i),q&&((i,g,x)=>{i.useKHR_materials_specular=!0,i.KHR_specularFactor=g.specularFactor??1,i.KHR_specularColorFactor=g.specularColorFactor||[1,1,1];const{specularTexture:_,specularColorTexture:v}=g;_&&parseMaterialTexture(x,i,_,"KHR_specularTexture"),v&&parseMaterialTexture(x,i,v,"KHR_specularColorTexture",`${navigator.gpu.getPreferredCanvasFormat()}-srgb`)})(v,q,i)}}else v=new PBRMaterial(_);Object.hasOwn(x.attributes,"COLOR_0")&&(v.useVertexColor=!0),v.doubleSided=b,v.cutOff=S;const{blendColorState:w,blendAlphaState:L}=v;switch(y){case"BLEND":v.alphaBlend=2,w.srcFactor=mr.SRC_ALPHA,w.dstFactor=mr.ONE_MINUS_SRC_ALPHA,L.srcFactor=mr.SRC_ALPHA,L.dstFactor=mr.ONE_MINUS_SRC_ALPHA,v.transparent=!0;break;case"MASK":v.alphaBlend=1,v.useCutOff=!0,w.srcFactor=mr.ONE,w.dstFactor=mr.ZERO,L.srcFactor=mr.ONE,L.dstFactor=mr.ZERO;break;default:w.srcFactor=mr.ONE,w.dstFactor=mr.ZERO,L.srcFactor=mr.ONE,L.dstFactor=mr.ZERO,v.alphaBlend=0}return v},parseIndicesInfo_GLTF=(i,g)=>{const{accessor:x,startIndex:_,getMethod:v,bufferURIDataView:b,componentType_BYTES_PER_ELEMENT:y}=i,{type:S,count:w}=x;let L,k=_;if("SCALAR"===S)for(L=k+w;k<L;k++)g.push(b[v](k*y,!0))},parseInterleaveData_GLTF=(i,g,x,_,v,b,y,S,w,L,k=!1,z=!1)=>{let H,q,W,be,Ke,Xe,je,Ye,Ze,Je=0,Qe=g.length/3,et=0;const tt=g.length,it=_.length,ft=b.length,pt=x.length,xt=S.length,vt=w.length,bt=L.length;if(H=W=Xe=0,q=be=je=1,Ke=Ye=2,Ze=3,k)for(;Je<Qe;Je++)xt?(i[et++]=S[Xe],i[et++]=S[je],i[et++]=S[Ye],i[et++]=S[Ze]):(i[et++]=0,i[et++]=0,i[et++]=0,i[et++]=0),H+=2,q+=2,W+=3,be+=3,Ke+=3,Xe+=4,je+=4,Ye+=4,Ze+=4;else if(z)for(;Je<Qe;Je++)vt?(i[et++]=w[Xe],i[et++]=w[je],i[et++]=w[Ye],i[et++]=w[Ze]):(i[et++]=0,i[et++]=0,i[et++]=0,i[et++]=0),H+=2,q+=2,W+=3,be+=3,Ke+=3,Xe+=4,je+=4,Ye+=4,Ze+=4;else for(;Je<Qe;Je++)tt&&(i[et++]=g[W],i[et++]=g[be],i[et++]=g[Ke]),it?(i[et++]=_[W],i[et++]=_[be],i[et++]=_[Ke]):(i[et++]=0,i[et++]=0,i[et++]=0),v.length||v.push(0,0),v.length&&(i[et++]=v[H],i[et++]=v[q]),ft?(i[et++]=b[H],i[et++]=b[q]):v.length&&(i[et++]=v[H],i[et++]=v[q]),pt?(i[et++]=x[Xe],i[et++]=x[je],i[et++]=x[Ye],i[et++]=x[Ze]):(i[et++]=0,i[et++]=0,i[et++]=0,i[et++]=0),bt?(i[et++]=L[Xe],i[et++]=L[je],i[et++]=L[Ye],i[et++]=L[Ze]):(i[et++]=0,i[et++]=0,i[et++]=0,i[et++]=0),H+=2,q+=2,W+=3,be+=3,Ke+=3,Xe+=4,je+=4,Ye+=4,Ze+=4},quaternionToRotationMat4=(i,g)=>{let x=i[0],_=i[1],v=i[2],b=i[3],y=x+x,S=_+_,w=v+v,L=x*y,k=x*S,z=x*w,H=_*S,q=_*w,W=v*w,be=b*y,Ke=b*S,Xe=b*w;return g[0]=1-(H+W),g[4]=k-Xe,g[8]=z+Ke,g[1]=k+Xe,g[5]=1-(L+W),g[9]=q-be,g[2]=z-Ke,g[6]=q+be,g[10]=1-(L+H),g[3]=0,g[7]=0,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1,g},ra=180/Math.PI,setMeshRotation=(i,g)=>{g.setRotation(i[0]*ra,i[1]*ra,i[2]*ra)},parseTRSAndMATRIX_GLTF=(i,g)=>{const{matrix:x,rotation:_,translation:v,scale:b}=g;let y,S;if(y=create$4(),"matrix"in g){S=create$3(),mat4ToEuler(x,S),setMeshRotation(S,i),i.setPosition(x[12],x[13],x[14]);const g=fromValues$3(1,1,1);getScaling(g,x),i.setScale(g[0],g[1],g[2])}else"rotation"in g&&(S=create$3(),quaternionToRotationMat4(_,y),mat4ToEuler(y,S),setMeshRotation(S,i)),"translation"in g&&i.setPosition(v[0],v[1],v[2]),"scale"in g&&(i.setScale(b[0],b[1],b[2]),(b[0]<0||b[1]<0||b[2]<0)&&(i.primitiveState.frontFace=ti.CW))},parseChildrenAndSkin=(i,g,x,_,v)=>{if("children"in _){const v=_.children,b=v.length;for(let _=0;_<b;_++)parseNode_GLTF(i,g,v[_],x)}"skin"in _&&((i,g,x,_)=>{const v=new ParsedSkinInfo_GLTF,b=[],{nodes:y}=g,{joints:S,skeleton:w}=x;{let g=0;const x=S.length;for(;g<x;g++){const x=S[g];parseJoint_GLTF(i,v,y,x)}}w&&(v.skeletonMesh=y[w].Mesh);const L=x.inverseBindMatrices,k=new AccessorInfo_GLTF(i,g,L),{startIndex:z,accessor:H,componentType_BYTES_PER_ELEMENT:q,bufferViewByteStride:W,bufferURIDataView:be,getMethod:Ke}=k,{type:Xe,count:je}=H;let Ye=0;const Ze=W/q;let Je,Qe=z;if("MAT4"===Xe)if(W)for(Je=Qe+je*(W/q);Qe<Je;Qe++)Ye%Ze<16&&b.push(be[Ke](Qe*q,!0)),Ye++;else for(Je=Qe+16*je;Qe<Je;Qe++)b.push(be[Ke](Qe*q,!0)),Ye++;v.inverseBindMatrices=[];for(let i=0;i<S.length;i++)v.inverseBindMatrices.push(new Float32Array([b[16*i],b[16*i+1],b[16*i+2],b[16*i+3],b[16*i+4],b[16*i+5],b[16*i+6],b[16*i+7],b[16*i+8],b[16*i+9],b[16*i+10],b[16*i+11],b[16*i+12],b[16*i+13],b[16*i+14],b[16*i+15]]));_.animationInfo.skinInfo=v,_.material.useSkin=!!_.animationInfo.skinInfo})(i,g,v[_.skin],x)},parseNode_GLTF=(i,g,x,_)=>{const{redGPUContext:v,parsingResult:b}=i,{nodes:y,meshes:S,skins:w}=g,{groups:L,cameras:k}=b,z=y[x];if("mesh"in z){const v=function(i,g,x,_){const{redGPUContext:v}=i;let b;x.name&&(b=x.name);const y=[],{primitives:S}=x;let w=0;const L=S.length;for(;w<L;w++){const L=S[w];let k,z,H,q=[],W=[],be=[],Ke=[],Xe=[],je=[],Ye=[],Ze=[],Je=[],Qe=[];const{attributes:et}=L,tt=new Map;if(et)for(const x in et){const _=et[x],v=new AccessorInfo_GLTF(i,g,_),b=x.indexOf("TEXCOORD_")>-1;if(b){const i=`TEXCOORD_${tt.size}`;tt.set(x,i)}parseAttributeInfo_GLTF(b?tt.get(x):x,v,W,Ke,Xe,0,Ye,Ze,Je,be,Qe),v.accessor.sparse&&parseSparse_GLTF(i,x,v.accessor,g,W)}if("indices"in L){let x=L.indices,_=new AccessorInfo_GLTF(i,g,x);parseIndicesInfo_GLTF(_,q)}z=parseMaterialInfo_GLTF(i,g,L),z instanceof PBRMaterial&&i.parsingResult.materials.push(z);let it,ft=!1;if("mode"in L)switch(L.mode){case 0:H=Lr.POINT_LIST;break;case 1:case 2:H=Lr.LINE_LIST;break;case 3:H=Lr.LINE_STRIP,ft=!0;break;case 4:case 6:H=Lr.TRIANGLE_LIST;break;case 5:H=Lr.TRIANGLE_STRIP,ft=!0}be.length&&(z.useVertexColor_0=!0),it=Ye.length?Ye:calculateNormals(W,q),Qe.length&&(z.useVertexTangent=!0);let pt,xt=[];parseInterleaveData_GLTF(xt,W,be,it,Ke,Xe,0,Ze,Je,Qe);let vt={};W.length&&(vt.aVertexPosition=VertexInterleaveType.float32x3),it.length&&(vt.aVertexNormal=VertexInterleaveType.float32x3),Ke.length&&(vt.aTexcoord=VertexInterleaveType.float32x2),(je.length||Xe.length||Ke.length)&&(vt.aTexcoord1=VertexInterleaveType.float32x2),vt.aVertexColor_0=VertexInterleaveType.float32x4,vt.aVertexTangent=VertexInterleaveType.float32x4;const bt=[],yt=[];parseInterleaveData_GLTF(bt,W,be,it,Ke,Xe,0,Ze,Je,Qe,!0),parseInterleaveData_GLTF(yt,W,be,it,Ke,Xe,0,Ze,Je,Qe,!1,!0);const St=new VertexBuffer(v,bt,new VertexInterleavedStruct({aVertexWeight:VertexInterleaveType.float32x4}),void 0,`Weight_${i.url}_${_}_${w}`),Tt=new IndexBuffer(v,yt,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,`Joint_${i.url}_${_}_${w}`);let Mt=new MorphInfo_GLTF(i,g,L,x.weights);const wt=`Vertex_${i.url}_${_}_${w}_${Mt.weights.length?createUUID():""}`,Ct=v.resourceManager.managedVertexBufferState.table.get(wt)?.buffer;if(pt=new Geometry(v,Ct||new VertexBuffer(v,xt,new VertexInterleavedStruct(vt,"PBR"),void 0,wt),!ft&&q.length?new IndexBuffer(v,new Uint32Array(q),void 0,`Index_${i.url}_${_}_${w}`):null),z||consoleAndThrowError("재질을 파싱할수없는경우 ",L),k=new Mesh(v,pt,z),k.animationInfo.weightBuffer=St,k.animationInfo.jointBuffer=Tt,b&&(k.name=b,i.parsingOption))for(let g in i.parsingOption)b.toLowerCase().indexOf(g)>-1&&i.parsingOption[g](k);k.primitiveState.topology=H||Lr.TRIANGLE_LIST,k.material.doubleSided&&(k.primitiveState.cullMode=ei.NONE),k.material.use2PathRender&&(k.primitiveState.cullMode=ei.NONE,k.depthStencilState.depthCompare=Tn.LESS_EQUAL),2===k.material.alphaBlend&&(k.depthStencilState.depthCompare=Tn.LESS_EQUAL),k.animationInfo.morphInfo=Mt,k.animationInfo.morphInfo.origin=new Float32Array(xt);let Pt=k.geometry.vertexBuffer.data;k.gpuRenderInfo||k.initGPURenderInfos();let Rt=0;for(const i in vt)Rt+=vt[i].numElements;if(!Ct){const i=k.animationInfo.morphInfo.morphInfoDataList;let g=0;const x=i.length,_=Pt.length;for(;g<x;){const x=i[g].vertices;let v=0,b=_/Rt,y=null==k.animationInfo.morphInfo.weights[g]?.5:k.animationInfo.morphInfo.weights[g];for(;v<b;)Pt[v*Rt]+=x[3*v]*y,Pt[v*Rt+1]+=x[3*v+1]*y,Pt[v*Rt+2]+=x[3*v+2]*y,v++;g++}}k.geometry.vertexBuffer.updateAllData(Pt),k.animationInfo.morphInfo.origin=new Float32Array(Pt),L.Mesh=k,y.push(k)}return y}(i,g,S[z.mesh],x),b=v.length;for(let x=0;x<b;x++){let b=v[x];_.addChild(z.Mesh=b),parseTRSAndMATRIX_GLTF(b,z),parseChildrenAndSkin(i,g,b,z,w)}}else{let b;L[x]?(b=L[x],z.Mesh=b):(b=new Mesh(v),_.addChild(b),z.Mesh=b,b.name=z.name,L[x]=b),parseTRSAndMATRIX_GLTF(b,z),parseChildrenAndSkin(i,g,b,z,w)}},parseGLTF=(i,g,x,_)=>{g.extensionsUsed?.includes("KHR_draco_mesh_compression")&&alert("RedGPU GLTFLoader does not support the KHR_draco_mesh_compression extension. Models using this extension may not load properly."),requestAnimationFrame(()=>{(i=>{const g=i?.asset;g||consoleAndThrowError("GLTFLoader - asset must be defined"),g.version||consoleAndThrowError("GLTFLoader - asset version must be defined");const x=parseFloat(g.version);isNaN(x)&&consoleAndThrowError("GLTFLoader - asset version must be a numerical value"),x<2&&consoleAndThrowError("GLTFLoader - asset version must be 2.0 or higher")})(g),requestAnimationFrame(()=>{((i,g,x,_)=>{const{parsingResult:v}=i,{uris:b}=v,y="buffers",S=b[y],w=g.buffers,L=w.length;let k=0;checkProgress(i,g,k),w.forEach((v,b)=>{var w;function checkLoadingStatus(){checkProgress(i,g,k),_?.(i.loadingProgressInfo),k===L&&x&&x()}v._redURIkey=y,v._redURIIndex=b,v.uri instanceof ArrayBuffer?(w=new DataView(v.uri),k++,S[b]=w,checkLoadingStatus()):function(g){const x=g.startsWith("data:")?g:i.filePath+g;arrayBufferLoader(x,function(i){k++,S[b]=new DataView(i),checkLoadingStatus()},function(i,g){})}(v.uri)})})(i,g,()=>{requestAnimationFrame(()=>{((i,g,x)=>{const{scenes:_}=g;_[0].nodes.forEach(x=>{parseNode_GLTF(i,g,x,i.resultMesh)}),x?.()})(i,g,()=>{requestAnimationFrame(()=>{((i,g)=>{const{cameras:x}=g;x&&x.forEach(function(g){let x=new PerspectiveCamera;"orthographic"==g.type||(x.fieldOfView=180*g.perspective.yfieldOfView/Math.PI,x.farClipping=g.perspective.zfar,x.nearClipping=g.perspective.znear),i.parsingResult.cameras.push(x)})})(i,g),new TextureLoader(i.redGPUContext,Object.values(i.parsingResult.textureRawList),_=>{_.textures.forEach(i=>{const{targetTextureKey:g,targetSamplerKey:x,samplerList:_}=i.srcInfo;i.srcInfo.materialList.forEach((v,b)=>{v[g]=i.texture,_[b]&&(v[x]=_[b])})}),parseAnimations(i,g).then(i=>{x&&x()})},g=>{i.loadingProgressInfo.textures=g,_?.(i.loadingProgressInfo)})})})})},_)})})},ia=new Map,aa=new Map,parseFileGLB=async(i,x,_)=>{const v=getAbsoluteURL(window.location.href,i.filePath+i.fileName),progress=()=>{if(_){const g=ia.get(v);i.loadingProgressInfo.model={loaded:g.byteLength,total:g.byteLength,lengthComputable:!0,percent:100,transferred:"Cached",totalSize:"Cached"},_(i.loadingProgressInfo)}};if(ia.has(v))return g("GLB Model parsing has cache",v),progress(),void await parseArrayBuffer(i,ia.get(v),x,_);if(aa.has(v))return await aa.get(v),progress(),void await parseArrayBuffer(i,ia.get(v),x,_);const b=new Promise((x,b)=>{(async(i,g,x=()=>{},_=()=>{})=>{try{const x=await fetch(i);if(!x.ok)throw new Error(`HTTP error! status:${x.status}`);const v=x.headers.get("content-length"),b=v?parseInt(v,10):0,y=b>0,S=y?formatBytes(b):"Unknown";if(!x.body)return void g(new ArrayBuffer(0));const w=x.body.getReader();let L=0;const k=[];for(;;){const{done:i,value:g}=await w.read();if(i)break;g&&(k.push(g),L+=g.length,_({loaded:L,total:b,lengthComputable:y,percent:y?Math.min(100,parseFloat((L/b*100).toFixed(2))):0,transferred:formatBytes(L),totalSize:S}))}if(0===L)return void g(new ArrayBuffer(0));const z=new Blob(k);g(await z.arrayBuffer())}catch(i){x?x(i):console.error("getArrayBufferFromSrc 로딩 중 오류 발생:",i)}})(v,i=>{ia.set(v,i),g("GLB Model parsing set cache",v),aa.delete(v),x(i)},i=>{g("GLB Model parsing error",i),aa.delete(v),b(i)},g=>{i.loadingProgressInfo.model=g,_?.(i.loadingProgressInfo)})});aa.set(v,b);try{const g=await b;await parseArrayBuffer(i,g,x,_)}catch(i){}},parseArrayBuffer=async(i,g,x,_)=>{const{content:v,binaryChunk:b}=parseBuffer(g);if(null===v)throw new Error("JSON content not found");const y=JSON.parse(v);processImagesIfExist(y,b),y.buffers[0].uri=b,i.gltfData=y,parseGLTF(i,y,x,_)},parseBuffer=i=>{let g=null,x=null;const _=new DataView(i,12),v=_.byteLength;for(let b=0;b<v;){const v=_.getUint32(b,!0);b+=4;const y=_.getUint32(b,!0);switch(b+=4,y){case 1313821514:const _=new Uint8Array(i,12+b,v);g=convertUint8ArrayToString(_);break;case 5130562:const y=12+b;x=i.slice(y,y+v)}b+=v}return{content:g,binaryChunk:x}},processImagesIfExist=(i,g)=>{const{images:x,bufferViews:_}=i,v=["image/png","image/jpeg","image/gif","image/webp"],b=new Map;if(x)for(let i=0;i<x.length;i++){const y=x[i],{mimeType:S,bufferView:w}=y;if(v.includes(S)&&void 0!==w){const i=_[w].byteOffset||0,x=_[w].byteLength,v=`${i}_${x}_${S}`;if(b.has(v))y.uri=b.get(v);else{const _=g.slice(i,i+x),w=new Blob([new Uint8Array(_)],{type:S}),L=URL.createObjectURL(w);b.set(v,L),y.uri=L}}}return b},convertUint8ArrayToString=i=>{let g="";for(let x of i)g+=String.fromCharCode(x);return g},sa=new Map,oa=new Map,getData=i=>({...i,meshes:JSON.parse(JSON.stringify(i.meshes))});class GLTFLoader{parsingResult;resultMesh;parsingOption;activeAnimations=[];#l;#_h;#vh;#bh;#yh;#Sh;#z;#H;#Th;#Mh={url:"",model:{loaded:0,total:0,lengthComputable:!0,percent:0,transferred:"0",totalSize:"0"}};constructor(i,g,x,_,v){validateRedGPUContext(i),this.#l=i,this.#bh=g,this.#_h=getFilePath(g),this.#vh=getFileName(g),this.#yh=getFileExtension(g),this.#z=x,this.#Th=_,this.#H=v,this.parsingResult={groups:[],materials:[],uris:{buffers:[]},textures:{},textureRawList:[],cameras:[],animations:[]},this.resultMesh=new Mesh(this.#l),this.resultMesh.gltfLoaderInfo=this,this.resultMesh.animationInfo.animationsList=this.parsingResult.animations,this.#Mh.url=getFileName(g),this.#wh()}get loadingProgressInfo(){return this.#Mh}get redGPUContext(){return this.#l}get filePath(){return this.#_h}get gltfData(){return this.#Sh}set gltfData(i){this.#Sh=i}get fileName(){return this.#vh}get url(){return this.#bh}stopAnimation(){this.activeAnimations.length=0}playAnimation(i){const{activeAnimations:g}=this;g.push(new PlayAnimationInfo(performance.now(),i))}async#wh(){try{"glb"===this.#yh?parseFileGLB(this,()=>this.#z(this),this.#Th):"gltf"===this.#yh?(async(i,x,_)=>{const v=getAbsoluteURL(window.location.href,i.filePath+i.fileName),cachedProgress=()=>{if(_){const g=sa.get(v);i.loadingProgressInfo.model={loaded:g.byteLength,total:g.byteLength,lengthComputable:!0,percent:100,transferred:"Cached",totalSize:"Cached"},_(i.loadingProgressInfo)}};if(sa.has(v))return i.gltfData=getData(sa.get(v)),cachedProgress(),void requestAnimationFrame(()=>{parseGLTF(i,i.gltfData,x,_)});if(oa.has(v))return await oa.get(v),cachedProgress(),i.gltfData=getData(sa.get(v)),void requestAnimationFrame(()=>{parseGLTF(i,i.gltfData,x,_)});const b=new Promise(async(x,b)=>{try{const b=await fetch(i.url);if(!b.ok)throw new Error("GLTF 네트워크 오류:"+b.status);const y=b.headers.get("content-length"),S=y?parseInt(y,10):0;g(`전체 사이즈:${S} bytes`);const w=await b.json();sa.set(v,w),i.loadingProgressInfo.model={loaded:S,total:S,lengthComputable:!0,percent:100,transferred:formatBytes(S),totalSize:formatBytes(S)};{g(w);const x=w.buffers.length;if(x){let g=0;i.loadingProgressInfo.buffers={loaded:g,total:x,percent:Math.min(100,parseFloat((g/x*100).toFixed(2)))}}}_?.(i.loadingProgressInfo),x(w)}catch(i){b(i)}finally{oa.delete(v)}});oa.set(v,b);const y=await b;i.gltfData=getData(y),requestAnimationFrame(()=>{parseGLTF(i,i.gltfData,x,_)})})(this,()=>this.#z(this),this.#Th):consoleAndThrowError("Unknown file extension:"+this.#yh)}catch(i){this.#H?.(i)}}}Object.freeze(GLTFLoader);class PlayAnimationInfo{startTime;targetGLTFParsedSingleClip;constructor(i,g){this.startTime=i,this.targetGLTFParsedSingleClip=g}}var ua=Object.freeze({__proto__:null,AABB:AABB,OBB:OBB,calculateGeometryAABB:calculateGeometryAABB,calculateMeshAABB:calculateMeshAABB,calculateMeshCombinedAABB:calculateMeshCombinedAABB,calculateMeshOBB:calculateMeshOBB}),la=Object.freeze({__proto__:null,AController:AController});const ca=Math.PI/180,updateObject3DMatrix=(i,g)=>{const{pixelRectObject:x}=g,_=i.parent,v=i.localMatrix;identity$1(v),translate(v,v,[i.x,i.y,i.z]),rotateX$2(v,v,i.rotationX*ca),rotateY$2(v,v,i.rotationY*ca),rotateZ$2(v,v,i.rotationZ*ca);let b=[i.scaleX,i.scaleY,i.scaleZ];if(i.renderTextureWidth&&(b[0]*=i.renderTextureWidth/x.height,b[1]*=i.renderTextureHeight/x.height),scale$4(v,v,b),i.pivotX||i.pivotY||i.pivotZ){translate(v,v,[-i.pivotX,-i.pivotY,-i.pivotZ])}_?.modelMatrix?multiply$4(i.modelMatrix,_.modelMatrix,i.localMatrix):copy$4(i.modelMatrix,i.localMatrix)},ha=Math.PI/180;const fa=Math.PI/180,da=create$4(),ma=create$3();const pa=Math.PI/180,ga=1e-4,xa=create$4();var _a=Object.freeze({__proto__:null,Camera2D:Camera2D,Core:la,FollowController:class extends AController{#Ch=10;#Ph=10;#Rh=.02;#Bh=5;#Ih=5;#Eh=.02;#Dh=.02;#Uh=0;#Lh=0;#Ah=.02;#Gh=20;#kh=20;#Oh=.02;#Nh=!0;#Vh=0;#Fh=0;#zh=0;#Ta;#Hh=create$3();constructor(i,g){super(i,{HD_Wheel:i=>{this.#Ph+=i.deltaY/100},HD_TouchPinch:i=>{const g=i-1;this.#Ph-=g*this.#Ph}}),this.targetMesh=g,this.#Ta.setIgnoreFrustumCullingRecursively(!0)}get distance(){return this.#Ph}set distance(i){validateNumberRange(i,.1),this.#Ph=i}get distanceInterpolation(){return this.#Rh}set distanceInterpolation(i){validateNumberRange(i,.01,1),this.#Rh=i}get height(){return this.#Ih}set height(i){validateNumber(i),this.#Ih=i}get heightInterpolation(){return this.#Eh}set heightInterpolation(i){validateNumberRange(i,.01,1),this.#Eh=i}get pan(){return this.#Lh}set pan(i){validateNumber(i),this.#Lh=i}get panInterpolation(){return this.#Ah}set panInterpolation(i){validateNumberRange(i,.01,1),this.#Ah=i}get tilt(){return this.#kh}set tilt(i){validateNumber(i),this.#kh=Math.max(-89,Math.min(89,i))}get tiltInterpolation(){return this.#Oh}set tiltInterpolation(i){validateNumberRange(i,.01,1),this.#Oh=i}get interpolation(){return this.#Dh}set interpolation(i){validateNumberRange(i,.01,1),this.#Dh=i}get followTargetRotation(){return this.#Nh}set followTargetRotation(i){this.#Nh=i}get targetOffsetX(){return this.#Vh}set targetOffsetX(i){validateNumber(i),this.#Vh=i}get targetOffsetY(){return this.#Fh}set targetOffsetY(i){validateNumber(i),this.#Fh=i}get targetOffsetZ(){return this.#zh}set targetOffsetZ(i){validateNumber(i),this.#zh=i}get targetMesh(){return this.#Ta}set targetMesh(i){if(!i)throw new Error("FollowController:targetMesh cannot be null or undefined");this.#Ta=i,this.#Ta.setIgnoreFrustumCullingRecursively(!0),this.#$h()}setTargetOffset(i,g=0,x=0){validateNumber(i),validateNumber(g),validateNumber(x),this.#Vh=i,this.#Fh=g,this.#zh=x}update(i,g){super.update(i,g,g=>{const{targetMesh:x}=this;x&&updateObject3DMatrix(x,i),this.#Ch=this.#Ph+(this.#Ch-this.#Ph)*Math.pow(this.#Rh,g),this.#Bh=this.#Ih+(this.#Bh-this.#Ih)*Math.pow(this.#Eh,g);let _=(this.#Lh-this.#Uh)%360;_>180&&(_-=360),_<-180&&(_+=360),this.#Uh+=_*(1-Math.pow(this.#Ah,g)),this.#Gh=this.#kh+(this.#Gh-this.#kh)*Math.pow(this.#Oh,g);const v=this.#Kh(),b=Math.pow(this.#Dh,g);this.#Hh[0]=v[0]+(this.#Hh[0]-v[0])*b,this.#Hh[1]=v[1]+(this.#Hh[1]-v[1])*b,this.#Hh[2]=v[2]+(this.#Hh[2]-v[2])*b,this.camera.setPosition(this.#Hh[0],this.#Hh[1],this.#Hh[2]);const y=this.#Xh();this.camera.lookAt(y[0],y[1],y[2])})}#Kh(){const i=this.#Uh*fa,g=this.#Gh*fa,x=Math.cos(g),_=Math.sin(g),v=Math.cos(i),b=Math.sin(i),y=this.#Ta.modelMatrix,S=y[12],w=y[13],L=y[14];return this.#Nh?(set$3(ma,b*this.#Ch*x,_*this.#Ch+this.#Bh,v*this.#Ch*x),copy$4(da,y),da[12]=da[13]=da[14]=0,transformMat4$2(ma,ma,da),fromValues$3(S+ma[0],w+ma[1],L+ma[2])):fromValues$3(S+this.#Ch*x*b,w+this.#Bh+this.#Ch*_,L+this.#Ch*x*v)}#Xh(){set$3(ma,this.#Vh,this.#Fh,this.#zh);const i=this.#Ta.modelMatrix,g=i[12],x=i[13],_=i[14];return!this.#Nh||0===this.#Vh&&0===this.#Fh&&0===this.#zh||(copy$4(da,i),da[12]=da[13]=da[14]=0,transformMat4$2(ma,ma,da)),fromValues$3(g+ma[0],x+ma[1],_+ma[2])}#$h(){updateObject3DMatrix(this.#Ta,{pixelRectObject:{height:1}}),this.#Ch=this.#Ph,this.#Bh=this.#Ih,this.#Uh=this.#Lh,this.#Gh=this.#kh;const i=this.#Kh();copy$3(this.#Hh,i),this.camera.setPosition(this.#Hh[0],this.#Hh[1],this.#Hh[2]);const g=this.#Xh();this.camera.lookAt(g[0],g[1],g[2])}},FreeController:class extends AController{#Ra={moveForward:"w",moveBack:"s",moveLeft:"a",moveRight:"d",moveUp:"e",moveDown:"q",turnLeft:"z",turnRight:"c",turnUp:"r",turnDown:"f"};#Ca=600;#jh=.001;#Yh=1;#qh=0;#Wh=360;#Zh=.001;#Jh=.15;#Qh=[0,0,0];#ef=0;#tf=0;#Ta;#nf=create$4();#rf=create$4();#if=create$3();constructor(i){super(i,{HD_Move:(i,g)=>{this.#ef-=i*this.#Jh,this.#tf-=g*this.#Jh},useKeyboard:!0}),this.#oa()}get x(){return this.#Ta.x}set x(i){validateNumber(i),this.#Ta.x=i,this.#Qh[0]=i}get y(){return this.#Ta.y}set y(i){validateNumber(i),this.#Ta.y=i,this.#Qh[1]=i}get z(){return this.#Ta.z}set z(i){validateNumber(i),this.#Ta.z=i,this.#Qh[2]=i}get pan(){return this.#ef}set pan(i){validateNumber(i),this.#ef=i}get tilt(){return this.#tf}set tilt(i){validateNumber(i),this.#tf=Math.max(-89.9,Math.min(89.9,i))}get mouseSensitivity(){return this.#Jh}set mouseSensitivity(i){validateNumberRange(i,.01),this.#Jh=i}get moveSpeed(){return this.#Ca}set moveSpeed(i){validateNumberRange(i,.01),this.#Ca=i}get moveSpeedInterpolation(){return this.#jh}set moveSpeedInterpolation(i){validateNumberRange(i,1e-4,1),this.#jh=i}get rotationSpeed(){return this.#Wh}set rotationSpeed(i){validateNumberRange(i,.01),this.#Wh=i}get rotationSpeedInterpolation(){return this.#Zh}set rotationSpeedInterpolation(i){validateNumberRange(i,1e-4,1),this.#Zh=i}get maxAcceleration(){return this.#Yh}set maxAcceleration(i){this.#Yh=i}get keyNameMapper(){return{...this.#Ra}}setMoveForwardKey(i){this.#Ra.moveForward=i}setMoveBackKey(i){this.#Ra.moveBack=i}setMoveLeftKey(i){this.#Ra.moveLeft=i}setMoveRightKey(i){this.#Ra.moveRight=i}setMoveUpKey(i){this.#Ra.moveUp=i}setMoveDownKey(i){this.#Ra.moveDown=i}setTurnLeftKey(i){this.#Ra.turnLeft=i}setTurnRightKey(i){this.#Ra.turnRight=i}setTurnUpKey(i){this.#Ra.turnUp=i}setTurnDownKey(i){this.#Ra.turnDown=i}update(i,g){super.update(i,g,x=>{this.#Ea(i,g,x)})}#oa(){this.#Ta=new Mesh(this.redGPUContext)}#Ea(i,g,x){const _=this.#Ta,v=Math.pow(this.#jh,x),b=Math.pow(this.#Zh,x);let y=(this.#ef-_.rotationY)%360;y>180&&(y-=360),y<-180&&(y+=360),_.rotationY+=y*(1-b);const S=this.#tf-_.rotationX;_.rotationX+=S*(1-b),this.#af(i,x)&&(updateObject3DMatrix(_,i),identity$1(this.#rf),rotateY$2(this.#rf,this.#rf,_.rotationY*ha),rotateX$2(this.#rf,this.#rf,_.rotationX*ha),translate(this.#rf,this.#rf,this.#if),identity$1(this.#nf),translate(this.#nf,this.#nf,_.position),multiply$4(this.#nf,this.#nf,this.#rf),this.#Qh[0]=this.#nf[12],this.#Qh[1]=this.#nf[13],this.#Qh[2]=this.#nf[14]),_.x+=(this.#Qh[0]-_.x)*(1-v),_.y+=(this.#Qh[1]-_.y)*(1-v),_.z+=(this.#Qh[2]-_.z)*(1-v),identity$1(this.#nf),translate(this.#nf,this.#nf,_.position),rotateY$2(this.#nf,this.#nf,_.rotationY*ha),rotateX$2(this.#nf,this.#nf,_.rotationX*ha),this.camera.setPosition(_.x,_.y,_.z);const w=fromValues$3(0,0,-10);transformMat4$2(w,w,this.#nf),this.camera.lookAt(w[0],w[1],w[2])}#af(i,g){if(!this.checkKeyboardInput(i,this.#Ra))return!1;const{keyboardKeyBuffer:x}=i.redGPUContext,_=this.#Ca*g,v=this.#Wh*g,b=this.#Ra;let y=!1,S=!1,w=0,L=0;this.#if[0]=0,this.#if[1]=0,this.#if[2]=0;const k=this.#qh*_;x[b.turnLeft]&&(S=!0,w=v),x[b.turnRight]&&(S=!0,w=-v),x[b.turnUp]&&(S=!0,L=v),x[b.turnDown]&&(S=!0,L=-v),x[b.moveForward]&&(y=!0,this.#if[2]=-k),x[b.moveBack]&&(y=!0,this.#if[2]=k),x[b.moveLeft]&&(y=!0,this.#if[0]=-k),x[b.moveRight]&&(y=!0,this.#if[0]=k),x[b.moveUp]&&(y=!0,this.#if[1]=k),x[b.moveDown]&&(y=!0,this.#if[1]=-k);const z=3*g;return this.#qh=S||y?Math.min(this.#Yh,this.#qh+z):Math.max(0,this.#qh-z),S&&(this.#ef+=w,this.#tf=Math.max(-89.9,Math.min(89.9,this.#tf+L))),y||S}},IsometricController:IsometricController,OrbitController:class extends AController{#sf=0;#of=0;#uf=0;#lf=15;#cf=1.5;#Rh=.02;#hf=.1;#Br=1/0;#ef=0;#tf=-35;#ff=3;#Zh=.02;#df=-90;#mf=90;#Uh=0;#Gh=0;#Ch=0;constructor(i){super(i,{HD_Move:(i,g)=>{this.#ef-=i*this.#ff*.1,this.#tf-=g*this.#ff*.1},HD_Wheel:i=>{this.#lf+=i.deltaY/100*this.#cf,this.#lf<this.#hf&&(this.#lf=this.#hf),this.#lf>this.#Br&&(this.#lf=this.#Br)},HD_TouchPinch:i=>{const g=(i-1)*this.#cf;this.#lf-=g*this.#lf,this.#lf<this.#hf&&(this.#lf=this.#hf),this.#lf>this.#Br&&(this.#lf=this.#Br)}}),this.#Uh=this.#ef,this.#Gh=this.#tf,this.#Ch=this.#lf}get centerX(){return this.#sf}set centerX(i){this.#sf=i}get centerY(){return this.#of}set centerY(i){this.#of=i}get centerZ(){return this.#uf}set centerZ(i){this.#uf=i}get distance(){return this.#lf}set distance(i){validateNumberRange(i,0),this.#lf=i}get speedDistance(){return this.#cf}set speedDistance(i){validateNumberRange(i,.01),this.#cf=i}get distanceInterpolation(){return this.#Rh}set distanceInterpolation(i){validateNumberRange(i,.01,1),this.#Rh=i}get minDistance(){return this.#hf}set minDistance(i){validateNumberRange(i,.1),this.#hf=i}get maxDistance(){return this.#Br}set maxDistance(i){validateNumberRange(i,.1),this.#Br=i}get speedRotation(){return this.#ff}set speedRotation(i){validateNumberRange(i,.01),this.#ff=i}get rotationInterpolation(){return this.#Zh}set rotationInterpolation(i){validateNumberRange(i,.01,1),this.#Zh=i}get pan(){return this.#ef}set pan(i){this.#ef=i}get tilt(){return this.#tf}set tilt(i){validateNumberRange(i,-90,90),this.#tf=i}get minTilt(){return this.#df}set minTilt(i){validateNumberRange(i,-90,90),this.#df=i}get maxTilt(){return this.#mf}set maxTilt(i){validateNumberRange(i,-90,90),this.#mf=i}#pf(i,g){updateObject3DMatrix(i,g);let x=i.children.length;for(let _=0;_<x;_++){const x=i.children[_];x instanceof Mesh&&this.#pf(x,g)}}fitMeshToScreenCenter(i,g){this.#pf(i,g);const x=i.combinedBoundingAABB;if(!x||x.minX===1/0||isNaN(x.centerX))return;const _=g.rawCamera.fieldOfView*Math.PI/180,v=Math.tan(_/2),b=v*g.aspect,y=x.xSize,S=x.ySize,w=x.zSize,L=y/2/b,k=S/2/v,z=1.15*Math.max(L,k)+w/2;if(this.centerX=x.centerX,this.centerY=x.centerY,this.centerZ=x.centerZ,this.distance=Math.max(z,2*g.rawCamera.nearClipping),this.distance<1){const g=1/this.distance;i.setScale(g),this.centerX*=g,this.centerY*=g,this.centerZ*=g,this.distance=1}this.speedDistance=Math.max(.1,.1*z)}update(i,g){super.update(i,g,i=>{this.#Ea(i)})}#Ea(i){this.#tf<this.#df&&(this.#tf=this.#df),this.#tf>this.#mf&&(this.#tf=this.#mf);const{camera:g}=this,x=this.#ef-this.#Uh;Math.abs(x)>ga?this.#Uh+=x*(1-Math.pow(this.#Zh,i)):this.#Uh=this.#ef;const _=this.#tf-this.#Gh;Math.abs(_)>ga?this.#Gh+=_*(1-Math.pow(this.#Zh,i)):this.#Gh=this.#tf,this.#lf<g.nearClipping&&(this.#lf=g.nearClipping),this.#lf<this.#hf&&(this.#lf=this.#hf),this.#lf>this.#Br&&(this.#lf=this.#Br);const v=this.#lf-this.#Ch;Math.abs(v)>1e-4?this.#Ch+=v*(1-Math.pow(this.#Rh,i)):this.#Ch=this.#lf,this.#Ch<g.nearClipping&&(this.#Ch=g.nearClipping),identity$1(xa),translate(xa,xa,[this.#sf,this.#of,this.#uf]),rotateY$2(xa,xa,this.#Uh*pa),rotateX$2(xa,xa,this.#Gh*pa),translate(xa,xa,[0,0,this.#Ch]),g.x=xa[12],g.y=xa[13],g.z=xa[14],this.camera.lookAt(this.#sf,this.#of,this.#uf)}},OrthographicCamera:OrthographicCamera,PerspectiveCamera:PerspectiveCamera}),va=Object.freeze({__proto__:null,RedGPUContextDetector:RedGPUContextDetector,RedGPUContextSizeManager:RedGPUContextSizeManager,RedGPUContextViewContainer:RedGPUContextViewContainer}),ba=Object.freeze({__proto__:null,Core:va,RedGPUContext:RedGPUContext}),ya=Object.freeze({__proto__:null,ColorRGB:ColorRGB,ColorRGBA:ColorRGBA,convertHexToRgb:convertHexToRgb,convertRgbToHex:convertRgbToHex}),Sa="const PI:f32=3.14159265359;\nconst MAX_TAU:f32=50.0;\nstruct AtmosphereParameters { rayleighScattering:vec3<f32>, mieAnisotropy:f32, ozoneAbsorption:vec3<f32>, ozoneLayerCenter:f32, groundAlbedo:vec3<f32>, groundAmbient:f32, sunDirection:vec3<f32>, sunSize:f32, earthRadius:f32, atmosphereHeight:f32, mieScattering:f32, mieExtinction:f32, rayleighScaleHeight:f32, mieScaleHeight:f32, cameraHeight:f32, multiScatteringAmbient:f32, exposure:f32, sunIntensity:f32, heightFogDensity:f32, heightFogFalloff:f32, horizonHaze:f32, mieGlow:f32, mieHalo:f32, groundShininess:f32, groundSpecular:f32, ozoneLayerWidth:f32, padding0:f32, padding1:f32,\n};\nfn get_ray_sphere_intersection(ray_origin:vec3<f32>,ray_dir:vec3<f32>,sphere_radius:f32) -> f32 { let b=dot(ray_origin,ray_dir); let c=dot(ray_origin,ray_origin) - sphere_radius * sphere_radius; let delta=b * b - c; if (delta < 0.0) { return -1.0;} let s=sqrt(delta); let t0=-b - s; let t1=-b + s; if (t0 > -1e-6) { return max(0.0,t0);} if (t1 > -1e-6) { return max(0.0,t1);} return -1.0;\n}\nfn get_transmittance_uv(h:f32,cos_theta:f32,atmosphere_height:f32) -> vec2<f32> { let v=sqrt(clamp(h/atmosphere_height,0.0,1.0)); let u=clamp(cos_theta * 0.5 + 0.5,0.0,1.0); return vec2<f32>(u,v);\n}\nfn get_transmittance(t_tex:texture_2d<f32>,t_sam:sampler,h:f32,cos_theta:f32,atmosphere_height:f32) -> vec3<f32> { let uv=get_transmittance_uv(h,cos_theta,atmosphere_height); return textureSampleLevel(t_tex,t_sam,uv,0.0).rgb;\n}\nfn phase_rayleigh(cos_theta:f32) -> f32 { return 3.0/(16.0 * PI) * (1.0 + cos_theta * cos_theta);\n}\nfn phase_mie(cos_theta:f32,g:f32) -> f32 { let g2=g * g; return 1.0/(4.0 * PI) * ((1.0 - g2)/pow(max(0.001,1.0 + g2 - 2.0 * g * cos_theta),1.5));\n}\nfn get_height_fog_transmittance(cam_h:f32,ray_dir_y:f32,dist:f32,density:f32,falloff:f32) -> f32 { if (density <=0.0) { return 1.0;} let h=max(0.0,cam_h); let k=falloff; let d=dist; let y=ray_dir_y; var exponent:f32; if (abs(y) < 0.0001) { exponent=density * exp(-k * h) * d; } else { exponent=(density * exp(-k * h))/(k * y) * (1.0 - exp(-k * y * d)); } return exp(-max(0.0,exponent));\n}\n";const Ta=parseWGSL(Sa+"#redgpu_include SYSTEM_UNIFORM;\nstruct OutData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec4<f32>,\n};\nstruct FragmentOutput { @location(0) color:vec4<f32>, @location(1) normal:vec4<f32>, @location(2) motionVector:vec4<f32>,\n};\n@group(2) @binding(0) var<uniform> uniforms:AtmosphereParameters;\n@group(2) @binding(1) var transmittanceTexture:texture_2d<f32>;\n@group(2) @binding(2) var multiScatteringTexture:texture_2d<f32>;\n@group(2) @binding(3) var skyViewTexture:texture_2d<f32>;\n@group(2) @binding(4) var cameraVolumeTexture:texture_3d<f32>;\n@group(2) @binding(5) var tSampler:sampler;\n@fragment\nfn main(outData:OutData) -> FragmentOutput { var output:FragmentOutput; let sunDir=normalize(uniforms.sunDirection); let sunSize=uniforms.sunSize; let atmH=uniforms.atmosphereHeight; let exposure=uniforms.exposure; let sunIntensity=uniforms.sunIntensity; let camH=uniforms.cameraHeight; let earthRadius=uniforms.earthRadius; let viewDir=normalize(outData.vertexPosition.xyz); let r=earthRadius; let h_c=max(0.0001,camH); let horizon_sin=-sqrt(max(0.0,h_c * (2.0 * r + h_c)))/(r + h_c); let horizon_elevation=asin(clamp(horizon_sin,-1.0,1.0)); let azimuth=atan2(viewDir.z,viewDir.x); let elevation=asin(clamp(viewDir.y,-1.0,1.0)); let distFromHorizon=elevation - horizon_elevation; let absDistFromHorizon=abs(distFromHorizon); var skyV:f32; if (elevation >=horizon_elevation) { let v_range=(PI * 0.5) - horizon_elevation; skyV=0.5 * (1.0 - sqrt(max(0.0,(elevation - horizon_elevation)/v_range))); } else { let v_range=horizon_elevation + (PI * 0.5); skyV=0.5 * (1.0 + sqrt(max(0.0,(horizon_elevation - elevation)/v_range))); } let skyU=azimuth/(2.0 * PI) + 0.5; let skySample=textureSampleLevel(skyViewTexture,tSampler,vec2<f32>(skyU,skyV),0.0); let skyLuminance=skySample.rgb; let lutTransmittance=skySample.a; let atmosphereColor=skyLuminance * sunIntensity; let view_sun_cos=dot(viewDir,sunDir); let sun_angular_radius=sunSize * (PI/180.0); let cosSunRadius=cos(sun_angular_radius); let sunTrans=get_transmittance(transmittanceTexture,tSampler,camH,sunDir.y,atmH); let sunRadiance=sunIntensity/max(1e-7,2.0 * PI * (1.0 - cosSunRadius)); let sunDiskMask=smoothstep(cosSunRadius - 0.001,cosSunRadius + 0.001,view_sun_cos); let sunFade=smoothstep(-0.02,0.05,distFromHorizon); let sunDiskLuminance=sunRadiance * sunTrans * sunDiskMask * sunFade; let haloStrength=uniforms.mieScattering * 1.2; let p_mie_glow=phase_mie(view_sun_cos,uniforms.mieGlow); let p_mie_halo=phase_mie(view_sun_cos,uniforms.mieHalo); let sunHalo=sunIntensity * sunTrans * (p_mie_glow * haloStrength + p_mie_halo * (haloStrength * 0.2)); let sun_haze_factor=smoothstep(-0.2,0.5,sunDir.y); let haze_amount=mix(0.3,0.1,sun_haze_factor); var groundPart=vec3<f32>(0.0); let albedo=uniforms.groundAlbedo/PI; var hitDist:f32=1e6; { let camPos=vec3<f32>(0.0,earthRadius + h_c,0.0); let b=dot(camPos,viewDir); let c=dot(camPos,camPos) - earthRadius * earthRadius; let delta=b * b - c; var finalGroundColor=vec3<f32>(0.0); if (delta >=0.0) { let t=-b - sqrt(delta); hitDist=t; let hitPos=camPos + viewDir * t; let groundNormal=normalize(hitPos); let localCosSun=dot(groundNormal,sunDir); let NdotL=max(0.0,localCosSun); let gTransUV=get_transmittance_uv(0.0,localCosSun,atmH); let gTrans=textureSampleLevel(transmittanceTexture,tSampler,gTransUV,0.0).rgb; let gLightFade=smoothstep(-0.02,0.02,localCosSun); let ambientFade=smoothstep(-0.4,0.1,sunDir.y); let ambUV=vec2<f32>(clamp(localCosSun * 0.5 + 0.5,0.0,1.0),0.0); let ambLight=textureSampleLevel(multiScatteringTexture,tSampler,ambUV,0.0).rgb; let V=-viewDir; let L=sunDir; let H=normalize(V + L); let NdotH=max(0.0,dot(groundNormal,H)); let specular=pow(NdotH,uniforms.groundShininess) * uniforms.groundSpecular; let diffuseLight=sunIntensity * gTrans * NdotL * gLightFade; let ambientLight=ambLight * sunIntensity * uniforms.groundAmbient * ambientFade; let specularLight=sunIntensity * gTrans * specular * gLightFade; let groundRawColor=albedo * (diffuseLight + ambientLight) + specularLight; let azimuth=atan2(viewDir.z,viewDir.x); let elevation=asin(clamp(viewDir.y,-1.0,1.0)); let u=azimuth/(2.0 * PI) + 0.5; let v=elevation/PI + 0.5; let max_dist=100.0; let w=sqrt(clamp(hitDist/max_dist,0.0,1.0)); let apSample=textureSampleLevel(cameraVolumeTexture,tSampler,vec3<f32>(u,v,w),0.0); let aerialScattering=apSample.rgb; let aerialTransmittance=apSample.a; finalGroundColor=(groundRawColor * aerialTransmittance) + (aerialScattering * sunIntensity); } else { finalGroundColor=vec3<f32>(0.0); } groundPart=finalGroundColor; } let horizonMask=smoothstep(-0.008,0.008,distFromHorizon); var finalHDR=mix(groundPart,atmosphereColor,horizonMask); let effectiveSun=sunDiskLuminance * horizonMask; let effectiveHalo=sunHalo * max(0.2,horizonMask); finalHDR +=effectiveSun + effectiveHalo; let haze_range=mix(0.1,0.2,1.0 - sun_haze_factor); let horizon_haze_mask=exp(-absDistFromHorizon * (5.0/(haze_amount + 0.01))); let haze_boost=atmosphereColor * uniforms.horizonHaze * 0.8; finalHDR +=haze_boost * horizon_haze_mask; let horizonDist=sqrt(h_c * (2.0 * earthRadius + h_c)); let fogCalcDist=select(horizonDist,hitDist,hitDist < 1e5); let fogT=get_height_fog_transmittance(camH,viewDir.y,fogCalcDist,uniforms.heightFogDensity,uniforms.heightFogFalloff); finalHDR=mix(atmosphereColor,finalHDR,fogT); output.color=vec4<f32>(finalHDR * exposure * 0.2,1.0); output.normal=vec4<f32>(0.0,0.0,0.0,0.0); output.motionVector=vec4<f32>(0.0,0.0,0.0,1.0); return output;\n}");class SkyAtmosphereMaterial extends ABitmapBaseMaterial{dirtyPipeline=!1;constructor(i){super(i,"SKY_ATMOSPHERE_MATERIAL",Ta,2),this.initGPURenderInfos(),this.rayleighScattering=new Float32Array([.0058,.0135,.0331]),this.mieAnisotropy=.9,this.ozoneAbsorption=new Float32Array([65e-5,.00188,8e-5]),this.ozoneLayerCenter=25,this.groundAlbedo=new Float32Array([.15,.15,.15]),this.groundAmbient=.4,this.sunDirection=new Float32Array([0,1,0]),this.sunSize=.5,this.earthRadius=6360,this.atmosphereHeight=60,this.mieScattering=.021,this.mieExtinction=.021,this.rayleighScaleHeight=8,this.mieScaleHeight=1.2,this.cameraHeight=.2,this.multiScatteringAmbient=.05,this.exposure=1,this.sunIntensity=22,this.heightFogDensity=0,this.heightFogFalloff=.1,this.horizonHaze=.3,this.mieGlow=.75,this.mieHalo=.99,this.groundShininess=512,this.groundSpecular=4,this.ozoneLayerWidth=15,this.transmittanceTextureSampler=new Sampler(this.redGPUContext,{magFilter:"linear",minFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"})}}dr.defineVec3(SkyAtmosphereMaterial,["rayleighScattering"]),dr.definePositiveNumber(SkyAtmosphereMaterial,["mieAnisotropy"]),dr.defineVec3(SkyAtmosphereMaterial,["ozoneAbsorption"]),dr.definePositiveNumber(SkyAtmosphereMaterial,["ozoneLayerCenter"]),dr.defineVec3(SkyAtmosphereMaterial,["groundAlbedo"]),dr.definePositiveNumber(SkyAtmosphereMaterial,["groundAmbient"]),dr.defineVec3(SkyAtmosphereMaterial,["sunDirection"]),dr.definePositiveNumber(SkyAtmosphereMaterial,["sunSize"]),dr.definePositiveNumber(SkyAtmosphereMaterial,["earthRadius","atmosphereHeight","mieScattering","mieExtinction","rayleighScaleHeight","mieScaleHeight","cameraHeight","multiScatteringAmbient","exposure","sunIntensity","heightFogDensity","heightFogFalloff","horizonHaze","mieGlow","mieHalo","groundShininess","groundSpecular","ozoneLayerWidth"]),dr.defineTexture(SkyAtmosphereMaterial,["transmittanceTexture","multiScatteringTexture","skyViewTexture"]),dr.defineTexture3D(SkyAtmosphereMaterial,["cameraVolumeTexture"]),dr.defineSampler(SkyAtmosphereMaterial,["transmittanceTextureSampler"]),Object.freeze(SkyAtmosphereMaterial);class TransmittanceLUTTexture extends ManagementResourceBase{#L;#gf;#It;#Et;constructor(i,g,x){super(i,"managedBitmapTextureState"),this.#It=g,this.#Et=x,this.#ne()}#ne(){const{gpuDevice:i}=this.redGPUContext;this.#L=i.createTexture({label:"TransmittanceLUTTexture",size:[this.#It,this.#Et],format:"rgba16float",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING}),this.#gf=this.#L.createView(),this.__fireListenerList()}get gpuTexture(){return this.#L}get gpuTextureView(){return this.#gf}get videoMemorySize(){return this.#It*this.#Et*8}notifyUpdate(){this.__fireListenerList()}}Object.freeze(TransmittanceLUTTexture);const Ma=parseWGSL(Sa+"\n@group(0) @binding(0) var transmittanceTexture:texture_storage_2d<rgba16float,write>;\n@group(0) @binding(1) var<uniform> params:AtmosphereParameters;\nfn get_optical_depth(h:f32,cos_theta:f32) -> vec3<f32> { let r=params.earthRadius; let atmosphereRadius=r + params.atmosphereHeight; let ray_origin=vec3<f32>(0.0,h + r,0.0); let sin_theta=sqrt(max(0.0,1.0 - cos_theta * cos_theta)); let ray_dir=vec3<f32>(sin_theta,cos_theta,0.0); let t_earth=get_ray_sphere_intersection(ray_origin,ray_dir,r); if (t_earth > 0.0) { return vec3<f32>(MAX_TAU);} let t_max=get_ray_sphere_intersection(ray_origin,ray_dir,atmosphereRadius); if (t_max < 0.0) { return vec3<f32>(0.0);} let steps:i32=40; let step_size=t_max/f32(steps); var opt_r=0.0; var opt_m=0.0; var opt_o=0.0; for (var i:i32=0;i < steps;i=i + 1) { let t=(f32(i) + 0.5) * step_size; let p=ray_origin + ray_dir * t; let height=length(p) - r; opt_r +=exp(-max(0.0,height)/params.rayleighScaleHeight) * step_size; opt_m +=exp(-max(0.0,height)/params.mieScaleHeight) * step_size; let o_width=max(1e-3,params.ozoneLayerWidth); opt_o +=max(0.0,1.0 - abs(height - params.ozoneLayerCenter)/o_width) * step_size; } return params.rayleighScattering * opt_r + params.mieExtinction * opt_m + params.ozoneAbsorption * opt_o;\n}\n@compute @workgroup_size(16,16)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>) { let size=textureDimensions(transmittanceTexture); if (global_id.x >=size.x || global_id.y >=size.y) { return;} let uv=vec2<f32>(global_id.xy)/vec2<f32>(size - 1u); let h=(uv.y * uv.y) * params.atmosphereHeight; let cos_theta=uv.x * 2.0 - 1.0; let tau3=get_optical_depth(h,cos_theta); let T=exp(-min(tau3,vec3<f32>(MAX_TAU))); textureStore(transmittanceTexture,global_id.xy,vec4<f32>(T,1.0));\n}\n"),wa=Ma.uniforms.params;class TransmittanceGenerator{#l;#xf;#Q;#sn;#jn;width=256;height=64;constructor(i){this.#l=i,this.#ne()}get lutTexture(){return this.#xf}#ne(){const{gpuDevice:i}=this.#l;this.#xf=new TransmittanceLUTTexture(this.#l,this.width,this.height);const g=new ArrayBuffer(wa.arrayBufferByteLength);this.#jn=new UniformBuffer(this.#l,g,"TRANS_GEN_UNIFORM_BUFFER");const x=i.createShaderModule({code:Ma.defaultSource});this.#Q=i.createComputePipeline({layout:"auto",compute:{module:x,entryPoint:"main"}}),this.#sn=i.createBindGroup({layout:this.#Q.getBindGroupLayout(0),entries:[{binding:0,resource:this.#xf.gpuTextureView},{binding:1,resource:{buffer:this.#jn.gpuBuffer}}]})}render(i){const{gpuDevice:g}=this.#l,{members:x}=wa;for(const[g,_]of Object.entries(x)){const x=i[g];void 0!==x&&this.#jn.writeOnlyBuffer(_,x)}const _=g.createCommandEncoder(),v=_.beginComputePass();v.setPipeline(this.#Q),v.setBindGroup(0,this.#sn),v.dispatchWorkgroups(Math.ceil(this.width/16),Math.ceil(this.height/16)),v.end(),g.queue.submit([_.finish()]),this.#xf.notifyUpdate()}}class MultiScatteringLUTTexture extends ManagementResourceBase{#L;#gf;#It;#Et;constructor(i,g=32,x=32){super(i,"managedBitmapTextureState"),this.#It=g,this.#Et=x,this.#ne()}#ne(){const{gpuDevice:i}=this.redGPUContext;this.#L=i.createTexture({label:"MultiScatteringLUTTexture",size:[this.#It,this.#Et],format:"rgba16float",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING}),this.#gf=this.#L.createView(),this.__fireListenerList()}get gpuTexture(){return this.#L}get gpuTextureView(){return this.#gf}get videoMemorySize(){return this.#It*this.#Et*8}notifyUpdate(){this.__fireListenerList()}}Object.freeze(MultiScatteringLUTTexture);const Ca=parseWGSL(Sa+"\n@group(0) @binding(0) var multiScatTexture:texture_storage_2d<rgba16float,write>;\n@group(0) @binding(1) var transmittanceTexture:texture_2d<f32>;\n@group(0) @binding(2) var tSampler:sampler;\n@group(0) @binding(3) var<uniform> params:AtmosphereParameters;\n@compute @workgroup_size(8,8)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>) { let size=textureDimensions(multiScatTexture); if (global_id.x >=size.x || global_id.y >=size.y) { return;} let uv=vec2<f32>(global_id.xy)/vec2<f32>(size - 1u); let cos_sun_theta=uv.x * 2.0 - 1.0; let h=(uv.y * uv.y) * params.atmosphereHeight; let r=params.earthRadius; let ray_origin=vec3<f32>(0.0,h + r,0.0); let sun_dir=vec3<f32>(sqrt(max(0.0,1.0 - cos_sun_theta * cos_sun_theta)),cos_sun_theta,0.0); var lum_total=vec3<f32>(0.0); var fms_total=vec3<f32>(0.0); let sample_count=64; for (var i=0;i < sample_count;i=i + 1) { let step=f32(i) + 0.5; let theta=acos(1.0 - 2.0 * step/f32(sample_count)); let phi=(sqrt(5.0) + 1.0) * PI * step; let ray_dir=vec3<f32>(sin(theta) * cos(phi),cos(theta),sin(theta) * sin(phi)); let t_max=get_ray_sphere_intersection(ray_origin,ray_dir,r + params.atmosphereHeight); let t_earth=get_ray_sphere_intersection(ray_origin,ray_dir,r); var dist_limit=t_max; var hit_ground=false; if (t_earth > 0.0) { dist_limit=t_earth; hit_ground=true; } if (dist_limit > 0.0) { let steps=20; let step_size=dist_limit/f32(steps); var L1=vec3<f32>(0.0); var f1=vec3<f32>(0.0); var T_path=vec3<f32>(1.0); for(var j=0;j < steps;j=j + 1) { let t=(f32(j) + 0.5) * step_size; let cur_p=ray_origin + ray_dir * t; let cur_h=length(cur_p) - r; let cos_s=dot(normalize(cur_p),sun_dir); let sun_t=get_transmittance(transmittanceTexture,tSampler,cur_h,cos_s,params.atmosphereHeight); let rho_r=exp(-max(0.0,cur_h)/params.rayleighScaleHeight); let rho_m=exp(-max(0.0,cur_h)/params.mieScaleHeight); let scat_total=params.rayleighScattering * rho_r + params.mieScattering * rho_m; let ext_total=params.rayleighScattering * rho_r + params.mieExtinction * rho_m; let phase=1.0/(4.0 * PI); L1 +=T_path * sun_t * scat_total * phase * step_size; f1 +=T_path * scat_total * step_size; T_path *=exp(-ext_total * step_size); } if (hit_ground) { let hit_p=ray_origin + ray_dir * dist_limit; let ground_n=normalize(hit_p); let cos_s=max(0.0,dot(ground_n,sun_dir)); let sun_t=get_transmittance(transmittanceTexture,tSampler,0.0,cos_s,params.atmosphereHeight); L1 +=T_path * sun_t * cos_s * params.groundAlbedo/PI; } lum_total +=L1; fms_total +=f1/f32(sample_count); } } let L2=lum_total/f32(sample_count); let output=L2/(1.0 - min(fms_total,vec3<f32>(0.999))); textureStore(multiScatTexture,global_id.xy,vec4<f32>(output,1.0));\n}\n"),Pa=Ca.uniforms.params;class MultiScatteringGenerator{#l;#xf;#Q;#jn;#ae;width=256;height=256;constructor(i){this.#l=i,this.#ae=new Sampler(this.#l,{magFilter:"linear",minFilter:"linear"}),this.#ne()}get lutTexture(){return this.#xf}#ne(){const{gpuDevice:i}=this.#l;this.#xf=new MultiScatteringLUTTexture(this.#l,this.width,this.height);const g=new ArrayBuffer(Pa.arrayBufferByteLength);this.#jn=new UniformBuffer(this.#l,g,"MULTI_SCAT_GEN_UNIFORM_BUFFER");const x=i.createShaderModule({code:Ca.defaultSource});this.#Q=i.createComputePipeline({layout:"auto",compute:{module:x,entryPoint:"main"}})}render(i,g){const{gpuDevice:x}=this.#l,{members:_}=Pa;for(const[i,x]of Object.entries(_)){const _=g[i];void 0!==_&&this.#jn.writeOnlyBuffer(x,_)}const v=x.createBindGroup({layout:this.#Q.getBindGroupLayout(0),entries:[{binding:0,resource:this.#xf.gpuTextureView},{binding:1,resource:i.gpuTextureView},{binding:2,resource:this.#ae.gpuSampler},{binding:3,resource:{buffer:this.#jn.gpuBuffer}}]}),b=x.createCommandEncoder(),y=b.beginComputePass();y.setPipeline(this.#Q),y.setBindGroup(0,v),y.dispatchWorkgroups(Math.ceil(this.width/8),Math.ceil(this.height/8)),y.end(),x.queue.submit([b.finish()]),this.#xf.notifyUpdate()}}class SkyViewLUTTexture extends ManagementResourceBase{#L;#gf;#It;#Et;constructor(i,g=200,x=200){super(i,"managedBitmapTextureState"),this.#It=g,this.#Et=x,this.#ne()}#ne(){const{gpuDevice:i}=this.redGPUContext;this.#L=i.createTexture({label:"SkyViewLUTTexture",size:[this.#It,this.#Et],format:"rgba16float",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING}),this.#gf=this.#L.createView(),this.__fireListenerList()}get gpuTexture(){return this.#L}get gpuTextureView(){return this.#gf}get videoMemorySize(){return this.#It*this.#Et*8}notifyUpdate(){this.__fireListenerList()}}Object.freeze(SkyViewLUTTexture);const Ra=parseWGSL(Sa+"\n@group(0) @binding(0) var skyViewTexture:texture_storage_2d<rgba16float,write>;\n@group(0) @binding(1) var transmittanceTexture:texture_2d<f32>;\n@group(0) @binding(2) var multiScatTexture:texture_2d<f32>;\n@group(0) @binding(3) var tSampler:sampler;\n@group(0) @binding(4) var<uniform> params:AtmosphereParameters;\n@compute @workgroup_size(16,16)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>) { let size=textureDimensions(skyViewTexture); if (global_id.x >=size.x || global_id.y >=size.y) { return;} let uv=vec2<f32>(global_id.xy)/vec2<f32>(size - 1u); let azimuth=(uv.x - 0.5) * 2.0 * PI; let r=params.earthRadius; let h_c=max(0.0001,params.cameraHeight); let horizon_sin=-sqrt(max(0.0,h_c * (2.0 * r + h_c)))/(r + h_c); let horizon_elevation=asin(clamp(horizon_sin,-1.0,1.0)); let v_coord=uv.y; var elevation:f32; if (v_coord <=0.5) { let coord=1.0 - v_coord * 2.0; elevation=horizon_elevation + (coord * coord) * (PI * 0.5 - horizon_elevation); } else { let coord=(v_coord - 0.5) * 2.0; elevation=horizon_elevation - (coord * coord) * (horizon_elevation + PI * 0.5); } let view_dir=vec3<f32>(cos(elevation) * cos(azimuth),sin(elevation),cos(elevation) * sin(azimuth)); let ray_origin=vec3<f32>(0.0,h_c + r,0.0); let t_max=get_ray_sphere_intersection(ray_origin,view_dir,r + params.atmosphereHeight); let t_earth=get_ray_sphere_intersection(ray_origin,view_dir,r); var dist_limit=t_max; if (t_earth > 0.0) { if (t_max < 0.0) { dist_limit=t_earth; } else { dist_limit=min(t_max,t_earth); } } var luminance=vec3<f32>(0.0); var transmittance_to_camera=vec3<f32>(1.0); if (dist_limit > 0.0) { let steps=128; let step_size=dist_limit/f32(steps); for (var i=0;i < steps;i=i + 1) { let t=(f32(i) + 0.5) * step_size; let p=ray_origin + view_dir * t; let p_len=length(p); let up=p/p_len; let cur_h=p_len - r; let cos_sun=dot(up,params.sunDirection); let current_horizon_cos=-sqrt(max(0.0,cur_h * (2.0 * r + cur_h)))/(r + cur_h); let light_fade=smoothstep(current_horizon_cos - 0.1,current_horizon_cos + 0.1,cos_sun); let sun_trans=get_transmittance(transmittanceTexture,tSampler,cur_h,cos_sun,params.atmosphereHeight) * light_fade; var shadow_mask=1.0; let t_earth_shadow=get_ray_sphere_intersection(p,params.sunDirection,r); if (t_earth_shadow > 0.0) {  shadow_mask=smoothstep(-0.05,0.02,cos_sun); } shadow_mask=min(shadow_mask,light_fade); let rho_r=exp(-max(0.0,cur_h)/params.rayleighScaleHeight); let rho_m=exp(-max(0.0,cur_h)/params.mieScaleHeight); let o_width=max(1e-3,params.ozoneLayerWidth); let rho_o=max(0.0,1.0 - abs(cur_h - params.ozoneLayerCenter)/o_width); let view_sun_cos=dot(view_dir,params.sunDirection); let step_scat=(params.rayleighScattering * rho_r * phase_rayleigh(view_sun_cos) +  params.mieScattering * rho_m * phase_mie(view_sun_cos,params.mieAnisotropy)) * sun_trans * shadow_mask; let multi_scat_uv=vec2<f32>(clamp(cos_sun * 0.5 + 0.5,0.0,1.0),sqrt(clamp(max(0.0,cur_h)/params.atmosphereHeight,0.0,1.0))); let multi_scat_energy=textureSampleLevel(multiScatTexture,tSampler,multi_scat_uv,0.0).rgb; let total_scat=params.rayleighScattering * rho_r + params.mieScattering * rho_m; let scat_ms=multi_scat_energy * total_scat; let extinction=params.rayleighScattering * rho_r + params.mieExtinction * rho_m + params.ozoneAbsorption * rho_o; luminance +=transmittance_to_camera * (step_scat + scat_ms) * step_size; transmittance_to_camera *=exp(-extinction * step_size); if (all(transmittance_to_camera < vec3<f32>(0.001))) { break;} } } let avg_transmittance=(transmittance_to_camera.r + transmittance_to_camera.g + transmittance_to_camera.b)/3.0; textureStore(skyViewTexture,global_id.xy,vec4<f32>(luminance,avg_transmittance));\n}\n"),Ba=Ra.uniforms.params;class SkyViewGenerator{#l;#xf;#Q;#jn;#ae;width=512;height=512;constructor(i){this.#l=i,this.#ae=new Sampler(this.#l,{magFilter:"linear",minFilter:"linear"}),this.#ne()}get lutTexture(){return this.#xf}#ne(){const{gpuDevice:i}=this.#l;this.#xf=new SkyViewLUTTexture(this.#l,this.width,this.height);const g=new ArrayBuffer(Ba.arrayBufferByteLength);this.#jn=new UniformBuffer(this.#l,g,"SKY_VIEW_GEN_UNIFORM_BUFFER");const x=i.createShaderModule({code:Ra.defaultSource});this.#Q=i.createComputePipeline({layout:"auto",compute:{module:x,entryPoint:"main"}})}render(i,g,x){const{gpuDevice:_}=this.#l,{members:v}=Ba;for(const[i,g]of Object.entries(v)){const _=x[i];void 0!==_&&this.#jn.writeOnlyBuffer(g,_)}const b=_.createBindGroup({layout:this.#Q.getBindGroupLayout(0),entries:[{binding:0,resource:this.#xf.gpuTextureView},{binding:1,resource:i.gpuTextureView},{binding:2,resource:g.gpuTextureView},{binding:3,resource:this.#ae.gpuSampler},{binding:4,resource:{buffer:this.#jn.gpuBuffer}}]}),y=_.createCommandEncoder(),S=y.beginComputePass();S.setPipeline(this.#Q),S.setBindGroup(0,b),S.dispatchWorkgroups(Math.ceil(this.width/16),Math.ceil(this.height/16)),S.end(),_.queue.submit([y.finish()]),this.#xf.notifyUpdate()}}class CameraVolumeLUTTexture extends ManagementResourceBase{#L;#gf;#It;#Et;#_f;constructor(i,g=32,x=32,_=16){super(i,"managedBitmapTextureState"),this.#It=g,this.#Et=x,this.#_f=_,this.#ne()}#ne(){const{gpuDevice:i}=this.redGPUContext;this.#L=i.createTexture({label:"CameraVolumeLUTTexture",size:[this.#It,this.#Et,this.#_f],dimension:"3d",format:"rgba16float",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING}),this.#gf=this.#L.createView(),this.__fireListenerList()}get gpuTexture(){return this.#L}get gpuTextureView(){return this.#gf}get videoMemorySize(){return this.#It*this.#Et*this.#_f*8}notifyUpdate(){this.__fireListenerList()}}Object.freeze(CameraVolumeLUTTexture);const Ia=parseWGSL(Sa+"\n@group(0) @binding(0) var cameraVolumeTexture:texture_storage_3d<rgba16float,write>;\n@group(0) @binding(1) var transmittanceTexture:texture_2d<f32>;\n@group(0) @binding(2) var multiScatTexture:texture_2d<f32>;\n@group(0) @binding(3) var tSampler:sampler;\n@group(0) @binding(4) var<uniform> params:AtmosphereParameters;\n@compute @workgroup_size(4,4,4)\nfn main(@builtin(global_invocation_id) global_id:vec3<u32>) { let size=textureDimensions(cameraVolumeTexture); if (global_id.x >=size.x || global_id.y >=size.y || global_id.z >=size.z) { return;} let uvw=(vec3<f32>(global_id) + 0.5)/vec3<f32>(size); let azimuth=(uvw.x - 0.5) * 2.0 * PI; let elevation=(uvw.y - 0.5) * PI; let view_dir=vec3<f32>(cos(elevation) * cos(azimuth),sin(elevation),cos(elevation) * sin(azimuth)); let max_dist=100.0; let slice_dist=uvw.z * uvw.z * max_dist; let r=params.earthRadius; let h_c=max(0.0001,params.cameraHeight); let ray_origin=vec3<f32>(0.0,h_c + r,0.0); var luminance=vec3<f32>(0.0); var transmittance=vec3<f32>(1.0); let steps=32; let step_size=slice_dist/f32(steps); if (slice_dist > 0.0) { for (var i=0;i < steps;i=i + 1) { let t=(f32(i) + 0.5) * step_size; let p=ray_origin + view_dir * t; let p_len=length(p); let cur_h=p_len - r; if (cur_h < 0.0) { break;} let up=p/p_len; let cos_sun=dot(up,params.sunDirection); let sun_trans=get_transmittance(transmittanceTexture,tSampler,cur_h,cos_sun,params.atmosphereHeight); let rho_r=exp(-max(0.0,cur_h)/params.rayleighScaleHeight); let rho_m=exp(-max(0.0,cur_h)/params.mieScaleHeight); let o_width=max(1e-3,params.ozoneLayerWidth); let rho_o=max(0.0,1.0 - abs(cur_h - params.ozoneLayerCenter)/o_width); let view_sun_cos=dot(view_dir,params.sunDirection); let step_scat=(params.rayleighScattering * rho_r * phase_rayleigh(view_sun_cos) +  params.mieScattering * rho_m * phase_mie(view_sun_cos,params.mieAnisotropy)) * sun_trans; let multi_scat_uv=vec2<f32>(clamp(cos_sun * 0.5 + 0.5,0.0,1.0),sqrt(clamp(max(0.0,cur_h)/params.atmosphereHeight,0.0,1.0))); let multi_scat_energy=textureSampleLevel(multiScatTexture,tSampler,multi_scat_uv,0.0).rgb; let total_scat=params.rayleighScattering * rho_r + params.mieScattering * rho_m; let scat_ms=multi_scat_energy * total_scat; let extinction=params.rayleighScattering * rho_r + params.mieExtinction * rho_m + params.ozoneAbsorption * rho_o; luminance +=transmittance * (step_scat + scat_ms) * step_size; transmittance *=exp(-extinction * step_size); } } let avg_trans=(transmittance.r + transmittance.g + transmittance.b)/3.0; textureStore(cameraVolumeTexture,global_id,vec4<f32>(luminance,avg_trans));\n}\n"),Ea=Ia.uniforms.params;class CameraVolumeGenerator{#l;#xf;#Q;#jn;#ae;width=32;height=32;depth=16;constructor(i){this.#l=i,this.#ae=new Sampler(this.#l,{magFilter:"linear",minFilter:"linear"}),this.#ne()}get lutTexture(){return this.#xf}#ne(){const{gpuDevice:i}=this.#l;this.#xf=new CameraVolumeLUTTexture(this.#l,this.width,this.height,this.depth);const g=new ArrayBuffer(Ea.arrayBufferByteLength);this.#jn=new UniformBuffer(this.#l,g,"CAMERA_VOLUME_GEN_UNIFORM_BUFFER");const x=i.createShaderModule({code:Ia.defaultSource});this.#Q=i.createComputePipeline({layout:"auto",compute:{module:x,entryPoint:"main"}})}render(i,g,x){const{gpuDevice:_}=this.#l,{members:v}=Ea;for(const[i,g]of Object.entries(v)){const _=x[i];void 0!==_&&this.#jn.writeOnlyBuffer(g,_)}const b=_.createBindGroup({layout:this.#Q.getBindGroupLayout(0),entries:[{binding:0,resource:this.#xf.gpuTextureView},{binding:1,resource:i.gpuTextureView},{binding:2,resource:g.gpuTextureView},{binding:3,resource:this.#ae.gpuSampler},{binding:4,resource:{buffer:this.#jn.gpuBuffer}}]}),y=_.createCommandEncoder(),S=y.beginComputePass();S.setPipeline(this.#Q),S.setBindGroup(0,b),S.dispatchWorkgroups(Math.ceil(this.width/4),Math.ceil(this.height/4),Math.ceil(this.depth/4)),S.end(),_.queue.submit([y.finish()]),this.#xf.notifyUpdate()}}var Da="#redgpu_include SYSTEM_UNIFORM;\nstruct InputData { @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>,\n};\nstruct OutData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec4<f32>,\n};\nstruct VertexUniforms { modelMatrix:mat4x4<f32>,\n};\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\n@vertex\nfn main(inputData:InputData) -> OutData { var outData:OutData; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; outData.position=u_projectionCameraMatrix * vertexUniforms.modelMatrix * vec4<f32>(inputData.position,1.0); outData.position.z=outData.position.w; outData.vertexPosition=vec4<f32>(inputData.position,1.0); return outData;\n}\n";const Ua=parseWGSL(Da),La=Ua.uniforms.vertexUniforms;class SkyAtmosphere{modelMatrix=create$4();gpuRenderInfo;#vf=!0;#uo;#bf;#qa;#l;#Os;#Ns;#yf;#Sf;#Tf;#Mf;#wf={earthRadius:6360,atmosphereHeight:60,mieScattering:.021,mieExtinction:.021,rayleighScattering:[.0058,.0135,.0331],rayleighScaleHeight:8,mieScaleHeight:1.2,mieAnisotropy:.9,ozoneAbsorption:[65e-5,.00188,8e-5],ozoneLayerCenter:25,ozoneLayerWidth:15,multiScatteringAmbient:.05,sunSize:.5,sunIntensity:22,exposure:1,heightFogDensity:0,heightFogFalloff:.1,horizonHaze:.3,groundAmbient:.4,groundAlbedo:[.15,.15,.15],mieGlow:.75,mieHalo:.99,groundShininess:512,groundSpecular:4,sunDirection:new Float32Array([0,1,0]),cameraHeight:.2,padding:0};#Cf=45;#Pf=0;#Rf=!0;#Bf=!0;#ml;constructor(i){validateRedGPUContext(i),this.#l=i,this.#bf=new Sphere(i,1,32,32),this.#qa=new SkyAtmosphereMaterial(i),this.#Os=new PrimitiveState(this),this.#Os.cullMode=ei.NONE,this.#Ns=new DepthStencilState(this),this.#Ns.depthCompare="less-equal",this.#Ns.depthWriteEnabled=!1,this.#yf=new TransmittanceGenerator(i),this.#Sf=new MultiScatteringGenerator(i),this.#Tf=new SkyViewGenerator(i),this.#Mf=new CameraVolumeGenerator(i),this.#qa.transmittanceTexture=this.#yf.lutTexture,this.#qa.multiScatteringTexture=this.#Sf.lutTexture,this.#qa.skyViewTexture=this.#Tf.lutTexture,this.#qa.cameraVolumeTexture=this.#Mf.lutTexture,this.#If(),this.#Ef()}#If(){Object.keys(this.#wf).forEach(i=>{"sunDirection"!==i&&"cameraHeight"!==i&&"padding"!==i&&(this[i]=this.#wf[i])})}#Ef(){const i=(90-this.#Cf)*(Math.PI/180),g=this.#Pf*(Math.PI/180),x=Math.sin(i)*Math.cos(g),_=Math.cos(i),v=Math.sin(i)*Math.sin(g);this.#wf.sunDirection[0]=x,this.#wf.sunDirection[1]=_,this.#wf.sunDirection[2]=v,this.#qa.sunDirection=this.#wf.sunDirection,this.#Bf=!0}get sunElevation(){return this.#Cf}set sunElevation(i){validateNumberRange(i,-90,90),this.#Cf=i,this.#Ef()}get sunAzimuth(){return this.#Pf}set sunAzimuth(i){validateNumberRange(i,-360,360),this.#Pf=i,this.#Ef()}get earthRadius(){return this.#wf.earthRadius}set earthRadius(i){validatePositiveNumberRange(i,1),this.#wf.earthRadius=i,this.#qa.earthRadius=i,this.#Rf=!0}get atmosphereHeight(){return this.#wf.atmosphereHeight}set atmosphereHeight(i){validatePositiveNumberRange(i,1),this.#wf.atmosphereHeight=i,this.#qa.atmosphereHeight=i,this.#Rf=!0}get mieScattering(){return this.#wf.mieScattering}set mieScattering(i){validatePositiveNumberRange(i,0,1),this.#wf.mieScattering=i,this.#qa.mieScattering=i,this.#Rf=!0}get mieExtinction(){return this.#wf.mieExtinction}set mieExtinction(i){validatePositiveNumberRange(i,0,1),this.#wf.mieExtinction=i,this.#qa.mieExtinction=i,this.#Rf=!0}get rayleighScattering(){return this.#wf.rayleighScattering}set rayleighScattering(i){this.#wf.rayleighScattering=[...i],this.#qa.rayleighScattering=new Float32Array(i),this.#Rf=!0}get rayleighScaleHeight(){return this.#wf.rayleighScaleHeight}set rayleighScaleHeight(i){validatePositiveNumberRange(i,.1,100),this.#wf.rayleighScaleHeight=i,this.#qa.rayleighScaleHeight=i,this.#Rf=!0}get mieScaleHeight(){return this.#wf.mieScaleHeight}set mieScaleHeight(i){validatePositiveNumberRange(i,.1,100),this.#wf.mieScaleHeight=i,this.#qa.mieScaleHeight=i,this.#Rf=!0}get mieAnisotropy(){return this.#wf.mieAnisotropy}set mieAnisotropy(i){validateNumberRange(i,0,.999),this.#wf.mieAnisotropy=i,this.#qa.mieAnisotropy=i,this.#Rf=!0}get ozoneAbsorption(){return this.#wf.ozoneAbsorption}set ozoneAbsorption(i){this.#wf.ozoneAbsorption=[...i],this.#qa.ozoneAbsorption=new Float32Array(i),this.#Rf=!0}get ozoneLayerCenter(){return this.#wf.ozoneLayerCenter}set ozoneLayerCenter(i){validatePositiveNumberRange(i,0,100),this.#wf.ozoneLayerCenter=i,this.#qa.ozoneLayerCenter=i,this.#Rf=!0}get ozoneLayerWidth(){return this.#wf.ozoneLayerWidth}set ozoneLayerWidth(i){validatePositiveNumberRange(i,1,50),this.#wf.ozoneLayerWidth=i,this.#qa.ozoneLayerWidth=i,this.#Rf=!0}get multiScatteringAmbient(){return this.#wf.multiScatteringAmbient}set multiScatteringAmbient(i){validatePositiveNumberRange(i,0,1),this.#wf.multiScatteringAmbient=i,this.#qa.multiScatteringAmbient=i,this.#Bf=!0}get sunSize(){return this.#wf.sunSize}set sunSize(i){validatePositiveNumberRange(i,.01,10),this.#wf.sunSize=i,this.#qa.sunSize=i}get sunIntensity(){return this.#wf.sunIntensity}set sunIntensity(i){validatePositiveNumberRange(i,0,1e4),this.#wf.sunIntensity=i,this.#qa.sunIntensity=i}get exposure(){return this.#wf.exposure}set exposure(i){validatePositiveNumberRange(i,0,100),this.#wf.exposure=i,this.#qa.exposure=i}get heightFogDensity(){return this.#wf.heightFogDensity}set heightFogDensity(i){validatePositiveNumberRange(i,0,10),this.#wf.heightFogDensity=i,this.#qa.heightFogDensity=i}get heightFogFalloff(){return this.#wf.heightFogFalloff}set heightFogFalloff(i){validatePositiveNumberRange(i,.001,10),this.#wf.heightFogFalloff=i,this.#qa.heightFogFalloff=i}get horizonHaze(){return this.#wf.horizonHaze}set horizonHaze(i){validatePositiveNumberRange(i,0,10),this.#wf.horizonHaze=i,this.#qa.horizonHaze=i}get groundAmbient(){return this.#wf.groundAmbient}set groundAmbient(i){validatePositiveNumberRange(i,0,10),this.#wf.groundAmbient=i,this.#qa.groundAmbient=i}get groundAlbedo(){return this.#wf.groundAlbedo}set groundAlbedo(i){this.#wf.groundAlbedo=[...i],this.#qa.groundAlbedo=new Float32Array(i),this.#Bf=!0}get mieGlow(){return this.#wf.mieGlow}set mieGlow(i){validateNumberRange(i,0,.999),this.#wf.mieGlow=i,this.#qa.mieGlow=i}get mieHalo(){return this.#wf.mieHalo}set mieHalo(i){validateNumberRange(i,0,.999),this.#wf.mieHalo=i,this.#qa.mieHalo=i}get groundShininess(){return this.#wf.groundShininess}set groundShininess(i){validatePositiveNumberRange(i,1,2048),this.#wf.groundShininess=i,this.#qa.groundShininess=i}get groundSpecular(){return this.#wf.groundSpecular}set groundSpecular(i){validatePositiveNumberRange(i,0,100),this.#wf.groundSpecular=i,this.#qa.groundSpecular=i}render(i){const{currentRenderPassEncoder:g,view:x}=i,{indexBuffer:_}=this.#bf,{triangleCount:v,indexCount:b,format:y}=_,{gpuDevice:S}=this.#l,w=x.rawCamera,L=[w.x,w.y,w.z],k=Math.max(.001,L[1]/1e3);if(Math.abs(this.#wf.cameraHeight-k)>.001&&(this.#wf.cameraHeight=k,this.#qa.cameraHeight=k,this.#Bf=!0),this.#Rf&&(this.#yf.render(this.#wf),this.#Sf.render(this.#yf.lutTexture,this.#wf),this.#Rf=!1,this.#Bf=!0),this.#Bf&&(this.#Tf.render(this.#yf.lutTexture,this.#Sf.lutTexture,this.#wf),this.#Bf=!1),this.#Mf.render(this.#yf.lutTexture,this.#Sf.lutTexture,this.#wf),this.#Df(),this.gpuRenderInfo||this.#Uf(this.#l),identity$1(this.modelMatrix),translate(this.modelMatrix,this.modelMatrix,L),scale$4(this.modelMatrix,this.modelMatrix,[1e6,1e6,1e6]),this.gpuRenderInfo.vertexUniformBuffer.writeOnlyBuffer(La.members.modelMatrix,this.modelMatrix),this.#vf||this.#qa.dirtyPipeline||this.#ml!==x.systemUniform_Vertex_UniformBindGroup){this.gpuRenderInfo.pipeline=this.#Lf(),this.#vf=!1,i.numDirtyPipelines++,this.#ml=x.systemUniform_Vertex_UniformBindGroup,this.#qa.dirtyPipeline=!1;const g=S.createRenderBundleEncoder({...x.basicRenderBundleEncoderDescriptor,label:"skyAtmosphere"});g.setPipeline(this.gpuRenderInfo.pipeline),g.setBindGroup(0,x.systemUniform_Vertex_UniformBindGroup),g.setVertexBuffer(0,this.#bf.vertexBuffer.gpuBuffer),g.setBindGroup(1,this.gpuRenderInfo.vertexUniformBindGroup),g.setBindGroup(2,this.#qa.gpuRenderInfo.fragmentUniformBindGroup),g.setIndexBuffer(_.gpuBuffer,y),g.drawIndexed(_.indexCount,1,0,0,0),this.#uo=g.finish({label:"renderBundle skyAtmosphere"})}g.executeBundles([this.#uo]),i.num3DObjects++,i.numDrawCalls++,i.numTriangles+=v,i.numPoints+=b}#Df(){const{changedMSAA:i}=this.#l.antialiasingManager;i&&(this.#vf=!0)}#Uf(i){const{resourceManager:g}=this.#l,x=g.getGPUBindGroupLayout("SKY_ATMOSPHERE_VERTEX_BIND_GROUP_LAYOUT")||g.createBindGroupLayout("SKY_ATMOSPHERE_VERTEX_BIND_GROUP_LAYOUT",getVertexBindGroupLayoutDescriptorFromShaderInfo(Ua,1)),_=new ArrayBuffer(La.arrayBufferByteLength),v=new UniformBuffer(i,_,"SKY_ATMOSPHERE_VERTEX_UNIFORM_BUFFER","SKY_ATMOSPHERE_VERTEX_UNIFORM_BUFFER"),b={layout:x,label:"VERTEX_BIND_GROUP_DESCRIPTOR_SKY_ATMOSPHERE",entries:[{binding:0,resource:{buffer:v.gpuBuffer,offset:0,size:v.size}}]},y=i.gpuDevice.createBindGroup(b);this.gpuRenderInfo=new VertexGPURenderInfo(null,Ua.shaderSourceVariant,Ua.conditionalBlocks,La,x,v,y,this.#Lf())}#Lf(){const{resourceManager:i,gpuDevice:g,antialiasingManager:x}=this.#l,_={module:i.createGPUShaderModule("VERTEX_MODULE_SKY_ATMOSPHERE",{code:Da}),entryPoint:"main",buffers:this.#bf.gpuRenderInfo.buffers},v=i.getGPUBindGroupLayout("SKY_ATMOSPHERE_VERTEX_BIND_GROUP_LAYOUT")||i.createBindGroupLayout("SKY_ATMOSPHERE_VERTEX_BIND_GROUP_LAYOUT",getVertexBindGroupLayoutDescriptorFromShaderInfo(Ua,1)),b=[i.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),v,this.#qa.gpuRenderInfo.fragmentBindGroupLayout],y={label:"PIPELINE_DESCRIPTOR_SKY_ATMOSPHERE",layout:i.createGPUPipelineLayout("SKY_ATMOSPHERE_PIPELINE_LAYOUT",{bindGroupLayouts:b}),vertex:_,fragment:this.#qa.gpuRenderInfo.fragmentState,primitive:this.#Os.state,depthStencil:this.#Ns.state,multisample:{count:x.useMSAA?4:1}};return g.createRenderPipeline(y)}get transmittanceTexture(){return this.#yf.lutTexture}get multiScatteringTexture(){return this.#Sf.lutTexture}get skyViewTexture(){return this.#Tf.lutTexture}}Object.freeze(SkyAtmosphere);const Aa=parseWGSL("#redgpu_include FragmentOutput\nstruct Uniforms { opacity:f32, blur:f32, transitionProgress:f32,\n};\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\n@group(2) @binding(1) var skyboxTextureSampler:sampler;\n@group(2) @binding(2) var skyboxTexture:texture_cube<f32>;\n@group(2) @binding(3) var transitionTexture:texture_cube<f32>;\n@group(2) @binding(4) var transitionAlphaTexture:texture_2d<f32>;\nstruct InputData { @location(0) vertexPosition:vec4<f32>,\n};\nfn sphericalToUV(dir:vec3<f32>) -> vec2<f32> { let normalizedDir=normalize(dir); let phi=atan2(normalizedDir.z,normalizedDir.x); let theta=acos(clamp(normalizedDir.y,-1.0,1.0)); let u=(phi + 3.14159265359)/(2.0 * 3.14159265359); let v=theta/3.14159265359; return vec2<f32>(u,v);\n}\n@fragment\nfn main(inputData:InputData) -> FragmentOutput { var cubemapVec=(inputData.vertexPosition.xyz); let mipmapCount:f32=f32(textureNumLevels(skyboxTexture) - 1); let blurCurve=uniforms.blur * uniforms.blur; let skyboxColor=textureSampleLevel(skyboxTexture,skyboxTextureSampler,cubemapVec,mipmapCount * blurCurve); var sampleColor=skyboxColor; let u_transitionProgress=uniforms.transitionProgress; if (u_transitionProgress > 0.0) { let transitionSample=textureSampleLevel(transitionTexture,skyboxTextureSampler,cubemapVec,mipmapCount * blurCurve); #redgpu_if transitionAlphaTexture let uv=sphericalToUV(normalize(cubemapVec)); let transitionAlphaSample=textureSampleLevel(transitionAlphaTexture,skyboxTextureSampler,uv,0.0); let transitionAlphaValue=dot(transitionAlphaSample.rgb,vec3<f32>(0.299,0.587,0.114)); let threshold=u_transitionProgress; let noiseInfluence=0.3; let edgeSoftness=0.1; let maskValue=smoothstep( threshold - edgeSoftness, threshold + edgeSoftness, transitionAlphaValue + (u_transitionProgress - 0.5) * noiseInfluence ); sampleColor=mix(transitionSample,skyboxColor,maskValue * (1.0 - u_transitionProgress)); #redgpu_else sampleColor=mix(skyboxColor,transitionSample,u_transitionProgress); #redgpu_endIf } var outColor=vec4<f32>(sampleColor.rgb,sampleColor.a * uniforms.opacity); if (outColor.a==0.0) { discard; } var output:FragmentOutput; output.color=outColor; return output;\n}\n");class SkyBoxMaterial extends ABitmapBaseMaterial{dirtyPipeline=!1;constructor(i,g){super(i,"SKYBOX_MATERIAL",Aa,2),this.skyboxTexture=g,this.skyboxTextureSampler=new Sampler(this.redGPUContext,{addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge"}),this.initGPURenderInfos()}}dr.definePositiveNumber(SkyBoxMaterial,[["blur",0],["opacity",1,0,1]]),dr.definePositiveNumber(SkyBoxMaterial,[["transitionProgress",0]]),dr.defineCubeTexture(SkyBoxMaterial,["transitionTexture"]),dr.defineTexture(SkyBoxMaterial,["transitionAlphaTexture"]),dr.defineCubeTexture(SkyBoxMaterial,["skyboxTexture"]),dr.defineSampler(SkyBoxMaterial,["skyboxTextureSampler"]),Object.freeze(SkyBoxMaterial);var Ga="#redgpu_include SYSTEM_UNIFORM;\nstruct InputData { @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>,\n};\nstruct OutData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec4<f32>,\n};\nstruct VertexUniforms { modelMatrix:mat4x4<f32>,\n};\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\n@vertex\nfn main(inputData:InputData) -> OutData { var outData:OutData; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; outData.position=u_projectionCameraMatrix * vertexUniforms.modelMatrix * vec4<f32>(inputData.position,1.0); outData.vertexPosition=vec4<f32>(inputData.position,1.0); return outData;\n}\n";const ka=parseWGSL(Ga),Oa=ka.uniforms.vertexUniforms;class SkyBox{modelMatrix=create$4();gpuRenderInfo;#vf=!0;#uo;#bf;#qa;#l;#Os;#Ns;#Af;#Gf;#kf=0;#Of=0;#Nf=0;#ml;constructor(i,g){validateRedGPUContext(i),this.#l=i,this.#bf=new Box(i),this.#Af=g,this.#qa=new SkyBoxMaterial(i,this.#Af),this.#Os=new PrimitiveState(this),this.#Os.cullMode=ei.NONE,this.#Ns=new DepthStencilState(this)}get transitionDuration(){return this.#Of}get transitionElapsed(){return this.#Nf}get transitionProgress(){return this.#qa.transitionProgress}get blur(){return this.#qa.blur}set blur(i){validatePositiveNumberRange(1,0,1),this.#qa.blur=i}get opacity(){return this.#qa.opacity}set opacity(i){validatePositiveNumberRange(1,0,1),this.#qa.opacity=i}get skyboxTexture(){return this.#Af}set skyboxTexture(i){i?(this.#Af=i,this.#qa.skyboxTexture=i):consoleAndThrowError("SkyBox requires a valid CubeTexture | IBLCubeTexture")}get transitionTexture(){return this.#Gf}transition(i,g=300,x){this.#Gf=i,this.#qa.transitionTexture=i,this.#Of=g,this.#kf=performance.now(),this.#qa.transitionAlphaTexture=x}render(i){const{currentRenderPassEncoder:g,startTime:x,view:_}=i,{indexBuffer:v}=this.#bf,{triangleCount:b,indexCount:y,format:S}=v,{gpuDevice:w,antialiasingManager:L}=this.#l,{useMSAA:k,changedMSAA:z}=L;if(this.#Df(),this.gpuRenderInfo||this.#Uf(this.#l),this.#kf)if(this.#Nf=Math.max(x-this.#kf,0),this.#Nf>this.#Of)this.#kf=0,this.#qa.transitionProgress=0,this.skyboxTexture=this.#Gf,this.#qa.transitionTexture=null,this.#vf=!0;else{const i=this.#Nf/this.#Of;this.#qa.transitionProgress=i<0?0:i>1?1:i}if(this.#vf||this.#qa.dirtyPipeline||this.#ml!==_.systemUniform_Vertex_UniformBindGroup){this.gpuRenderInfo.pipeline=this.#Lf(),this.#vf=!1,i.numDirtyPipelines++,this.#ml=_.systemUniform_Vertex_UniformBindGroup;{this.#qa.dirtyPipeline=!1;const i=w.createRenderBundleEncoder({..._.basicRenderBundleEncoderDescriptor,label:"skybox"}),{gpuRenderInfo:g}=this,{vertexUniformBindGroup:x,pipeline:b}=g;i.setPipeline(b),i.setBindGroup(0,_.systemUniform_Vertex_UniformBindGroup),i.setVertexBuffer(0,this.#bf.vertexBuffer.gpuBuffer),i.setBindGroup(1,x),i.setBindGroup(2,this.#qa.gpuRenderInfo.fragmentUniformBindGroup),i.setIndexBuffer(v.gpuBuffer,S),i.drawIndexed(v.indexCount,1,0,0,0),this.#uo=i.finish({label:"renderBundle skybox"})}}g.executeBundles([this.#uo]),i.num3DObjects++,i.numDrawCalls++,i.numTriangles+=b,i.numPoints+=y}#Df(){const{changedMSAA:i}=this.#l.antialiasingManager;i&&(this.#vf=!0)}#Uf(i){const{resourceManager:g}=this.#l,x=g.getGPUBindGroupLayout("SKYBOX_VERTEX_BIND_GROUP_LAYOUT")||g.createBindGroupLayout("SKYBOX_VERTEX_BIND_GROUP_LAYOUT",getVertexBindGroupLayoutDescriptorFromShaderInfo(ka,1)),_=new ArrayBuffer(Oa.arrayBufferByteLength),v=new UniformBuffer(i,_,"SKYBOX_VERTEX_UNIFORM_BUFFER","SKYBOX_VERTEX_UNIFORM_BUFFER");identity$1(this.modelMatrix),scale$4(this.modelMatrix,this.modelMatrix,[1e4,1e4,1e4]),v.writeOnlyBuffer(Oa.members.modelMatrix,this.modelMatrix);const b={layout:x,label:"VERTEX_BIND_GROUP_DESCRIPTOR_SKYBOX",entries:[{binding:0,resource:{buffer:v.gpuBuffer,offset:0,size:v.size}}]},y=i.gpuDevice.createBindGroup(b);this.gpuRenderInfo=new VertexGPURenderInfo(null,ka.shaderSourceVariant,ka.conditionalBlocks,Oa,x,v,y,this.#Lf())}#Lf(){const{resourceManager:i,gpuDevice:g,antialiasingManager:x}=this.#l,_={code:Ga},v={module:i.createGPUShaderModule("VERTEX_MODULE_SKYBOX",_),entryPoint:"main",buffers:this.#bf.gpuRenderInfo.buffers},b=i.getGPUBindGroupLayout("SKYBOX_VERTEX_BIND_GROUP_LAYOUT")||i.createBindGroupLayout("SKYBOX_VERTEX_BIND_GROUP_LAYOUT",getVertexBindGroupLayoutDescriptorFromShaderInfo(ka,1)),y={bindGroupLayouts:[i.getGPUBindGroupLayout(ResourceManager.PRESET_GPUBindGroupLayout_System),b,this.#qa.gpuRenderInfo.fragmentBindGroupLayout]},S={label:"PIPELINE_DESCRIPTOR_SKYBOX",layout:i.createGPUPipelineLayout("SKYBOX_PIPELINE_LAYOUT",y),vertex:v,fragment:this.#qa.gpuRenderInfo.fragmentState,primitive:this.#Os.state,depthStencil:this.#Ns.state,multisample:{count:x.useMSAA?4:1}};return g.createRenderPipeline(S)}}Object.freeze(SkyBox);var Na=Object.freeze({__proto__:null,SkyBoxMaterial:SkyBoxMaterial});const Va={NORMAL:0,MULTIPLY:1,LIGHTEN:2,SCREEN:3,LINEAR_DODGE:4,SUBTRACT:5,DIFFERENCE:6,EXCLUSION:7};function mixInMesh2D(i){const g=class extends i{#Vf=0;#Ff=Va.NORMAL;get blendMode(){const i=Object.entries(Va).find(([,i])=>i===this.#Ff);if(!i)throw new Error(`Invalid blendMode value:${this.#Ff}`);return i[0]}set blendMode(i){let g;if("string"==typeof i){if(!(i in Va))throw new Error(`Invalid blendMode key:${i}`);g=Va[i]}else{if("number"!=typeof i||!Object.values(Va).includes(i))throw new Error(`Invalid blendMode:${i}`);g=i}this.#Ff=g,this.#zf(g)}get rotation(){return this.#Vf}set rotation(i){this.#Vf=i,super.rotationZ=i}setScale(i,g){g=g??i,super.setScale(i,g,1)}setPosition(i,g){g=g??i,super.setPosition(i,g,0)}setRotation(i){this.rotation=i}#zf(i){const{blendColorState:g,blendAlphaState:x}=this._material;switch(i){case Va.NORMAL:g.operation=pr.ADD,g.srcFactor=mr.SRC_ALPHA,g.dstFactor=mr.ONE_MINUS_SRC_ALPHA,x.operation=pr.ADD,x.srcFactor=mr.SRC_ALPHA,x.dstFactor=mr.ONE_MINUS_SRC_ALPHA;break;case Va.MULTIPLY:g.operation=pr.ADD,g.srcFactor=mr.ONE_MINUS_DST_ALPHA,g.dstFactor=mr.ONE_MINUS_SRC_ALPHA,x.operation=pr.ADD,x.srcFactor=mr.SRC_ALPHA,x.dstFactor=mr.ONE_MINUS_SRC_ALPHA;break;case Va.LIGHTEN:g.operation=pr.MAX,g.srcFactor=mr.ONE,g.dstFactor=mr.ONE,x.operation=pr.ADD,x.srcFactor=mr.SRC_ALPHA,x.dstFactor=mr.ONE_MINUS_SRC_ALPHA;break;case Va.SCREEN:g.operation=pr.ADD,g.srcFactor=mr.ONE,g.dstFactor=mr.ONE_MINUS_SRC,x.operation=pr.ADD,x.srcFactor=mr.SRC_ALPHA,x.dstFactor=mr.ONE_MINUS_SRC_ALPHA;break;case Va.LINEAR_DODGE:g.operation=pr.ADD,g.srcFactor=mr.ONE,g.dstFactor=mr.ONE,x.operation=pr.ADD,x.srcFactor=mr.SRC_ALPHA,x.dstFactor=mr.ONE;break;case Va.SUBTRACT:g.operation=pr.REVERSE_SUBTRACT,g.srcFactor=mr.SRC_ALPHA,g.dstFactor=mr.ONE_MINUS_SRC_ALPHA,x.operation=pr.REVERSE_SUBTRACT,x.srcFactor=mr.ONE,x.dstFactor=mr.ONE;break;case Va.DIFFERENCE:g.operation=pr.SUBTRACT,g.srcFactor=mr.ONE,g.dstFactor=mr.ONE,x.operation=pr.SUBTRACT,x.srcFactor=mr.ONE,x.dstFactor=mr.ONE;break;case Va.EXCLUSION:g.operation=pr.ADD,g.srcFactor=mr.ONE_MINUS_DST_ALPHA,g.dstFactor=mr.ONE_MINUS_SRC_ALPHA,x.operation=pr.ADD,x.srcFactor=mr.ONE,x.dstFactor=mr.ONE;break;default:console.warn(`Unsupported blend mode:${i}`)}}};return Object.defineProperty(g.prototype,"is2DMeshType",{value:!0,writable:!1}),g}var Fa=Object.freeze({__proto__:null,LODManager:LODManager,MeshBase:MeshBase,Object3DContainer:Object3DContainer,VertexGPURenderInfo:VertexGPURenderInfo,createMeshVertexUniformBuffers:createMeshVertexUniformBuffers,mixInMesh2D:mixInMesh2D}),za=Object.freeze({__proto__:null,AView:AView,RenderViewStateData:RenderViewStateData,ViewRenderTextureManager:ViewRenderTextureManager,ViewTransform:ViewTransform});class View2D extends View3D{constructor(i,g,x){super(i,g,new Camera2D,x)}}Object.freeze(View2D);class GroupBase extends Object3DContainer{modelMatrix=create$4();localMatrix=create$4();#f;#h;#Fs;#Nt=0;#Ft=0;#Vt=0;#zs=[0,0,0];#Hs=0;#$s=0;#Ks=0;#js=1;#Ys=1;#qs=1;#Ws=[1,1,1];#Ui=0;#Li=0;#Ai=0;#Zs=[0,0,0];#Hf=!0;constructor(i){super(),i&&(this.name=i)}get dirtyTransform(){return this.#Hf}set dirtyTransform(i){this.#Hf=i}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get parent(){return this.#Fs}set parent(i){this.#Fs=i}get pivotX(){return this.#Hs}set pivotX(i){this.#Hs=i,this.dirtyTransform=!0}get pivotY(){return this.#$s}set pivotY(i){this.#$s=i,this.dirtyTransform=!0}get pivotZ(){return this.#Ks}set pivotZ(i){this.#Ks=i,this.dirtyTransform=!0}get x(){return this.#Nt}set x(i){this.#Nt=this.#zs[0]=i,this.dirtyTransform=!0}get y(){return this.#Vt}set y(i){this.#Vt=this.#zs[1]=i,this.dirtyTransform=!0}get z(){return this.#Ft}set z(i){this.#Ft=this.#zs[2]=i,this.dirtyTransform=!0}get position(){return this.#zs}get scaleX(){return this.#js}set scaleX(i){this.#js=this.#Ws[0]=i,this.dirtyTransform=!0}get scaleY(){return this.#Ys}set scaleY(i){this.#Ys=this.#Ws[1]=i,this.dirtyTransform=!0}get scaleZ(){return this.#qs}set scaleZ(i){this.#qs=this.#Ws[2]=i,this.dirtyTransform=!0}get scale(){return this.#zs}get rotationX(){return this.#Ui}set rotationX(i){this.#Ui=this.#Zs[0]=i,this.dirtyTransform=!0}get rotationY(){return this.#Li}set rotationY(i){this.#Li=this.#Zs[1]=i,this.dirtyTransform=!0}get rotationZ(){return this.#Ai}set rotationZ(i){this.#Ai=this.#Zs[2]=i,this.dirtyTransform=!0}get rotation(){return this.#Zs}setScale(i,g,x){g=g??i,x=x??i;const _=this.#Ws;this.#js=_[0]=i,this.#Ys=_[1]=g,this.#qs=_[2]=x,this.dirtyTransform=!0}setPosition(i,g,x){g=g??i,x=x??i;const _=this.#zs;this.#Nt=_[0]=i,this.#Vt=_[1]=g,this.#Ft=_[2]=x,this.dirtyTransform=!0}setRotation(i,g,x){g=g??i,x=x??i;const _=this.#Zs;this.#Ui=_[0]=i,this.#Li=_[1]=g,this.#Ai=_[2]=x,this.dirtyTransform=!0}render(i){const{view:g,isScene2DMode:x}=i;let _;x&&(this.#Ft=0,this.#Ks=0),this.dirtyTransform&&(_=!0,updateObject3DMatrix(this,g)),this.dirtyTransform&&(_=!0,this.dirtyTransform=!1),i.num3DGroups++;const{children:v}=this;let b=0;const y=v.length;for(;b<y;b++)_&&(v[b].dirtyTransform=_),v[b].render(i)}}Object.defineProperty(GroupBase.prototype,"meshType",{value:Gr.MESH,writable:!1}),Object.freeze(GroupBase);class Group2D extends GroupBase{#f;#h;#Vf=0;constructor(i){super(),i&&(this.name=i)}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}get rotation(){return this.#Vf}set rotation(i){this.#Vf=i,super.rotationZ=i}setScale(i,g){g=g??i,super.setScale(i,g,1)}setPosition(i,g){g=g??i,super.setPosition(i,g,0)}setRotation(i){this.rotation=i}}Object.defineProperty(Group2D.prototype,"is2DMeshType",{value:!0,writable:!1}),Object.freeze(Group2D);class Group3D extends GroupBase{#f;#h;constructor(i){super(),i&&(this.name=i)}get name(){return this.#f||(this.#f=InstanceIdGenerator.getNextId(this.constructor)),this.#h||`${this.constructor.name} Instance ${this.#f}`}set name(i){this.#h=i}}Object.defineProperty(Group3D.prototype,"meshType",{value:Gr.MESH,writable:!1}),Object.freeze(Group3D);var Ha=Object.freeze({__proto__:null,AGroupBase:GroupBase});const $a={Linear:0,QuintIn:1,QuintOut:2,QuintInOut:3,BackIn:4,BackOut:5,BackInOut:6,CircIn:7,CircOut:8,CircInOut:9,CubicIn:10,CubicOut:11,CubicInOut:12,ExpoIn:13,ExpoOut:14,ExpoInOut:15,QuadIn:16,QuadOut:17,QuadInOut:18,QuartIn:19,QuartOut:20,QuartInOut:21,SineIn:22,SineOut:23,SineInOut:24,ElasticIn:25,ElasticOut:26,ElasticInOut:27};const Ka=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include calcTintBlendMode;\n#redgpu_include drawPicking;\n#redgpu_include FragmentOutput;\n#redgpu_include calculateMotionVector;\nstruct Uniforms { opacity:f32, useTint:u32, tint:vec4<f32>, tintBlendMode:u32,\n};\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\n@group(2) @binding(1) var diffuseTextureSampler:sampler;\n@group(2) @binding(2) var diffuseTexture:texture_2d<f32>;\nstruct InputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\n@fragment\nfn main(inputData:InputData) -> FragmentOutput { var output:FragmentOutput; var finalColor:vec4<f32>=vec4<f32>(0.0); #redgpu_if diffuseTexture finalColor=textureSample(diffuseTexture,diffuseTextureSampler,inputData.uv); #redgpu_endIf let alpha2D=select(finalColor.a,1.0,systemUniforms.isView3D==1u); finalColor=vec4<f32>(finalColor.rgb * alpha2D,finalColor.a * uniforms.opacity * inputData.combinedOpacity); #redgpu_if useTint finalColor=calcTintBlendMode(finalColor,uniforms.tintBlendMode,uniforms.tint); #redgpu_endIf if (systemUniforms.isView3D==1 && finalColor.a==0.0) { discard; } output.color=finalColor; output.gBufferMotionVector=vec4<f32>(calculateMotionVector(inputData.currentClipPos,inputData.prevClipPos),0.0,1.0 ); return output;\n};\n");class BitmapMaterial extends AUVTransformBaseMaterial{dirtyPipeline=!1;constructor(i,g,x){super(i,"BITMAP_MATERIAL",Ka,2),x&&(this.name=x),this.diffuseTexture=g,this.diffuseTextureSampler=new Sampler(this.redGPUContext),this.initGPURenderInfos()}}dr.defineByPreset(BitmapMaterial,[dr.PRESET_TEXTURE.DIFFUSE_TEXTURE,dr.PRESET_SAMPLER.DIFFUSE_TEXTURE_SAMPLER]),Object.freeze(BitmapMaterial);var Xa="#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include getBillboardMatrix;\nstruct MatrixList{ modelMatrix:mat4x4<f32>, normalModelMatrix:mat4x4<f32>,\n}\nstruct VertexUniforms { matrixList:MatrixList, pickingId:u32, useBillboardPerspective:u32, useBillboard:u32, combinedOpacity:f32,\n};\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\nstruct InputData { @location(0) a_position:vec3<f32>, @location(1) a_normal:vec3<f32>, @location(2) a_uv:vec2<f32>, @location(3) position:vec3<f32>, @location(4) alpha:f32, @location(5) rotation:vec3<f32>, @location(6) scale:f32,\n};\nstruct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(14) @interpolate(flat) receiveShadow:f32, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\nfn mat4_inverse(a:mat4x4<f32>) -> mat4x4<f32> { var a00:f32=a[0][0]; var a01:f32=a[0][1]; var a02:f32=a[0][2]; var a03:f32=a[0][3]; var a10:f32=a[1][0]; var a11:f32=a[1][1]; var a12:f32=a[1][2]; var a13:f32=a[1][3]; var a20:f32=a[2][0]; var a21:f32=a[2][1]; var a22:f32=a[2][2]; var a23:f32=a[2][3]; var a30:f32=a[3][0]; var a31:f32=a[3][1]; var a32:f32=a[3][2]; var a33:f32=a[3][3]; var b00:f32=a00*a11 - a01*a10; var b01:f32=a00*a12 - a02*a10; var b02:f32=a00*a13 - a03*a10; var b03:f32=a01*a12 - a02*a11; var b04:f32=a01*a13 - a03*a11; var b05:f32=a02*a13 - a03*a12; var b06:f32=a20*a31 - a21*a30; var b07:f32=a20*a32 - a22*a30; var b08:f32=a20*a33 - a23*a30; var b09:f32=a21*a32 - a22*a31; var b10:f32=a21*a33 - a23*a31; var b11:f32=a22*a33 - a23*a32; var det:f32=b00*b11 - b01*b10 + b02*b09 + b03*b08 - b04*b07 + b05*b06; if (det !=0.0) { det=1.0/det; return mat4x4<f32>( (a11*b11 - a12*b10 + a13*b09) * det, (a02*b10 - a01*b11 - a03*b09) * det, (a31*b05 - a32*b04 + a33*b03) * det, (a22*b04 - a21*b05 - a23*b03) * det, (a12*b08 - a10*b11 - a13*b07) * det, (a00*b11 - a02*b08 + a03*b07) * det, (a32*b02 - a30*b05 - a33*b01) * det, (a20*b05 - a22*b02 + a23*b01) * det, (a10*b10 - a11*b08 + a13*b06) * det, (a01*b08 - a00*b10 - a03*b06) * det, (a30*b04 - a31*b02 + a33*b00) * det, (a21*b02 - a20*b04 - a23*b00) * det, (a11*b07 - a10*b09 - a12*b06) * det, (a00*b09 - a01*b07 + a02*b06) * det, (a31*b01 - a30*b03 - a32*b00) * det, (a20*b03 - a21*b01 + a22*b00) * det ); } return mat4x4<f32>( 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0 );\n}\nfn rotationMTX(t:vec3<f32>)->mat4x4<f32>\n{ var s:f32=sin(t.x); var c:f32=cos(t.x); var m1=mat4x4<f32>(1,0,0,0, 0,c,-s,0, 0,s,c,0, 0,0,0,1); s=sin(t[1]);c=cos(t[1]); var m2=mat4x4<f32>(c,0,s,0, 0,1,0,0, -s,0,c,0, 0,0,0,1); s=sin(t[2]);c=cos(t[2]); var m3=mat4x4<f32>(c,-s,0,0, s,c,0,0, 0,0,1,0, 0,0,0,1); return m1 * m2 * m3;\n}\n@vertex\nfn main( inputData:InputData) -> OutputData { var output:OutputData; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_resolution=systemUniforms.resolution; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_normalModelMatrix=vertexUniforms.matrixList.normalModelMatrix; let u_useBillboardPerspective=vertexUniforms.useBillboardPerspective==1u; let u_useBillboard=vertexUniforms.useBillboard==1u; let input_position=inputData.position; var position:vec4<f32>; var normalPosition:vec4<f32>; var scaleMTX=mat4x4<f32>( inputData.scale,0,0,0, 0,inputData.scale,0,0, 0,0,inputData.scale,0, 0,0,0,1 ); var translateTX=mat4x4<f32>( 1,0,0,0, 0,1,0,0, 0,0,1,0, inputData.position.x,inputData.position.y,inputData.position.z,1 ); var temp:mat4x4<f32>; if(u_useBillboard){ var rotateMTX2=rotationMTX( vec3(0,0,inputData.rotation.z) ); temp=translateTX * rotateMTX2; position=rotateMTX2 * vec4<f32>(inputData.a_position,1); output.position=u_projectionMatrix * getBillboardMatrixNoScaleRatio( u_cameraMatrix,temp ) * scaleMTX * position; }else{ var rotateMTX=rotationMTX( inputData.rotation ); temp=translateTX * rotateMTX * scaleMTX; position=temp * vec4<f32>(inputData.a_position,1); output.position=u_projectionCameraMatrix * position; } output.vertexPosition=position.xyz; output.vertexNormal=(transpose(mat4_inverse(temp) ) * vec4<f32>(inputData.a_normal,1.0)).xyz; output.uv=inputData.a_uv; output.combinedOpacity=inputData.alpha; return output;\n}\nstruct OutputShadowData { @builtin(position) position:vec4<f32>,\n};\n";const ja=parseWGSL(Xa),Ya=ja.uniforms.vertexUniforms;class ParticleEmitter extends Mesh{#$f=1e3;#Kf=5e3;#Xf=0;#jf=0;#Yf=0;#qf=0;#Wf=0;#Zf=0;#Jf=-5;#Qf=-5;#ed=-5;#td=5;#nd=5;#rd=5;#id=1;#ad=1;#sd=1;#od=1;#ud=0;#ld=1;#cd=0;#hd=0;#fd=-360;#dd=-360;#md=-360;#pd=360;#gd=360;#xd=360;#_d=-360;#vd=-360;#bd=-360;#yd=360;#Sd=360;#Td=360;#Md=$a.CubicOut;#wd=$a.CubicOut;#Cd=$a.CubicOut;#Pd=$a.Linear;#Rd=$a.Linear;#Bd=$a.CubicOut;#Id=$a.CubicOut;#Ed=$a.CubicOut;#Dd;#Ud;#Ld;#Xn;#Ad;#Gd=2e3;constructor(i){super(i),this.geometry=new Plane(i),this.material=new BitmapMaterial(i),this.ignoreFrustumCulling=!0,this.useBillboard=!0}get vertexStateBuffers(){return[{arrayStride:32,stepMode:"vertex",attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x3"},{shaderLocation:2,offset:24,format:"float32x2"}]},{arrayStride:48,stepMode:"instance",attributes:[{shaderLocation:3,offset:16,format:"float32x3"},{shaderLocation:4,offset:28,format:"float32"},{shaderLocation:5,offset:32,format:"float32x3"},{shaderLocation:6,offset:44,format:"float32"}]}]}get particleNum(){return this.#Gd}set particleNum(i){this.#Gd=Math.max(Math.min(i,5e5),1),this.#Dd||this.#ne(),this.#kd()}get minLife(){return this.#$f}set minLife(i){this.#$f=i}get maxLife(){return this.#Kf}set maxLife(i){this.#Kf=i}get minStartX(){return this.#Xf}set minStartX(i){this.#Xf=i}get minStartY(){return this.#jf}set minStartY(i){this.#jf=i}get minStartZ(){return this.#Yf}set minStartZ(i){this.#Yf=i}get maxStartX(){return this.#qf}set maxStartX(i){this.#qf=i}get maxStartY(){return this.#Wf}set maxStartY(i){this.#Wf=i}get maxStartZ(){return this.#Zf}set maxStartZ(i){this.#Zf=i}get minEndX(){return this.#Jf}set minEndX(i){this.#Jf=i}get minEndY(){return this.#Qf}set minEndY(i){this.#Qf=i}get minEndZ(){return this.#ed}set minEndZ(i){this.#ed=i}get maxEndX(){return this.#td}set maxEndX(i){this.#td=i}get maxEndY(){return this.#nd}set maxEndY(i){this.#nd=i}get maxEndZ(){return this.#rd}set maxEndZ(i){this.#rd=i}get minStartAlpha(){return this.#id}set minStartAlpha(i){this.#id=i}get maxStartAlpha(){return this.#ad}set maxStartAlpha(i){this.#ad=i}get minEndAlpha(){return this.#sd}set minEndAlpha(i){this.#sd=i}get maxEndAlpha(){return this.#od}set maxEndAlpha(i){this.#od=i}get minStartScale(){return this.#ud}set minStartScale(i){this.#ud=i}get maxStartScale(){return this.#ld}set maxStartScale(i){this.#ld=i}get minEndScale(){return this.#cd}set minEndScale(i){this.#cd=i}get maxEndScale(){return this.#hd}set maxEndScale(i){this.#hd=i}get minStartRotationX(){return this.#fd}set minStartRotationX(i){this.#fd=i}get minStartRotationY(){return this.#dd}set minStartRotationY(i){this.#dd=i}get minStartRotationZ(){return this.#md}set minStartRotationZ(i){this.#md=i}get maxStartRotationX(){return this.#pd}set maxStartRotationX(i){this.#pd=i}get maxStartRotationY(){return this.#gd}set maxStartRotationY(i){this.#gd=i}get maxStartRotationZ(){return this.#xd}set maxStartRotationZ(i){this.#xd=i}get minEndRotationX(){return this.#_d}set minEndRotationX(i){this.#_d=i}get minEndRotationY(){return this.#vd}set minEndRotationY(i){this.#vd=i}get minEndRotationZ(){return this.#bd}set minEndRotationZ(i){this.#bd=i}get maxEndRotationX(){return this.#yd}set maxEndRotationX(i){this.#yd=i}get maxEndRotationY(){return this.#Sd}set maxEndRotationY(i){this.#Sd=i}get maxEndRotationZ(){return this.#Td}set maxEndRotationZ(i){this.#Td=i}get easeX(){return this.#Md}set easeX(i){this.#Md=i}get easeY(){return this.#wd}set easeY(i){this.#wd=i}get easeZ(){return this.#Cd}set easeZ(i){this.#Cd=i}get easeAlpha(){return this.#Pd}set easeAlpha(i){this.#Pd=i}get easeScale(){return this.#Rd}set easeScale(i){this.#Rd=i}get easeRotationX(){return this.#Bd}set easeRotationX(i){this.#Bd=i}get easeRotationY(){return this.#Id}set easeRotationY(i){this.#Id=i}get easeRotationZ(){return this.#Ed}set easeRotationZ(i){this.#Ed=i}get particleBuffers(){return this.#Ud}render(i){this.#Dd||this.#ne(),this.#Od(i.timestamp),super.render(i)}createCustomMeshVertexShaderModule=()=>this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_PARTICLE_EMITTER",ja,Ya,Xa);#ne(){this.#Ld=new Float32Array(46);let i={size:this.#Ld.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST};const{gpuDevice:g}=this.redGPUContext;this.#Dd=g.createBuffer(i),g.queue.writeBuffer(this.#Dd,0,this.#Ld),this.#kd(),this.depthStencilState.depthWriteEnabled=!1}#kd(){this.dirtyPipeline=!0;let i=this.redGPUContext;const g=new Float32Array(12*this.#Gd),x=new Float32Array(12*this.#Gd),_=new Float32Array(12*this.#Gd),v=new Float32Array(4*this.#Gd),b=new Float32Array(4*this.#Gd),y=performance.now(),S=this.localToWorld(this.x,this.y,this.z);for(let i=0;i<this.#Gd;++i){let w=Math.random()*this.#Kf,L=Math.random()*w;const k=S[0]+Math.random()*(this.#qf-this.#Xf)+this.#Xf,z=S[1]+Math.random()*(this.#Wf-this.#jf)+this.#jf,H=S[2]+Math.random()*(this.#Zf-this.#Yf)+this.#Yf,q=Math.random()*(this.#pd-this.#fd)+this.#fd,W=Math.random()*(this.#gd-this.#dd)+this.#dd,be=Math.random()*(this.#xd-this.#md)+this.#md;Math.random(),this.#ld,this.#ud,this.#ud,Math.random(),this.#ad,this.#id,this.#id,g[12*i]=y-L,g[12*i+1]=w,g[12*i+4]=k,g[12*i+5]=z,g[12*i+6]=H,g[12*i+7]=0,g[12*i+8]=q,g[12*i+9]=W,g[12*i+10]=be,g[12*i+11]=0,x[4*i]=k,x[4*i+1]=Math.random()*(this.#td-this.#Jf)+this.#Jf,x[4*i+2]=this.#Md,x[4*i+3]=S[0],x[4*i+4]=z,x[4*i+5]=Math.random()*(this.#nd-this.#Qf)+this.#Qf,x[4*i+6]=this.#wd,x[4*i+7]=S[1],x[4*i+8]=H,x[4*i+9]=Math.random()*(this.#rd-this.#ed)+this.#ed,x[4*i+10]=this.#Cd,x[4*i+11]=S[2],_[4*i]=q,_[4*i+1]=Math.random()*(this.#yd-this.#_d)+this.#_d,_[4*i+2]=this.#Bd,_[4*i+3]=0,_[4*i+4]=W,_[4*i+5]=Math.random()*(this.#Sd-this.#vd)+this.#vd,_[4*i+6]=this.#Id,_[4*i+7]=0,_[4*i+8]=be,_[4*i+9]=Math.random()*(this.#Td-this.#bd)+this.#bd,_[4*i+10]=this.#Ed,_[4*i+11]=0,v[4*i]=0,v[4*i+1]=Math.random()*(this.#hd-this.#cd)+this.#cd,v[4*i+2]=this.#Rd,v[4*i+3]=0,b[4*i]=0,b[4*i+1]=Math.random()*(this.#od-this.#sd)+this.#sd,b[4*i+2]=this.#Pd,b[4*i+3]=0}const w=this.#Ud;this.#Ud=[];const L=[g,x,_,v,b];L.forEach((g,x)=>{const _=i.gpuDevice.createBuffer({size:g.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC|GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE});i.gpuDevice.queue.writeBuffer(_,0,g),this.#Ud.push(_),w?.length&&copyGPUBuffer(i.gpuDevice,w[x],_)}),w&&w.forEach(i=>i.destroy());let k={code:"\nstruct Info { startValue:f32, endValue:f32, easeType:f32, birthCenterValue:f32\n};\nstruct InfoGroup { infoX:Info, infoY:Info, infoZ:Info,\n};\nstruct Particle { startTime:f32, life:f32, valuePosition:vec3<f32>, valueAlpha:f32, valueRotation:vec3<f32>, valueScale:f32,\n};\nstruct SimParams { time:f32, currentPositionX:f32,currentPositionY:f32,currentPositionZ:f32, minLife:f32,maxLife:f32, minStartX:f32,maxStartX:f32,minEndX:f32,maxEndX:f32,easeX:f32, minStartY:f32,maxStartY:f32,minEndY:f32,maxEndY:f32,easeY:f32, minStartZ:f32,maxStartZ:f32,minEndZ:f32,maxEndZ:f32,easeZ:f32, minStartAlpha:f32,maxStartAlpha:f32,minEndAlpha:f32,maxEndAlpha:f32,easeAlpha:f32, minStartScale:f32,maxStartScale:f32,minEndScale:f32,maxEndScale:f32,easeScale:f32, minStartRotationX:f32,maxStartRotationX:f32,minEndRotationX:f32,maxEndRotationX:f32,easeRotationX:f32, minStartRotationY:f32,maxStartRotationY:f32,minEndRotationY:f32,maxEndRotationY:f32,easeRotationY:f32, minStartRotationZ:f32,maxStartRotationZ:f32,minEndRotationZ:f32,maxEndRotationZ:f32,easeRotationZ:f32,\n};\n@group(0) @binding(0) var<uniform> params:SimParams;\n@group(0) @binding(1) var<storage,read_write> particles:array<Particle>;\n@group(0) @binding(2) var<storage,read_write> infoPosition:array<InfoGroup>;\n@group(0) @binding(3) var<storage,read_write> infoRotation:array<InfoGroup>;\n@group(0) @binding(4) var<storage,read_write> infoScale:array<Info>;\n@group(0) @binding(5) var<storage,read_write> infoAlpha:array<Info>;\nconst PI:f32=3.141592653589793;\nconst HPI:f32=PI * 0.5;\nconst PI2:f32=PI * 2.0;\nfn calEasing(n:f32,easingType:f32) -> f32 { var m:f32=n; let easingInt:i32=i32(easingType); switch (easingInt) { case 0:{ m=m;} case 1:{ m=m * m * m * m * m;} case 2:{ m -=1.0; m=(m * m * m * m * m) + 1.0; } case 3:{ if(m * 2.0 < 1.0) { m *=2.0; m=m * m * m * m * m * 0.5; } else { m=m * 2.0 - 2.0; m=0.5 * (m * m * m * m * m + 2.0); } } case 4:{ m=m * m * (m * 1.70158 + m - 1.70158);} case 5:{ m -=1.0; m=m * m * (m * 1.70158 + m + 1.70158) + 1.0; } case 6:{ if(m * 2.0 < 1.0) { m *=2.0; m=0.5 * m * m * (m * 1.70158 + m - 1.70158); } else { m=m * 2.0 - 2.0; m=0.5 * m * m * (m * 1.70158 + m + 1.70158) + 1.0; } } case 7:{ m=-1.0 * (sqrt(1.0 - m * m) - 1.0);} case 8:{ m -=1.0; m=sqrt(1.0 - m * m); } case 9:{ if(m * 2.0 < 1.0) { m *=2.0; m=-0.5 * (sqrt(1.0 - m * m) - 1.0); } else { m=m * 2.0 - 2.0; m=0.5 * sqrt(1.0 - m * m) + 0.5; } } case 10:{ m=m * m * m;} case 11:{ m -=1.0; m=m * m * m + 1.0; } case 12:{ if(m * 2.0 < 1.0) { m *=2.0; m=m * m * m * 0.5; } else { m=m * 2.0 - 2.0; m=0.5 * (m * m * m + 2.0); } } case 13:{ if (m==0.0) { m=0.0;} else { m=pow(2.0,10.0 * (m - 1.0));} } case 14:{ if (m==1.0) { m=1.0;} else { m=-pow(2.0,-10.0 * m) + 1.0;} } case 15:{ if(m * 2.0 < 1.0) { if (m==0.0) { m=0.0;} else { m *=2.0;m=0.5 * pow(2.0,10.0 * (m - 1.0));} } else { if (m==2.0) { m=1.0;} else { m=m * 2.0 - 1.0;m=-0.5 * pow(2.0,-10.0 * m) + 1.0;} } } case 16:{ m=m * m;} case 17:{ m=(2.0 - m) * m;} case 18:{ if(m * 2.0 < 1.0) { m *=2.0; m=m * m * 0.5; } else { m=2.0 - m; m=0.5 * (m * m + 1.0); } } case 19:{ m=m * m * m * m;} case 20:{ m -=1.0; m=1.0 - (m * m * m * m); } case 21:{ if(m * 2.0 < 1.0) { m *=2.0; m=m * m * m * m * 0.5; } else { m=m * 2.0 - 2.0; m=1.0 - (m * m * m * m * 0.5); } } case 22:{ m=-cos(m * HPI) + 1.0;} case 23:{ m=sin(m * HPI);} case 24:{ m=(-cos(m * PI) + 1.0) * 0.5;} case 25:{ if (m==0.0) { m=0.0;} else if (m==1.0) { m=1.0;} else { m -=1.0;m=-1.0 * pow(2.0,10.0 * m) * sin((m - 0.075) * (PI2)/0.3);} } case 26:{ if (m==0.0) { m=0.0; } else if (m==1.0) { m=1.0; } else { m -=1.0; m=-pow(2.0,10.0 * m) * sin((m - 0.075) * PI2/0.3); } } case 27:{ if (m==0.0) { m=0.0; } else if (m==1.0) { m=1.0; } else { m=pow(2.0,-10.0 * m) * sin((m - 0.075) * PI2/0.3) + 1.0; } } default:{ m=m;} } return m;\n}\nfn rand(n:f32) -> f32 { return fract(sin(n) * 43758.5453123);\n}\nfn randomRange(min:f32,max:f32,v:f32)->f32\n{ var newValue:f32=rand(v); return (newValue * (max-min)) + min;\n}\nfn compute_value(tInfo:Info,lifeRatio:f32) -> f32 { return tInfo.startValue + ((tInfo.endValue - tInfo.startValue) * calEasing(lifeRatio,tInfo.easeType));\n}\n@compute @workgroup_size(256,1,1)\nfn main( @builtin(global_invocation_id) global_id:vec3<u32> ) { let index:u32=(global_id.x); let age:f32=(params.time - particles[index].startTime); var lifeRatio:f32=(age/particles[index].life); if (lifeRatio >=1.0 ) { let uuid:f32=(params.time + f32(index)); particles[index].startTime=params.time; particles[index].life=randomRange( params.minLife,params.maxLife,uuid ); infoPosition[index].infoX.startValue=randomRange( params.minStartX + params.currentPositionX,params.maxStartX + params.currentPositionX,(uuid + 1.0) ); infoPosition[index].infoX.endValue=randomRange( params.minEndX + params.currentPositionX,params.maxEndX + params.currentPositionX,(uuid + 2.0) ); infoPosition[index].infoX.easeType=params.easeX; infoPosition[index].infoX.birthCenterValue=params.currentPositionX; infoPosition[index].infoY.startValue=randomRange( params.minStartY +params.currentPositionY,params.maxStartY+params.currentPositionY,(uuid + 3.0) ); infoPosition[index].infoY.endValue=randomRange( params.minEndY+params.currentPositionY,params.maxEndY+params.currentPositionY,(uuid + 4.0) ); infoPosition[index].infoY.easeType=params.easeY; infoPosition[index].infoY.birthCenterValue=params.currentPositionY; infoPosition[index].infoZ.startValue=randomRange( params.minStartZ+params.currentPositionZ,params.maxStartZ+params.currentPositionZ,(uuid + 5.0) ); infoPosition[index].infoZ.endValue=randomRange( params.minEndZ+params.currentPositionZ,params.maxEndZ+params.currentPositionZ,(uuid + 6.0) ); infoPosition[index].infoZ.easeType=params.easeZ; infoPosition[index].infoZ.birthCenterValue=params.currentPositionZ; infoAlpha[index].startValue=randomRange( params.minStartAlpha,params.maxStartAlpha,(uuid + 7.0) ); infoAlpha[index].endValue=randomRange( params.minEndAlpha,params.maxEndAlpha,(uuid + 8.0) ); infoAlpha[index].easeType=params.easeAlpha; infoScale[index].startValue=randomRange( params.minStartScale,params.maxStartScale,(uuid + 9.0) ); infoScale[index].endValue=randomRange( params.minEndScale,params.maxEndScale,(uuid + 10.0)); infoScale[index].easeType=params.easeScale; infoRotation[index].infoX.startValue=randomRange( params.minStartRotationX,params.maxStartRotationX,(uuid + 11.0)); infoRotation[index].infoX.endValue=randomRange( params.minEndRotationX,params.maxEndRotationX,(uuid + 12.0)); infoRotation[index].infoX.easeType=params.easeRotationX; infoRotation[index].infoY.startValue=randomRange( params.minStartRotationY,params.maxStartRotationY,(uuid + 13.0)); infoRotation[index].infoY.endValue=randomRange( params.minEndRotationY,params.maxEndRotationY,(uuid + 14.0)); infoRotation[index].infoY.easeType=params.easeRotationY; infoRotation[index].infoZ.startValue=randomRange( params.minStartRotationZ,params.maxStartRotationZ,(uuid + 15.0)); infoRotation[index].infoZ.endValue=randomRange( params.minEndRotationZ,params.maxEndRotationZ,(uuid + 16.0)); infoRotation[index].infoZ.easeType=params.easeRotationZ; lifeRatio=0.0; } var targetInfo:Info; let targetParticle=particles[index]; targetInfo=infoPosition[index].infoX; particles[index].valuePosition.x=compute_value(targetInfo,lifeRatio); targetInfo=infoPosition[index].infoY; particles[index].valuePosition.y=compute_value(targetInfo,lifeRatio); targetInfo=infoPosition[index].infoZ; particles[index].valuePosition.z=compute_value(targetInfo,lifeRatio); targetInfo=infoAlpha[index]; particles[index].valueAlpha=compute_value(targetInfo,lifeRatio); targetInfo=infoScale[index]; particles[index].valueScale=compute_value(targetInfo,lifeRatio); targetInfo=infoRotation[index].infoX; particles[index].valueRotation.x=compute_value(targetInfo,lifeRatio) * PI/180.0; targetInfo=infoRotation[index].infoY; particles[index].valueRotation.y=compute_value(targetInfo,lifeRatio) * PI/180.0; targetInfo=infoRotation[index].infoZ; particles[index].valueRotation.z=compute_value(targetInfo,lifeRatio) * PI/180.0;\n}\n"},z=i.resourceManager.createGPUShaderModule("PARTICLE_EMITTER_MODULE",k);const H=[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}],q=[{binding:0,resource:{buffer:this.#Dd,offset:0,size:this.#Ld.byteLength}}];L.forEach((i,g)=>{H.push({binding:g+1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}),q.push({binding:g+1,resource:{buffer:this.#Ud[g],offset:0,size:i.byteLength}})});const W=i.gpuDevice.createBindGroupLayout({entries:H}),be=i.gpuDevice.createPipelineLayout({bindGroupLayouts:[W]});this.#Ad=i.gpuDevice.createBindGroup({label:"PARTICLE_EMITTER_BIND_GROUP",layout:W,entries:q}),this.#Xn=i.gpuDevice.createComputePipeline({label:"PARTICLE_EMITTER_PIPELINE",layout:be,compute:{module:z,entryPoint:"main"}})}#Od(i){const g=this.localToWorld(this.x,this.y,this.z);this.#Ld.set([i,...g,this.#$f,this.#Kf,this.#Xf,this.#qf,this.#Jf,this.#td,this.#Md,this.#jf,this.#Wf,this.#Qf,this.#nd,this.#wd,this.#Yf,this.#Zf,this.#ed,this.#rd,this.#Cd,this.#id,this.#ad,this.#sd,this.#od,this.#Pd,this.#ud,this.#ld,this.#cd,this.#hd,this.#Rd,this.#fd,this.#pd,this.#_d,this.#yd,this.#Bd,this.#dd,this.#gd,this.#vd,this.#Sd,this.#Id,this.#md,this.#xd,this.#bd,this.#Td,this.#Ed],0);const{gpuDevice:x}=this.redGPUContext;x.queue.writeBuffer(this.#Dd,0,this.#Ld);const _=x.createCommandEncoder({label:"PARTICLE_EMITTER_COMPUTE_COMMAND_ENCODER"}),v=_.beginComputePass({label:"PARTICLE_EMITTER_COMPUTE_PASS"});v.setPipeline(this.#Xn),v.setBindGroup(0,this.#Ad),v.dispatchWorkgroups(Math.ceil(this.#Gd/256)),v.end(),x.queue.submit([_.finish()])}}Object.defineProperty(ParticleEmitter.prototype,"meshType",{value:Gr.PARTICLE,writable:!1}),Er.defineByPreset(ParticleEmitter,[Er.PRESET_BOOLEAN.USE_BILLBOARD]),Er.definePositiveNumber(ParticleEmitter,[]),Object.freeze(ParticleEmitter);const qa=mixInMesh2D(Mesh);class Sprite2D extends qa{#It=1;#Et=1;constructor(i,g){super(i,new Plane(i,1,1,1,1,1,!0),g),this.primitiveState.cullMode=ei.FRONT}get width(){return this.#It}set width(i){validatePositiveNumberRange(i),this.#It=i,this.dirtyTransform=!0}get height(){return this.#Et}set height(i){validatePositiveNumberRange(i),this.#Et=i,this.dirtyTransform=!0}setSize(i,g){this.width=i,this.height=void 0!==g?g:i}}Object.freeze(Sprite2D);var Wa="#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include getBillboardMatrix;\n#redgpu_include calcBillboard;\n#redgpu_include billboardPicking;\n#redgpu_include billboardShadow;\nstruct MatrixList{ modelMatrix:mat4x4<f32>, normalModelMatrix:mat4x4<f32>,\n}\nstruct VertexUniforms { matrixList:MatrixList, pickingId:u32, useBillboard:u32, usePixelSize:u32, pixelSize:f32, _renderRatioX:f32, _renderRatioY:f32, combinedOpacity:f32,\n};\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\nstruct InputData { @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>,\n};\nstruct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\n@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; let billboardResult=calcBillboard( inputData.position, inputData.vertexNormal, vertexUniforms.matrixList.modelMatrix, systemUniforms.camera.cameraMatrix, systemUniforms.projectionMatrix, systemUniforms.resolution, vertexUniforms.useBillboard, vertexUniforms.usePixelSize, vertexUniforms.pixelSize, vertexUniforms._renderRatioX, vertexUniforms._renderRatioY ); output.position=billboardResult.position; output.vertexPosition=billboardResult.vertexPosition; output.vertexNormal=billboardResult.vertexNormal; output.uv=inputData.uv; output.combinedOpacity=vertexUniforms.combinedOpacity; return output;\n}\n";const Za=parseWGSL(Wa),Ja=Za.uniforms.vertexUniforms;class Sprite3D extends Mesh{#Wo=1;#Zo=1;#Jo=1;#Nd=0;#Qo=!1;constructor(i,g,x){super(i),this._geometry=x||new Plane(i),this._material=g,this._material&&(this._material.transparent=!0),this.dirtyPipeline=!0,this.dirtyTransform=!0,this.primitiveState.cullMode=ei.NONE}get worldSize(){return this.#Jo}set worldSize(i){this.#Jo!==i&&(this.#Jo=i,this.#eu())}get usePixelSize(){return this.#Qo}set usePixelSize(i){if(this.gpuRenderInfo){const{vertexUniformBuffer:g,vertexUniformInfo:x}=this.gpuRenderInfo;this.redGPUContext.gpuDevice.queue.writeBuffer(g.gpuBuffer,x.members.usePixelSize.uniformOffset,new Uint32Array([i?1:0]))}this.#Qo!==i&&(this.#Qo=i,this.#eu())}get pixelSize(){return this.#Nd}set pixelSize(i){if(this.gpuRenderInfo){const{vertexUniformBuffer:g,vertexUniformInfo:x}=this.gpuRenderInfo;this.redGPUContext.gpuDevice.queue.writeBuffer(g.gpuBuffer,x.members.pixelSize.uniformOffset,new Float32Array([i*window.devicePixelRatio]))}this.#Nd=i}#eu(){if(this.#Zo){const i=this._renderRatioX,g=this._renderRatioY;this.usePixelSize?(this._renderRatioY=1,this._renderRatioX=this.#Wo/this.#Zo):(this._renderRatioY=this.#Jo,this._renderRatioX=this.#Wo/this.#Zo*this.#Jo),i===this._renderRatioX&&g===this._renderRatioY||(this.dirtyTransform=!0)}}render(i){if(this._material instanceof BitmapMaterial&&this._material.diffuseTexture){const{gpuTexture:i}=this._material.diffuseTexture;if(i){const g=i.width,x=i.height;if(g!==this.#Wo||x!==this.#Zo){this.#Wo=g,this.#Zo=x;const i=this.pixelSize;this.pixelSize=this.pixelSize||x,this.#eu(),i!==this.pixelSize&&(this.dirtyTransform=!0)}}}super.render(i)}createCustomMeshVertexShaderModule=()=>this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_SPRITE_3D",Za,Ja,Wa)}Er.definePositiveNumber(Sprite3D,[["_renderRatioX",1],["_renderRatioY",1]]),Er.defineByPreset(Sprite3D,[[Er.PRESET_BOOLEAN.USE_BILLBOARD,!0]]),Object.freeze(Sprite3D);class ASpriteSheet extends Mesh{#Vd=0;#Fd=0;#zd=0;#Hd=!0;#$d=!0;#Kd;#Xd;#jd="play";constructor(i,g,x){super(i),this.#Xd=x,this._material=new BitmapMaterial(i),this._material.transparent=!0,this.dirtyPipeline=!0,this.dirtyTransform=!0,this.spriteSheetInfo=g,this._material.diffuseTextureSampler=new Sampler(i),this._material.diffuseTextureSampler.addressModeU=_.REPEAT,this._material.diffuseTextureSampler.addressModeV=_.REPEAT}get state(){return this.#jd}get loop(){return this.#$d}set loop(i){this.#$d=i}get frameRate(){return this.#Vd}set frameRate(i){i<0&&(i=0),0===this.#Vd&&i&&(this.#Fd=0),this.#Vd=i,this.#zd=1e3/this.#Vd}get geometry(){return this._geometry}set geometry(i){consoleAndThrowError("ASpriteSheet can not change geometry")}get material(){return this._material}set material(i){consoleAndThrowError("ASpriteSheet can not change material")}get spriteSheetInfo(){return this.#Kd}set spriteSheetInfo(i){this.#Kd=i,this.frameRate=i.frameRate,this.segmentW=i.segmentW,this.segmentH=i.segmentH,this.totalFrame=i.totalFrame,this.currentIndex=i.startIndex,this.#$d=!0,this.#Fd=0,this._material.diffuseTexture=i.texture}play(){this.#Hd=!0,this.#jd="play",this.#Fd=0}pause(){this.#Hd=!1,this.#jd="pause"}stop(){this.#Hd=!1,this.currentIndex=0,this.#jd="stop"}render(i){const{diffuseTexture:g}=this._material;this.#Xd(g,this.segmentW,this.segmentH);const{timestamp:x}=i;if(this.#Fd||(this.#Fd=this.#zd+x),this.#Hd&&this.#Fd<x&&this.#Vd){const i=Math.floor((x-this.#Fd)/this.#zd),g=(Number.isFinite(i)?i:0)||1;this.#Fd=this.#zd+x,this.currentIndex+=g,this.currentIndex>=this.totalFrame&&(this.loop?(this.#Hd=!0,this.currentIndex=0):(this.#Hd=!1,this.currentIndex=this.totalFrame-1))}super.render(i)}}Er.definePositiveNumber(ASpriteSheet,[["segmentW",5],["segmentH",3],["totalFrame",15],["currentIndex",0]]),Object.freeze(ASpriteSheet);var Qa=Object.freeze({__proto__:null,ASpriteSheet:ASpriteSheet}),es="#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include getBillboardMatrix;\nstruct MatrixList{ modelMatrix:mat4x4<f32>, normalModelMatrix:mat4x4<f32>,\n}\nstruct VertexUniforms { matrixList:MatrixList, pickingId:u32, segmentW:f32, segmentH:f32, totalFrame:f32, currentIndex:f32, combinedOpacity:f32,\n};\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\nstruct InputData { @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>,\n};\nstruct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\n@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_normalModelMatrix=vertexUniforms.matrixList.normalModelMatrix; let input_position=inputData.position; let input_vertexNormal=inputData.vertexNormal; let input_uv=inputData.uv; var position:vec4<f32>; var normalPosition:vec4<f32>; position=u_cameraMatrix * u_modelMatrix * vec4<f32>(input_position,1.0); normalPosition=u_cameraMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0); output.position=u_projectionMatrix * position; output.vertexPosition=position.xyz; output.vertexNormal=normalPosition.xyz; output.combinedOpacity=vertexUniforms.combinedOpacity; let uv=vec2<f32>( input_uv.x * 1/vertexUniforms.segmentW + ((vertexUniforms.currentIndex % vertexUniforms.segmentW)/vertexUniforms.segmentW), input_uv.y * 1/vertexUniforms.segmentH - (floor(vertexUniforms.currentIndex/vertexUniforms.segmentH)/vertexUniforms.segmentH) ); output.uv=uv; return output;\n}\n@vertex\nfn picking(inputData:InputData) -> OutputData { var output:OutputData; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_normalModelMatrix=vertexUniforms.matrixList.normalModelMatrix; let input_position=inputData.position; let input_vertexNormal=inputData.vertexNormal; let input_uv=inputData.uv; var position:vec4<f32>; var normalPosition:vec4<f32>; position=u_cameraMatrix * u_modelMatrix * vec4<f32>(input_position,1.0); normalPosition=u_cameraMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0); output.position=u_projectionMatrix * position; output.pickingId=unpack4x8unorm(vertexUniforms.pickingId); return output;\n}\n";const ts=parseWGSL(es),ns=ts.uniforms.vertexUniforms,rs=mixInMesh2D(ASpriteSheet);class SpriteSheet2D extends rs{#It=1;#Et=1;constructor(i,g){super(i,g,(i,g,x)=>{if(i){const{gpuTexture:_}=i,v=_?.width/g,b=_?.height/x;v===this.#It&&b===this.#Et||(this.#It=_?.width/g,this.#Et=_?.height/x,this.dirtyTransform=!0)}else this.#It=1,this.#Et=1}),this._geometry=new Plane(i,1,1,1,1,1,!0),this.primitiveState.cullMode=ei.FRONT}get width(){return this.#It}get height(){return this.#Et}get geometry(){return this._geometry}set geometry(i){consoleAndThrowError("SpriteSheet2D can not change geometry")}get material(){return this._material}set material(i){consoleAndThrowError("SpriteSheet2D can not change material")}createCustomMeshVertexShaderModule=()=>this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_SPRITE_SHEET_2D",ts,ns,es)}Object.freeze(SpriteSheet2D);var is="#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include getBillboardMatrix;\n#redgpu_include calcBillboard;\n#redgpu_include billboardPicking;\n#redgpu_include billboardShadow;\nstruct MatrixList{ modelMatrix:mat4x4<f32>, normalModelMatrix:mat4x4<f32>,\n}\nstruct VertexUniforms { matrixList:MatrixList, pickingId:u32, useSizeAttenuation:u32, useBillboard:u32, segmentW:f32, segmentH:f32, totalFrame:f32, currentIndex:f32, usePixelSize:u32, pixelSize:f32, _renderRatioX:f32, _renderRatioY:f32, combinedOpacity:f32,\n};\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\nstruct InputData { @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>,\n};\nstruct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\n@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; let billboardResult=calcBillboard( inputData.position, inputData.vertexNormal, vertexUniforms.matrixList.modelMatrix, systemUniforms.camera.cameraMatrix, systemUniforms.projectionMatrix, systemUniforms.resolution, vertexUniforms.useBillboard, vertexUniforms.usePixelSize, vertexUniforms.pixelSize, vertexUniforms._renderRatioX, vertexUniforms._renderRatioY ); output.position=billboardResult.position; output.vertexPosition=billboardResult.vertexPosition; output.vertexNormal=billboardResult.vertexNormal; output.uv=vec2<f32>( inputData.uv.x/vertexUniforms.segmentW + ((vertexUniforms.currentIndex % vertexUniforms.segmentW)/vertexUniforms.segmentW), inputData.uv.y/vertexUniforms.segmentH - (floor(vertexUniforms.currentIndex/vertexUniforms.segmentH)/vertexUniforms.segmentH) ); output.combinedOpacity=vertexUniforms.combinedOpacity; return output;\n}";const as=parseWGSL(is),ss=as.uniforms.vertexUniforms;class SpriteSheet3D extends ASpriteSheet{#Wo=1;#Zo=1;#Jo=1;#Nd=0;#Qo=!1;constructor(i,x){super(i,x,(i,x,_)=>{if(i){const{gpuTexture:v}=i;if(v){const i=v.width/x,b=v.height/_;i===this.#Wo&&b===this.#Zo||(this.#Wo=i,this.#Zo=b,this.pixelSize,this.pixelSize=this.#Nd?this.#Nd:b,this.#eu(),g("오냐 ",this.pixelSize),this.dirtyTransform=!0)}}else this.#Wo=1,this.#Zo=1}),this._geometry=new Plane(i)}get worldSize(){return this.#Jo}set worldSize(i){this.#Jo!==i&&(this.#Jo=i,this.#eu())}get pixelSize(){return this.#Nd}set pixelSize(i){if(this.gpuRenderInfo){const{vertexUniformBuffer:g,vertexUniformInfo:x}=this.gpuRenderInfo;this.redGPUContext.gpuDevice.queue.writeBuffer(g.gpuBuffer,x.members.pixelSize.uniformOffset,new Float32Array([i*window.devicePixelRatio]))}this.#Nd=i}get usePixelSize(){return this.#Qo}set usePixelSize(i){if(this.gpuRenderInfo){const{vertexUniformBuffer:g,vertexUniformInfo:x}=this.gpuRenderInfo;this.redGPUContext.gpuDevice.queue.writeBuffer(g.gpuBuffer,x.members.usePixelSize.uniformOffset,new Uint32Array([i?1:0]))}this.#Qo!==i&&(this.#Qo=i,this.#eu())}#eu(){if(this.#Zo){const i=this._renderRatioX,g=this._renderRatioY;this.usePixelSize?(this._renderRatioY=1,this._renderRatioX=this.#Wo/this.#Zo):(this._renderRatioY=this.#Jo,this._renderRatioX=this.#Wo/this.#Zo*this.#Jo),i===this._renderRatioX&&g===this._renderRatioY||(this.dirtyTransform=!0)}}render(i){super.render(i)}get geometry(){return this._geometry}set geometry(i){consoleAndThrowError("SpriteSheet3D can not change geometry")}get material(){return this._material}set material(i){consoleAndThrowError("SpriteSheet3D can not change material")}createCustomMeshVertexShaderModule=()=>this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_SPRITE_SHEET_3D",as,ss,is)}Er.definePositiveNumber(SpriteSheet3D,[["_renderRatioX",1],["_renderRatioY",1]]),Er.defineByPreset(SpriteSheet3D,[[Er.PRESET_BOOLEAN.USE_BILLBOARD,!0]]),Object.freeze(SpriteSheet3D);class SpriteSheetInfo{#Yd=0;#qd=0;#Wd=0;#Zd=0;#Vd=0;#$d=!0;#Jd;constructor(i,g,x,_,v,b,y=!0,S=60){validateRedGPUContext(i),validateUintRange(x),validateUintRange(_),validateUintRange(v),validateUintRange(b),validateUintRange(S),this.#Yd=x,this.#qd=_,this.#Wd=v,this.#Zd=b,this.#Jd=new BitmapTexture(i,g),this.#$d=y,this.#Vd=S}get segmentW(){return this.#Yd}get segmentH(){return this.#qd}get totalFrame(){return this.#Wd}get startIndex(){return this.#Zd}get texture(){return this.#Jd}get frameRate(){return this.#Vd}get loop(){return this.#$d}}Object.freeze(SpriteSheetInfo);const os=parseWGSL("#redgpu_include drawPicking;\n#redgpu_include FragmentOutput;\n#redgpu_include calculateMotionVector;\nstruct Uniforms { opacity:f32\n};\nstruct InputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexColor:vec4<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n}\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\n@fragment\nfn main(inputData:InputData) -> FragmentOutput { var output:FragmentOutput; output.color=inputData.vertexColor; output.gBufferMotionVector=vec4<f32>(calculateMotionVector(inputData.currentClipPos,inputData.prevClipPos),0.0,1.0 ); return output;\n}\n");class LineMaterial extends ABaseMaterial{constructor(i,g){super(i,"LINE_MATERIAL",os,2),g&&(this.name=g),this.initGPURenderInfos()}}Object.freeze(LineMaterial);class LinePoint{position;colorRGBA;constructor(i=0,g=0,x=0,_){this.position=[i,g,x],this.colorRGBA=_}}const getPointsOnBezierCurveWithSplitting=(i,g,x,_)=>{let v=_||[];if(((i,g)=>{let x=i[g].position,_=i[g+1].position,v=i[g+2].position,b=i[g+3].position,y=3*_[0]-2*x[0]-b[0],S=3*_[1]-2*x[1]-b[1],w=3*v[0]-2*b[0]-x[0],L=3*v[1]-2*b[1]-x[1];return y*=y,S*=S,w*=w,L*=L,y<w&&(y=w),S<L&&(S=L),y+S})(i,g)<x)v.push(i[g],i[g+3]);else{let _=.5,b=i[g],y=i[g+1],S=i[g+2],w=i[g+3],L=lerp$3(create$3(),b.position,y.position,_),k=lerp$3(create$3(),y.position,S.position,_),z=lerp$3(create$3(),S.position,w.position,_),H=lerp$3(create$3(),L,k,_),q=lerp$3(create$3(),k,z,_),W=lerp$3(create$3(),H,q,_);W=new LinePoint(W[0],W[1],W[2],b.colorRGBA),L=new LinePoint(L[0],L[1],L[2],L.colorRGBA),z=new LinePoint(z[0],z[1],z[2],z.colorRGBA),H=new LinePoint(H[0],H[1],H[2],H.colorRGBA),q=new LinePoint(q[0],q[1],q[2],q.colorRGBA),getPointsOnBezierCurveWithSplitting([b,L,H,W],0,x,v),getPointsOnBezierCurveWithSplitting([W,q,z,w],0,x,v)}return v};class LinePointWithInOut{inLinePoint;linePoint;outLinePoint;constructor(i=0,g=0,x=0,_=0,v=0,b=0,y=0,S=0,w=0,L,k){let z=[...convertHexToRgb(L,!0)];z=[z[0]/255,z[1]/255,z[2]/255,k],this.inLinePoint=new LinePoint(_,v,b,z),this.linePoint=new LinePoint(i,g,x,z),this.outLinePoint=new LinePoint(y,S,w,z)}}const lineVec2DistanceToSegmentSq=function(i,g,x){i=[i[0],i[1]],g=[g[0],g[1]],x=[x[0],x[1]];let _=vn(g,x);if(0===_)return vn(i,g);let v=((i[0]-g[0])*(x[0]-g[0])+(i[1]-g[1])*(x[1]-g[1]))/_;return v=Math.max(0,Math.min(1,v)),vn(i,lerp([0,0],g,x,v))},lineSimplifyPoints=(i,g,x,_,v)=>{let b=v||[],y=i[g],S=i[x-1],w=0,L=1,k=g+1;for(;k<x-1;++k){let g=lineVec2DistanceToSegmentSq(i[k].position,y.position,S.position);g>w&&(w=g,L=k)}return Math.sqrt(w)>_?(lineSimplifyPoints(i,g,L+1,_,b),lineSimplifyPoints(i,L,x,_,b)):b.push(y,S),b},us={LINEAR:"linear",CATMULL_ROM:"catmullRom",BEZIER:"bezier"};Object.freeze(us);var ls="#redgpu_include SYSTEM_UNIFORM;\nstruct MatrixList{ modelMatrix:mat4x4<f32>, prevModelMatrix:mat4x4<f32>, normalModelMatrix:mat4x4<f32>,\n}\nstruct VertexUniforms { matrixList:MatrixList, pickingId:u32,\n};\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\nstruct InputData { @location(0) position:vec3<f32>, @location(1) vertexColor:vec4<f32>,\n};\nstruct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexColor:vec4<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\nstruct OutputShadowData { @builtin(position) position:vec4<f32>,\n};\n@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_noneJitterProjectionCameraMatrix=systemUniforms.noneJitterProjectionCameraMatrix; let u_prevNoneJitterProjectionCameraMatrix=systemUniforms.prevNoneJitterProjectionCameraMatrix; let u_matrixList=vertexUniforms.matrixList; let u_modelMatrix=u_matrixList.modelMatrix; let u_prevModelMatrix=u_matrixList.prevModelMatrix; let input_position=inputData.position; let input_vertexColor=inputData.vertexColor; let input_position_vec4=vec4<f32>(input_position,1.0); var position:vec4<f32>; position=u_modelMatrix * input_position_vec4; output.position=u_projectionCameraMatrix * position; output.vertexPosition=position.xyz; output.vertexColor=input_vertexColor; { output.currentClipPos=u_noneJitterProjectionCameraMatrix * position; output.prevClipPos=u_prevNoneJitterProjectionCameraMatrix * u_prevModelMatrix * input_position_vec4; } return output;\n}\n@vertex\nfn picking(inputData:InputData) -> OutputData { var output:OutputData; return output;\n}\n";const cs=parseWGSL(ls),hs=cs.uniforms.vertexUniforms;class Line3D extends Mesh{baseColor;#Qd;#em=1;#tm=.01;#lf=.01;#nm=[];#rm=[];#im;constructor(i,g=us.LINEAR,x="#fff"){super(i),this.primitiveState.topology=Lr.LINE_STRIP,this.baseColor=x,this.#Qd=g,this._geometry=new Geometry(i,new VertexBuffer(i,this.#nm,new VertexInterleavedStruct({vertexPosition:VertexInterleaveType.float32x3,vertexColor:VertexInterleaveType.float32x4}))),this._material=new LineMaterial(i)}get originalPoints(){return this.#rm}get type(){return this.#Qd}set type(i){this.#Qd=i,this.#am()}get interleaveData(){return this.#nm}get tension(){return this.#em}set tension(i){validatePositiveNumberRange(i),this.#em=i,this.#am()}get tolerance(){return this.#tm}set tolerance(i){validatePositiveNumberRange(i),this.#tm=i,this.#am()}get distance(){return this.#lf}set distance(i){validatePositiveNumberRange(i),this.#lf=i,this.#am()}get numPoints(){return this.#rm.length}get geometry(){return this._geometry}set geometry(i){consoleAndThrowError("Line3D can not change geometry")}get material(){return this._material}set material(i){consoleAndThrowError("Line3D can not change material")}createCustomMeshVertexShaderModule=()=>this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_LINE_3D",cs,hs,ls);addPoint(i=0,g=0,x=0,_=this.baseColor,v=1,b=0,y=0,S=0,w=0,L=0,k=0){this.#rm.push(new LinePointWithInOut(i,g,x,b,y,S,w,L,k,_,v)),this.#am()}addPointAt(i,g=0,x=0,_=0,v=this.baseColor,b=1,y=0,S=0,w=0,L=0,k=0,z=0){this.#rm.length<i&&(i=this.#rm.length),null!=i?this.#rm.splice(i,0,new LinePointWithInOut(g,x,_,y,S,w,L,k,z,v,b)):this.#rm.push(new LinePointWithInOut(g,x,_,y,S,w,L,k,z,v,b)),this.#am()}removePointAt(i){validateUintRange(i),this.#rm[i]?this.#rm.splice(i,1):consoleAndThrowError("removeChildAt","index 해당인덱스에 위치한 포인트가 없음.","입력값:"+i),this.#am()}removeAllPoint(){this.#rm.length=0,this.#am()}#an(){if(this._geometry,this.#rm.length){const{redGPUContext:i}=this;this._geometry=new Geometry(i,new VertexBuffer(i,this.#nm,new VertexInterleavedStruct({vertexPosition:VertexInterleaveType.float32x3,vertexColor:VertexInterleaveType.float32x4})))}this.dirtyPipeline=!0}#am(){const i=this.#rm,g=this.#em,x=this.#tm,_=this.#lf;let v,b,y,S;switch(this.#nm.length=0,this.#Qd){case us.CATMULL_ROM:case us.BEZIER:if(i.length>1)for(this.#im=(i=>{let g,x=[],_=0,v=0;const b=i.length;for(;_<b;_++){g=i[_];const{inLinePoint:b,linePoint:y,outLinePoint:S}=g;0===v?(x[v++]=y,x[v++]=S):(x[v++]=b,x[v++]=y,i[_+1]&&(x[v++]=S))}return x})(us.CATMULL_ROM===this.#Qd?((i,g=1)=>{const x=i.length,_=x-2;for(let v=0;v<x-1;v++){const x=v?i[v-1].linePoint.position:i[v].linePoint.position,b=i[v].linePoint.position,y=i[v+1].linePoint.position,S=v===_?y:i[v+2].linePoint.position;i[v].outLinePoint.position=[b[0]+(y[0]-x[0])/6*g,b[1]+(y[1]-x[1])/6*g,b[2]+(y[2]-x[2])/6*g],i[v+1].inLinePoint.position=[y[0]-(S[0]-b[0])/6*g,y[1]-(S[1]-b[1])/6*g,y[2]-(S[2]-b[2])/6*g]}return i})(i,g):i),v=((i,g)=>{let x=[],_=(i.length-1)/3;_=Math.floor(_);let v,b=0;for(;b<_;++b)v=3*b,getPointsOnBezierCurveWithSplitting(i,v,g,x);return x})(this.#im,x),v=lineSimplifyPoints(v,0,v.length,_),b=0,y=v.length;b<y;b++)S=v[b],this.#nm.push(...S.position,...S.colorRGBA);else this.#nm.push(0,0,0,1,1,1,1);break;default:for(b=0,y=i.length;b<y;b++){const{linePoint:g}=i[b],x=g.colorRGBA;this.interleaveData.push(...g.position,...x)}}this.#an()}}Object.freeze(Line3D);const fs=parseWGSL(ls),ds=fs.uniforms.vertexUniforms;var ms=Object.freeze({__proto__:null,ATextField:ATextField,TextFieldMaterial:TextFieldMaterial}),ps="#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include getBillboardMatrix;\nstruct MatrixList{ modelMatrix:mat4x4<f32>, normalModelMatrix:mat4x4<f32>,\n}\nstruct VertexUniforms { pickingId:u32, matrixList:MatrixList, combinedOpacity:f32,\n};\n@group(1) @binding(0) var<uniform> vertexUniforms:VertexUniforms;\nstruct InputData { @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>,\n};\nstruct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(11) combinedOpacity:f32, @location(13) shadowPos:vec3<f32>, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\nstruct OutputShadowData { @builtin(position) position:vec4<f32>,\n};\n@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_normalModelMatrix=vertexUniforms.matrixList.normalModelMatrix; let input_position=inputData.position; let input_vertexNormal=inputData.vertexNormal; let input_uv=inputData.uv; var position:vec4<f32>; var normalPosition:vec4<f32>; position=u_cameraMatrix * u_modelMatrix * vec4<f32>(input_position,1.0); normalPosition=u_cameraMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0); output.position=u_projectionMatrix * position; output.vertexPosition=position.xyz; output.vertexNormal=normalPosition.xyz; output.uv=input_uv; output.combinedOpacity=vertexUniforms.combinedOpacity; return output;\n}\n@vertex\nfn picking(inputData:InputData) -> OutputData { var output:OutputData; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_modelMatrix=vertexUniforms.matrixList.modelMatrix; let u_normalModelMatrix=vertexUniforms.matrixList.normalModelMatrix; let input_position=inputData.position; let input_vertexNormal=inputData.vertexNormal; let input_uv=inputData.uv; var position:vec4<f32>; var normalPosition:vec4<f32>; position=u_cameraMatrix * u_modelMatrix * vec4<f32>(input_position,1.0); normalPosition=u_cameraMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0); output.position=u_projectionMatrix * position; output.pickingId=unpack4x8unorm(vertexUniforms.pickingId); return output;\n}\n";const gs=parseWGSL(ps),xs=gs.uniforms.vertexUniforms,_s=mixInMesh2D(ATextField);class TextField2D extends _s{#It=1;#Et=1;#sm=!0;constructor(i,x=!0){super(i,(i,g)=>{this.#It===i&&this.#Et===g||(this.dirtyTransform=!0),this.#It=i,this.#Et=g},!1),this._geometry=new Plane(i,1,1,1,1,1,!0),this.useSmoothing=x,this.primitiveState.cullMode=ei.FRONT,g(this)}get useSmoothing(){return this.#sm}set useSmoothing(i){this.#sm=i,this.useSmoothing?(this._material.diffuseTextureSampler.minFilter=v.LINEAR,this._material.diffuseTextureSampler.magFilter=v.LINEAR,this._material.diffuseTextureSampler.mipmapFilter=b.LINEAR):(this._material.diffuseTextureSampler.minFilter=v.NEAREST,this._material.diffuseTextureSampler.magFilter=v.NEAREST,this._material.diffuseTextureSampler.mipmapFilter=null)}get width(){return this.#It}get height(){return this.#Et}get geometry(){return this._geometry}set geometry(i){console.error("TextField2D can not change geometry")}get material(){return this._material}set material(i){console.error("TextField2D can not change material")}createCustomMeshVertexShaderModule=()=>this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_TEXT_FIELD_2D",gs,xs,ps)}Object.freeze(TextField2D);const vs=3.141592653589793,bs=6.283185307179586,ys=.225,Ss=1.27323954,Ts=.405284735,Ms=1.5707963267948966,ws=Math.PI/180;class InstancingMeshObject3D{modelMatrix=create$4();localMatrix=create$4();normalModelMatrix=create$4();#Nt=0;#Ft=0;#Vt=0;#zs=[0,0,0];#js=1;#Ys=1;#qs=1;#Ws=[1,1,1];#Ui=0;#Li=0;#Ai=0;#Zs=[0,0,0];#om=0;#um;#l;#to=1;constructor(i,g,x){validateRedGPUContext(i),this.#l=i,this.#um=x,this.#om=g,this.#lm()}get opacity(){return this.#to}set opacity(i){validatePositiveNumberRange(i,0,1),this.#to=i,this.#lm()}get x(){return this.#Nt}set x(i){this.#Nt=this.#zs[0]=i,this.#lm()}get y(){return this.#Vt}set y(i){this.#Vt=this.#zs[1]=i,this.#lm()}get z(){return this.#Ft}set z(i){this.#Ft=this.#zs[2]=i,this.#lm()}get position(){return this.#zs}set position(i){this.#Nt=this.#zs[0]=i,this.#Vt=this.#zs[1]=i,this.#Ft=this.#zs[2]=i,this.#lm()}get scaleX(){return this.#js}set scaleX(i){this.#js=this.#Ws[0]=i,this.#lm()}get scaleY(){return this.#Ys}set scaleY(i){this.#Ys=this.#Ws[1]=i,this.#lm()}get scaleZ(){return this.#qs}set scaleZ(i){this.#qs=this.#Ws[2]=i,this.#lm()}get scale(){return this.#zs}set scale(i){this.#js=this.#Ws[0]=i,this.#Ys=this.#Ws[1]=i,this.#qs=this.#Ws[2]=i,this.#lm()}get rotationX(){return this.#Ui}set rotationX(i){this.#Ui=this.#Zs[0]=i,this.#lm()}get rotationY(){return this.#Li}set rotationY(i){this.#Li=this.#Zs[1]=i,this.#lm()}get rotationZ(){return this.#Ai}set rotationZ(i){this.#Ai=this.#Zs[2]=i,this.#lm()}get rotation(){return this.#Zs}set rotation(i){this.#Ui=this.#Zs[0]=i,this.#Li=this.#Zs[1]=i,this.#Ai=this.#Zs[2]=i,this.#lm()}setScale(i,g,x){g=g??i,x=x??i;const _=this.#Ws;this.#js=_[0]=i,this.#Ys=_[1]=g,this.#qs=_[2]=x,this.#lm()}setPosition(i,g,x){g=g??i,x=x??i;const _=this.#zs;this.#Nt=_[0]=i,this.#Vt=_[1]=g,this.#Ft=_[2]=x,this.#lm()}setRotation(i,g,x){g=g??i,x=x??i;const _=this.#Zs;this.#Ui=_[0]=i,this.#Li=_[1]=g,this.#Ai=_[2]=x,this.#lm()}#lm(){let i,g,x,_,v,b,y,S,w,L,k,z,H,q,W,be,Ke,Xe,je,Ye,Ze,Je,Qe,et,tt,it,ft,pt,xt,vt,bt,yt,St,Tt,Mt,wt,Ct,Pt;{const H=this.localMatrix;let Ke;L=1,k=0,z=0,q=0,W=1,be=0,Xe=0,je=0,Ye=1,H[12]=this.#Nt,H[13]=this.#Vt,H[14]=this.#Ft,H[15]=1,y=this.#Ui*ws,S=this.#Li*ws,w=this.#Ai*ws,Ke=y%bs,Ke<-vs?Ke+=bs:Ke>vs&&(Ke-=bs),Ke=Ke<0?Ss*Ke+Ts*Ke*Ke:Ss*Ke-Ts*Ke*Ke,i=Ke<0?ys*(Ke*-Ke-Ke)+Ke:ys*(Ke*Ke-Ke)+Ke,Ke=(y+Ms)%bs,Ke<-vs?Ke+=bs:Ke>vs&&(Ke-=bs),Ke=Ke<0?Ss*Ke+Ts*Ke*Ke:Ss*Ke-Ts*Ke*Ke,_=Ke<0?ys*(Ke*-Ke-Ke)+Ke:ys*(Ke*Ke-Ke)+Ke,Ke=S%bs,Ke<-vs?Ke+=bs:Ke>vs&&(Ke-=bs),Ke=Ke<0?Ss*Ke+Ts*Ke*Ke:Ss*Ke-Ts*Ke*Ke,g=Ke<0?ys*(Ke*-Ke-Ke)+Ke:ys*(Ke*Ke-Ke)+Ke,Ke=(S+Ms)%bs,Ke<-vs?Ke+=bs:Ke>vs&&(Ke-=bs),Ke=Ke<0?Ss*Ke+Ts*Ke*Ke:Ss*Ke-Ts*Ke*Ke,v=Ke<0?ys*(Ke*-Ke-Ke)+Ke:ys*(Ke*Ke-Ke)+Ke,Ke=w%bs,Ke<-vs?Ke+=bs:Ke>vs&&(Ke-=bs),Ke=Ke<0?Ss*Ke+Ts*Ke*Ke:Ss*Ke-Ts*Ke*Ke,x=Ke<0?ys*(Ke*-Ke-Ke)+Ke:ys*(Ke*Ke-Ke)+Ke,Ke=(w+Ms)%bs,Ke<-vs?Ke+=bs:Ke>vs&&(Ke-=bs),Ke=Ke<0?Ss*Ke+Ts*Ke*Ke:Ss*Ke-Ts*Ke*Ke,b=Ke<0?ys*(Ke*-Ke-Ke)+Ke:ys*(Ke*Ke-Ke)+Ke,vt=v*b,bt=_*x+i*g*b,yt=i*x-_*g*b,St=-v*x,Tt=_*b-i*g*x,Mt=i*b+_*g*x,wt=g,Ct=-i*v,Pt=_*v;let Ze=this.#js,Je=this.#Ys,Qe=this.#qs;H[0]=vt*Ze,H[1]=bt*Ze,H[2]=yt*Ze,H[3]=0,H[4]=St*Je,H[5]=Tt*Je,H[6]=Mt*Je,H[7]=0,H[8]=wt*Qe,H[9]=Ct*Qe,H[10]=Pt*Qe,H[11]=0}this.modelMatrix=this.localMatrix;{let i=this.normalModelMatrix,g=this.modelMatrix;L=g[0],k=g[1],z=g[2],H=g[3],q=g[4],W=g[5],be=g[6],Ke=g[7],Xe=g[8],je=g[9],Ye=g[10],Ze=g[11],Qe=g[12],et=g[13],tt=g[14],it=g[15],Je=L*W-k*q,ft=L*be-z*q,pt=L*Ke-H*q,xt=k*be-z*W,vt=k*Ke-H*W,bt=z*Ke-H*be,yt=Xe*et-je*Qe,St=Xe*tt-Ye*Qe,Tt=Xe*it-Ze*Qe,wt=je*it-Ze*et,Mt=Ye*it-Ze*tt,Pt=Je*Mt-ft*wt+pt*Mt+xt*Tt-vt*St+bt*yt,Pt=1/Pt,i[0]=(W*Mt-be*wt+Ke*Mt)*Pt,i[4]=(-k*Mt+z*wt-H*Mt)*Pt,i[8]=(et*bt-tt*vt+it*xt)*Pt,i[12]=(-je*bt+Ye*vt-Ze*xt)*Pt,i[1]=(-q*Mt+be*Tt-Ke*St)*Pt,i[5]=(L*Mt-z*Tt+H*St)*Pt,i[9]=(-Qe*bt+tt*pt-it*ft)*Pt,i[13]=(Xe*bt-Ye*pt+Ze*ft)*Pt,i[2]=(q*wt-W*Tt+Ke*yt)*Pt,i[6]=(-L*wt+k*Tt-H*yt)*Pt,i[10]=(Qe*vt-et*pt+it*Je)*Pt,i[14]=(-Xe*vt+je*pt-Ze*Je)*Pt,i[3]=(-q*Mt+W*St-be*yt)*Pt,i[7]=(L*Mt-k*St+z*yt)*Pt,i[11]=(-Qe*xt+et*ft-tt*Je)*Pt,i[15]=(Xe*xt-je*ft+Ye*Je)*Pt}if(this.#um.gpuRenderInfo){const{vertexUniformBuffer:i,vertexUniformInfo:g}=this.#um.gpuRenderInfo,{dataViewF32:x}=i,{members:_}=g,v=_.instanceModelMatrixs,b=_.instanceNormalModelMatrix,y=_.instanceOpacity;x.set(this.modelMatrix,(v.uniformOffset+v.stride*this.#om)/4),x.set(this.normalModelMatrix,(b.uniformOffset+b.stride*this.#om)/4),x.set([this.opacity],(y.uniformOffset+y.stride*this.#om)/4),this.#um.dirtyInstanceMeshObject3D=!0}}}var Cs=Object.freeze({__proto__:null,instancingMeshObject3D:InstancingMeshObject3D});class ResourceStateStorageBuffer{static dirtyList=[];buffer;uuid;#Zt=0;constructor(i){this.buffer=i,this.uuid=i.uuid}get useNum(){return this.#Zt}set useNum(i){this.#Zt=i,ResourceStateStorageBuffer.dirtyList.push(this)}}class StorageBuffer extends AUniformBaseBuffer{constructor(i,g,x="",_=""){super(i,"managedStorageBufferState",GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,g,x);const{table:v}=this.targetResourceManagedState,b=v.get(_);if(b)return b.buffer;_&&(this.name=_,this[er]=_),this.redGPUContext.resourceManager.registerManagementResource(this,new ResourceStateStorageBuffer(this))}}Object.freeze(StorageBuffer);var Ps="struct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(3) uv1:vec2<f32>, @location(4) vertexColor_0:vec4<f32>, @location(5) vertexTangent:vec4<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(10) localNodeScale_volumeScale:vec2<f32>, @location(11) instanceOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(14) @interpolate(flat) receiveShadow:f32, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\n";const Rs="VERTEX_MODULE_INSTANCING";class InstancingMesh extends Mesh{dirtyInstanceMeshObject3D=!0;dirtyInstanceNum=!0;#l;#cm=1;#hm=1;#fm=[];#_o;#dm;#mm;#pm;#gm;#xm;#_m=0;#vm=0;#bm;#bo=[];constructor(i,g,x,_,v){super(i,_,v),this.#l=i,this.#ne(),this.maxInstanceCount=g,this.instanceCount=x}get instanceCount(){return this.#cm}set instanceCount(i){validateUintRange(i),this.#cm=Math.min(i,this.#hm),this.gpuRenderInfo.vertexUniformInfo=parseWGSL(this.#ym(this.geometry,this.material)).storage.instanceUniforms,this.#Sm(),this.#fm.length>this.#cm&&(this.#fm.length=this.#cm);let g=this.#cm;for(;g--;)this.#fm[g]||(this.#fm[g]=new InstancingMeshObject3D(this.#l,g,this));this.#Tm(),this.#Uf(this.#l),this.dirtyInstanceNum=!0}get maxInstanceCount(){return this.#hm}set maxInstanceCount(i){validateUintRange(i);const g=InstancingMesh.getLimitSize();i=Math.min(i,g),this.#hm=i,this.#cm>this.#hm&&(this.instanceCount=this.#hm)}get instanceChildren(){return this.#fm}static getLimitSize(){const i=Math.floor(Math.min(268435456,134217728));return Math.floor((i-80)/132)}render(i,g=!1){if(this.dirtyLOD)return this.#Tm(),this.#Uf(this.#l),this.dirtyInstanceNum=!0,void(this.dirtyLOD=!1);const{view:x,currentRenderPassEncoder:_}=i,{scene:v}=x,{shadowManager:b}=v,{directionalShadowManager:y}=b,{castingList:S}=y;this.dirtyTransform&&this.#Mm(),this.geometry?i.num3DObjects++:i.num3DGroups++;const w=this.#l;if(this.geometry){const{antialiasingManager:x}=w;x.changedMSAA&&(this.dirtyPipeline=!0),this.gpuRenderInfo||this.#Uf(w);(this.dirtyPipeline||this.material.dirtyPipeline)&&this.#wm(i),g||this.#Cm(i),this.#Pm(i,g,_)}this.castShadow&&(S[S.length]=this);const{children:L}=this;let k=L.length;for(;k--;)L[k].dirtyTransform=this.dirtyTransform,L[k].render(i);this.dirtyTransform=!1}#Mm(){identity$1(this.localMatrix),translate(this.localMatrix,this.localMatrix,[this.x,this.y,this.z]),rotateX$2(this.localMatrix,this.localMatrix,this.rotationX),rotateY$2(this.localMatrix,this.localMatrix,this.rotationY),rotateZ$2(this.localMatrix,this.localMatrix,this.rotationZ),scale$4(this.localMatrix,this.localMatrix,[this.scaleX,this.scaleY,this.scaleZ]);const i=this.parent;i?.modelMatrix?multiply$4(this.modelMatrix,this.localMatrix,i.modelMatrix):this.modelMatrix=clone$4(this.localMatrix)}#wm(i){this.dirtyTransform=!0,this.material.dirtyPipeline&&this.material._updateFragmentState(),this.#Rm(),this.material.dirtyPipeline=!1,this.dirtyPipeline=!1,i.numDirtyPipelines++}#Pm(i,g,x){const{gpuRenderInfo:_}=this,{pipeline:v,shadowPipeline:b}=_;this.#Bm(),this.#Im();const{fragmentUniformBindGroup:y}=this.material.gpuRenderInfo;x.setBindGroup(0,i.view.systemUniform_Vertex_UniformBindGroup),x.setBindGroup(2,y),x.setPipeline(g?b:v);this.#Em(x,this.geometry,this.gpuRenderInfo.vertexUniformBindGroup,this.material.gpuRenderInfo.fragmentUniformBindGroup,0,20),this.LODManager.LODList.forEach((i,g)=>{const _=this.#bo[g];x.setPipeline(_.pipeline),this.#Em(x,i.geometry,_.vertexUniformBindGroup,i.material?i.material.gpuRenderInfo.fragmentUniformBindGroup:this.material.gpuRenderInfo.fragmentUniformBindGroup,g+1,20)}),i.numDrawCalls++,i.numInstances++}#Em(i,g,x,_,v,b){const{vertexBuffer:y,indexBuffer:S}=g,w=b*v;if(i.setBindGroup(1,x),i.setBindGroup(2,_),i.setVertexBuffer(0,y.gpuBuffer),S){const{gpuBuffer:g,format:x}=S;i.setIndexBuffer(g,x),i.drawIndexedIndirect(this.#bm,w)}else i.drawIndirect(this.#bm,w)}#Bm(){const{vertexUniformBuffer:i,vertexUniformInfo:g}=this.gpuRenderInfo,{displacementTexture:x,displacementScale:_}=this.material||{},{members:v}=g;void 0!==v.displacementScale&&this.#_o!==_&&(this.#_o=_,i.dataViewF32.set(new v.displacementScale.View([_]),v.displacementScale.uniformOffset/4)),void 0!==v.useDisplacementTexture&&this.#dm!==!!x&&(this.#dm=!!x,i.dataViewF32.set(new v.useDisplacementTexture.View([x?1:0]),v.useDisplacementTexture.uniformOffset/4))}#Im(){const{vertexUniformBuffer:i,vertexUniformInfo:g}=this.gpuRenderInfo,{gpuDevice:x}=this.#l,{members:_}=g;this.dirtyTransform&&(i.dataViewF32.set(this.modelMatrix,_.instanceGroupModelMatrix.uniformOffset/4),x.queue.writeBuffer(i.gpuBuffer,_.instanceGroupModelMatrix.uniformOffset,new _.instanceGroupModelMatrix.View(this.modelMatrix))),(this.dirtyInstanceMeshObject3D||this.dirtyInstanceNum)&&(x.queue.writeBuffer(i.gpuBuffer,0,i.data),this.dirtyInstanceMeshObject3D=!1,this.dirtyInstanceNum=!1)}#ne(){const{gpuDevice:i}=this.#l;this.gpuRenderInfo=new VertexGPURenderInfo(null,null,null,null,null,null,null,null);this.#bm=i.createBuffer({size:160,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,label:`IndirectDrawBuffer_${this.uuid}`});const g=new Float32Array(40);this.#gm=new StorageBuffer(this.#l,g.buffer,`CullingUniformBuffer_${this.uuid}`)}#Uf(i){this.dirtyPipeline=!0;const g=new ArrayBuffer(this.#_m*(this.LODManager.LODList.length+1));this.#xm?.destroy(),this.#xm=new StorageBuffer(i,g,`VisibilityBuffer_${this.uuid}`),this.#Rm(),this.#Dm(this.#l)}#Dm(i){const{gpuDevice:g,resourceManager:x}=i,_={code:this.#Um()},v=x.createGPUShaderModule(`CULLING_COMPUTE_MODULE_INSTANCING_${this.#hm}_${this.uuid}`,_),b=g.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});this.#mm=g.createComputePipeline({layout:g.createPipelineLayout({bindGroupLayouts:[b]}),compute:{module:v,entryPoint:"main"}}),this.#pm=g.createBindGroup({layout:b,entries:[{binding:0,resource:{buffer:this.gpuRenderInfo.vertexUniformBuffer.gpuBuffer}},{binding:1,resource:{buffer:this.#gm.gpuBuffer}},{binding:2,resource:{buffer:this.#xm.gpuBuffer}},{binding:3,resource:{buffer:this.#bm}}]})}#Lm(i){const{view:g}=i,{gpuDevice:x}=this.#l,{data:_,dataViewU32:v,dataViewF32:b}=this.#gm;v.set([this.#cm],0),v.set([this.#vm],1),v.set([this.LODManager.LODList.length],2),b.set(g.rawCamera.position,4),b.set(g.frustumPlanes.flat(),8),b.set([...this.LODManager.LODList.map(i=>i.distance)],32),x.queue.writeBuffer(this.#gm.gpuBuffer,0,_)}#Cm(i){const{gpuDevice:g}=this.#l;this.#Lm(i);const x=this.geometry.indexBuffer?this.geometry.indexBuffer.indexCount:this.geometry.vertexBuffer.vertexCount,_=new Uint32Array([x,0,0,0,0]);g.queue.writeBuffer(this.#bm,0,_),this.LODManager.LODList.forEach((i,x)=>{const _=i.geometry.indexBuffer.indexCount,v=new Uint32Array([_,0,0,0,0]),b=20*(x+1);g.queue.writeBuffer(this.#bm,b,v)});const v=g.createCommandEncoder(),b=v.beginComputePass();b.setPipeline(this.#mm),b.setBindGroup(0,this.#pm);const y=Math.ceil(this.#cm/64);b.dispatchWorkgroups(y),b.end(),g.queue.submit([v.finish()])}#Rm(){const{resourceManager:i,gpuDevice:g}=this.#l,x={code:this.#ym(this.geometry,this.material)},_=i.createGPUShaderModule(`${Rs}_${this.#hm}_${this.uuid}`,x),v=i.getGPUBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_Instancing);this.gpuRenderInfo.vertexShaderModule=_,this.gpuRenderInfo.pipeline=createBasePipeline(this,_,v),this.gpuRenderInfo.shadowPipeline=createBasePipeline(this,_,v,hi),this.gpuRenderInfo.vertexUniformBindGroup=g.createBindGroup(this.#Am()),this.#bo.length=0,this.LODManager.LODList.forEach((x,_)=>{const b={code:this.#ym(x.geometry,x.material)},y=i.createGPUShaderModule(`${Rs}_${this.#hm}_LOD${_}_${this.uuid}`,b);this.#bo[_]={pipeline:createBasePipeline({vertexStateBuffers:x.geometry.gpuRenderInfo.buffers,primitiveState:this.primitiveState,depthStencilState:this.depthStencilState,geometry:x.geometry,material:x.material||this.material,redGPUContext:this.#l,gpuRenderInfo:this.gpuRenderInfo},y,v),vertexUniformBindGroup:g.createBindGroup(this.#Am(_+1))}})}#Am(i=0){const{resourceManager:g}=this.#l,{vertexUniformBuffer:x}=this.gpuRenderInfo,{material:_}=this,{basicSampler:v,emptyBitmapTextureView:b}=g,{gpuSampler:y}=v,S=g.getGPUBindGroupLayout(ResourceManager.PRESET_VERTEX_GPUBindGroupLayout_Instancing),w=this.#_m,L=w*i,k=w;if(L+k>this.#xm.size)throw new Error("Binding range exceeds visibility buffer size.");return{layout:S,label:"VERTEX_BIND_GROUP_DESCRIPTOR_INSTANCING",entries:[{binding:0,resource:{buffer:x.gpuBuffer,offset:0,size:x.size}},{binding:1,resource:_?.displacementTextureSampler?.gpuSampler||y},{binding:2,resource:g.getGPUResourceBitmapTextureView(_?.displacementTexture)||b},{binding:3,resource:{buffer:this.#xm.gpuBuffer,offset:L,size:k}}]}}#Tm(){const i=4*this.#cm;this.#_m=256*Math.ceil(i/256),this.#vm=this.#_m/4}#Sm(){const i=this.gpuRenderInfo.vertexUniformInfo,g=new ArrayBuffer(i.arrayBufferByteLength),x=new StorageBuffer(this.#l,g,`InstanceBuffer_${this.uuid}`),_=this.gpuRenderInfo.vertexUniformBuffer;_?.gpuBuffer&&(x.dataViewF32.set(_.dataViewF32,0),x.dataViewU32.set([_.dataViewU32[0]],0),x.dataViewU32.set([_.dataViewU32[1]],4),_.destroy()),this.gpuRenderInfo.vertexUniformBuffer=x}#Gm(i,g="",x="",_="",v=""){return[g,x,_,i.replaceAll(/__INSTANCE_COUNT__/g,this.#hm.toString()),v].join("\n")}#ym(i,g){const x=i.vertexBuffer.interleavedStruct.label,_=g instanceof PBRMaterial,v="PBR"===x&&_,b=v?"struct InputData { @builtin(instance_index) instanceIdx:u32, @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(3) uv1:vec2<f32>, @location(4) vertexColor_0:vec4<f32>, @location(5) vertexTangent:vec4<f32>,\n};\n":"struct InputData { @builtin(instance_index) instanceIdx:u32, @location(0) position:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>,\n};",y="PBR"!==x&&_||v?Ps:"struct OutputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(11) instanceOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(14) @interpolate(flat) receiveShadow:f32, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n};\n";return this.#Gm("#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include calcDisplacements;\nstruct InstanceUniforms { useDisplacementTexture:u32, displacementScale:f32, instanceGroupModelMatrix:mat4x4<f32>, instanceModelMatrixs:array<mat4x4<f32>,__INSTANCE_COUNT__>, instanceNormalModelMatrix:array<mat4x4<f32>,__INSTANCE_COUNT__>, instanceOpacity:array<f32,__INSTANCE_COUNT__>,\n};\n@group(1) @binding(0) var<storage,read> instanceUniforms:InstanceUniforms;\n@group(1) @binding(1) var displacementTextureSampler:sampler;\n@group(1) @binding(2) var displacementTexture:texture_2d<f32>;\n@group(1) @binding(3) var<storage,read> visibilityBuffer:array<u32>;\nconst maxDistance:f32=1000.0;\nconst maxMipLevel:f32=10.0;",v?"@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; let input_instanceIdx:u32=visibilityBuffer[inputData.instanceIdx]; let u_modelMatrix=instanceUniforms.instanceModelMatrixs[input_instanceIdx]; let u_normalModelMatrix=instanceUniforms.instanceNormalModelMatrix[input_instanceIdx]; let u_instanceGroupModelMatrix=instanceUniforms.instanceGroupModelMatrix; let u_useDisplacementTexture=instanceUniforms.useDisplacementTexture==1u; let u_displacementScale=instanceUniforms.displacementScale; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let input_position=inputData.position; let input_vertexNormal=inputData.vertexNormal; let input_uv=inputData.uv; var position:vec4<f32>=u_modelMatrix * vec4<f32>(input_position,1.0); let worldPosition=position.xyz; if (u_useDisplacementTexture) { let distance=distance(position.xyz,u_cameraPosition); let mipLevel=(distance/maxDistance) * maxMipLevel; let displacedPosition=calcDisplacementPosition( input_position, input_vertexNormal, displacementTexture, displacementTextureSampler, u_displacementScale, input_uv, mipLevel ); position=u_modelMatrix * vec4<f32>(displacedPosition,1.0); } output.position=u_projectionCameraMatrix * u_instanceGroupModelMatrix * position; output.vertexPosition=position.xyz; var normalPosition:vec3<f32>=(u_instanceGroupModelMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0)).xyz; output.vertexNormal=normalPosition; output.instanceOpacity=instanceUniforms.instanceOpacity[input_instanceIdx]; output.uv=inputData.uv; output.uv1=inputData.uv1; output.vertexColor_0=inputData.vertexColor_0; output.vertexTangent=u_normalModelMatrix * inputData.vertexTangent; return output;\n}\n":"@vertex\nfn main(inputData:InputData) -> OutputData { var output:OutputData; let input_instanceIdx:u32=visibilityBuffer[inputData.instanceIdx]; let u_modelMatrix=instanceUniforms.instanceModelMatrixs[input_instanceIdx]; let u_normalModelMatrix=instanceUniforms.instanceNormalModelMatrix[input_instanceIdx]; let u_instanceGroupModelMatrix=instanceUniforms.instanceGroupModelMatrix; let u_useDisplacementTexture=instanceUniforms.useDisplacementTexture==1u; let u_displacementScale=instanceUniforms.displacementScale; let u_projectionMatrix=systemUniforms.projectionMatrix; let u_projectionCameraMatrix=systemUniforms.projectionCameraMatrix; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let input_position=inputData.position; let input_vertexNormal=inputData.vertexNormal; let input_uv=inputData.uv; var position:vec4<f32>=u_modelMatrix * vec4<f32>(input_position,1.0); let worldPosition=position.xyz; if (u_useDisplacementTexture) { let distance=distance(position.xyz,u_cameraPosition); let mipLevel=(distance/maxDistance) * maxMipLevel; let displacedPosition=calcDisplacementPosition( input_position, input_vertexNormal, displacementTexture, displacementTextureSampler, u_displacementScale, input_uv, mipLevel ); position=u_modelMatrix * vec4<f32>(displacedPosition,1.0); } output.position=u_projectionCameraMatrix * u_instanceGroupModelMatrix * position; output.vertexPosition=position.xyz; var normalPosition:vec3<f32>=(u_instanceGroupModelMatrix * u_normalModelMatrix * vec4<f32>(input_vertexNormal,1.0)).xyz; output.vertexNormal=normalPosition; output.uv=input_uv; output.instanceOpacity=instanceUniforms.instanceOpacity[input_instanceIdx]; return output;\n}\n",b,y,"\nstruct OutputShadowData { @builtin(position) position:vec4<f32>,\n};\n@vertex\nfn drawDirectionalShadowDepth(inputData:InputData) -> OutputShadowData { var output:OutputShadowData; let input_instanceIdx:u32=visibilityBuffer[inputData.instanceIdx]; let u_directionalLightProjectionViewMatrix=systemUniforms.directionalLightProjectionViewMatrix; let u_modelMatrix=instanceUniforms.instanceModelMatrixs[input_instanceIdx]; let u_useDisplacementTexture=instanceUniforms.useDisplacementTexture==1u; let u_displacementScale=instanceUniforms.displacementScale; let input_position=inputData.position; let input_vertexNormal=inputData.vertexNormal; let input_uv=inputData.uv; var position:vec4<f32>=u_modelMatrix * vec4<f32>(input_position,1.0); if (u_useDisplacementTexture) { let distance=distance(position.xyz,u_directionalLightProjectionViewMatrix[3].xyz); let mipLevel=(distance/maxDistance) * maxMipLevel; let displacedPosition=calcDisplacementPosition( input_position, input_vertexNormal, displacementTexture, displacementTextureSampler, u_displacementScale, input_uv, mipLevel ); position=u_modelMatrix * vec4<f32>(displacedPosition,1.0); } output.position=u_directionalLightProjectionViewMatrix * position; return output;\n}\n")}#Um(){return this.#Gm("struct InstanceUniforms { useDisplacementTexture:u32, displacementScale:f32, instanceGroupModelMatrix:mat4x4<f32>, instanceModelMatrixs:array<mat4x4<f32>,__INSTANCE_COUNT__>, instanceNormalModelMatrix:array<mat4x4<f32>,__INSTANCE_COUNT__>, instanceOpacity:array<f32,__INSTANCE_COUNT__>,\n};\nstruct CullingUniforms { instanceCount:u32, stride:u32, lodNum:u32, padding:f32, cameraPosition:vec3<f32>, frustumPlanes:array<vec4<f32>,6>, lodDistanceList:array<f32,7>,\n};\nstruct IndirectDrawArgs { vertexCount:u32, instanceCount:atomic<u32>, firstVertex:u32, baseVertex:u32, firstInstance:u32,\n};\n@group(0) @binding(0) var<storage,read> instanceUniforms:InstanceUniforms;\n@group(0) @binding(1) var<storage,read> cullingUniforms:CullingUniforms;\n@group(0) @binding(2) var<storage,read_write> visibilityBuffer:array<u32>;\n@group(0) @binding(3) var<storage,read_write> indirectDrawBuffer:array<IndirectDrawArgs>;\nconst BOUNDING_RADIUS:f32=1.0;\nfn distanceToPlane(position:vec3<f32>,plane:vec4<f32>) -> f32 { return dot(vec4<f32>(position,1.0),plane);\n}\nfn isInsideFrustum(position:vec3<f32>,radius:f32) -> bool { for (var i:u32=0u;i < 6u;i=i + 1u) { let plane=cullingUniforms.frustumPlanes[i]; let distance=distanceToPlane(position,plane); if (distance < -radius) { return false; } } return true;\n}\nfn calculateLODLevel(distanceToCamera:f32) -> u32 { if (cullingUniforms.lodNum==0u) { return 0u; } for (var i:u32=0u;i < cullingUniforms.lodNum;i=i + 1u) { if (distanceToCamera < cullingUniforms.lodDistanceList[i]) { return i; } } return cullingUniforms.lodNum;\n}\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) globalId:vec3<u32>) { let instanceIdx=globalId.x; if (instanceIdx >=(cullingUniforms.instanceCount)) { return; } let u_instanceGroupModelMatrix=instanceUniforms.instanceGroupModelMatrix; let modelMatrix=u_instanceGroupModelMatrix * instanceUniforms.instanceModelMatrixs[instanceIdx]; let worldPosition=vec3<f32>( modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2] ); let scaleX=length(vec3<f32>(modelMatrix[0][0],modelMatrix[0][1],modelMatrix[0][2])); let scaleY=length(vec3<f32>(modelMatrix[1][0],modelMatrix[1][1],modelMatrix[1][2])); let scaleZ=length(vec3<f32>(modelMatrix[2][0],modelMatrix[2][1],modelMatrix[2][2])); let maxScale=max(max(scaleX,scaleY),scaleZ); let scaledRadius=BOUNDING_RADIUS * maxScale; let isVisible=isInsideFrustum(worldPosition,scaledRadius); if (isVisible) { let distanceToCamera=distance(worldPosition,cullingUniforms.cameraPosition); let lodLevel=calculateLODLevel(distanceToCamera); let visibilityStride=cullingUniforms.stride; let aliveIndex=atomicAdd(&indirectDrawBuffer[lodLevel].instanceCount,1u); visibilityBuffer[visibilityStride * lodLevel + aliveIndex]=instanceIdx; }\n}\n")}}Object.defineProperty(InstancingMesh.prototype,"meshType",{value:Gr.INSTANCED_MESH,writable:!1});var Bs=Object.freeze({__proto__:null,CoreGroup:Ha,CoreInstancingMesh:Cs,CoreMesh:Fa,CoreSkyBox:Na,CoreSpriteSheet:Qa,CoreTextField:ms,CoreView:za,Group2D:Group2D,Group3D:Group3D,InstancingMesh:InstancingMesh,LINE_TYPE:us,Line2D:class extends Line3D{constructor(i,g=us.LINEAR,x="#fff"){super(i,g,x),this._material=new LineMaterial(i)}get geometry(){return this._geometry}set geometry(i){consoleAndThrowError("Line2D can not change geometry")}get material(){return this._material}set material(i){consoleAndThrowError("Line2D can not change material")}createCustomMeshVertexShaderModule=()=>this.createMeshVertexShaderModuleBASIC("VERTEX_MODULE_LINE_2D",fs,ds,ls);addPoint(i=0,g=0,x=this.baseColor,_=1,v=0,b=0,y=0,S=0){super.addPoint(i,g,0,x,_,v,b,0,y,S,0)}addPointAt(i,g=0,x=0,_=this.baseColor,v=1,b=0,y=0,S=0,w=0){super.addPointAt(i,g,x,0,_,v,b,y,0,S,w,0)}},Line3D:Line3D,Mesh:Mesh,PARTICLE_EASE:$a,ParticleEmitter:ParticleEmitter,Scene:Scene,SkyAtmosphere:SkyAtmosphere,SkyBox:SkyBox,Sprite2D:Sprite2D,Sprite3D:Sprite3D,SpriteSheet2D:SpriteSheet2D,SpriteSheet3D:SpriteSheet3D,SpriteSheetInfo:SpriteSheetInfo,TextField2D:TextField2D,TextField3D:TextField3D,View2D:View2D,View3D:View3D}),Is=Object.freeze({__proto__:null,ABaseLight:ABaseLight}),Es=Object.freeze({__proto__:null,AmbientLight:AmbientLight,Core:Is,DirectionalLight:DirectionalLight,LightManager:LightManager,PointLight:PointLight,SpotLight:SpotLight});function sortTransparentObjects(i,g){const x={},{x:_,y:v,z:b}=i;return g.sort((i,g)=>{if(i=i.mesh,g=g.mesh,!x[i.uuid]){const g=i.x-_,y=i.y-v,S=i.z-b;x[i.uuid]=g*g+y*y+S*S}if(!x[g.uuid]){const i=g.x-_,y=g.y-v,S=g.z-b;x[g.uuid]=i*i+y*y+S*S}return x[g.uuid]-x[i.uuid]})}var Ds=Object.freeze({__proto__:null,Ray:Ray,calculateNormals:calculateNormals,calculateTangents:(i,g,x,_,v)=>{const b=1e-6,y=i.length/3,S=_.length>0,w=S?_.length/3:y/3,L=new Float32Array(3*y),k=new Float32Array(3*y);for(let g=0;g<w;g++){const v=S?_[3*g]:3*g,y=S?_[3*g+1]:3*g+1,w=S?_[3*g+2]:3*g+2,z=i[3*v],H=i[3*v+1],q=i[3*v+2],W=i[3*y],be=i[3*y+1],Ke=i[3*y+2],Xe=i[3*w],je=i[3*w+1],Ye=i[3*w+2],Ze=x[2*v],Je=x[2*v+1],Qe=x[2*y],et=x[2*y+1],tt=W-z,it=Xe-z,ft=be-H,pt=je-H,xt=Ke-q,vt=Ye-q,bt=Qe-Ze,yt=x[2*w]-Ze,St=et-Je,Tt=x[2*w+1]-Je,Mt=bt*Tt-yt*St,wt=Math.abs(Mt)<b?0:1/Mt,Ct=(Tt*tt-St*it)*wt,Pt=(Tt*ft-St*pt)*wt,Rt=(Tt*xt-St*vt)*wt,Bt=(bt*it-yt*tt)*wt,It=(bt*pt-yt*ft)*wt,Et=(bt*vt-yt*xt)*wt;L[3*v]+=Ct,L[3*v+1]+=Pt,L[3*v+2]+=Rt,L[3*y]+=Ct,L[3*y+1]+=Pt,L[3*y+2]+=Rt,L[3*w]+=Ct,L[3*w+1]+=Pt,L[3*w+2]+=Rt,k[3*v]+=Bt,k[3*v+1]+=It,k[3*v+2]+=Et,k[3*y]+=Bt,k[3*y+1]+=It,k[3*y+2]+=Et,k[3*w]+=Bt,k[3*w+1]+=It,k[3*w+2]+=Et}const z=[],H=v&&v.length>=4*y;for(let i=0;i<y;i++){if(H){const g=v[4*i],x=v[4*i+1],_=v[4*i+2];if(Math.sqrt(g*g+x*x+_*_)>b){z.push(g,x,_,v[4*i+3]);continue}}const x=g[3*i],_=g[3*i+1],y=g[3*i+2],S=L[3*i],w=L[3*i+1],q=L[3*i+2],W=k[3*i],be=k[3*i+1],Ke=k[3*i+2],Xe=x*S+_*w+y*q;let je=S-x*Xe,Ye=w-_*Xe,Ze=q-y*Xe,Je=Math.sqrt(je*je+Ye*Ye+Ze*Ze);if(Je<b){const i=Math.abs(x)<.9?[1,0,0]:[0,1,0];je=i[0]-x*(x*i[0]+_*i[1]+y*i[2]),Ye=i[1]-_*(x*i[0]+_*i[1]+y*i[2]),Ze=i[2]-y*(x*i[0]+_*i[1]+y*i[2]),Je=Math.sqrt(je*je+Ye*Ye+Ze*Ze)}je/=Je,Ye/=Je,Ze/=Je;const Qe=(_*Ze-y*Ye)*W+(y*je-x*Ze)*be+(x*Ye-_*je)*Ke<0?-1:1;z.push(je,Ye,Ze,Qe)}return z},computeViewFrustumPlanes:computeViewFrustumPlanes,getScreenPoint:getScreenPoint,localToWorld:localToWorld,mat3:xt,mat4:Tt,matToEuler:mat4ToEuler,quat:dn,quaternionToRotationMat4:quaternionToRotationMat4,screenToWorld:screenToWorld,sortTransparentObjects:sortTransparentObjects,updateObject3DMatrix:updateObject3DMatrix,vec2:Sn,vec3:Ut,vec4:zt,worldToLocal:worldToLocal}),Us=Object.freeze({__proto__:null,GeometryGPURenderInfo:GeometryGPURenderInfo,Primitive:Primitive,createPrimitiveGeometry:createPrimitiveGeometry});function calculatePositionOnCurve(i,g,x,_,v){const b=Math.cos(i),y=Math.sin(i),S=x/g*i,w=Math.cos(S);v[0]=_*(2+w)*.5*b,v[1]=_*(2+w)*y*.5,v[2]=_*Math.sin(S)*.5}var Ls=Object.freeze({__proto__:null,Box:Box,Capsule:class extends Primitive{#Ei=function(){return function(i,g,x,_,v,b,y){const S=[],w=[],L=[];let k=0;const z=2*y+b,H=_/2,q=Math.PI/2*x,W=2*q+_;for(let i=0;i<=z;i++){const g=[];let w=0,z=0,be=0;if(i<y){const g=i/y*(Math.PI/2);w=H+x*Math.cos(g),z=x*Math.sin(g),be=i/y*q}else if(i<=y+b){const g=(i-y)/b;w=H-g*_,z=x,be=q+g*_}else{const g=(i-(y+b))/y,v=Math.PI/2+g*(Math.PI/2);w=-H+x*Math.cos(v),z=x*Math.sin(v),be=q+_+g*q}const Ke=be/W;for(let x=0;x<=v;x++){const _=x/v,L=_*Math.PI*2,q=z*Math.sin(L),W=z*Math.cos(L);S.push(q,w,W);const be=fromValues$3(q,i<y||i>y+b?w-(i<y?H:-H):0,W);normalize$3(be,be),S.push(be[0],be[1],be[2]),S.push(_,1-Ke),g.push(k++)}L.push(g)}for(let i=0;i<z;i++)for(let g=0;g<v;g++){const x=L[i][g+1],_=L[i][g],v=L[i+1][g],b=L[i+1][g+1];w.push(x,_,b),w.push(_,v,b)}return createPrimitiveGeometry(g,S,w,i)}}();constructor(i,g=.5,x=1,_=32,v=1,b=12){super(i);const y=`PRIMITIVE_CAPSULE_R${g}_CH${x}_RS${_}_HS${v}_CS${b}`,S=i.resourceManager.cachedBufferState;let w=S[y];w||(w=S[y]=this.#Ei(y,i,g,x,_,v,b)),this._setData(w)}},Circle:class extends Primitive{#Ei=function(){return function(i,g,x,_,v,b){const y=[],S=[];y.push(0,0,0,0,0,1,.5,.5);for(let i=0;i<=_;i++){const g=v+i/_*b,S=Math.cos(g),w=Math.sin(g),L=x*S,k=x*w,z=0,H=(S+1)/2,q=(w+1)/2;y.push(L,k,z,0,0,1,H,q)}for(let i=1;i<=_;i++)S.push(0,i,i+1);return createPrimitiveGeometry(g,y,S,i)}}();constructor(i,g=1,x=32,_=0,v=2*Math.PI){if(super(i),x<3)throw new Error("segments must be 3 or greater");if(g<=0)throw new Error("radius must be greater than 0");if(v<=0)throw new Error("thetaLength must be greater than 0");const b=`PRIMITIVE_CIRCLE_R${g}_S${x}_TS${_}_TL${v}`,y=i.resourceManager.cachedBufferState;let S=y[b];S||(S=y[b]=this.#Ei(b,i,g,x,_,v)),this._setData(S)}},Core:Us,Cylinder:Cylinder,Ground:class extends Primitive{#Ei=function(){const i=[],g=[];return function(x,_,v,b,y,S,w,L){const k=v/2,z=b/2,H=Math.floor(y)||1,q=Math.floor(S)||1,W=H+1,be=q+1,Ke=v/H,Xe=b/q;i.length=0,g.length=0;for(let x=0;x<be;x++){const _=x*Xe-z,v=L?(1-x/q)*w:x/q*w;for(let b=0;b<W;b++){const y=b*Ke-k,S=b/H*w;if(i.push(y,0,_,0,1,0,S,v),x<q&&b<H){const i=b+W*x,_=b+W*(x+1),v=b+1+W*(x+1),y=b+1+W*x;g.push(i,_,y),g.push(_,v,y)}}}return createPrimitiveGeometry(_,i,g,x)}}();constructor(i,g=1,x=1,_=1,v=1,b=1,y=!1){super(i);const S=`PRIMITIVE_GROUND_W${g}_H${x}_WS${_}_HS${v}_UV${b}_FY${y}`,w=i.resourceManager.cachedBufferState;let L=w[S];L||(L=w[S]=this.#Ei(S,i,g,x,_,v,b,y)),this._setData(L)}},Plane:Plane,Sphere:Sphere,Torus:class extends Primitive{#Ei=function(){return function(i,g,x,_,v,b,y,S){y=y||0;const w=(S=S||2*Math.PI)-y,L=v+1,k=b+1,z=[],H=[];for(let i=0;i<k;++i){const g=i/b,S=g*Math.PI*2,k=Math.sin(S),H=x+k*_,q=Math.cos(S),W=q*_;for(let i=0;i<L;++i){const x=i/v,_=y+x*w,b=Math.sin(_),S=Math.cos(_),L=b*H,be=S*H,Ke=b*k,Xe=S*k;z.push(L,W,be,Ke,q,Xe,x,1-g)}}for(let i=0;i<b;++i)for(let g=0;g<v;++g){const x=1+g,_=1+i;H.push(L*i+g,L*_+g,L*i+x),H.push(L*_+g,L*_+x,L*i+x)}return createPrimitiveGeometry(g,z,H,i)}}();constructor(i,g=1,x=.5,_=16,v=16,b=0,y=2*Math.PI){if(super(i),_<3)throw new Error("radialSubdivisions must be 3 or greater");if(v<3)throw new Error("verticalSubdivisions must be 3 or greater");const S=`PRIMITIVE_TORUS_R${g}_T${x}_RSD${_}_BSD${v}_SA${b}_EA${y}`,w=i.resourceManager.cachedBufferState;let L=w[S];L||(L=w[S]=this.#Ei(S,i,g,x,_,v,b,y)),this._setData(L)}},TorusKnot:class extends Primitive{#Ei=function(){return function(i,g,x,_,v,b,y,S){v=Math.floor(v),b=Math.floor(b);const w=[],L=[],k=[],z=[],H=[0,0,0],q=[0,0,0],W=[0,0,0],be=[0,0,0],Ke=[0,0,0];for(let i=0;i<=v;++i){const g=i/v*y*Math.PI*2;calculatePositionOnCurve(g,y,S,x,H),calculatePositionOnCurve(g+.01,y,S,x,q),be[0]=q[0]-H[0],be[1]=q[1]-H[1],be[2]=q[2]-H[2],Ke[0]=q[0]+H[0],Ke[1]=q[1]+H[1],Ke[2]=q[2]+H[2];{const i=be[0],g=be[1],x=be[2],_=Ke[0],v=Ke[1],b=Ke[2];W[0]=g*b-x*v,W[1]=x*_-i*b,W[2]=i*v-g*_}{const i=W[0],g=W[1],x=W[2],_=be[0],v=be[1],b=be[2];Ke[0]=g*b-x*v,Ke[1]=x*_-i*b,Ke[2]=i*v-g*_}{let i=W[0],g=W[1],x=W[2],_=i*i+g*g+x*x;_>0&&(_=1/Math.sqrt(_||1)),W[0]=W[0]*_,W[1]=W[1]*_,W[2]=W[2]*_}{let i=Ke[0],g=Ke[1],x=Ke[2],_=i*i+g*g+x*x;_>0&&(_=1/Math.sqrt(_)),Ke[0]=Ke[0]*_,Ke[1]=Ke[1]*_,Ke[2]=Ke[2]*_}for(let g=0;g<=b;++g){const x=g/b*Math.PI*2,y=-_*Math.cos(x),S=_*Math.sin(x);k[0]=H[0]+(y*Ke[0]+S*W[0]),k[1]=H[1]+(y*Ke[1]+S*W[1]),k[2]=H[2]+(y*Ke[2]+S*W[2]),w.push(k[0],k[1],k[2]);{z[0]=k[0]-H[0],z[1]=k[1]-H[1],z[2]=k[2]-H[2];let i=z[0],g=z[1],x=z[2],_=i*i+g*g+x*x;_>0&&(_=1/Math.sqrt(_)),z[0]=z[0]*_,z[1]=z[1]*_,z[2]=z[2]*_}w.push(z[0],z[1],z[2],i/v,g/b)}}for(let i=1;i<=v;i++)for(let g=1;g<=b;g++){const x=(b+1)*(i-1)+(g-1),_=(b+1)*i+(g-1),v=(b+1)*i+g,y=(b+1)*(i-1)+g;L.push(x,_,y),L.push(_,v,y)}return createPrimitiveGeometry(g,w,L,i)}}();constructor(i,g=1,x=.4,_=64,v=8,b=2,y=3){super(i);const S=`PRIMITIVE_TORUS_NUT_R${g}_T${x}_TS${_}_RS${v}_P${b}_Q${y}`,w=i.resourceManager.cachedBufferState;let L=w[S];L||(L=w[S]=this.#Ei(S,i,g,x,_,v,b,y)),this._setData(L)}}});const As=parseWGSL("#redgpu_include SYSTEM_UNIFORM;\n#redgpu_include calcTintBlendMode;\n#redgpu_include calcDirectionalShadowVisibility;\n#redgpu_include normalFunctions;\n#redgpu_include drawPicking;\n#redgpu_include FragmentOutput;\n#redgpu_include calculateMotionVector;\nstruct Uniforms { color:vec3<f32>, emissiveColor:vec3<f32>, emissiveStrength:f32, specularColor:vec3<f32>, specularStrength:f32, shininess:f32, aoStrength:f32, normalScale:f32, opacity:f32, useTint:u32, tint:vec4<f32>, tintBlendMode:u32, useSSR:u32, metallic:f32, roughness:f32,\n};\nstruct InputData { @builtin(position) position:vec4<f32>, @location(0) vertexPosition:vec3<f32>, @location(1) vertexNormal:vec3<f32>, @location(2) uv:vec2<f32>, @location(7) currentClipPos:vec4<f32>, @location(8) prevClipPos:vec4<f32>, @location(11) combinedOpacity:f32, @location(12) motionVector:vec3<f32>, @location(13) shadowPos:vec3<f32>, @location(14) @interpolate(flat) receiveShadow:f32, @location(15) @interpolate(flat) pickingId:vec4<f32>,\n}\n@group(2) @binding(0) var<uniform> uniforms:Uniforms;\n@group(2) @binding(1) var diffuseTextureSampler:sampler;\n@group(2) @binding(2) var diffuseTexture:texture_2d<f32>;\n@group(2) @binding(3) var alphaTextureSampler:sampler;\n@group(2) @binding(4) var alphaTexture:texture_2d<f32>;\n@group(2) @binding(5) var specularTextureSampler:sampler;\n@group(2) @binding(6) var specularTexture:texture_2d<f32>;\n@group(2) @binding(7) var emissiveTextureSampler:sampler;\n@group(2) @binding(8) var emissiveTexture:texture_2d<f32>;\n@group(2) @binding(9) var aoTextureSampler:sampler;\n@group(2) @binding(10) var aoTexture:texture_2d<f32>;\n@group(2) @binding(11) var normalTextureSampler:sampler;\n@group(2) @binding(12) var normalTexture:texture_2d<f32>;\n@fragment\nfn main(inputData:InputData) -> FragmentOutput { var output:FragmentOutput; let u_ambientLight=systemUniforms.ambientLight; let u_ambientLightColor=u_ambientLight.color; let u_ambientLightIntensity=u_ambientLight.intensity; let u_directionalLightCount=systemUniforms.directionalLightCount; let u_directionalLights=systemUniforms.directionalLights; let u_shadowDepthTextureSize=systemUniforms.shadowDepthTextureSize; let u_bias=systemUniforms.bias; let u_camera=systemUniforms.camera; let u_cameraMatrix=u_camera.cameraMatrix; let u_cameraPosition=u_camera.cameraPosition; let u_color=uniforms.color; let u_aoStrength=uniforms.aoStrength; let u_emissiveColor=uniforms.emissiveColor; let u_emissiveStrength=uniforms.emissiveStrength; let u_normalScale=uniforms.normalScale; let u_specularColor=uniforms.specularColor; let u_specularStrength=uniforms.specularStrength; let u_shininess=uniforms.shininess; let u_opacity=uniforms.opacity; let E=normalize(u_cameraPosition - inputData.vertexPosition); let receiveShadowYn=inputData.receiveShadow !=.0; var N=normalize(inputData.vertexNormal); #redgpu_if normalTexture let normalSamplerColor=textureSample(normalTexture,normalTextureSampler,inputData.uv).rgb; N=perturb_normal( N,inputData.vertexPosition,inputData.uv,normalSamplerColor,u_normalScale ); #redgpu_endIf var finalColor:vec4<f32>; var resultAlpha:f32=u_opacity * inputData.combinedOpacity; var diffuseColor:vec3<f32>=u_color; #redgpu_if diffuseTexture let diffuseSampleColor=textureSample(diffuseTexture,diffuseTextureSampler,inputData.uv); diffuseColor=diffuseSampleColor.rgb; resultAlpha=resultAlpha * diffuseSampleColor.a; #redgpu_endIf var specularSamplerValue:f32=1; #redgpu_if specularTexture specularSamplerValue=textureSample(specularTexture,specularTextureSampler,inputData.uv).r; #redgpu_endIf var mixColor:vec3<f32>; let ambientContribution=u_ambientLightColor * u_ambientLightIntensity; let ambientDiffuse=diffuseColor * ambientContribution; mixColor +=ambientDiffuse; var visibility:f32=1.0; visibility=calcDirectionalShadowVisibility( directionalShadowMap, directionalShadowMapSampler, u_shadowDepthTextureSize, u_bias, inputData.shadowPos, ); if(!receiveShadowYn){ visibility=1.0; } for (var i=0u;i < u_directionalLightCount;i=i + 1) { let u_directionalLightDirection=u_directionalLights[i].direction; let u_directionalLightColor=u_directionalLights[i].color; let u_directionalLightIntensity=u_directionalLights[i].intensity; let L=normalize(u_directionalLightDirection); let R=reflect(L,N); let lambertTerm=max(dot(N,-L),0.0); let specular=pow(max(dot(R,E),0.0),u_shininess) * specularSamplerValue; let lightContribution=u_directionalLightColor * u_directionalLightIntensity * visibility; let ld=diffuseColor * lightContribution * lambertTerm; let ls=u_specularColor * u_specularStrength * lightContribution * specular; mixColor +=ld + ls; } let clusterIndex=getClusterLightClusterIndex(inputData.position); let lightOffset=clusterLightGroup.lights[clusterIndex].offset; let lightCount:u32=clusterLightGroup.lights[clusterIndex].count; for (var lightIndex=0u;lightIndex < lightCount;lightIndex=lightIndex + 1u) { let i=clusterLightGroup.indices[lightOffset + lightIndex]; let u_clusterLightPosition=clusterLightList.lights[i].position; let u_clusterLightColor=clusterLightList.lights[i].color; let u_clusterLightIntensity=clusterLightList.lights[i].intensity; let u_clusterLightRadius=clusterLightList.lights[i].radius; let u_isSpotLight=clusterLightList.lights[i].isSpotLight; let lightDir=u_clusterLightPosition - inputData.vertexPosition; let lightDistance=length(lightDir); if (lightDistance > u_clusterLightRadius) { continue; } let L=normalize(lightDir); let dist2=max(dot(lightDir,lightDir),0.0001); let d=sqrt(dist2); let rangePart=pow(clamp(1.0 - d/u_clusterLightRadius,0.0,1.0),2.0); let invSquare=(u_clusterLightRadius * u_clusterLightRadius)/dist2; let attenuation=rangePart * invSquare; var finalAttenuation=attenuation; if (u_isSpotLight > 0.0) { let u_clusterLightDirection=normalize(vec3<f32>( clusterLightList.lights[i].directionX, clusterLightList.lights[i].directionY, clusterLightList.lights[i].directionZ )); let u_clusterLightInnerAngle=clusterLightList.lights[i].innerCutoff; let u_clusterLightOuterCutoff=clusterLightList.lights[i].outerCutoff; let lightToVertex=normalize(-lightDir); let cosTheta=dot(lightToVertex,u_clusterLightDirection); let cosOuter=cos(radians(u_clusterLightOuterCutoff)); let cosInner=cos(radians(u_clusterLightInnerAngle)); if (cosTheta < cosOuter) { continue; } let epsilon=cosInner - cosOuter; let spotIntensity=clamp((cosTheta - cosOuter)/epsilon,0.0,1.0); finalAttenuation *=spotIntensity; } let R=reflect(-L,N); let diffuse=diffuseColor * max(dot(N,L),0.0); let specular=pow(max(dot(R,E),0.0),u_shininess) * specularSamplerValue; let diffuseAttenuation=finalAttenuation; let specularAttenuation=finalAttenuation * finalAttenuation; let ld=u_clusterLightColor * diffuse * diffuseAttenuation * u_clusterLightIntensity; let ls=u_specularColor * u_specularStrength * specular * specularAttenuation * u_clusterLightIntensity; mixColor +=ld + ls; } #redgpu_if alphaTexture let alphaMapValue:f32=textureSample(alphaTexture,alphaTextureSampler,inputData.uv).r; resultAlpha=alphaMapValue * resultAlpha; if(resultAlpha==0){ discard;} #redgpu_endIf var emissiveColor=u_emissiveColor * u_emissiveStrength; #redgpu_if emissiveTexture emissiveColor=textureSample(emissiveTexture,emissiveTextureSampler,inputData.uv).rgb * u_emissiveStrength; #redgpu_endIf #redgpu_if aoTexture mixColor=mixColor * textureSample(aoTexture,aoTextureSampler,inputData.uv).rgb * u_aoStrength; #redgpu_endIf finalColor=vec4<f32>(mixColor + emissiveColor,resultAlpha); #redgpu_if useTint finalColor=calcTintBlendMode(finalColor,uniforms.tintBlendMode,uniforms.tint); #redgpu_endIf if (systemUniforms.isView3D==1 && finalColor.a==0.0) { discard; } output.color=finalColor; { let metallic=uniforms.metallic; let roughness=uniforms.roughness; let smoothness=1.0 - roughness; let smoothnessCurved=smoothness * smoothness * (3.0 - 2.0 * smoothness); let metallicWeight=metallic * metallic; let baseReflection=0.04 + 0.96 * metallicWeight; let baseReflectionStrength=smoothnessCurved * baseReflection; output.gBufferNormal=vec4<f32>(N * 0.5 + 0.5,baseReflectionStrength); } output.gBufferMotionVector=vec4<f32>(calculateMotionVector(inputData.currentClipPos,inputData.prevClipPos),0.0,1.0 ); return output;\n}\n");class PhongMaterial extends AUVTransformBaseMaterial{#km;#_o=1;constructor(i,g="#fff",x){super(i,"PHONG_MATERIAL",As,2),x&&(this.name=x),this.initGPURenderInfos(),this.color.setColorByHEX(g),this.emissiveColor.setColorByHEX(this.emissiveColor.hex),this.specularColor.setColorByHEX(this.specularColor.hex)}get displacementScale(){return this.#_o}set displacementScale(i){this.#_o=i}get displacementTexture(){return this.#km}set displacementTexture(i){const g=this.#km;this.#km=i,this.updateTexture(g,i),this.dirtyPipeline=!0}}dr.defineByPreset(PhongMaterial,[dr.PRESET_COLOR_RGB.COLOR,dr.PRESET_TEXTURE.ALPHA_TEXTURE,dr.PRESET_SAMPLER.ALPHA_TEXTURE_SAMPLER,dr.PRESET_TEXTURE.AO_TEXTURE,dr.PRESET_SAMPLER.AO_TEXTURE_SAMPLER,dr.PRESET_POSITIVE_NUMBER.AO_STRENGTH,dr.PRESET_TEXTURE.DIFFUSE_TEXTURE,dr.PRESET_SAMPLER.DIFFUSE_TEXTURE_SAMPLER,dr.PRESET_TEXTURE.EMISSIVE_TEXTURE,dr.PRESET_SAMPLER.EMISSIVE_TEXTURE_SAMPLER,dr.PRESET_POSITIVE_NUMBER.EMISSIVE_STRENGTH,[dr.PRESET_COLOR_RGB.EMISSIVE_COLOR,"#000000"],dr.PRESET_TEXTURE.NORMAL_TEXTURE,dr.PRESET_SAMPLER.NORMAL_TEXTURE_SAMPLER,dr.PRESET_POSITIVE_NUMBER.NORMAL_SCALE,dr.PRESET_TEXTURE.SPECULAR_TEXTURE,dr.PRESET_SAMPLER.SPECULAR_TEXTURE_SAMPLER,dr.PRESET_POSITIVE_NUMBER.SPECULAR_STRENGTH,[dr.PRESET_COLOR_RGB.SPECULAR_COLOR,"#ffffff"],[dr.PRESET_POSITIVE_NUMBER.SHININESS,32]]),dr.defineBoolean(PhongMaterial,[["useSSR",!1]]),dr.definePositiveNumber(PhongMaterial,[["metallic",0,0,1],["roughness",0,0,1]]),Object.freeze(PhongMaterial);var Gs=Object.freeze({__proto__:null,BLEND_MODE:Va,BitmapMaterial:BitmapMaterial,COMPOSITE_MODE:{ADDITIVE:"additive",SOURCE_OVER:"source-over",SOURCE_IN:"source-in",SOURCE_OUT:"source-out",SOURCE_ATOP:"source-atop",DESTINATION_OVER:"destination-over",DESTINATION_IN:"destination-in",DESTINATION_OUT:"destination-out",DESTINATION_ATOP:"destination-atop"},ColorMaterial:ColorMaterial,Core:wr,PBRMaterial:PBRMaterial,PhongMaterial:PhongMaterial,TINT_BLEND_MODE:Tr}),ks=Object.freeze({__proto__:null,ManagementResourceBase:ManagementResourceBase,ResourceBase:ResourceBase,ResourceManager:ResourceManager,ResourceStatusInfo:ResourceStatusInfo});var Os=Object.freeze({__proto__:null,ABaseBuffer:ABaseBuffer,AUniformBaseBuffer:AUniformBaseBuffer,getUniformOffsetByRoundUp:(i,g)=>((i+g-1)/g|0)*g}),Ns=Object.freeze({__proto__:null,VertexInterleavedStructElement:VertexInterleavedStructElement});class ResourceStateHDRTexture{texture;src;cacheKey;useNum=0;uuid;constructor(i){this.texture=i,this.src=i.src,this.cacheKey=i.cacheKey,this.useNum=0,this.uuid=i.uuid}}class HDRLoader{#Om=!0;constructor(i=!0){this.#Om=i}get enableDebugLogs(){return this.#Om}set enableDebugLogs(i){this.#Om=i}async loadHDRFile(i){this.#Om&&g(`HDR 파일 로딩 시작:${i}`);const x=await fetch(i);if(!x.ok)throw new Error(`HTTP ${x.status}:${x.statusText}`);const _=await x.arrayBuffer(),v=new Uint8Array(_),b=this.#Nm(v,i);return g({...b}),{...b}}#Nm(i,x){const _=this.#Vm(i);if(this.#Om&&g(`파일 형식:${_.format}`),!_.isValid)throw new Error(_.error||"지원되지 않는 파일 형식입니다");if(x.split("?")[0].toLowerCase().endsWith(".hdr")){this.#Om&&this.#Fm(i.slice(0,200));const g=this.#zm(i);return this.#Om&&this.#Hm(g),g}throw x.split("?")[0].toLowerCase().endsWith(".exr")?new Error("EXR format not supported yet"):new Error(`Unsupported HDR format:${x}`)}#zm(i){let x=0,_="";const v={};for(;x<i.length;){const g=String.fromCharCode(i[x++]);if("\n"===g)break;_+=g}if(!_.startsWith("#?RADIANCE")&&!_.startsWith("#?RGBE"))throw new Error("Invalid HDR file header");for(;x<i.length;){for(_="";x<i.length;){const g=String.fromCharCode(i[x++]);if("\n"===g)break;_+=g}if(""===_.trim())break;const g=_.indexOf("=");if(g>0){const i=_.substring(0,g).trim(),x=_.substring(g+1).trim();v[i]=x}}for(_="";x<i.length;){const g=String.fromCharCode(i[x++]);if("\n"===g)break;_+=g}const b=_.match(/-Y\s+(\d+)\s+\+X\s+(\d+)/);if(!b)throw new Error("Invalid resolution format in HDR file");const y=parseInt(b[1]),S=parseInt(b[2]);let w;v.EXPOSURE&&(w=parseFloat(v.EXPOSURE),this.#Om&&g(`파일 노출값:${w.toFixed(3)}`));const L=new Float32Array(S*y*4);let k=0;for(let g=0;g<y;g++){const g=this.#$m(i,x,S);x=g.nextOffset;for(let i=0;i<S;i++){const x=4*i,_=g.data[x],v=g.data[x+1],b=g.data[x+2],y=g.data[x+3];if(0===y)L[k++]=0,L[k++]=0,L[k++]=0,L[k++]=1;else{const i=Math.pow(2,y-128-8);L[k++]=_*i,L[k++]=v*i,L[k++]=b*i,L[k++]=1}}}return{data:L,width:S,height:y}}#Vm(i){if(i.length<50)return{isValid:!1,format:"unknown",error:"파일이 너무 작습니다"};const g=new TextDecoder("ascii",{fatal:!1}).decode(i.slice(0,50));return g.startsWith("#?RADIANCE")||g.startsWith("#?RGBE")?{isValid:!0,format:"RGBE/Radiance"}:g.includes("RADIANCE")||g.includes("RGBE")?{isValid:!0,format:"RGBE/Radiance (variant)"}:{isValid:!1,format:"unknown",error:"지원되지 않는 HDR 형식입니다"}}#$m(i,g,x){const _=new Uint8Array(4*x);if(2===i[g]&&2===i[g+1]&&i[g+2]===(x>>8&255)&&i[g+3]===(255&x)){g+=4;for(let v=0;v<4;v++){let b=v;for(;b<4*x;){const v=i[g++];if(v>128){const y=v-128,S=i[g++];for(let i=0;i<y&&b<4*x;i++)_[b]=S,b+=4}else{const y=v;for(let v=0;v<y&&b<4*x;v++)_[b]=i[g++],b+=4}}}}else for(let v=0;v<4*x;v++)_[v]=i[g++];return{data:_,nextOffset:g}}#Hm(i){if(this.#Om){g("HDR 정보:"),g(`크기:${i.width} x ${i.height}`),g(`데이터 길이:${i.data.length}`),g("예상 픽셀 수:"+i.width*i.height*4);for(let g=0;g<Math.min(16,i.data.length);g+=4)i.data[g],i.data[g+1],i.data[g+2],i.data[g+3]}}#Fm(i){if(this.#Om)for(let g=0;g<i.length;g+=16)Array.from(i.slice(g,g+16)).map(i=>i.toString(16).padStart(2,"0")).join(" "),Array.from(i.slice(g,g+16)).map(i=>i>=32&&i<=126?String.fromCharCode(i):".").join("")}}async function float32ToFloat16Linear(i,g,x){const _=performance.now(),{gpuDevice:v}=i,{width:b,height:y,workgroupSize:S=[8,8],maxValue:w=1e3}=x,L=g.length/4,k=function(i){return` struct Constants { width:u32, height:u32, }\n @group(0) @binding(0) var<storage,read> inputData:array<f32>; @group(0) @binding(1) var<storage,read_write> outputData:array<u32>; @group(0) @binding(2) var<uniform> constants:Constants;\n fn floatToHalf(value:f32) -> u32 { let bits=bitcast<u32>(value); let sign=(bits >> 16u) & 0x8000u; var exp=(bits >> 23u) & 0xFFu; var mantissa=bits & 0x7FFFFFu;\n if (exp==0u) { return sign; }\n if (exp==255u) { return sign | 0x7C00u | select(0u,1u,mantissa !=0u); }\n let newExp=i32(exp) - 127 + 15; if (newExp <=0) { return sign; } if (newExp >=31) { return sign | 0x7C00u; }\n return sign | (u32(newExp) << 10u) | (mantissa >> 13u); }\n @compute @workgroup_size(${i[0]},${i[1]}) fn main(@builtin(global_invocation_id) global_id:vec3<u32>) { let x=global_id.x; let y=global_id.y;\n if (x >=constants.width || y >=constants.height) { return; }\n let pixelIndex=y * constants.width + x; let baseIndex=pixelIndex * 4u;\n let r=inputData[baseIndex]; let g=inputData[baseIndex + 1u]; let b=inputData[baseIndex + 2u]; let a=inputData[baseIndex + 3u];\n let r16=floatToHalf(r); let g16=floatToHalf(g); let b16=floatToHalf(b); let a16=floatToHalf(a);\n let outputIndex=pixelIndex * 2u; outputData[outputIndex]=(g16 << 16u) | r16; outputData[outputIndex + 1u]=(a16 << 16u) | b16; } `}(S);try{const i=v.createShaderModule({code:k,label:"float16_linear_conversion_shader"}),x=function(i,g,x){const _=i.createBuffer({size:g.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,label:"float16_input_buffer"}),v=i.createBuffer({size:8*x,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC,label:"float16_output_buffer"}),b=i.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"float16_constants_buffer"}),y=i.createBuffer({size:8*x,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:"float16_read_buffer"});return i.queue.writeBuffer(_,0,g),{inputBuffer:_,outputBuffer:v,constantsBuffer:b,readBuffer:y}}(v,g,L);!function(i,g,x,_,v){const b=new ArrayBuffer(16),y=new DataView(b);y.setUint32(0,x,!0),y.setUint32(4,_,!0),y.setFloat32(8,v,!0),i.queue.writeBuffer(g,0,b)}(v,x.constantsBuffer,b,y,w);const{computePipeline:z,bindGroup:H}=function(i,g,x){const _=i.createComputePipeline({layout:"auto",compute:{module:g,entryPoint:"main"},label:"float16_conversion_pipeline"}),v=i.createBindGroup({layout:_.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:x.inputBuffer}},{binding:1,resource:{buffer:x.outputBuffer}},{binding:2,resource:{buffer:x.constantsBuffer}}],label:"float16_conversion_bindgroup"});return{computePipeline:_,bindGroup:v}}(v,i,x),q=await async function(i,g,x,_,v,b,y,S,w){const L=Math.ceil(b/S[0]),k=Math.ceil(y/S[1]);if(L>65535||k>65535)throw new Error(`이미지 크기 초과:${L} × ${k}`);const z=i.createCommandEncoder(),H=z.beginComputePass();H.setPipeline(g),H.setBindGroup(0,x),H.dispatchWorkgroups(L,k),H.end(),z.copyBufferToBuffer(_,0,v,0,8*w),i.queue.submit([z.finish()]),await v.mapAsync(GPUMapMode.READ);const q=new Uint32Array(v.getMappedRange()),W=new Uint16Array(q.buffer.slice(q.byteOffset,q.byteOffset+q.byteLength));return v.unmap(),W}(v,z,H,x.outputBuffer,x.readBuffer,b,y,S,L);!function(i){i.inputBuffer.destroy(),i.outputBuffer.destroy(),i.constantsBuffer.destroy(),i.readBuffer.destroy()}(x);return{data:q,processedPixels:L,executionTime:performance.now()-_}}catch(i){throw console.error("Float16 변환 실패:",i),i}}class HDRTexture extends ManagementResourceBase{#L;#A;#N=0;#Km=new HDRLoader;#F="rgba16float";#z;#H;#It=0;#Et=0;constructor(i,g,x,_){if(super(i,"managedHDRTextureState"),this.#z=x,this.#H=_,g){const i=this.#$(g);this.#Xm(i),this.#A=i,this.cacheKey=this.#K(g);const{table:x}=this.targetResourceManagedState;let _=x.get(this.cacheKey);if(_){const i=_.texture;return this.#z?.(i),i}this.src=g,this.#X()}}get width(){return this.#It}get height(){return this.#Et}get videoMemorySize(){return this.#N}get gpuTexture(){return this.#L}get src(){return this.#A}set src(i){const g=this.#$(i);this.#Xm(g),this.#A=g,this.cacheKey=this.#K(i),this.#A&&this.#jm(this.#A)}destroy(){const i=this.#L;this.#q(null),this.__fireListenerList(!0),this.#W(),this.#A=null,this.cacheKey=null,i&&i.destroy()}#K(i){let g;return i||(g=this.uuid),g="string"==typeof i?getAbsoluteURL(window.location.href,i):i.cacheKey||getAbsoluteURL(window.location.href,i.src),`HDRTexture_${g}`}#$(i){return"string"==typeof i?i:i.src}#Xm(i){if(!i||"string"!=typeof i)throw new Error("HDR 파일 경로가 필요합니다");if(!i.split("?")[0].split("#")[0].toLowerCase().endsWith(".hdr"))throw new Error(`지원되지 않는 형식입니다. .hdr 형식만 지원됩니다. 입력된 파일:${i}`)}async#jm(i){try{const g=await this.#Km.loadHDRFile(i);this.#It=g.width,this.#Et=g.height,await this.#Y(g),this.#z?.(this),this.__fireListenerList()}catch(i){console.error("HDR loading error:",i),this.#H?.(i)}}async#Y(i){const{gpuDevice:g}=this.redGPUContext,x=this.#L,_={size:[this.#It,this.#Et,1],format:this.#F,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,label:`HDRTexture_2D_${this.#A}`},v=g.createTexture(_),b=await float32ToFloat16Linear(this.redGPUContext,i.data,{width:this.#It,height:this.#Et,workgroupSize:[8,8]});g.queue.writeTexture({texture:v},b.data.buffer,{bytesPerRow:8*this.#It,rowsPerImage:this.#Et},{width:this.#It,height:this.#Et}),this.#q(v),x&&(await g.queue.onSubmittedWorkDone(),x.destroy())}#q(i){this.targetResourceManagedState.videoMemory-=this.#N,this.#L=i,this.#N=i?calculateTextureByteSize(i):0,this.targetResourceManagedState.videoMemory+=this.#N,this.__fireListenerList()}#X(){this.redGPUContext.resourceManager.registerManagementResource(this,new ResourceStateHDRTexture(this))}#W(){this.redGPUContext.resourceManager.unregisterManagementResource(this)}}Object.freeze(HDRTexture);const Vs={MODE_1D:1,MODE_2D:2,MODE_3D:3};Object.freeze(Vs);const Fs="managedBitmapTextureState",zs={animationSpeed:1,animationX:.1,animationY:.1};class ANoiseTexture extends ManagementResourceBase{mipLevelCount;useMipmap;src;#L;#me=8;#pe=8;#Nr=1;#Vr;#Fr;#zr;#Hr;#jn;#Ym;#It;#Et;#qm;#Wm=0;#Zm=1;#Jm=zs.animationX;#Qm=zs.animationY;#N=0;constructor(i,g=1024,x=1024,_){super(i,Fs),validateUintRange(g,2,2048),validateUintRange(x,2,2048),this.#It=g,this.#Et=x,this.#qm=_,this.#ne(i),this.cacheKey=`NoiseTexture_${g}x${x}_${Date.now()}`,this.#L=this.#li(i,g,x),this.#N=calculateTextureByteSize(this.#L),this.#hi(),this.#X()}get videoMemorySize(){return this.#N}get resourceManagerKey(){return Fs}get animationSpeed(){return this.#Zm}set animationSpeed(i){validatePositiveNumberRange(i),this.#Zm=i,this.updateUniform("animationSpeed",i)}get animationX(){return this.#Jm}set animationX(i){validateNumber(i),this.#Jm=i,this.updateUniform("animationX",i)}get animationY(){return this.#Qm}set animationY(i){validateNumber(i),this.#Qm=i,this.updateUniform("animationY",i)}get uniformInfo(){return this.#Ym}get gpuTexture(){return this.#L}get time(){return this.#Wm}set time(i){validatePositiveNumberRange(i),this.#Wm=i,this.updateUniform("time",i/1e3)}updateUniform(i,g){this.#Ym.members[i]&&(this.#jn.writeOnlyBuffer(this.#Ym.members[i],g),this.#qm[i]=g),this.#hi()}updateUniforms(i){Object.entries(i).forEach(([i,g])=>{this.#Ym.members[i]&&(this.#jn.writeOnlyBuffer(this.#Ym.members[i],g),this.#qm[i]=g)}),this.#hi()}render(i){this.updateUniform("time",i),this.#hi()}destroy(){const i=this.#L;this.__fireListenerList(!0),this.#W(),i&&i.destroy(),this.src=null,this.cacheKey=null,this.#L=null}#ne(i){const{gpuDevice:g}=i,x=this.#ep();this.cacheKey=this.uuid,this.#Vr=g.createShaderModule({code:x}),this.#zr=this.#oi(i),this.#Hr=this.#ui(g,this.#Vr,this.#zr);const _=parseWGSL(x);this.#Ym=_.uniforms.uniforms;const v=new ArrayBuffer(this.#Ym.arrayBufferByteLength);this.#jn=new UniformBuffer(i,v,`${this.constructor.name}_UniformBuffer`),this.#qm.uniformDefaults&&this.updateUniforms({...zs,...this.#qm.uniformDefaults})}#ep(){return` ${` struct Uniforms { time:f32, animationSpeed:f32, animationX:f32, animationY:f32, ${this.#qm.uniformStruct||""} }; `} @group(0) @binding(0) var<uniform> uniforms:Uniforms; @group(0) @binding(1) var outputTexture:texture_storage_2d<rgba8unorm,write>;  ${this.#qm.helperFunctions||""} @compute @workgroup_size(${this.#me},${this.#pe},${this.#Nr}) fn main ( @builtin(global_invocation_id) global_id:vec3<u32>, ){ let index=vec2<u32>(global_id.xy); let dimensions:vec2<u32>=textureDimensions(outputTexture);  if (index.x >=dimensions.x || index.y >=dimensions.y) { return; }  let dimW=f32(dimensions.x); let dimH=f32(dimensions.y); let base_uv=vec2<f32>((f32(index.x) + 0.5)/dimW,(f32(index.y) + 0.5)/dimH); ${this.#qm.mainLogic}  textureStore(outputTexture,index,finalColor); } `}#hi(){if(!this.#Fr)return;const i=this.redGPUContext.gpuDevice.createCommandEncoder(),g=i.beginComputePass();g.setPipeline(this.#Hr),g.setBindGroup(0,this.#Fr),g.dispatchWorkgroups(Math.ceil(this.#It/this.#me),Math.ceil(this.#Et/this.#pe)),g.end(),this.redGPUContext.gpuDevice.queue.submit([i.finish()])}#oi(i){return i.resourceManager.createBindGroupLayout("NoiseTextureBindGroupLayout",{entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm"}}]})}#li(i,g,x){const _=i.gpuDevice.createTexture({size:{width:g,height:x},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING,label:this.cacheKey}),v=_.createView();return this.#Fr=this.#ci(i,this.#zr,v),_}#ci(i,g,x){return i.gpuDevice.createBindGroup({layout:g,entries:[{binding:0,resource:{buffer:this.#jn.gpuBuffer,offset:0,size:this.#jn.gpuBuffer.size}},{binding:1,resource:x}]})}#ui(i,g,x){return i.createComputePipeline({layout:i.createPipelineLayout({bindGroupLayouts:[x]}),compute:{module:g,entryPoint:"main"}})}#X(){this.redGPUContext.resourceManager.registerManagementResource(this,new ResourceStateBitmapTexture(this))}#W(){this.redGPUContext.resourceManager.unregisterManagementResource(this)}}const mergerNoiseUniformStruct=(i,g)=>[i,g].filter(Boolean).join("\n"),mergerNoiseUniformDefault=(i,g)=>({...i,...g||{}}),mergerNoiseHelperFunctions=(i,g)=>[i,g].filter(Boolean).join("\n");const Hs=Object.values(Vs),$s={frequency:8,amplitude:1,octaves:1,persistence:.5,lacunarity:2,seed:0,noiseDimension:Vs.MODE_2D};const Ks={EUCLIDEAN:0,MANHATTAN:1,CHEBYSHEV:2};Object.freeze(Ks);const Xs={F1:0,F2:1,F2_MINUS_F1:2,F1_PLUS_F2:3,CELL_ID:4,CELL_ID_COLOR:5};Object.freeze(Xs);const js=Object.values(Ks),Ys=Object.values(Xs),qs={frequency:8,distanceScale:1,octaves:1,persistence:.5,lacunarity:2,seed:0,distanceType:Ks.EUCLIDEAN,outputType:Xs.F1,jitter:1,cellIdColorIntensity:1};var Ws=Object.freeze({__proto__:null,ANoiseTexture:ANoiseTexture,mergerNoiseHelperFunctions:mergerNoiseHelperFunctions,mergerNoiseUniformDefault:mergerNoiseUniformDefault,mergerNoiseUniformStruct:mergerNoiseUniformStruct});class IBL{#l;#tp;#np;#rp;#ip;#ap;#sp;#op;#up;#lp=!1;constructor(i,g,x=1024,_=512,v=64){const b=`${g}?key=${x}_${_}_${v}`;this.#op=_,this.#sp=x,this.#up=v,this.#l=i,this.#np=new IBLCubeTexture(i,`IBL_ENV_${b}`),this.#ip=new IBLCubeTexture(i,`IBL_SPECULAR_${b}`),this.#rp=new IBLCubeTexture(i,`IBL_IRRADIANCE_${b}`);const onLoad=async i=>{i.__addDirtyPipelineListener(this.#cp),i.gpuTexture&&await this.#cp(i)};this.#ap="string"==typeof g?new HDRTexture(i,g,onLoad):new CubeTexture(i,g,!0,onLoad)}#cp=async i=>{if((i=i||this.#ap)&&i.gpuTexture&&!this.#lp){this.#lp=!0;try{if(i instanceof HDRTexture){const{equirectangularToCubeGenerator:g}=this.#l.resourceManager,x=await g.generate(i.gpuTexture,this.#sp);this.#tp=x.gpuTexture}else this.#tp=i.gpuTexture;await this.#hp()}finally{this.#lp=!1}}};get environmentSize(){return this.#sp}get prefilterSize(){return this.#op}get irradianceSize(){return this.#up}get irradianceTexture(){return this.#rp}get environmentTexture(){return this.#np}get prefilterTexture(){return this.#ip}async#hp(){const{resourceManager:i}=this.#l,{prefilterGenerator:g,irradianceGenerator:x}=i;if(this.#tp){this.#np.gpuTexture=this.#tp;const i=await g.generate(this.#tp,this.#op);this.#ip.gpuTexture=i.gpuTexture;const _=await x.generate(this.#tp,this.#up);this.#rp.gpuTexture=_.gpuTexture}}}Object.freeze(IBL);var Zs=Object.freeze({__proto__:null,ShaderVariantGenerator:ShaderVariantGenerator,WGSLUniformTypes:WGSLUniformTypes,ensureVertexIndexBuiltin:ensureVertexIndexBuiltin,preprocessWGSL:preprocessWGSL}),Js=Object.freeze({__proto__:null,BitmapTexture:BitmapTexture,Core:ks,CoreBuffer:Os,CoreIBL:k,CoreNoiseTexture:Ws,CoreVertexBuffer:Ns,CoreWGSLParser:Zs,CubeTexture:CubeTexture,HDRTexture:HDRTexture,IBL:IBL,IndexBuffer:IndexBuffer,NOISE_DIMENSION:Vs,PackedTexture:PackedTexture,Sampler:Sampler,SimplexTexture:class extends ANoiseTexture{#fp=$s.frequency;#dp=$s.amplitude;#mp=$s.octaves;#pp=$s.persistence;#gp=$s.lacunarity;#xp=$s.seed;#_p=$s.noiseDimension;constructor(i,g=1024,x=1024,_){super(i,g,x,{..._,mainLogic:_?.mainLogic||" let uv=vec2<f32>( (base_uv.x + uniforms.time * ( uniforms.animationX * uniforms.animationSpeed )), (base_uv.y + uniforms.time * ( uniforms.animationY * uniforms.animationSpeed ))  ); let noise=getSimplexNoiseByDimension( uv,uniforms );  let finalColor=vec4<f32>(noise,noise,noise,1.0); ",uniformStruct:mergerNoiseUniformStruct(" noiseDimension:f32, frequency:f32, amplitude:f32, octaves:i32, persistence:f32, lacunarity:f32, seed:f32, ",_?.uniformStruct),uniformDefaults:mergerNoiseUniformDefault($s,_?.uniformDefaults),helperFunctions:mergerNoiseHelperFunctions("\nfn mod289_vec3(x:vec3<f32>) -> vec3<f32> { return x - floor(x * (1.0/289.0)) * 289.0;\n}\nfn mod289_vec2(x:vec2<f32>) -> vec2<f32> { return x - floor(x * (1.0/289.0)) * 289.0;\n}\nfn mod289_vec4(x:vec4<f32>) -> vec4<f32> { return x - floor(x * (1.0/289.0)) * 289.0;\n}\nfn mod289_f32(x:f32) -> f32 { return x - floor(x * (1.0/289.0)) * 289.0;\n}\nfn permute(x:vec3<f32>) -> vec3<f32> { return mod289_vec3(((x * 34.0) + 1.0) * x);\n}\nfn permute4(x:vec4<f32>) -> vec4<f32> { return mod289_vec4(((x * 34.0) + 1.0) * x);\n}\nfn permute_f32(x:f32) -> f32 { return mod289_f32(((x * 34.0) + 1.0) * x);\n}\nfn taylorInvSqrt4(r:vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r;\n}\nfn simplex1D(x:f32) -> f32 { var i=floor(x); let f=fract(x); let g0=select(-1.0,1.0,(permute_f32(i) * 0.024390243902439) >=0.5); let g1=select(-1.0,1.0,(permute_f32(i + 1.0) * 0.024390243902439) >=0.5); let d0=f; let d1=f - 1.0; let t=f * f * f * (f * (f * 6.0 - 15.0) + 10.0); let n0=g0 * d0; let n1=g1 * d1; return mix(n0,n1,t) * 0.395;\n}\nfn simplex2D(v:vec2<f32>) -> f32 { let C=vec4<f32>(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439); var i=floor(v + dot(v,C.yy)); let x0=v - i + dot(i,C.xx); let i1=select(vec2<f32>(0.0,1.0),vec2<f32>(1.0,0.0),x0.x > x0.y); var x12=x0.xyxy + C.xxzz; x12.x=x12.x - i1.x; x12.y=x12.y - i1.y; i=mod289_vec2(i); let p=permute(permute(i.y + vec3<f32>(0.0,i1.y,1.0)) + i.x + vec3<f32>(0.0,i1.x,1.0)); var m=max(0.5 - vec3<f32>(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),vec3<f32>(0.0)); m=m * m; m=m * m; let x=2.0 * fract(p * C.www) - 1.0; let h=abs(x) - 0.5; let ox=floor(x + 0.5); let a0=x - ox; m=m * (1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h)); let g=vec3<f32>(a0.x * x0.x + h.x * x0.y,a0.y * x12.x + h.y * x12.y,a0.z * x12.z + h.z * x12.w); return 130.0 * dot(m,g);\n}\nfn simplex3D(v:vec3<f32>) -> f32 { let C=vec2<f32>(1.0/6.0,1.0/3.0); let D=vec4<f32>(0.0,0.5,1.0,2.0); var i=floor(v + dot(v,C.yyy)); let x0=v - i + dot(i,C.xxx); let g=step(x0.yzx,x0.xyz); let l=1.0 - g; let i1=min(g.xyz,l.zxy); let i2=max(g.xyz,l.zxy); let x1=x0 - i1 + C.xxx; let x2=x0 - i2 + C.yyy; let x3=x0 - D.yyy; i=mod289_vec3(i); let p=permute4(permute4(permute4( i.z + vec4<f32>(0.0,i1.z,i2.z,1.0 )) + i.y + vec4<f32>(0.0,i1.y,i2.y,1.0 )) + i.x + vec4<f32>(0.0,i1.x,i2.x,1.0 )); let n_=0.142857142857; let ns=n_ * D.wyz - D.xzx; let j=p - 49.0 * floor(p * ns.z * ns.z); let x_=floor(j * ns.z); let y_=floor(j - 7.0 * x_ ); let x=x_ *ns.x + ns.yyyy; let y=y_ *ns.x + ns.yyyy; let h=1.0 - abs(x) - abs(y); let b0=vec4<f32>( x.xy,y.xy ); let b1=vec4<f32>( x.zw,y.zw ); let s0=floor(b0)*2.0 + 1.0; let s1=floor(b1)*2.0 + 1.0; let sh=-step(h,vec4<f32>(0.0)); let a0=b0.xzyw + s0.xzyw*sh.xxyy; let a1=b1.xzyw + s1.xzyw*sh.zzww; var p0=vec3<f32>(a0.xy,h.x); var p1=vec3<f32>(a0.zw,h.y); var p2=vec3<f32>(a1.xy,h.z); var p3=vec3<f32>(a1.zw,h.w); let norm=taylorInvSqrt4(vec4<f32>(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3))); p0 *=norm.x; p1 *=norm.y; p2 *=norm.z; p3 *=norm.w; var m=max(0.6 - vec4<f32>(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),vec4<f32>(0.0)); m=m * m; return 42.0 * dot( m*m,vec4<f32>( dot(p0,x0),dot(p1,x1), dot(p2,x2),dot(p3,x3) ) );\n}\nfn fbm1D(pos:f32,octaves:i32) -> f32 { var value=0.0; var amplitude=0.5; var frequency=1.0; var max_value=0.0; for (var i=0;i < octaves;i++) { if (i >=octaves) { break;} value +=simplex1D(pos * frequency) * amplitude; max_value +=amplitude; amplitude *=0.5; frequency *=2.0; } return value/max_value;\n}\nfn fbm(pos:vec2<f32>,octaves:i32) -> f32 { var value=0.0; var amplitude=0.5; var frequency=1.0; var max_value=0.0; for (var i=0;i < octaves;i++) { if (i >=octaves) { break;} value +=simplex2D(pos * frequency) * amplitude; max_value +=amplitude; amplitude *=0.5; frequency *=2.0; } return value/max_value;\n}\nfn fbm3D(pos:vec3<f32>,octaves:i32) -> f32 { var value=0.0; var amplitude=0.5; var frequency=1.0; var max_value=0.0; for (var i=0;i < octaves;i++) { if (i >=octaves) { break;} value +=simplex3D(pos * frequency) * amplitude; max_value +=amplitude; amplitude *=0.5; frequency *=2.0; } return value/max_value;\n}\nfn getSimplexNoise1D(pos:f32,uniforms:Uniforms) -> f32 { var total_amplitude:f32=0.0; var noise_value:f32=0.0; var current_amplitude:f32=1.0; var current_frequency:f32=uniforms.frequency; for (var i:i32=0;i < uniforms.octaves;i++) { let noise_pos=(pos + uniforms.seed) * current_frequency; let octave_noise=simplex1D(noise_pos); noise_value +=octave_noise * current_amplitude; total_amplitude +=current_amplitude; current_amplitude *=uniforms.persistence; current_frequency *=uniforms.lacunarity; } noise_value/=total_amplitude; noise_value *=uniforms.amplitude; let normalized_noise=(noise_value + 1.0) * 0.5; return normalized_noise;\n}\nfn getSimplexNoise2D(uv:vec2<f32>,uniforms:Uniforms) -> f32 { var total_amplitude:f32=0.0; var noise_value:f32=0.0; var current_amplitude:f32=1.0; var current_frequency:f32=uniforms.frequency; for (var i:i32=0;i < uniforms.octaves;i++) { let noise_pos=(uv + uniforms.seed) * current_frequency; let octave_noise=simplex2D(noise_pos); noise_value +=octave_noise * current_amplitude; total_amplitude +=current_amplitude; current_amplitude *=uniforms.persistence; current_frequency *=uniforms.lacunarity; } noise_value/=total_amplitude; noise_value *=uniforms.amplitude; let normalized_noise=(noise_value + 1.0) * 0.5; return normalized_noise;\n}\nfn getSimplexNoise3D(pos:vec3<f32>,uniforms:Uniforms) -> f32 { var total_amplitude:f32=0.0; var noise_value:f32=0.0; var current_amplitude:f32=1.0; var current_frequency:f32=uniforms.frequency; for (var i:i32=0;i < uniforms.octaves;i++) { let noise_pos=(pos + vec3<f32>(uniforms.seed)) * current_frequency; let octave_noise=simplex3D(noise_pos); noise_value +=octave_noise * current_amplitude; total_amplitude +=current_amplitude; current_amplitude *=uniforms.persistence; current_frequency *=uniforms.lacunarity; } noise_value/=total_amplitude; noise_value *=uniforms.amplitude; let normalized_noise=(noise_value + 1.0) * 0.5; return normalized_noise;\n}\nfn getSimplexNoiseByDimension(uv:vec2<f32>,uniforms:Uniforms) -> f32 { if (uniforms.noiseDimension < 1.1) { return getSimplexNoise1D(uv.x,uniforms); } else if (uniforms.noiseDimension < 2.1) { return getSimplexNoise2D(uv,uniforms); } else if (uniforms.noiseDimension < 3.1) { return getSimplexNoise3D(vec3<f32>(uv.x,uv.y,uniforms.seed * 0.1),uniforms); } else { return getSimplexNoise2D(uv,uniforms); }\n}\n",_?.helperFunctions)})}get noiseDimension(){return this.#_p}set noiseDimension(i){Hs.includes(i)?(this.#_p=i,this.updateUniform("noiseDimension",i)):consoleAndThrowError(`Invalid value for noiseDimension. Received ${i}. Expected one of:${Hs.join(",")}`)}get frequency(){return this.#fp}set frequency(i){validatePositiveNumberRange(i),this.#fp=i,this.updateUniform("frequency",i)}get amplitude(){return this.#dp}set amplitude(i){validatePositiveNumberRange(i),this.#dp=i,this.updateUniform("amplitude",i)}get octaves(){return this.#mp}set octaves(i){validateUintRange(i,1,8),this.#mp=i,this.updateUniform("octaves",i)}get persistence(){return this.#pp}set persistence(i){validatePositiveNumberRange(i,0,1),this.#pp=i,this.updateUniform("persistence",i)}get lacunarity(){return this.#gp}set lacunarity(i){validatePositiveNumberRange(i),this.#gp=i,this.updateUniform("lacunarity",i)}get seed(){return this.#xp}set seed(i){this.#xp=i,this.updateUniform("seed",i)}randomizeSeed(){this.seed=1e3*Math.random()}getSettings(){return{frequency:this.#fp,amplitude:this.#dp,octaves:this.#mp,persistence:this.#pp,lacunarity:this.#gp,seed:this.#xp}}applySettings(i){void 0!==i.frequency&&(this.frequency=i.frequency),void 0!==i.amplitude&&(this.amplitude=i.amplitude),void 0!==i.octaves&&(this.octaves=i.octaves),void 0!==i.persistence&&(this.persistence=i.persistence),void 0!==i.lacunarity&&(this.lacunarity=i.lacunarity),void 0!==i.seed&&(this.seed=i.seed)}},StorageBuffer:StorageBuffer,UniformBuffer:UniformBuffer,VORONOI_DISTANCE_TYPE:Ks,VORONOI_OUTPUT_TYPE:Xs,VertexBuffer:VertexBuffer,VertexInterleaveType:VertexInterleaveType,VertexInterleavedStruct:VertexInterleavedStruct,VoronoiTexture:class extends ANoiseTexture{#fp=qs.frequency;#vp=qs.distanceScale;#mp=qs.octaves;#pp=qs.persistence;#gp=qs.lacunarity;#xp=qs.seed;#bp=qs.distanceType;#yp=qs.outputType;#Sp=qs.jitter;#Tp=qs.cellIdColorIntensity;constructor(i,g=1024,x=1024,_){super(i,g,x,{..._,mainLogic:_?.mainLogic||" let uv=vec2<f32>( (base_uv.x + uniforms.time * (uniforms.animationX * uniforms.animationSpeed)), (base_uv.y + uniforms.time * (uniforms.animationY * uniforms.animationSpeed)) ); var finalColor:vec4<f32>; if (uniforms.outputType==5) { let colorNoise=getVoronoiColorNoise(uv,uniforms); finalColor=vec4<f32>(colorNoise,1.0); } else { let noise=getVoronoiNoise(uv,uniforms); finalColor=vec4<f32>(noise,noise,noise,1.0); } ",uniformStruct:mergerNoiseUniformStruct(" frequency:f32, distanceScale:f32, octaves:i32, persistence:f32, lacunarity:f32, seed:f32, distanceType:i32, outputType:i32, jitter:f32, cellIdColorIntensity:f32, ",_?.uniformStruct),uniformDefaults:mergerNoiseUniformDefault(qs,_?.uniformDefaults),helperFunctions:mergerNoiseHelperFunctions("fn hash22(p:vec2<f32>) -> vec2<f32> { var p3=fract(vec3<f32>(p.xyx) * vec3<f32>(0.1031,0.1030,0.0973)); p3 +=dot(p3,p3.yzx + 33.33); return fract((p3.xx + p3.yz) * p3.zy);\n}\nfn hash12(p:vec2<f32>) -> f32 { var p3=fract(vec3<f32>(p.xyx) * 0.1031); p3 +=dot(p3,p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z);\n}\nfn euclideanDistance(a:vec2<f32>,b:vec2<f32>) -> f32 { let d=a - b; return sqrt(d.x * d.x + d.y * d.y);\n}\nfn manhattanDistance(a:vec2<f32>,b:vec2<f32>) -> f32 { let d=abs(a - b); return d.x + d.y;\n}\nfn chebyshevDistance(a:vec2<f32>,b:vec2<f32>) -> f32 { let d=abs(a - b); return max(d.x,d.y);\n}\nfn calculateDistance(a:vec2<f32>,b:vec2<f32>,distanceType:i32) -> f32 { switch (distanceType) { case 0:{ return euclideanDistance(a,b);} case 1:{ return manhattanDistance(a,b);} case 2:{ return chebyshevDistance(a,b);} default:{ return euclideanDistance(a,b);} }\n}\nfn cellIdToColor(cellId:f32,intensity:f32) -> vec3<f32> { let h=cellId * 6.28318; let s=0.7 + 0.3 * fract(cellId * 7.0); let v=0.6 + 0.4 * fract(cellId * 13.0); let c=v * s; let x=c * (1.0 - abs(((h/1.047198) % 2.0) - 1.0)); let m=v - c; var rgb:vec3<f32>; let sector=i32(h/1.047198) % 6; switch (sector) { case 0:{ rgb=vec3<f32>(c,x,0.0);} case 1:{ rgb=vec3<f32>(x,c,0.0);} case 2:{ rgb=vec3<f32>(0.0,c,x);} case 3:{ rgb=vec3<f32>(0.0,x,c);} case 4:{ rgb=vec3<f32>(x,0.0,c);} default:{ rgb=vec3<f32>(c,0.0,x);} } return (rgb + m) * intensity;\n}\nstruct VoronoiResult { f1:f32, f2:f32, cellId:f32,\n}\nfn voronoiSingle(pos:vec2<f32>,frequency:f32,seed:f32,jitter:f32,distanceType:i32) -> VoronoiResult { let scaledPos=pos * frequency; let gridPos=floor(scaledPos); let localPos=fract(scaledPos); var minDist1=999.0; var minDist2=999.0; var closestCellId=0.0; for (var y=-1;y <=1;y++) { for (var x=-1;x <=1;x++) { let neighborGrid=gridPos + vec2<f32>(f32(x),f32(y)); let randomOffset=hash22(neighborGrid + seed); let jitteredOffset=mix(vec2<f32>(0.5),randomOffset,jitter); let cellPoint=vec2<f32>(f32(x),f32(y)) + jitteredOffset; let dist=calculateDistance(localPos,cellPoint,distanceType); if (dist < minDist1) { minDist2=minDist1; minDist1=dist; closestCellId=hash12(neighborGrid + seed); } else if (dist < minDist2) { minDist2=dist; } } } return VoronoiResult(minDist1,minDist2,closestCellId);\n}\nfn getVoronoiNoise(uv:vec2<f32>,uniforms:Uniforms) -> f32 { var total=0.0; var frequency=uniforms.frequency; var amplitude=1.0; var maxValue=0.0; for (var i=0;i < uniforms.octaves;i++) { let voronoiResult=voronoiSingle( uv, frequency, uniforms.seed + f32(i) * 100.0, uniforms.jitter, uniforms.distanceType ); let F1=voronoiResult.f1 * uniforms.distanceScale; let F2=voronoiResult.f2 * uniforms.distanceScale; let cellId=voronoiResult.cellId; var octaveValue:f32; switch (uniforms.outputType) { case 0:{ octaveValue=F1;} case 1:{ octaveValue=F2;} case 2:{ octaveValue=F2 - F1;} case 3:{ octaveValue=(F1 + F2) * 0.5;} case 4:{ octaveValue=cellId;}  case 5:{ let colorRGB=cellIdToColor(cellId,uniforms.cellIdColorIntensity); octaveValue=(colorRGB.r + colorRGB.g + colorRGB.b)/3.0; } default:{ octaveValue=F1;} } total +=octaveValue * amplitude; maxValue +=amplitude; frequency *=uniforms.lacunarity; amplitude *=uniforms.persistence; } return clamp(total/maxValue,0.0,1.0);\n}\nfn getVoronoiColorNoise(uv:vec2<f32>,uniforms:Uniforms) -> vec3<f32> { if (uniforms.outputType==5) {  let voronoiResult=voronoiSingle( uv, uniforms.frequency, uniforms.seed, uniforms.jitter, uniforms.distanceType ); return cellIdToColor(voronoiResult.cellId,uniforms.cellIdColorIntensity); } else { let grayValue=getVoronoiNoise(uv,uniforms); return vec3<f32>(grayValue,grayValue,grayValue); }\n}\n",_?.helperFunctions)})}get frequency(){return this.#fp}set frequency(i){validatePositiveNumberRange(i),this.#fp=i,this.updateUniform("frequency",i)}get distanceScale(){return this.#vp}set distanceScale(i){validatePositiveNumberRange(i),this.#vp=i,this.updateUniform("distanceScale",i)}get octaves(){return this.#mp}set octaves(i){validateUintRange(i,1,8),this.#mp=i,this.updateUniform("octaves",i)}get persistence(){return this.#pp}set persistence(i){validatePositiveNumberRange(i,0,1),this.#pp=i,this.updateUniform("persistence",i)}get lacunarity(){return this.#gp}set lacunarity(i){validatePositiveNumberRange(i),this.#gp=i,this.updateUniform("lacunarity",i)}get seed(){return this.#xp}set seed(i){this.#xp=i,this.updateUniform("seed",i)}get distanceType(){return this.#bp}set distanceType(i){js.includes(i)?(this.#bp=i,this.updateUniform("distanceType",i)):consoleAndThrowError(`Invalid value for distanceType. Received ${i}. Expected one of:${js.join(",")}`)}get outputType(){return this.#yp}set outputType(i){Ys.includes(i)?(this.#yp=i,this.updateUniform("outputType",i)):consoleAndThrowError(`Invalid value for outputType. Received ${i}. Expected one of:${Ys.join(",")}`)}get jitter(){return this.#Sp}set jitter(i){validatePositiveNumberRange(i,0,1),this.#Sp=i,this.updateUniform("jitter",i)}get cellIdColorIntensity(){return this.#Tp}set cellIdColorIntensity(i){validatePositiveNumberRange(i),this.#Tp=i,this.updateUniform("cellIdColorIntensity",i)}randomizeSeed(){this.seed=1e3*Math.random()}setEuclideanDistance(){this.distanceType=Ks.EUCLIDEAN}setManhattanDistance(){this.distanceType=Ks.MANHATTAN}setChebyshevDistance(){this.distanceType=Ks.CHEBYSHEV}setF1Output(){this.outputType=Xs.F1}setF2Output(){this.outputType=Xs.F2}setCrackPattern(){this.outputType=Xs.F2_MINUS_F1}setSmoothBlend(){this.outputType=Xs.F1_PLUS_F2}setCellIdOutput(){this.outputType=Xs.CELL_ID}setCellIdColorOutput(){this.outputType=Xs.CELL_ID_COLOR}setCellularPattern(){this.outputType=Xs.F1,this.distanceType=Ks.EUCLIDEAN,this.jitter=1}setStonePattern(){this.outputType=Xs.F2_MINUS_F1,this.distanceType=Ks.EUCLIDEAN,this.jitter=.8}setOrganicPattern(){this.distanceType=Ks.MANHATTAN,this.jitter=.6}setGridPattern(){this.jitter=0,this.distanceType=Ks.EUCLIDEAN}setCrystalPattern(){this.outputType=Xs.F2_MINUS_F1,this.distanceType=Ks.CHEBYSHEV,this.jitter=.9}setStainedGlassPattern(){this.outputType=Xs.CELL_ID_COLOR,this.distanceType=Ks.EUCLIDEAN,this.jitter=.7,this.cellIdColorIntensity=.8}setMosaicPattern(){this.outputType=Xs.CELL_ID_COLOR,this.distanceType=Ks.MANHATTAN,this.jitter=.3,this.cellIdColorIntensity=1}setBiomeMapPattern(){this.outputType=Xs.CELL_ID,this.distanceType=Ks.EUCLIDEAN,this.jitter=.8,this.frequency=4}getSettings(){return{frequency:this.#fp,distanceScale:this.#vp,octaves:this.#mp,persistence:this.#pp,lacunarity:this.#gp,seed:this.#xp,distanceType:this.#bp,outputType:this.#yp,jitter:this.#Sp,cellIdColorIntensity:this.#Tp}}applySettings(i){void 0!==i.frequency&&(this.frequency=i.frequency),void 0!==i.distanceScale&&(this.distanceScale=i.distanceScale),void 0!==i.octaves&&(this.octaves=i.octaves),void 0!==i.persistence&&(this.persistence=i.persistence),void 0!==i.lacunarity&&(this.lacunarity=i.lacunarity),void 0!==i.seed&&(this.seed=i.seed),void 0!==i.distanceType&&(this.distanceType=i.distanceType),void 0!==i.outputType&&(this.outputType=i.outputType),void 0!==i.jitter&&(this.jitter=i.jitter),void 0!==i.cellIdColorIntensity&&(this.cellIdColorIntensity=i.cellIdColorIntensity)}getDistanceTypeName(){return{[Ks.EUCLIDEAN]:"Euclidean",[Ks.MANHATTAN]:"Manhattan",[Ks.CHEBYSHEV]:"Chebyshev"}[this.#bp]||"Unknown"}getOutputTypeName(){return{[Xs.F1]:"F1",[Xs.F2]:"F2",[Xs.F2_MINUS_F1]:"F2-F1 (Crack)",[Xs.F1_PLUS_F2]:"F1+F2 (Blend)",[Xs.CELL_ID]:"Cell ID",[Xs.CELL_ID_COLOR]:"Cell ID Color"}[this.#yp]||"Unknown"}},parseWGSL:parseWGSL});class GltfAnimationLooperManager{#Mp=60;#wp=1e3/this.#Mp;#Wi=0;#Cp=0;render=(i,g,x,_)=>{const v=g;this.#Wi;this.#wp,this.#Wi=v,this.#Cp++;const b=et,y=180/Math.PI;let S,w,L,k,z,H,q,W,be,Ke,Xe,je,Ye,Ze,Je,Qe,tt,it,ft,pt,xt,vt,bt,yt,St,Tt,Mt,wt,Ct,Pt,Rt,Bt,It,Et,Dt,Ut,Lt,At,Gt,kt,Ot,Nt,Vt,Ft,zt,Ht,$t,Kt,Xt,jt,Yt,qt,Wt,Zt,Jt,Qt,en,tn,nn,rn,an,sn,on,un,cn,hn,fn,dn,mn=_.length;for(;mn--;){an=_[mn],rn=an.targetGLTFParsedSingleClip,nn=rn.length;const v=rn.maxTime;for(;nn--;){sn=rn[nn],on=sn.cacheTable;const{animationTargetMesh:_,timeAnimationInfo:et,aniDataAnimationInfo:mn,weightMeshes:pn}=sn;_.dirtyTransform=!0,Jt=(g-an.startTime)%(1e3*v)/1e3,hn=et.dataList,fn=mn.dataList,dn=hn.length;const gn=sn.lastPrevIdx||0;if(gn<dn-1)if(hn[gn]<=Jt&&Jt<hn[gn+1])cn=gn,un=gn+1;else if(gn+1<dn-1&&hn[gn+1]<=Jt&&Jt<hn[gn+2])cn=gn+1,un=gn+2;else if(Jt<=hn[0])cn=dn-1,un=0;else if(Jt>=hn[dn-1])cn=dn-1,un=0;else{let i=0,g=dn-1;for(;i<g-1;){const x=i+g>>1;hn[x]<=Jt?i=x:g=x}cn=i,un=g}else if(Jt<=hn[0])cn=dn-1,un=0;else if(Jt>=hn[dn-1])cn=dn-1,un=0;else{let i=0,g=dn-1;for(;i<g-1;){const x=i+g>>1;hn[x]<=Jt?i=x:g=x}cn=i,un=g}let xn,_n,vn,bn,yn,Sn,Tn;sn.lastPrevIdx=cn,Qt=hn[cn],en=hn[un];const Mn=sn.interpolation;if("CUBICSPLINE"==Mn){const i=en-Qt;tn=i==i?i:0;const g=(Jt-Qt)/tn;xn=g==g?g:0,_n=xn*xn,vn=_n*xn,Sn=-2*vn+3*_n,Tn=vn-_n,bn=1-Sn,yn=Tn-_n+xn}else if("STEP"==Mn)tn=0;else{const i=(Jt-Qt)/(en-Qt);tn=i==i?i:0}switch(sn.key){case"rotation":if(cn!==dn-1){if("CUBICSPLINE"===Mn){let i,g,x,_,v,b,y,Je;Gt=12*cn,kt=12*un,S=fn[Gt+4],w=fn[Gt+5],L=fn[Gt+6],k=fn[Gt+7],z=S*S+w*w+L*L+k*k,z>0?(H=1/Math.sqrt(z),q=S*H,W=w*H,be=L*H,Ke=k*H):(q=W=be=0,Ke=1),S=fn[Gt+8],w=fn[Gt+9],L=fn[Gt+10],k=fn[Gt+11],z=S*S+w*w+L*L+k*k,z>0?(H=1/Math.sqrt(z),i=S*H,g=w*H,x=L*H,_=k*H):(i=g=x=0,_=1),S=fn[kt],w=fn[kt+1],L=fn[kt+2],k=fn[kt+3],z=S*S+w*w+L*L+k*k,z>0?(H=1/Math.sqrt(z),v=S*H,b=w*H,y=L*H,Je=k*H):(v=b=y=0,Je=1),S=fn[kt+4],w=fn[kt+5],L=fn[kt+6],k=fn[kt+7],z=S*S+w*w+L*L+k*k,z>0?(H=1/Math.sqrt(z),Xe=S*H,je=w*H,Ye=L*H,Ze=k*H):(Xe=je=Ye=0,Ze=1),S=bn*q+yn*i*tn+Sn*Xe+Tn*v*tn,w=bn*W+yn*g*tn+Sn*je+Tn*b*tn,L=bn*be+yn*x*tn+Sn*Ye+Tn*y*tn,k=bn*Ke+yn*_*tn+Sn*Ze+Tn*Je*tn}else{Gt=cn<<2,kt=un<<2;const i=Gt<<16|kt;let g=on[i];g?(Je=g[0],q=g[1],W=g[2],be=g[3],Ke=g[4],Xe=g[5],je=g[6],Ye=g[7],Ze=g[8]):(S=fn[Gt],w=fn[Gt+1],L=fn[Gt+2],k=fn[Gt+3],z=S*S+w*w+L*L+k*k,z>0?(H=1/Math.sqrt(z),q=S*H,W=w*H,be=L*H,Ke=k*H):(q=W=be=0,Ke=1),S=fn[kt],w=fn[kt+1],L=fn[kt+2],k=fn[kt+3],z=S*S+w*w+L*L+k*k,z>0?(H=1/Math.sqrt(z),Xe=S*H,je=w*H,Ye=L*H,Ze=k*H):(Xe=je=Ye=0,Ze=1),Je=q*Xe+W*je+be*Ye+Ke*Ze,Je<0&&(Je=-Je,Xe=-Xe,je=-je,Ye=-Ye,Ze=-Ze),g=new Float32Array(9),g[0]=Je,g[1]=q,g[2]=W,g[3]=be,g[4]=Ke,g[5]=Xe,g[6]=je,g[7]=Ye,g[8]=Ze,on[i]=g),1-Je>b?(Qe=Math.acos(Je),tt=Math.sin(Qe),it=Math.sin((1-tn)*Qe)/tt,ft=Math.sin(tn*Qe)/tt):(it=1-tn,ft=tn),S=it*q+ft*Xe,w=it*W+ft*je,L=it*be+ft*Ye,k=it*Ke+ft*Ze}pt=S+S,xt=w+w,vt=L+L,bt=S*pt,yt=S*xt,St=S*vt,Tt=w*xt,Mt=w*vt,wt=L*vt,Ct=k*pt,Pt=k*xt,Rt=k*vt,Et=St+Pt,Bt=1-(Tt+wt),It=yt-Rt,Ut=Mt-Ct,At=1-(bt+Tt),Lt=Mt+Ct,Dt=1-(bt+wt),w=Math.asin(Math.max(-1,Math.min(1,Et))),Math.abs(Et)<.99999?(S=Math.atan2(-Ut,At),L=Math.atan2(-It,Bt)):(S=Math.atan2(Lt,Dt),L=0),_.rotationX=S*y,_.rotationY=w*y,_.rotationZ=L*y}break;case"translation":"CUBICSPLINE"===Mn?cn!==dn-1&&(Gt=9*cn,Ot=fn[Gt+3],Nt=fn[Gt+4],Vt=fn[Gt+5],jt=fn[Gt+6],Yt=fn[Gt+7],qt=fn[Gt+8],kt=9*un,$t=fn[kt],Kt=fn[kt+1],Xt=fn[kt+2],Ft=fn[kt+3],zt=fn[kt+4],Ht=fn[kt+5],Wt=jt*tn,Zt=$t*tn,_.x=bn*Ft+yn*Wt+Sn*Ot+Tn*Zt,Wt=Yt*tn,Zt=Kt*tn,_.y=bn*zt+yn*Wt+Sn*Nt+Tn*Zt,Wt=qt*tn,Zt=Xt*tn,_.z=bn*Ht+yn*Wt+Sn*Vt+Tn*Zt):(Gt=3*un,Ot=fn[Gt],Nt=fn[Gt+1],Vt=fn[Gt+2],kt=3*cn,Ft=fn[kt],zt=fn[kt+1],Ht=fn[kt+2],_.x=Ft+tn*(Ot-Ft),_.y=zt+tn*(Nt-zt),_.z=Ht+tn*(Vt-Ht));break;case"scale":"CUBICSPLINE"===Mn?cn!==dn-1&&(Gt=9*cn,Ot=fn[Gt+3],Nt=fn[Gt+4],Vt=fn[Gt+5],jt=fn[Gt+6],Yt=fn[Gt+7],qt=fn[Gt+8],kt=9*un,$t=fn[kt],Kt=fn[kt+1],Xt=fn[kt+2],Ft=fn[kt+3],zt=fn[kt+4],Ht=fn[kt+5],Wt=jt*tn,Zt=$t*tn,_.scaleX=bn*Ft+yn*Wt+Sn*Ot+Tn*Zt,Wt=Yt*tn,Zt=Kt*tn,_.scaleY=bn*zt+yn*Wt+Sn*Nt+Tn*Zt,Wt=qt*tn,Zt=Xt*tn,_.scaleZ=bn*Ht+yn*Wt+Sn*Vt+Tn*Zt):(Gt=3*un,Ot=fn[Gt],Nt=fn[Gt+1],Vt=fn[Gt+2],kt=3*cn,Ft=fn[kt],zt=fn[kt+1],Ht=fn[kt+2],_.scaleX=Ft+tn*(Ot-Ft),_.scaleY=zt+tn*(Nt-zt),_.scaleZ=Ht+tn*(Vt-Ht));break;case"weights":{let g=pn.length;for(;g--;)sn.renderWeight(i,x,pn[g],tn,cn,un);break}}}}}}!function(i,g){void 0===g&&(g={});var x=g.insertAt;if("undefined"!=typeof document){var _=document.head||document.getElementsByTagName("head")[0],v=document.createElement("style");v.type="text/css","top"===x&&_.firstChild?_.insertBefore(v,_.firstChild):_.appendChild(v),v.styleSheet?v.styleSheet.cssText=i:v.appendChild(document.createTextNode(i))}}(".RedGPUDebugPanel{background:rgba(0,0,0,.9);bottom:0;color:#fff;font-size:11px;left:0;line-height:1;max-height:100%;min-width:250px;overflow-y:auto;position:fixed;transform:translateZ(0);width:330px;will-change:transform;z-index:2}.RedGPUDebugPanel::-webkit-scrollbar{width:6px}.RedGPUDebugPanel::-webkit-scrollbar-track{background:#000}.RedGPUDebugPanel::-webkit-scrollbar-thumb{background:#333}.RedGPUDebugPanel::-webkit-scrollbar-thumb:hover{background:#444}.debug-group{line-height:1.4;padding:10px;b{color:#fdb48d;font-weight:700}}.debug-sub-group{background:linear-gradient(90deg,hsla(0,0%,100%,.1),rgba(0,0,0,.01));border:1px solid hsla(0,0%,100%,.16);border-radius:6px;box-shadow:0 0 10px rgba(0,0,0,.16);line-height:1.4;margin:8px 0;padding:6px 10px;b{color:#fdb48d;font-weight:700}}.debug-sub-group-title{color:#e3b096}.debug-item{align-items:center;color:#ccc;display:flex;font-weight:400;gap:10px;justify-content:space-between;transform:translateZ(0);width:100%;will-change:transform;b{color:#fdb48d;font-weight:700}}.boolean-true{background:green}.boolean-false,.boolean-true{border-radius:4px;color:#fff;line-height:1;margin:2px 0;padding:2px 4px}.boolean-false{background:red}.debug-folder{background:rgba(0,0,0,.5);border-bottom:1px solid hsla(0,0%,100%,.05);display:flex;flex-direction:column;width:100%}.debug-folder-title{color:#fdb48d;font-size:15px;b{color:#fdb48d;font-size:11px;font-weight:700}}.debug-folder-small-title,.debug-folder-title{align-items:center;background:linear-gradient(0deg,rgba(0,0,0,.95),hsla(0,0%,100%,.055));cursor:pointer;display:flex;justify-content:space-between;line-height:1;padding:10px 8px;width:100%}.debug-folder-small-title{color:#fff;font-size:12px;b{color:#fdb48d;font-size:11px;font-weight:700}}.debug-folder-title .onoff{font-size:11px}.debug-item-title{color:#888;max-width:240px}.debug-item-cache-key,.debug-item-title{font-weight:500;overflow:hidden;text-overflow:ellipsis;text-shadow:1px 1px 0 rgba(0,0,0,.3)}.debug-item-cache-key{color:#fff;max-width:250px;white-space:nowrap}.div-line{background:hsla(0,0%,100%,.06);border-bottom:1px solid transparent;height:1px;margin:10px 0;width:100%}.root-padding{padding:6px;width:100%}.color-box{border:1px solid hsla(0,0%,100%,.2);border-radius:4px;margin:2px;padding:3px}");const createDebugTitle=i=>`<div>${i}</div>`,makeColorDebug=(i,g)=>`\n<div class='debug-item'>\n\x3c!--\t<span class='debug-item-title'>${i}</span> --\x3e\n\t<span class='debug-item-title'></span> \n\t<div style="border:1px solid rgba(255,255,255,0.2);border-radius:4px;background:rgba(${g.rgba});padding:3px;margin:2px"> ${g.rgba}\n\t</div>\n</div>\n`,makeBooleanDebug=(i,g)=>`<span class="${g?"boolean-true":"boolean-false"}">${g?"TRUE":"FALSE"}</span>`,getDebugFormatValue=i=>"boolean"==typeof i?i.toString():"number"==typeof i?i.toLocaleString():i,updateDebugItemValue=(i,g,x,_,v="")=>{const b=i.querySelector(`.${g}`);if(!b)return;const y=`${getDebugFormatValue(x)}${v}`;b.innerHTML!==y&&(b.innerHTML=y,_&&(b.style.background=x?"green":"rgba(255,255,255,0.1)"))};let Qs=class{dom;#Pp;#Rp=!1;constructor(i){this.#Pp=i,this.dom=document.createElement("div"),this.dom.innerHTML=` <div class="debug-folder">\t <div class="debug-folder-small-title" style="display:flex;align-items:center;justify-content:space-between;cursor:pointer;"> ${createDebugTitle(`${i} Num:<span class="totalCount"></span> (<b class="targetVideoMemorySize"></b>)`)}\n\x3c!-- <div class="onoff">${this.#Rp?"close":"open"}</div>--\x3e </div> <div class="item-container" style="display:none"></div> </div>\n`}get openYn(){return this.#Rp}set openYn(i){this.#Rp=i,this.dom.querySelector(".onoff").innerHTML=this.openYn?"close":"open"}update(i,g){const{resourceManager:x}=g;if("Buffer"===this.#Pp){const g=x.resources.get("GPUBuffer"),{videoMemory:_}=g;i.totalUsedVideoMemory+=_,updateDebugItemValue(this.dom,"totalCount",g.size),updateDebugItemValue(this.dom,"targetVideoMemorySize",formatBytes(_))}else{const g=x[`managed${this.#Pp}State`],{table:_,videoMemory:v}=g;i.totalUsedVideoMemory+=v,updateDebugItemValue(this.dom,"totalCount",_.size),updateDebugItemValue(this.dom,"targetVideoMemorySize",formatBytes(v)),this.#Pp}}#Bp(i){let g=i;(i.startsWith("Vertex_")||i.startsWith("Index_"))&&(g=i.substring(i.indexOf("_")+1));try{const i=new URL(g),x=i.pathname.split("/").pop()||g;return{host:i.host,filename:x}}catch{return{host:null,filename:g}}}#Ip(i){const g=this.dom.querySelector(".item-container"),x=new Set,_=this.#Pp,v=new Map;g.querySelectorAll(".debug-group").forEach(i=>{const g=i.className.split(" ")[1].replace(`${_}_`,"");x.add(g),v.set(g,i)});let b=0;i.forEach((i,y)=>{const S=y,w=i.size||0,L=`${_}_${S}`;let k=v.get(S);k?x.delete(S):(k=document.createElement("div"),k.className=`debug-group ${L}`,k.innerHTML=` <div class='debug-item'> <div> <div class='debug-item-title'><span style="white-space:nowrap"> <span class="host"></span> <div class="name"></div> </span></div> <div style="font-size:10px">${S}</div> </div> <div style="display:flex;flex-direction:column;align-items:center;gap:4px;width:50px"> <span style="white-space:nowrap"><b class="videoMemorySize"></b></span> </div> </div> `,g.appendChild(k));const{host:z,filename:H}=this.#Bp(y);z?(updateDebugItemValue(k,"host",`${b} ${z}`),updateDebugItemValue(k,"name",H)):updateDebugItemValue(k,"host",`${b} ${y}`),updateDebugItemValue(k,"videoMemorySize",formatBytes(w)),b++});for(let i of x)v.get(i).remove()}#Ep(i){const g=this.dom.querySelector(".item-container"),x=new Set,_=this.#Pp,v=new Map;g.querySelectorAll(".debug-group").forEach(i=>{const g=i.className.split(" ")[1].replace(`${_}_`,"");x.add(g),v.set(g,i)});let b=0;const y="UniformBuffer"===this.#Pp||"StorageBuffer"===this.#Pp;i.forEach(i=>{const{useNum:S,buffer:w}=i,{uuid:L,size:k,name:z,gpuBuffer:H}=w,{label:q}=H,W=`${_}_${L}`;let be=v.get(L);be?x.delete(L):(be=document.createElement("div"),be.className=`debug-group ${W}`,be.innerHTML=` <div class='debug-item'> <div style="display:flex;flex-direction:column;width:100%"> <div class='debug-item-title'><span style="white-space:nowrap"> <span class="host"></span> <div class="name"></div> </span></div> <div style="font-size:10px">${L}</div> </div> <div style="display:flex;flex-direction:column;align-items:center;gap:4px;width:50px;min-width:50px"> <span class='useNum' style="display:${y?"none":"block"};padding:2px 4px;border-radius:4px;width:100%;text-align:center"></span> <span style="white-space:nowrap"><b class="videoMemorySize"></b></span> </div> </div> `,g.appendChild(be));const{host:Ke,filename:Xe}=this.#Bp(z);Ke?(updateDebugItemValue(be,"host",`${b} ${Ke}`),updateDebugItemValue(be,"name",Xe)):updateDebugItemValue(be,"host",`${b} ${q}`),y||updateDebugItemValue(be,"useNum",S,!0),updateDebugItemValue(be,"videoMemorySize",formatBytes(k)),b++});for(let i of x)v.get(i).remove()}};class DebugBufferList{debugStatisticsDomService;constructor(i){this.debugStatisticsDomService=new Qs(i)}get dom(){return this.debugStatisticsDomService.dom}update(i,g){this.debugStatisticsDomService.update(i,g)}}class ADebugItem{debugStatisticsDomService;constructor(){}get dom(){return this.debugStatisticsDomService.dom}update(i,g,x){this.debugStatisticsDomService.update(i,g)}}class ADebugStatisticsDomService{dom;#Rp=!1;constructor(){}get openYn(){return this.#Rp}set openYn(i){this.#Rp=i,this.dom.querySelector(".onoff").innerHTML=this.openYn?"close":"open"}init(i,g=!1,x=!1){this.#Rp=g,this.dom=document.createElement("div"),this.dom.innerHTML=` <div class="debug-folder">\t <div class="${x?"debug-folder-small-title":"debug-folder-title"}"> ${i}\n\x3c!-- <div class="onoff">${this.openYn?"close":"open"}</div>--\x3e </div> <div class="item-container" style="display:${g?"":"none"}"></div> </div>\n`}update(i,g){}}const eo=["useMSAA","useFXAA","useTAA","alphaMode","renderScale"];let to=class extends ADebugStatisticsDomService{constructor(){super(),this.init(`${createDebugTitle("RedGPUContext")}`,!0),this.#Ep()}update(i,g){eo.forEach(i=>this.#Dp(g,i)),this.#Up(g)}#Ep(){const i=this.dom.querySelector(".item-container"),g=['<div class="debug-group">',...eo.map(i=>this.#Lp(i)),this.#Lp("width_height"),this.#Lp("pixelRectArray"),this.#Lp("backgroundColor"),"</div>"];i.innerHTML=g.join("")}#Lp(i){return` <div class='debug-item'> ${i} <span class='debug-item-title redGPUContext_${i}'/> </div> `}#Dp(i,g){const x=["useMSAA","useFXAA","useTAA"].includes(g),_=x?i.antialiasingManager[g]:i[g];updateDebugItemValue(this.dom,`redGPUContext_${g}`,x?makeBooleanDebug(0,_):getDebugFormatValue(_))}#Up(i){const{sizeManager:g,width:x,height:_,backgroundColor:v}=i,{pixelRectArray:b}=g;updateDebugItemValue(this.dom,"redGPUContext_width_height",`${x},${_}`),updateDebugItemValue(this.dom,"redGPUContext_pixelRectArray",b),updateDebugItemValue(this.dom,"redGPUContext_backgroundColor",makeColorDebug("backgroundColor",v))}};class DebugRedGPUContext extends ADebugItem{constructor(){super(),this.debugStatisticsDomService=new to}}let no=class extends ADebugStatisticsDomService{#Ap;constructor(i){super(),this.#Ap=i,this.init(`${createDebugTitle(`${i}Texture Num:<span class="totalCount"></span> (<b class="targetVideoMemorySize"></b>)`)}`,!1,!0)}update(i,g){if("Packed"===this.#Ap)this.#Gp(i,g);else{const{resourceManager:x}=g,{managedBitmapTextureState:_,managedCubeTextureState:v,managedHDRTextureState:b}=x,{table:y,videoMemory:S}="Bitmap"===this.#Ap?_:"Cube"===this.#Ap?v:b;i.totalUsedVideoMemory+=S,updateDebugItemValue(this.dom,"totalCount",y.size),updateDebugItemValue(this.dom,"targetVideoMemorySize",formatBytes(S))}}getTargetSrc(i){if("Packed"===this.#Ap)return i.src||"packed texture";if(i instanceof ResourceStateCubeTexture){const{cacheKey:g}=i;return`${g}...`}{const{src:g}=i;return g?g.startsWith("data:")?"base64 texture":g:"null"}}getUpdatedTdom(i,g,x,_,v,b){return i||((i=document.createElement("div")).className=`debug-group ${x}`,i.innerHTML=` <div class='debug-item'> \t<div style="display:flex;flex-direction:column;width:100%"> <div class='debug-item-title'>${_} <span class="targetSrc" style="white-space:nowrap">${v||""}</span></div>  <div class='debug-item-cache-key'><span class="host">Place holder for host</span></div> <div class='debug-item-cache-key'><span class="fileName">Place holder for fileName</span></div> <div>mipLevelCount:<span class="mipLevelCount"></span>/useMipmap:<span class="useMipmap"></span></div> <div>width:<span class="width"></span>/height:<span class="height"></span></div> </div> <div style="display:flex;flex-direction:column;align-items:center;gap:4px;width:50px;min-width:50px"> <span class='useNum' style="display:${"HDR"===this.#Ap?"none":"block"}padding:2px 4px;border-radius:4px;width:100%;text-align:center"></span> <span><b class="videoMemorySize"></b></span> </div> </div> <div style="font-size:10px">${b}</div> `,g.appendChild(i)),i}updateDebugItems(i,g,x,_,v,b,y,S,w){updateDebugItemValue(i,"mipLevelCount",g),updateDebugItemValue(i,"useMipmap",x),updateDebugItemValue(i,"width",_),updateDebugItemValue(i,"height",v),"HDR"!==this.#Ap&&updateDebugItemValue(i,"useNum",b,!0);const{host:L,filename:k}=this.#Bp(y);L?(updateDebugItemValue(i,"host",L),updateDebugItemValue(i,"fileName",k)):updateDebugItemValue(i,"fileName",y),updateDebugItemValue(i,"targetSrc","null"===S?"":S),updateDebugItemValue(i,"videoMemorySize",formatBytes(w))}#Gp(i,g){const x=PackedTexture.getCacheMap(),_=this.#kp(x);let v=0;_.forEach(i=>{v+=i.texture.videoMemorySize}),i.totalUsedVideoMemory+=v,updateDebugItemValue(this.dom,"totalCount",_.size),updateDebugItemValue(this.dom,"targetVideoMemorySize",formatBytes(v))}#kp(i){const g=new Map;return i.forEach((i,x)=>{const _={gpuTexture:i.gpuTexture,uuid:i.uuid,mipLevelCount:i.gpuTexture.mipLevelCount||1,useMipmap:(i.gpuTexture.mipLevelCount||1)>1,videoMemorySize:this.#Op(i.gpuTexture)},v={useNum:i.useNum,cacheKey:x,texture:_,src:`packed:${x.substring(0,50)}${x.length>50?"...":""}`,mappingKey:i.mappingKey};g.set(x,v)}),g}#Op(i){const g=i.label?.match(/(\d+)x(\d+)/);if(g){const x=parseInt(g[1]),_=parseInt(g[2]),v=i.mipLevelCount||1;let b=0;for(let i=0;i<v;i++){b+=Math.max(1,x>>i)*Math.max(1,_>>i)*4}return b}return 4194304}#Bp(i){if("Packed"===this.#Ap){try{const g=i.split("}_");if(g.length>=2){const i=g[0]+"}";g[1];return{host:"packed",filename:`${i.substring(0,20)}...`}}}catch{}return{host:"packed",filename:i.length>30?i.substring(0,30)+"...":i}}try{const g=new URL(i),x=g.pathname.split("/").pop()||i;return{host:g.host,filename:x}}catch{const g=i.split("_");return{host:g[0],filename:g.pop()||i}}}#Ep(i){const g=this.dom.querySelector(".item-container"),x=new Set,_="Bitmap"===this.#Ap?"cube_texture":"Cube"===this.#Ap?"bitmap_texture":"HDR"===this.#Ap?"hdr_texture":"packed_texture";g.querySelectorAll(".debug-group").forEach(i=>{const g=i.className.split(" ")[1].replace(`${_}_`,"");x.add(g)});let v=0;for(const b of i.values()){const{useNum:i,cacheKey:y,texture:S}=b;let w=this.getTargetSrc(b);const{mipLevelCount:L,useMipmap:k,gpuTexture:z,uuid:H,videoMemorySize:q}=S,{width:W,height:be}=z||{},Ke=`${_}_${S.uuid}`;let Xe=g.querySelector(`.${Ke}`);Xe=this.getUpdatedTdom(Xe,g,Ke,v,w,H),x.delete(S.uuid),this.updateDebugItems(Xe,L,k,W,be,i,y,w,q),v++}for(let i of x)g.querySelector(`.${_}_${i}`)?.remove()}};class DebugTextureList extends ADebugItem{constructor(i="Bitmap"){super(),this.debugStatisticsDomService=new no(i)}}const ro=["totalNum3DGroups","totalNum3DObjects","totalNumInstances","totalNumDrawCalls","totalNumTriangles","totalNumPoints","totalUsedVideoMemory"];let io=class{dom;constructor(){this.dom=document.createElement("div"),this.#Np()}update(i){ro.forEach(g=>{const x=i[g],_="totalUsedVideoMemory"===g?`<b>${formatBytes(x)}</b>`:x;updateDebugItemValue(this.dom,g,_)})}#Np(){const i=this.#Ep();this.dom.innerHTML=` <div class="debug-group"> ${createDebugTitle("Total State")} <div>${i}</div>  </div> `}#Ep(){return ro.map(i=>"totalUsedVideoMemory"===i?`<div class='debug-item'>${i}<span class='debug-item-title'/><b class="${i}"></b></div>`:`<div class='debug-item'>${i}<span class='debug-item-title ${i}'/></div>`).join("")}};class DebugTotalState extends ADebugItem{constructor(){super(),this.debugStatisticsDomService=new io}}const ao=["usedVideoMemory","viewRenderTime","num3DGroups","num3DObjects","numInstances","numDrawCalls","numTriangles","numPoints"],so={viewRenderTime:"ms"},oo={camera:"camera.name",scene:"scene.name",useBackgroundColor:"scene.useBackgroundColor",backgroundColor:"scene.backgroundColor",x_y:"x,y",width_height:"width,height"};let uo=class extends ADebugStatisticsDomService{#Vp=0;constructor(){super(),this.init(`${createDebugTitle("ViewList")}`,!0)}update(i,g){const{viewList:x,numViews:_}=g;this.#Vp!==_&&(this.#Fp(x),this.#Vp=_),x.forEach((g,x)=>{ao.forEach(_=>this.#Dp(g,x,_,i)),this.#Up(g,x)})}#Lp(i,g){return` <div class='debug-item'> ${oo[g]||g} <span class='debug-item-title view${i}_${g}'/> </div> `}#Fp(i){const g=this.dom.querySelector(".item-container"),x=i.map((i,g)=>{const{name:x}=i,_=ao.map(i=>this.#Lp(g,i));return _.push('<div class="debug-sub-group">',this.#Lp(g,"x_y"),this.#Lp(g,"width_height"),this.#Lp(g,"pixelRectArray"),this.#Lp(g,"camera"),this.#Lp(g,"scene"),this.#Lp(g,"useBackgroundColor"),this.#Lp(g,"backgroundColor"),"</div>"),`${createDebugTitle(`<div class="debug-sub-group-title">${x}</div>`)}${_.join("")}`});return g.innerHTML=` <div class="debug-group"> ${x.join('<div class="div-line"></div>')} </div> `}#Dp(i,g,x,_){const{renderViewStateData:v}=i,b=`total${x.charAt(0).toUpperCase()}${x.substring(1)}`,y=v[x],S="usedVideoMemory"===x?`<b>${formatBytes(y)}</b>`:y,w=so[x];_[b]+=y,updateDebugItemValue(this.dom,`view${g}_${x}`,S,!1,w)}#Up(i,g){const{renderViewStateData:x,rawCamera:_,scene:v}=i,{backgroundColor:b,useBackgroundColor:y}=v,{viewportSize:S}=x,{pixelRectArray:w,x:L,y:k,width:z,height:H}=S;updateDebugItemValue(this.dom,`view${g}_x_y`,`${formatNumber(L)},${formatNumber(k)}`),updateDebugItemValue(this.dom,`view${g}_width_height`,`${z},${H}`),updateDebugItemValue(this.dom,`view${g}_pixelRectArray`,w),updateDebugItemValue(this.dom,`view${g}_useBackgroundColor`,makeBooleanDebug(0,y)),updateDebugItemValue(this.dom,`view${g}_backgroundColor`,makeColorDebug("backgroundColor",b)),updateDebugItemValue(this.dom,`view${g}_camera`,_.name),updateDebugItemValue(this.dom,`view${g}_scene`,v.name)}};class DebugViewList extends ADebugItem{constructor(){super(),this.debugStatisticsDomService=new uo}}const formatNumber=i=>{const g=String(i);if(g.includes("%")){const i=parseFloat(g);return isNaN(i)?g:`${i.toFixed(2)}%`}if(g.includes("px")){const i=parseFloat(g);return isNaN(i)?g:`${i.toFixed(2)}px`}const x=parseFloat(g);return isNaN(x)?g:x.toFixed(2)};class DebugStatisticsDomService{dom;constructor(i){this.dom=document.createElement("div"),this.dom.style.cssText="z-index:1;position:sticky;top:0;background:#000;border-bottom:1px solid rgba(255,255,255,0.06);box-shadow:0 10px 10px rgba(0,0,0,0.5)",this.#Np(i)}update(i,g,x,_,v){const b={fps:i,avg:g,low1:x,low01:_,frameTime:v};Object.entries(b).forEach(([i,g])=>this.#zp(i,g))}#Np(i){this.dom.innerHTML=' <div class="debug-group"> <div class=\'debug-item\'> <span class=\'debug-item-title\' style="font-size:14px;font-weight:500;color:#fff">Performance<br/>Monitor</span> <div style="display:flex;align-items:center;justify-content:flex-end;gap:12px;"> <div style="display:flex;flex-direction:column;align-items:flex-end;gap:2px"> <div class="fps" style="color:#0f0;font-size:18px;font-weight:bold;white-space:nowrap">60 FPS</div> <div class="frameTime" style="color:#888;font-size:11px;">16.67ms</div> </div> <div style="width:1px;height:36px;background:rgba(255,255,255,0.15)"></div> <div style="display:flex;flex-direction:column;align-items:flex-end;gap:0px"> <div class="avg" style="color:#4af;font-size:11px;">Avg:60</div> <div class="low1" style="color:#fa0;font-size:11px;">1%:60</div> <div class="low01" style="color:#f50;font-size:11px;">0.1%:60</div> </div> <div class="panel_close" style="cursor:pointer;border-radius:4px;display:flex;align-items:center;justify-content:center;color:#fff;width:50px;height:48px;background:#c00;margin-left:8px;font-size:10px;font-weight:bold;transition:background 0.2s;" onmouseover="this.style.background=\'#e00\'" onmouseout="this.style.background=\'#c00\'">CLOSE</div> </div> </div> </div> '}#zp(i,g){const x=this.dom.querySelector(`.${i}`);x&&x.innerHTML!==g&&(x.innerHTML=g)}}class Fps extends ADebugItem{#Hp=0;#Cp=0;#$p=!1;#Kp=[];#Xp=1200;#jp=[];#Yp=10;#qp=0;#Wp=60;#Zp=0;#Jp=0;#Qp=0;#eg=60;constructor(i){super(),this.debugStatisticsDomService=new DebugStatisticsDomService(i)}update(i,g,x){if(0===this.#Cp)return this.#Hp=x,void this.#Cp++;const _=x-this.#Hp;if(this.#Hp=x,this.#Cp++,!this.#$p){const i=document.querySelector(".panel_close");i&&(i.addEventListener("click",()=>{g.useDebugPanel=!1}),this.#$p=!0)}const v=this.#tg(_);this.#Cp>this.#eg&&(this.#Kp.push(v),this.#Kp.length>this.#Xp&&this.#Kp.shift()),this.#jp.push(v),this.#jp.length>this.#Yp&&this.#jp.shift();const b=this.#ng();this.#qp++,this.#qp>=this.#Wp&&(this.#rg(),this.#qp=0),this.debugStatisticsDomService.update(`${b} FPS`,`Avg:${this.#Zp}`,`1%:${this.#Jp}`,`0.1%:${this.#Qp}`,`${v.toFixed(2)}ms`)}#tg(i){return Math.min(Math.max(i,.1),1e3)}#ng(){if(0===this.#jp.length)return 0;const i=this.#jp.reduce((i,g)=>i+g,0)/this.#jp.length;return Math.round(1e3/i)}#rg(){if(this.#Kp.length<100)return this.#Zp=0,this.#Jp=0,void(this.#Qp=0);const i=this.#ig();this.#Zp=i.avgFps,this.#Jp=i.low1Fps,this.#Qp=i.low01Fps}#ig(){const i=this.#Kp.reduce((i,g)=>i+g,0),g=i/this.#Kp.length,x=Math.round(1e3/g),_=[...this.#Kp].sort((i,g)=>g-i),v=_.length,b=Math.max(1,Math.ceil(.01*v)),y=_.slice(0,b),S=y.reduce((i,g)=>i+g,0)/y.length,w=Math.round(1e3/S),L=Math.max(1,Math.ceil(.001*v)),k=_.slice(0,L),z=k.reduce((i,g)=>i+g,0)/k.length;return{avgFps:x,low1Fps:w,low01Fps:Math.round(1e3/z)}}}class DebugRender{fps;debugTotalState;debugViewList;debugRedGPUContext;debugBitmapTextureList;debugCubeTextureList;debugHDRTextureList;debugPackedTextureList;debugIndexBufferList;debugVertexBufferList;debugUniformBufferList;debugStorageBufferList;debugBufferList;totalNum3DGroups;totalNum3DObjects;totalNumDrawCalls;totalNumInstances;totalNumTriangles;totalNumPoints;totalUsedVideoMemory;#ag;constructor(i){this.fps=new Fps(i),this.debugTotalState=new DebugTotalState,this.debugRedGPUContext=new DebugRedGPUContext,this.debugViewList=new DebugViewList,this.debugBitmapTextureList=new DebugTextureList,this.debugCubeTextureList=new DebugTextureList("Cube"),this.debugHDRTextureList=new DebugTextureList("HDR"),this.debugPackedTextureList=new DebugTextureList("Packed"),this.debugIndexBufferList=new DebugBufferList("IndexBuffer"),this.debugVertexBufferList=new DebugBufferList("VertexBuffer"),this.debugUniformBufferList=new DebugBufferList("UniformBuffer"),this.debugStorageBufferList=new DebugBufferList("StorageBuffer"),this.debugBufferList=new DebugBufferList("Buffer"),this.#sg()}render(i,g){i.useDebugPanel?(this.#og(),this.fps.update(this,i,g),this.debugRedGPUContext.update(this,i,g),this.debugViewList.update(this,i,g),this.debugBitmapTextureList.update(this,i,g),this.debugCubeTextureList.update(this,i,g),this.debugHDRTextureList.update(this,i,g),this.debugPackedTextureList.update(this,i,g),this.debugIndexBufferList.update(this,i),this.debugVertexBufferList.update(this,i),this.debugUniformBufferList.update(this,i),this.debugStorageBufferList.update(this,i),this.debugBufferList.update(this,i),this.debugTotalState.update(this,i,g)):this.#ug(),this.#sg()}#sg(){this.totalNum3DGroups=0,this.totalNum3DObjects=0,this.totalNumInstances=0,this.totalNumDrawCalls=0,this.totalNumTriangles=0,this.totalNumPoints=0,this.totalUsedVideoMemory=0}#og(){this.#ag||(this.#ag=document.createElement("div"),this.#ag.className="RedGPUDebugPanel",document.body.appendChild(this.#ag),[this.fps.debugStatisticsDomService,this.debugTotalState.debugStatisticsDomService,this.debugRedGPUContext.debugStatisticsDomService,this.debugViewList.debugStatisticsDomService,this.debugBufferList.debugStatisticsDomService,this.debugVertexBufferList.debugStatisticsDomService,this.debugIndexBufferList.debugStatisticsDomService,this.debugUniformBufferList.debugStatisticsDomService,this.debugStorageBufferList.debugStatisticsDomService,this.debugBitmapTextureList.debugStatisticsDomService,this.debugPackedTextureList.debugStatisticsDomService,this.debugCubeTextureList.debugStatisticsDomService,this.debugHDRTextureList.debugStatisticsDomService].forEach(i=>this.#ag.appendChild(i.dom)))}#ug(){this.#ag&&(this.#ag.remove(),this.#ag=null)}}Object.freeze(DebugRender);var lo="struct Uniforms{ backgroundColor:vec4<f32>\n}\n@group(1) @binding(0)\nvar _sampler:sampler;\n@group(1) @binding(1)\nvar _texture:texture_2d<f32>;\n@group(1) @binding(2)\nvar<uniform> uniforms:Uniforms;\n@fragment\nfn main(@location(0) fragUV:vec2<f32>) -> @location(0) vec4<f32> { var viewColor:vec4<f32>=textureSample(_texture,_sampler,fragUV); let backgroundColor=uniforms.backgroundColor; let blendedColor=vec4<f32>( viewColor.rgb + backgroundColor.rgb * (1.0 - viewColor.a), viewColor.a + backgroundColor.a * (1.0 - viewColor.a) ); return blendedColor;\n}\n",co="\nstruct VertexUniforms { modelMatrix:mat4x4<f32>,\n};\n@group(0) @binding(0)\nvar<uniform> vertexUniforms:VertexUniforms;\nstruct VertexOutput { @builtin(position) Position:vec4<f32>, @location(0) fragUV:vec2<f32>,\n};\n@vertex\nfn main(@builtin(vertex_index) VertexIndex:u32) -> VertexOutput { var pos=array<vec2<f32>,6>( vec2( 1.0,1.0), vec2( 1.0,-1.0), vec2(-1.0,-1.0), vec2( 1.0,1.0), vec2(-1.0,-1.0), vec2(-1.0,1.0), ); var uv=array<vec2<f32>,6>( vec2(1.0,0.0), vec2(1.0,1.0), vec2(0.0,1.0), vec2(1.0,0.0), vec2(0.0,1.0), vec2(0.0,0.0), ); var output:VertexOutput; output.Position=vertexUniforms.modelMatrix * vec4<f32>(pos[VertexIndex],0.0,1.0); output.fragUV=uv[VertexIndex]; return output;\n}\n";const ho=parseWGSL(co),fo=parseWGSL(lo),mo=ho.uniforms.vertexUniforms;class FinalRender{#lg=[];#cg=[];#hg;#fg;#dg;#mg;#pg;#gg=[];#Q;#xg=[];#_g=[];#ae;#vg=[];#bg=[];constructor(){}render(i,g){const{sizeManager:x,gpuDevice:_,antialiasingManager:v}=i,{changedMSAA:b,useMSAA:y}=v,{pixelRectObject:S}=x,{width:w,height:L}=S;if(0===w||0===L)return;const k=this.#yg(i),z=_.createCommandEncoder(),H=z.beginRenderPass(k);H.setViewport(0,0,w,L,0,1),H.setScissorRect(0,0,w,L),this.#hg&&!b||this.#Sg(i),this.#Tg(i,H,g.map(i=>{const g=i.colorAttachments[0];return g.postEffectView||g.pickingView||g.resolveTarget||g.view}),w,L,y),H.end(),_.queue.submit([z.finish()])}#Mg(i,g){{const{scene:x,redGPUContext:_}=i,{gpuDevice:v}=_,{backgroundColor:b,useBackgroundColor:y}=x,S=y?b.rgbaNormal:[0,0,0,0],w=_.backgroundColor.rgbaNormal;let L;const k=[S[0]*S[3],S[1]*S[3],S[2]*S[3],S[3]],z=[w[0]*w[3],w[1]*w[3],w[2]*w[3],w[3]];L=[k[0]+z[0]*(1-S[3]),k[1]+z[1]*(1-S[3]),k[2]+z[2]*(1-S[3]),S[3]+w[3]*(1-S[3])],this.#bg[g][0]=L[0],this.#bg[g][1]=L[1],this.#bg[g][2]=L[2],this.#bg[g][3]=L[3],v.queue.writeBuffer(this.#vg[g],0,this.#bg[g])}}#Tg(i,g,x,_,v,b){const{gpuDevice:y}=i;x.forEach((x,b)=>{const S=i.viewList[b],{x:w,y:L,width:k,height:z}=S.pixelRectObject,H=create$4();bt(H,0,1,0,1,-1e3,1e3),scale$4(H,H,[1/_,1/v,1]),translate(H,H,[k/2+w,v-z/2-L,0]),scale$4(H,H,[k/2,z/2,1]),this.#wg(i,b);const q=this.#lg[b],W=this.#cg[b];y.queue.writeBuffer(q.gpuBuffer,mo.members.modelMatrix.uniformOffset,H);if(i.antialiasingManager.changedMSAA||!this.#xg[b]||this.#xg[b].width!==k||this.#xg[b].height!==z||this.#_g[b]!==x){this.#vg[b]||(this.#vg[b]=i.gpuDevice.createBuffer({label:`FINAL_RENDER_FRAGMENT_BUFFER_${b}`,size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.#bg[b]=new Float32Array([1,0,0,1]));const g={layout:this.#mg,label:"FRAGMENT_BIND_GROUP_DESCRIPTOR_FINAL_RENDER",entries:[{binding:0,resource:this.#ae.gpuSampler},{binding:1,resource:x},{binding:2,resource:{buffer:this.#vg[b],offset:0,size:this.#vg[b].size}}]};this.#gg[b]=y.createBindGroup(g),this.#xg[b]={width:k||1,height:z||1},this.#_g[b]=x}this.#Mg(S,b),g.setPipeline(this.#Cg(i)),g.setBindGroup(0,W),g.setBindGroup(1,this.#gg[b]),g.draw(6,1,0,0)})}#Sg(i){const{resourceManager:g}=i;this.#hg=g.createBindGroupLayout("FINAL_RENDER_VERTEX_BIND_GROUP_LAYOUT",getVertexBindGroupLayoutDescriptorFromShaderInfo(ho,0)),this.#fg=g.createGPUShaderModule("VERTEX_MODULE_FINAL_RENDER",{code:co}),this.#dg={module:this.#fg,entryPoint:"main"},this.#pg=g.createGPUShaderModule("FRAGMENT_MODULE_FINAL_RENDER",{code:lo}),this.#mg=g.createBindGroupLayout("FINAL_RENDER_BIND_GROUP_LAYOUT",getFragmentBindGroupLayoutDescriptorFromShaderInfo(fo,1)),this.#ae=new Sampler(i,{minFilter:"linear"})}#wg(i,g){const{gpuDevice:x}=i;if(!this.#lg[g]){const _=new ArrayBuffer(mo.arrayBufferByteLength),v=this.#lg[g]=new UniformBuffer(i,_,`FinalRender_View(${g})_VertexUniform`),b={layout:this.#hg,label:"VERTEX_BIND_GROUP_DESCRIPTOR_FINAL_RENDER",entries:[{binding:0,resource:{buffer:v.gpuBuffer,offset:0,size:v.size}}]};this.#cg[g]=x.createBindGroup(b)}}#yg(i){const{backgroundColor:g,gpuContext:x}=i;return{colorAttachments:[{view:x.getCurrentTexture().createView({label:"FINAL_RENDER"}),clearValue:{r:0,g:0,b:0,a:0},loadOp:z.CLEAR,storeOp:H.STORE}]}}#Cg(i){if(!this.#Q||i.antialiasingManager.changedMSAA){const{gpuDevice:g}=i,x={label:"PIPELINE_DESCRIPTOR_FINAL_RENDER",layout:g.createPipelineLayout({label:"FINAL_RENDER_PIPELINE_LAYOUT",bindGroupLayouts:[this.#hg,this.#mg]}),vertex:this.#dg,fragment:{module:this.#pg,entryPoint:"main",targets:[{format:navigator.gpu.getPreferredCanvasFormat(),blend:{color:{srcFactor:mr.SRC_ALPHA,dstFactor:mr.ONE_MINUS_SRC_ALPHA,operation:pr.ADD},alpha:{srcFactor:mr.SRC_ALPHA,dstFactor:mr.ONE_MINUS_SRC_ALPHA,operation:pr.ADD}}}]}};this.#Q=g.createRenderPipeline(x)}return this.#Q}}const renderListForLayer=(i,g,x="pipeline")=>{let _=0;const v=i.length,{currentRenderPassEncoder:b}=g;for(b.setBindGroup(0,g.view.systemUniform_Vertex_UniformBindGroup);_<v;_++){const v=i[_];if(v.passFrustumCulling&&v.gpuRenderInfo){const i=v._geometry,_=v._material;i?g.num3DObjects++:g.num3DGroups++;const{gpuRenderInfo:y}=v,{vertexUniformBindGroup:S}=y;if(y[x]||("shadowPipeline"===x?y.shadowPipeline=v.gpuRenderInfo.vertexStructInfo.vertexEntries.includes("drawDirectionalShadowDepth")?createBasePipeline(v,v.gpuRenderInfo.vertexShaderModule,v.gpuRenderInfo.vertexBindGroupLayout,hi):null:"pickingPipeline"===x&&(y.pickingPipeline=v.gpuRenderInfo.vertexStructInfo.vertexEntries.includes("picking")?createBasePipeline(v,v.gpuRenderInfo.vertexShaderModule,v.gpuRenderInfo.vertexBindGroupLayout,fi):null)),i&&y[x]){b.setPipeline(y[x]);const{gpuBuffer:v}=i.vertexBuffer,{fragmentUniformBindGroup:w}=_.gpuRenderInfo;if(g.prevVertexGpuBuffer!==v&&(b.setVertexBuffer(0,v),g.prevVertexGpuBuffer=v),b.setBindGroup(1,S),g.prevFragmentUniformBindGroup!==w&&(b.setBindGroup(2,w),g.prevFragmentUniformBindGroup=w),g.numDrawCalls++,i.indexBuffer){const{indexBuffer:x}=i,{indexCount:_,triangleCount:v,gpuBuffer:y,format:S}=x;b.setIndexBuffer(y,S),b.drawIndexed(_,1,0,0,0),g.numTriangles+=v,g.numPoints+=_}else{const{vertexBuffer:x}=i,{vertexCount:_,triangleCount:v}=x;b.draw(_,1,0,0),g.numTriangles+=v,g.numPoints+=_}}}}g.prevVertexGpuBuffer=null,g.prevFragmentUniformBindGroup=null,g.prevVertexGpuBuffer=null};class Renderer{#Pg;#Rg;#Bg;#Ig=new GltfAnimationLooperManager;constructor(){}start(i,g){cancelAnimationFrame(i.currentRequestAnimationFrame);const HD_render=x=>{g?.(x),i.currentTime=x,this.renderFrame(i,x),this.#Bg.render(i,x),i.currentRequestAnimationFrame=requestAnimationFrame(HD_render)};i.currentRequestAnimationFrame=requestAnimationFrame(HD_render)}stop(i){cancelAnimationFrame(i.currentRequestAnimationFrame),i.currentRequestAnimationFrame=null}renderFrame(i,g){this.#Rg||(this.#Rg=new FinalRender),this.#Bg||(this.#Bg=new DebugRender(i));const x=[];{let _=0;const v=i.viewList.length;for(;_<v;_++){const v=i.viewList[_];x.push(this.renderView(v,g))}}this.#Rg.render(i,x),i.antialiasingManager.changedMSAA=!1}renderView(i,g){const{redGPUContext:x,camera:_,pickingManager:v,pixelRectObject:b,renderViewStateData:y}=i,{colorAttachment:S,depthStencilAttachment:w,gBufferNormalTextureAttachment:L,gBufferMotionVectorTextureAttachment:k}=this.#Eg(i),z=x.gpuDevice.createCommandEncoder({label:"ViewRender_MainCommandEncoder"}),H={label:`${i.name} Basic Render Pass`,colorAttachments:[S,L,k],depthStencilAttachment:w};if(i.renderViewStateData.reset(null,g),b.width&&b.height){{const{scene:g}=i,{shadowManager:_}=g;_.update(x)}DrawBufferManager.getInstance(x).flushAllCommands(y);{const{timestamp:x,prevTimestamp:v}=y,b=x-v,S=1e3/60;if(b>=S){y.prevTimestamp=x-b%S;const{scene:g}=i;g.physicsEngine&&g.physicsEngine.step(S/1e3)}_.update?.(i,g)}this.#Dg(i),this.#Ug(i,z),this.#Lg(i,z,H),this.#Ag(i,z,H,w),this.#Gg(i,z)}return H.colorAttachments[0].postEffectView=i.postEffectManager.render().textureView,x.gpuDevice.queue.submit([z.finish(),this.#kg(x,y)]),i.renderViewStateData.viewRenderTime=performance.now()-i.renderViewStateData.startTime,v?.checkEvents(i,g),H}#Ug(i,g){const{scene:x}=i,{shadowManager:_}=x,{directionalShadowManager:v}=_,b={label:`${i.name} Shadow Render Pass`,colorAttachments:[],depthStencilAttachment:{view:v.shadowDepthTextureView,depthClearValue:1,depthLoadOp:z.CLEAR,depthStoreOp:H.STORE}},y=g.beginRenderPass(b);this.#Og(i,y,!0),this.#Ng(i,y,!0,!1),v.castingList.length&&((i,g)=>{const{renderViewStateData:x,scene:_}=i;x.currentRenderPassEncoder=g;const{shadowManager:v}=_,{directionalShadowManager:b}=v,{castingList:y}=b;renderListForLayer(y,x,"shadowPipeline")})(i,y),y.end(),v.resetCastingList()}#Lg(i,g,x){const{renderViewStateData:_,skybox:v,skyAtmosphere:b,grid:y,axis:S}=i,w=g.beginRenderPass(x);{const g=i.viewRenderTextureManager.renderPath1ResultTextureView;this.#Og(i,w),this.#Ng(i,w,!1,!0,g)}_.currentRenderPassEncoder=w,w.setBindGroup(0,i.systemUniform_Vertex_UniformBindGroup),v&&v.render(_),b&&b.render(_),S&&S.render(_),((i,g)=>{const{renderViewStateData:x,scene:_}=i;x.currentRenderPassEncoder=g;const{children:v}=_;let b=0;const y=v.length;for(;b<y;b++)v[b].render(x);x.prevVertexGpuBuffer=null,x.prevFragmentUniformBindGroup=null,x.prevVertexGpuBuffer=null,g.executeBundles(x.bundleListBasicList)})(i,w),y&&y.render(_),((i,g)=>{const{renderViewStateData:x,rawCamera:_}=i;x.currentRenderPassEncoder=g;const{bundleListAlphaLayer:v,bundleListTransparentLayer:b,bundleListParticleLayer:y}=x;v.length&&g.executeBundles(v);const{x:S,y:w,z:L}=_;b.length&&g.executeBundles(sortTransparentObjects({x:S,y:w,z:L},b)),y.length&&g.executeBundles(y)})(i,w),w.end()}#Ag(i,g,x,_){const{redGPUContext:v,renderViewStateData:b}=i,{antialiasingManager:y}=v,{useMSAA:S}=y;if(i.renderViewStateData.bundleListRender2PathLayer.length){const{mipmapGenerator:y}=v.resourceManager;let w=i.viewRenderTextureManager.renderPath1ResultTexture,L=S?i.viewRenderTextureManager.gBufferColorResolveTexture:i.viewRenderTextureManager.gBufferColorTexture;L||(S?console.error("MSAA가 활성화되어 있지만 gBufferColorResolveTexture가 정의되지 않았습니다"):console.error("gBufferColorTexture가 정의되지 않았습니다")),w||console.error("renderPath1ResultTexture가 정의되지 않았습니다"),g.copyTextureToTexture({texture:L},{texture:w},{width:i.pixelRectObject.width,height:i.pixelRectObject.height,depthOrArrayLayers:1}),y.generateMipmap(w,i.viewRenderTextureManager.renderPath1ResultTextureDescriptor,!0);const k=g.beginRenderPass({label:`${i.name} 2Path Render Pass`,colorAttachments:[...x.colorAttachments].map(i=>({...i,loadOp:z.LOAD})),depthStencilAttachment:{..._,depthLoadOp:z.LOAD}});k.executeBundles(b.bundleListRender2PathLayer),k.end()}}#Gg(i,g){const{pickingManager:x}=i;if(x&&x.castingList.length){x.checkTexture(i);const _={label:`${i.name} Picking Render Pass`,colorAttachments:[{view:x.pickingGPUTextureView,clearValue:{r:0,g:0,b:0,a:0},loadOp:z.CLEAR,storeOp:H.STORE}],depthStencilAttachment:{view:x.pickingDepthGPUTextureView,depthClearValue:1,depthLoadOp:z.CLEAR,depthStoreOp:H.STORE}},v=g.beginRenderPass(_);this.#Og(i,v),this.#Ng(i,v,!1,!1),((i,g)=>{const{renderViewStateData:x,pickingManager:_}=i;x.currentRenderPassEncoder=g;const{castingList:v}=_;renderListForLayer(v,x,"pickingPipeline")})(i,v),v.end()}}#Dg(i){const{taa:g}=i,x=g.frameIndex||0,_=g.jitterStrength,v=x%16,b=this.#Vg(v+1,2),y=this.#Vg(v+1,3),S=window.devicePixelRatio||1,w=(b-.5)/S*_,L=(y-.5)/S*_;i.setJitterOffset(w,L)}#Vg(i,g){let x=0,_=1,v=i;for(;v>0;)_/=g,x+=_*(v%g),v=Math.floor(v/g);return x}#kg(i,g){const{animationList:x,skinList:_}=g,v=_.length,b=x.length,{gpuDevice:y}=i,S=y.createCommandEncoder({label:"BatchUpdateSkinMatrices_CommandEncoder"}),w=S.beginComputePass();b&&this.#Ig.render(i,g.timestamp,w,x.flat());for(let g=0;g<v;g++){const x=_[g],v=x.animationInfo.skinInfo;v.usedJoints||(v.usedJoints=v.getUsedJointIndices(x));const b=16*(1+v.usedJoints.length);v.jointData&&v.jointData.length===b||(v.jointData=new Float32Array(b),v.computeShader=null),v.invertNodeGlobalTransform=v.invertNodeGlobalTransform||new Float32Array(x.modelMatrix.length);{const i=x.modelMatrix,g=v.invertNodeGlobalTransform,_=i[0],b=i[1],y=i[2],S=i[3],w=i[4],L=i[5],k=i[6],z=i[7],H=i[8],q=i[9],W=i[10],be=i[11],Ke=i[12],Xe=i[13],je=i[14],Ye=i[15],Ze=L*(W*Ye-be*je)-k*(q*Ye-be*Xe)+z*(q*je-W*Xe),Je=-(w*(W*Ye-be*je)-k*(H*Ye-be*Ke)+z*(H*je-W*Ke)),Qe=w*(q*Ye-be*Xe)-L*(H*Ye-be*Ke)+z*(H*Xe-q*Ke),et=-(w*(q*je-W*Xe)-L*(H*je-W*Ke)+k*(H*Xe-q*Ke)),tt=-(b*(W*Ye-be*je)-y*(q*Ye-be*Xe)+S*(q*je-W*Xe)),it=_*(W*Ye-be*je)-y*(H*Ye-be*Ke)+S*(H*je-W*Ke),ft=-(_*(q*Ye-be*Xe)-b*(H*Ye-be*Ke)+S*(H*Xe-q*Ke)),pt=_*(q*je-W*Xe)-b*(H*je-W*Ke)+y*(H*Xe-q*Ke),xt=b*(k*Ye-z*je)-y*(L*Ye-z*Xe)+S*(L*je-k*Xe),vt=-(_*(k*Ye-z*je)-y*(w*Ye-z*Ke)+S*(w*je-k*Ke)),bt=_*(L*Ye-z*Xe)-b*(w*Ye-z*Ke)+S*(w*Xe-L*Ke),yt=-(_*(L*je-k*Xe)-b*(w*je-k*Ke)+y*(w*Xe-L*Ke)),St=-(b*(k*be-z*W)-y*(L*be-z*q)+S*(L*W-k*q)),Tt=_*(k*be-z*W)-y*(w*be-z*H)+S*(w*W-k*H),Mt=-(_*(L*be-z*q)-b*(w*be-z*H)+S*(w*q-L*H)),wt=_*(L*W-k*q)-b*(w*W-k*H)+y*(w*q-L*H),Ct=_*Ze+b*Je+y*Qe+S*et;if(Math.abs(Ct)<1e-10)console.error("Matrix is not invertible (determinant is zero or near zero)"),g[0]=1,g[1]=0,g[2]=0,g[3]=0,g[4]=0,g[5]=1,g[6]=0,g[7]=0,g[8]=0,g[9]=0,g[10]=1,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1;else{const i=1/Ct;g[0]=Ze*i,g[1]=tt*i,g[2]=xt*i,g[3]=St*i,g[4]=Je*i,g[5]=it*i,g[6]=vt*i,g[7]=Tt*i,g[8]=Qe*i,g[9]=ft*i,g[10]=bt*i,g[11]=Mt*i,g[12]=et*i,g[13]=pt*i,g[14]=yt*i,g[15]=wt*i}}v.computeShader||v.createCompute(i,y,x.geometry.vertexBuffer,x.animationInfo.weightBuffer,x.animationInfo.jointBuffer);{const i=v.usedJoints;let g=i.length;const x=v.jointData;for(;g--;)x.set(v.joints[i[g]].modelMatrix,16*(g+1));x.set(v.invertNodeGlobalTransform,0),y.queue.writeBuffer(v.uniformBuffer,0,x)}w.setPipeline(v.computePipeline),w.setBindGroup(0,v.bindGroup),w.dispatchWorkgroups(Math.ceil(x.geometry.vertexBuffer.vertexCount/v.WORK_SIZE))}return w.end(),S.finish()}#Eg(i){const{scene:g,redGPUContext:x,viewRenderTextureManager:_}=i,{depthTextureView:v,gBufferColorTextureView:b,gBufferColorResolveTextureView:y,gBufferNormalTextureView:S,gBufferNormalResolveTextureView:w,gBufferMotionVectorTextureView:L,gBufferMotionVectorResolveTextureView:k}=_,{antialiasingManager:q}=x,{useMSAA:W}=q,be={view:b,clearValue:{r:0,g:0,b:0,a:0},loadOp:z.CLEAR,storeOp:H.STORE},Ke={view:v,depthClearValue:1,depthLoadOp:z.CLEAR,depthStoreOp:H.STORE},Xe={view:S,clearValue:{r:0,g:0,b:0,a:0},loadOp:z.CLEAR,storeOp:H.STORE},je={view:L,clearValue:{r:0,g:0,b:0,a:0},loadOp:z.CLEAR,storeOp:H.STORE};return W&&(be.resolveTarget=y,Xe.resolveTarget=w,je.resolveTarget=k),{colorAttachment:be,depthStencilAttachment:Ke,gBufferNormalTextureAttachment:Xe,gBufferMotionVectorTextureAttachment:je}}#Og(i,g,x=!1){const{scene:_,pixelRectObject:v}=i,{shadowManager:b}=_,{directionalShadowManager:y}=b;if(x){const i=y.shadowDepthTextureSize,x=y.shadowDepthTextureSize;g.setViewport(0,0,i,x,0,1),g.setScissorRect(0,0,i,x)}else{const{width:i,height:x}=v;this.#Pg&&this.#Pg.width===i&&this.#Pg.height===x||(g.setViewport(0,0,i,x,0,1),g.setScissorRect(0,0,i,x),this.#Pg={width:i,height:x})}}#Ng(i,g,x=!1,_=!0,v=null){i.update(x,_,v),g.setBindGroup(0,i.systemUniform_Vertex_UniformBindGroup)}}create$4();var po=Object.freeze({__proto__:null,isHexColor:isHexColor,isUint:isUint,validateNumber:validateNumber,validateNumberRange:validateNumberRange,validatePositiveNumberRange:validatePositiveNumberRange,validateRedGPUContext:validateRedGPUContext,validateUintRange:validateUintRange});class BrightnessContrast extends ASinglePassPostEffect{#xc=0;#Tr=0;constructor(i){super(i),this.init(i,"POST_EFFECT_BRIGHTNESS_CONTRAST",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy );\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nvar color:vec4<f32>=textureLoad( sourceTexture,index,);\nlet brightness_value:f32=uniforms.brightness/255.0;\nlet contrast_value:f32=uniforms.contrast/255.0;\nvar tempColor:vec3<f32>;\nif ( contrast_value > 0.0 ) { tempColor=( color.rgb - 0.5 )/( 1.0 - contrast_value ) + 0.5;\n}else { tempColor=( color.rgb - 0.5 ) * ( 1.0 + contrast_value ) + 0.5;\n}\ncolor=vec4<f32>(tempColor + brightness_value,color.a);\ntextureStore(outputTexture,index,color );\n","struct Uniforms { brightness:f32, contrast:f32\n};\n"))}get brightness(){return this.#xc}set brightness(i){validateNumberRange(i,-150,150),this.#xc=i,this.updateUniform("brightness",i)}get contrast(){return this.#Tr}set contrast(i){validateNumberRange(i,-50,100),this.#Tr=i,this.updateUniform("contrast",i)}}Object.freeze(BrightnessContrast);class ColorBalance extends ASinglePassPostEffect{#Fg=0;#zg=0;#Hg=0;#$g=0;#Kg=0;#Xg=0;#jg=0;#Yg=0;#qg=0;#Wg=!0;constructor(i){super(i),this.init(i,"POST_EFFECT_COLOR_BALANCE",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy );\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nvar color:vec4<f32>=textureLoad( sourceTexture,index,);\nlet original_luminance=0.299 * color.r + 0.587 * color.g + 0.114 * color.b;\nlet shadow_weight=1.0 - smoothstep(0.0,0.5,original_luminance);\nlet highlight_weight=smoothstep(0.5,1.0,original_luminance);\nlet midtone_weight=1.0 - shadow_weight - highlight_weight;\nlet cyan_red=shadow_weight * uniforms.shadowCyanRed +\nmidtone_weight * uniforms.midtoneCyanRed +\nhighlight_weight * uniforms.highlightCyanRed;\nlet magenta_green=shadow_weight * uniforms.shadowMagentaGreen +\nmidtone_weight * uniforms.midtoneMagentaGreen +\nhighlight_weight * uniforms.highlightMagentaGreen;\nlet yellow_blue=shadow_weight * uniforms.shadowYellowBlue +\nmidtone_weight * uniforms.midtoneYellowBlue +\nhighlight_weight * uniforms.highlightYellowBlue;\ncolor.r +=cyan_red * 0.01;\ncolor.g +=magenta_green * 0.01;\ncolor.b +=yellow_blue * 0.01;\nlet adjusted_luminance=0.299 * color.r + 0.587 * color.g + 0.114 * color.b;\nif (uniforms.preserveLuminosity==1 && adjusted_luminance > 0.0) { let ratio=original_luminance/adjusted_luminance; color=color * ratio;\n}\ntextureStore(outputTexture,index,color );\n","struct Uniforms { shadowCyanRed:f32, shadowMagentaGreen:f32, shadowYellowBlue:f32, midtoneCyanRed:f32, midtoneMagentaGreen:f32, midtoneYellowBlue:f32, highlightCyanRed:f32, highlightMagentaGreen:f32, highlightYellowBlue:f32, preserveLuminosity:u32\n};\n"))}get shadowCyanRed(){return this.#Fg}set shadowCyanRed(i){validateNumberRange(i,-100,100),this.#Fg=i,this.updateUniform("shadowCyanRed",i)}get shadowMagentaGreen(){return this.#zg}set shadowMagentaGreen(i){validateNumberRange(i,-100,100),this.#zg=i,this.updateUniform("shadowMagentaGreen",i)}get shadowYellowBlue(){return this.#Hg}set shadowYellowBlue(i){validateNumberRange(i,-100,100),this.#Hg=i,this.updateUniform("shadowYellowBlue",i)}get midtoneCyanRed(){return this.#$g}set midtoneCyanRed(i){validateNumberRange(i,-100,100),this.#$g=i,this.updateUniform("midtoneCyanRed",i)}get midtoneMagentaGreen(){return this.#Kg}set midtoneMagentaGreen(i){validateNumberRange(i,-100,100),this.#Kg=i,this.updateUniform("midtoneMagentaGreen",i)}get midtoneYellowBlue(){return this.#Xg}set midtoneYellowBlue(i){validateNumberRange(i,-100,100),this.#Xg=i,this.updateUniform("midtoneYellowBlue",i)}get highlightCyanRed(){return this.#jg}set highlightCyanRed(i){validateNumberRange(i,-100,100),this.#jg=i,this.updateUniform("highlightCyanRed",i)}get highlightMagentaGreen(){return this.#Yg}set highlightMagentaGreen(i){validateNumberRange(i,-100,100),this.#Yg=i,this.updateUniform("highlightMagentaGreen",i)}get highlightYellowBlue(){return this.#qg}set highlightYellowBlue(i){validateNumberRange(i,-100,100),this.#qg=i,this.updateUniform("highlightYellowBlue",i)}get preserveLuminosity(){return this.#Wg}set preserveLuminosity(i){this.#Wg=i,this.updateUniform("preserveLuminosity",i)}}Object.freeze(ColorBalance);class ColorTemperatureTint extends ASinglePassPostEffect{#Zg=6500;#Jg=0;#Qg=100;constructor(i){super(i),this.init(i,"POST_EFFECT_COLOR_TEMPERATURE_TINT",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy);\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nvar color:vec4<f32>=textureLoad(sourceTexture,index);\nlet temp=uniforms.temperature;\nvar tempRGB:vec3<f32>;\nif (temp <=6600.0) { tempRGB.r=1.0;\n} else { let t=temp - 6600.0; tempRGB.r=clamp(1.292936 * pow(t,-0.1332047),0.0,1.0);\n}\nif (temp <=6600.0) { let t=temp; tempRGB.g=clamp(0.39008157 * log(t) - 0.63184144,0.0,1.0);\n} else { let t=temp - 6600.0; tempRGB.g=clamp(1.292936 * pow(t,-0.1332047),0.0,1.0);\n}\nif (temp >=6600.0) { tempRGB.b=1.0;\n} else if (temp <=1900.0) { tempRGB.b=0.0;\n} else { let t=temp - 1000.0; tempRGB.b=clamp(0.543206789 * log(t) - 1.19625408,0.0,1.0);\n}\nlet neutralTemp:vec3<f32>=vec3<f32>(1.0,1.0,1.0);\nlet tempAdjust:vec3<f32>=tempRGB/neutralTemp;\nlet tintValue=uniforms.tint * 0.01;\nvar tintRGB:vec3<f32>;\nif (tintValue >=0.0) { tintRGB=vec3<f32>(1.0 - tintValue * 0.2,1.0,1.0 - tintValue * 0.2);\n} else { let mag=-tintValue; tintRGB=vec3<f32>(1.0,1.0 - mag * 0.2,1.0);\n}\nlet colorAdjust=tempAdjust * tintRGB;\nlet strength=uniforms.strength * 0.01;\nlet finalAdjust=mix(vec3<f32>(1.0,1.0,1.0),colorAdjust,strength);\ncolor=vec4<f32>(color.rgb * finalAdjust,color.a);\ncolor=vec4<f32>(clamp(color.rgb,vec3<f32>(0.0),vec3<f32>(1.0)),color.a);\ntextureStore(outputTexture,index,color);\n","struct Uniforms { temperature:f32, tint:f32, strength:f32\n};\n")),this.strength=this.#Qg,this.tint=this.#Jg,this.temperature=this.#Zg}get temperature(){return this.#Zg}set temperature(i){validateNumberRange(i,1e3,2e4),this.#Zg=i,this.updateUniform("temperature",i)}get tint(){return this.#Jg}set tint(i){validateNumberRange(i,-100,100),this.#Jg=i,this.updateUniform("tint",i)}get strength(){return this.#Qg}set strength(i){validateNumberRange(i,0,100),this.#Qg=i,this.updateUniform("strength",i)}setWarmTone(){this.temperature=3200,this.tint=-10}setCoolTone(){this.temperature=8e3,this.tint=10}setNeutral(){this.temperature=6500,this.tint=0}setCandleLight(){this.temperature=1900,this.tint=-5}setDaylight(){this.temperature=5600,this.tint=0}setCloudyDay(){this.temperature=7500,this.tint=5}setNeonLight(){this.temperature=9e3,this.tint=15}}Object.freeze(ColorTemperatureTint);class Grayscale extends ASinglePassPostEffect{constructor(i){super(i);this.init(i,"POST_EFFECT_GRAYSCALE",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy );\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nvar color:vec4<f32>=textureLoad( sourceTexture,index );\nlet gray=(color.r + color.g + color.b)/3.0;\ntextureStore(outputTexture,index,vec4<f32>( gray,gray,gray,color.a) );\n",""))}}Object.freeze(Grayscale);class HueSaturation extends ASinglePassPostEffect{#ex=0;#tx=0;constructor(i){super(i),this.init(i,"POST_EFFECT_HUE_SATURATION",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy );\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nvar color:vec4<f32>=textureLoad( sourceTexture,index,);\nlet hue_value:f32=uniforms.hue/180.0;\nlet saturation_value:f32=uniforms.saturation/100.0;\nlet angle:f32=hue_value * 3.1415926535897932384626433832795;\nlet s:f32=sin(angle);\nlet c:f32=cos(angle);\nvar weights:vec3<f32>=(vec3<f32>(2.0 * c,-sqrt(3.0) * s - c,sqrt(3.0) * s - c) + 1.0)/3.0;\nlet len:f32=length(color.rgb);\ncolor=vec4<f32>( vec3<f32>( dot(color.rgb,weights.xyz), dot(color.rgb,weights.zxy), dot(color.rgb,weights.yzx) ), color.a\n);\nlet average:f32=(color.r + color.g + color.b)/3.0;\nif (saturation_value > 0.0) { color=vec4<f32>( color.rgb + (average - color.rgb) * (1.0 - 1.0/(1.001 - saturation_value)), color.a );\n} else { color=vec4<f32>( color.rgb + (average - color.rgb) * (-saturation_value), color.a );\n}\ntextureStore(outputTexture,index,color );\n","struct Uniforms { hue:f32, saturation:f32\n};\n"))}get hue(){return this.#ex}set hue(i){validateNumberRange(i,-180,180),this.#ex=i,this.updateUniform("hue",i)}get saturation(){return this.#tx}set saturation(i){validateNumberRange(i,-100,100),this.#tx=i,this.updateUniform("saturation",i)}}Object.freeze(HueSaturation);class Invert extends ASinglePassPostEffect{constructor(i){super(i);this.init(i,"POST_EFFECT_INVERT",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy );\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nvar color:vec4<f32>=textureLoad( sourceTexture,index,);\ncolor.r=1.0 - color.r;\ncolor.g=1.0 - color.g;\ncolor.b=1.0 - color.b;\ntextureStore(outputTexture,index,color );\n",""))}}Object.freeze(Invert);class Threshold extends ASinglePassPostEffect{#nx=128;constructor(i){super(i),this.init(i,"POST_EFFECT_THRESHOLD",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy );\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nvar color:vec4<f32>=textureLoad( sourceTexture,index,);\nlet threshold_value:f32=uniforms.threshold/255.0;\nvar v=0.0;\nif( 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b >=threshold_value) { v=1.0;\n}\ncolor=vec4<f32>(v,v,v,color.a);\ntextureStore(outputTexture,index,color );\n","struct Uniforms { threshold:f32\n};\n")),this.threshold=this.#nx}get threshold(){return this.#nx}set threshold(i){validateNumberRange(i,1,255),this.#nx=i,this.updateUniform("threshold",i)}}Object.freeze(Threshold);class Vibrance extends ASinglePassPostEffect{#rx=0;#tx=0;constructor(i){super(i),this.init(i,"POST_EFFECT_VIBRANCE",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy);\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nvar color:vec4<f32>=textureLoad(sourceTexture,index);\nlet originalColor=color;\nlet luminance=0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\nif (uniforms.saturation !=0.0) { let saturationFactor=1.0 + uniforms.saturation * 0.01; color=vec4<f32>( mix(luminance,color.r,saturationFactor), mix(luminance,color.g,saturationFactor), mix(luminance,color.b,saturationFactor), color.a );\n}\nif (uniforms.vibrance !=0.0) { let maxComponent=max(max(color.r,color.g),color.b); let minComponent=min(min(color.r,color.g),color.b); let currentSaturation=maxComponent - minComponent; let protectionFactor=1.0/(1.0 + exp(6.0 * (currentSaturation - 0.6))); var skinToneProtection=1.0; if (color.r > color.g && color.g > color.b) { let skinToneAmount=(color.r - color.b)/max(color.r,0.001); skinToneProtection=1.0 - smoothstep(0.3,0.8,skinToneAmount) * 0.7; } let finalProtection=protectionFactor * skinToneProtection; let vibranceStrength=uniforms.vibrance * 0.01 * finalProtection; let vibranceFactor=1.0 + vibranceStrength; color=vec4<f32>( mix(luminance,color.r,vibranceFactor), mix(luminance,color.g,vibranceFactor), mix(luminance,color.b,vibranceFactor), color.a );\n}\ncolor=clamp(color,vec4<f32>(0.0),vec4<f32>(1.0));\ntextureStore(outputTexture,index,color);\n","struct Uniforms { vibrance:f32, saturation:f32\n};\n"))}get vibrance(){return this.#rx}set vibrance(i){validateNumberRange(i,-100,100),this.#rx=i,this.updateUniform("vibrance",i)}get saturation(){return this.#tx}set saturation(i){validateNumberRange(i,-100,100),this.#tx=i,this.updateUniform("saturation",i)}}Object.freeze(Vibrance);const go=[0,0,0,0,0,1,0,0,0,0,0,0],xo=[0,-1,0,0,-1,5,-1,0,0,-1,0,0],_o=[1,1,1,0,1,1,1,0,1,1,1,0],vo=[0,1,0,0,1,-4,1,0,0,1,0,0],bo=[-2,-1,0,0,-1,1,1,0,0,1,2,0];class Convolution extends ASinglePassPostEffect{static NORMAL=go;static SHARPEN=xo;static BLUR=_o;static EDGE=vo;static EMBOSE=bo;#ix=_o;constructor(i){super(i),this.init(i,"POST_EFFECT_CONVOLUTION",createBasicPostEffectCode(this,"let index=vec2<i32>(global_id.xy );\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet perPX=vec2<f32>(1.0/dimW,1.0/dimH);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nvar color:vec4<f32>=vec4<f32>(0.0);\nlet kernelWeight_value:f32=uniforms.kernelWeight;\nlet kernel_value:mat3x3<f32>=uniforms.kernel;\ncolor +=textureLoad(sourceTexture,index + vec2<i32>(-1,-1)) * kernel_value[0][0];\ncolor +=textureLoad(sourceTexture,index + vec2<i32>(0,-1)) * kernel_value[0][1];\ncolor +=textureLoad(sourceTexture,index + vec2<i32>(1,-1)) * kernel_value[0][2];\ncolor +=textureLoad(sourceTexture,index + vec2<i32>(-1,0)) * kernel_value[1][0];\ncolor +=textureLoad(sourceTexture,index + vec2<i32>(0,0)) * kernel_value[1][1];\ncolor +=textureLoad(sourceTexture,index + vec2<i32>(1,0)) * kernel_value[1][2];\ncolor +=textureLoad(sourceTexture,index + vec2<i32>(-1,1)) * kernel_value[2][0];\ncolor +=textureLoad(sourceTexture,index + vec2<i32>(0,1)) * kernel_value[2][1];\ncolor +=textureLoad(sourceTexture,index + vec2<i32>(1,1)) * kernel_value[2][2];\ntextureStore(outputTexture,index,color/kernelWeight_value );\n","struct Uniforms { kernelWeight:f32, kernel:mat3x3<f32>\n};\n")),this.kernel=this.#ix}get kernel(){return this.#ix}set kernel(i){this.#ix=i;let g=0;for(const i in this.#ix)g+=this.#ix[i];this.updateUniform("kernelWeight",g),this.updateUniform("kernel",i)}}Object.freeze(Convolution);class Blur extends AMultiPassPostEffect{#ax;constructor(i){super(i,[new Convolution(i)]),this.#ax=this.passList[0],this.#ax.kernel=Convolution.BLUR}render(i,g,x,_){return this.#ax.render(i,g,x,_)}}Object.freeze(Blur);class DirectionalBlur extends ASinglePassPostEffect{#sx=15;#ox=0;constructor(i){super(i),this.init(i,"POST_EFFECT_DIRECTIONAL_BLUR",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet direction=vec2<f32>(uniforms.directionX,uniforms.directionY);\nlet dirLength=length(direction);\nlet normalizedDir=select(vec2<f32>(0.0),direction/dirLength,dirLength > 0.0);\nlet dir=normalizedDir * uniforms.amount;\nconst loopSize=30.0;\nlet offset=random(global_id,0.0);\nlet global_id_vec=vec2<f32>(f32(global_id.x),f32(global_id.y));\nvar sum=vec4<f32>(0.0,0.0,0.0,0.0);\nvar total=0.0;\nfor (var t=-loopSize;t <=loopSize;t=t + 1.0) { var percent=1.0 - (t + offset - 0.5)/loopSize; var weight=3.0 * (percent - percent * percent); let deltaPercent=dir * percent; let delta=vec2<i32>( i32(clamp(global_id_vec.x + deltaPercent.x,0.0,dimW - 1.0)), i32(clamp(global_id_vec.y + deltaPercent.y,0.0,dimH - 1.0)) ); sum +=textureLoad(sourceTexture,delta).xyzw * weight; total +=weight;\n}\ntextureStore(outputTexture,vec2<i32>(global_id.xy),sum/total);\n","struct Uniforms { amount:f32, directionX:f32, directionY:f32\n};\nfn random(id:vec3<u32>,delta:f32) -> f32 { let seed:u32=((id.x << 16) | (id.y & 0xFFFF)) ^ (id.z * 0x63641362); let t:vec3<f32>=vec3<f32>(f32(seed & 0xFF),f32((seed >> 8) & 0xFF),f32(seed >> 16)); return delta + fract(sin(dot(t,vec3<f32>(12.9898,78.233,12.9898))) * 43758.5453);\n}\n")),this.amount=this.#sx,this.angle=this.#ox}get angle(){return this.#ox}set angle(i){validateNumber(i),this.#ox=i%360,this.#ux()}get amount(){return this.#sx}set amount(i){validateNumberRange(i,0),this.#sx=i,this.updateUniform("amount",i)}#ux(){const i=this.#ox*Math.PI/180,g=Math.cos(i),x=Math.sin(i);this.updateUniform("directionX",g),this.updateUniform("directionY",x)}}Object.freeze(DirectionalBlur);class RadialBlur extends ASinglePassPostEffect{#sx=50;#sf=0;#of=0;#lx=16;constructor(i){super(i),this.init(i,"POST_EFFECT_RADIAL_BLUR",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet center=vec2<f32>(dimW * 0.5 + uniforms.centerX,dimH * 0.5 + uniforms.centerY);\nlet global_id_vec=vec2<f32>(f32(global_id.x),f32(global_id.y));\nlet toPixel=global_id_vec - center;\nlet distance=length(toPixel);\nlet angle=atan2(toPixel.y,toPixel.x);\nlet maxDist=min(dimW,dimH) * 0.5;\nlet normalizedDistance=distance/maxDist;\nlet rotationAngle=uniforms.amount * normalizedDistance * 0.001;\nlet sampleCount=i32(uniforms.sampleCount);\nvar sum=vec4<f32>(0.0,0.0,0.0,0.0);\nvar totalWeight=0.0;\nfor (var i=0;i < sampleCount;i=i + 1) { let t=f32(i)/f32(sampleCount - 1); let sampleAngle=angle + (t - 0.5) * rotationAngle; let samplePos=center + vec2<f32>( cos(sampleAngle) * distance, sin(sampleAngle) * distance ); var weight=1.0 - abs(t - 0.5) * 1.5; weight=max(weight,0.1); let sampleCoord=vec2<i32>( i32(clamp(samplePos.x,0.0,dimW - 1.0)), i32(clamp(samplePos.y,0.0,dimH - 1.0)) ); sum +=textureLoad(sourceTexture,sampleCoord).xyzw * weight; totalWeight +=weight;\n}\nlet centerFalloff=smoothstep(0.0,maxDist * 0.2,distance);\nlet originalColor=textureLoad(sourceTexture,vec2<i32>(global_id.xy)).xyzw;\nlet blurredColor=sum/totalWeight;\nlet finalColor=mix(originalColor,blurredColor,centerFalloff);\ntextureStore(outputTexture,vec2<i32>(global_id.xy),finalColor);\n","struct Uniforms { amount:f32, centerX:f32, centerY:f32, sampleCount:f32\n};\n")),this.amount=this.#sx,this.sampleCount=this.#lx}get centerX(){return this.#sf}set centerX(i){validateNumber(i),this.#sf=i,this.updateUniform("centerX",i)}get centerY(){return this.#of}set centerY(i){validateNumber(i),this.#of=i,this.updateUniform("centerY",i)}get amount(){return this.#sx}set amount(i){validateNumberRange(i,0),this.#sx=i,this.updateUniform("amount",i)}get sampleCount(){return this.#lx}set sampleCount(i){validateNumberRange(i,4),this.#lx=i,this.updateUniform("sampleCount",i)}}Object.freeze(RadialBlur);class ZoomBlur extends ASinglePassPostEffect{#sx=64;#sf=0;#of=0;constructor(i){super(i),this.init(i,"POST_EFFECT_ZOOM_BLUR",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet dimensionsVec=vec2<f32>(dimW,dimH);\nlet amount=uniforms.amount/min(dimW,dimH);\nconst loopSize=30.0;\nlet offset=random(global_id,0.0);\nlet center=vec2<f32>(dimW * 0.5 + uniforms.centerX,dimH * 0.5 + uniforms.centerY);\nlet global_id_vec=vec2<f32>(f32(global_id.x),f32(global_id.y));\nlet dir=(center - global_id_vec) * amount;\nvar sum=vec4<f32>(0.0,0.0,0.0,0.0);\nvar total=0.0;\nfor (var t=-loopSize;t <=loopSize;t=t + 1.0) { var percent=1.0 - (t + offset - 0.5)/loopSize; var weight=3.0 * (percent - percent * percent); let deltaPercent=dir * percent; let delta=vec2<i32>( i32(clamp(global_id_vec.x + deltaPercent.x,0.0,dimW - 1.0)), i32(clamp(global_id_vec.y + deltaPercent.y,0.0,dimH - 1.0)) ); sum +=textureLoad(sourceTexture,delta).xyzw * weight; total +=weight;\n}\ntextureStore(outputTexture,vec2<i32>(global_id.xy),sum/total);\n","struct Uniforms { amount:f32, centerX:f32, centerY:f32\n};\nfn random(id:vec3<u32>,delta:f32) -> f32 { let seed:u32=((id.x << 16) | (id.y & 0xFFFF)) ^ (id.z * 0x63641362); let t:vec3<f32>=vec3<f32>(f32(seed & 0xFF),f32((seed >> 8) & 0xFF),f32(seed >> 16)); return delta + fract(sin(dot(t,vec3<f32>(12.9898,78.233,12.9898))) * 43758.5453);\n}\n")),this.amount=this.#sx}get centerX(){return this.#sf}set centerX(i){validateNumber(i),this.#sf=i,this.updateUniform("centerX",i)}get centerY(){return this.#of}set centerY(i){validateNumber(i),this.#of=i,this.updateUniform("centerY",i)}get amount(){return this.#sx}set amount(i){validateNumberRange(i,0),this.#sx=i,this.updateUniform("amount",i)}}Object.freeze(ZoomBlur);const yo={filmGrainIntensity:.02,filmGrainResponse:.9,filmGrainScale:2.5,coloredGrain:.3,grainSaturation:.4},So={filmGrainIntensity:.05,filmGrainResponse:.8,filmGrainScale:3,coloredGrain:.5,grainSaturation:.6},To={filmGrainIntensity:.12,filmGrainResponse:.6,filmGrainScale:4,coloredGrain:.7,grainSaturation:.8},Mo={filmGrainIntensity:.08,filmGrainResponse:.7,filmGrainScale:5,coloredGrain:.9,grainSaturation:1};class FilmGrain extends ASinglePassPostEffect{static SUBTLE=yo;static MEDIUM=So;static HEAVY=To;static VINTAGE=Mo;#cx=To.filmGrainIntensity;#hx=To.filmGrainResponse;#fx=To.filmGrainScale;#dx=To.coloredGrain;#mx=To.grainSaturation;#Wm=0;#px=1;constructor(i){super(i),this.#px=window?.devicePixelRatio||1,this.init(i,"POST_EFFECT_FILM_GRAIN",createBasicPostEffectCode(this,"let index=vec2<i32>(global_id.xy);\nlet dimensions:vec2<u32>=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nlet originalColor=textureLoad(sourceTexture,index);\nlet filmGrainIntensity_value:f32=uniforms.filmGrainIntensity;\nlet filmGrainResponse_value:f32=uniforms.filmGrainResponse;\nlet filmGrainScale_value:f32=uniforms.filmGrainScale;\nlet coloredGrain_value:f32=uniforms.coloredGrain;\nlet grainSaturation_value:f32=uniforms.grainSaturation;\nlet time_value:f32=uniforms.time;\nlet devicePixelRatio_value:f32=uniforms.devicePixelRatio;\nif (filmGrainIntensity_value <=0.0) { textureStore(outputTexture,index,originalColor); return;\n}\nlet baseScale=max(filmGrainScale_value,0.1);\nlet scaledUV=uv * vec2<f32>(dimW,dimH) * devicePixelRatio_value/baseScale;\nlet timeOffset=vec2<f32>( fract(time_value * 0.0317) * 100.0, fract(time_value * 0.0271) * 100.0\n);\nlet grainCoord=scaledUV + timeOffset;\nlet sampleOffset=1.0/baseScale;\nlet noiseR=(filmGrainNoise(grainCoord) + filmGrainNoise(grainCoord + vec2<f32>(sampleOffset,0.0)) + filmGrainNoise(grainCoord + vec2<f32>(0.0,sampleOffset)))/3.0;\nlet noiseG=filmGrainNoise(grainCoord + vec2<f32>(127.1,311.7));\nlet noiseB=filmGrainNoise(grainCoord + vec2<f32>(269.5,183.3));\nlet monoGrain=(noiseR + noiseG + noiseB)/3.0;\nlet colorGrain=vec3<f32>(noiseR,noiseG,noiseB);\nvar grainColor=mix(vec3<f32>(monoGrain),colorGrain,coloredGrain_value);\nlet grainLuminance=dot(grainColor,vec3<f32>(0.299,0.587,0.114));\ngrainColor=mix(vec3<f32>(grainLuminance),grainColor,grainSaturation_value);\nlet luminance=dot(originalColor.rgb,vec3<f32>(0.299,0.587,0.114));\nlet luminanceWeight=pow(max(luminance,0.01),filmGrainResponse_value);\nlet grainIntensity=filmGrainIntensity_value * luminanceWeight;\nlet grain=grainColor * grainIntensity;\nlet finalColor=originalColor.rgb + grain;\nlet outputColor=vec4<f32>(clamp(finalColor,vec3<f32>(0.0),vec3<f32>(1.0)),originalColor.a);\ntextureStore(outputTexture,index,outputColor);\n","struct Uniforms { filmGrainIntensity:f32, filmGrainResponse:f32, filmGrainScale:f32, coloredGrain:f32, grainSaturation:f32, time:f32, devicePixelRatio:f32\n};\nfn filmGrainNoise(coord:vec2<f32>) -> f32 { let p=floor(coord); let f=fract(coord); let u=f * f * f * (f * (f * 6.0 - 15.0) + 10.0); let a=hash(p); let b=hash(p + vec2<f32>(1.0,0.0)); let c=hash(p + vec2<f32>(0.0,1.0)); let d=hash(p + vec2<f32>(1.0,1.0)); let noise=mix(mix(a,b,u.x),mix(c,d,u.x),u.y); return (noise - 0.5) * 2.0;\n}\nfn hash(p:vec2<f32>) -> f32 { var p3=fract(vec3<f32>(p.xyx) * 0.1031); p3 +=dot(p3,p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z);\n}\n")),this.#gx()}get filmGrainIntensity(){return this.#cx}set filmGrainIntensity(i){this.#cx=Math.max(0,Math.min(1,i)),this.updateUniform("filmGrainIntensity",this.#cx)}get filmGrainResponse(){return this.#hx}set filmGrainResponse(i){this.#hx=Math.max(0,Math.min(2,i)),this.updateUniform("filmGrainResponse",this.#hx)}get filmGrainScale(){return this.#fx}set filmGrainScale(i){this.#fx=Math.max(.1,Math.min(20,i)),this.updateUniform("filmGrainScale",this.#fx)}get coloredGrain(){return this.#dx}set coloredGrain(i){this.#dx=Math.max(0,Math.min(1,i)),this.updateUniform("coloredGrain",this.#dx)}get grainSaturation(){return this.#mx}set grainSaturation(i){this.#mx=Math.max(0,Math.min(2,i)),this.updateUniform("grainSaturation",this.#mx)}applyPreset(i){this.#cx=i.filmGrainIntensity,this.#hx=i.filmGrainResponse,this.#fx=i.filmGrainScale,this.#dx=i.coloredGrain,this.#mx=i.grainSaturation,this.#gx()}update(i){this.#Wm+=i,this.updateUniform("time",this.#Wm)}#gx(){this.updateUniform("filmGrainIntensity",this.#cx),this.updateUniform("filmGrainResponse",this.#hx),this.updateUniform("filmGrainScale",this.#fx),this.updateUniform("coloredGrain",this.#dx),this.updateUniform("grainSaturation",this.#mx),this.updateUniform("time",this.#Wm),this.updateUniform("devicePixelRatio",this.#px)}}Object.freeze(FilmGrain);class Fog extends ASinglePassPostEffect{static EXPONENTIAL=0;static EXPONENTIAL_SQUARED=1;#xx=Fog.EXPONENTIAL;#_x=.05;#vx=4.5;#bx=50;#yx;constructor(i){super(i),this.useDepthTexture=!0,this.init(i,"POST_EFFECT_FOG",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy);\nlet coord=vec2<i32>(global_id.xy);\nvar sceneColor:vec4<f32>=textureLoad(sourceTexture,coord);\nlet depth=textureLoad(depthTexture,coord,0);\nlet linearDepth=linearizeDepth(depth,systemUniforms.camera.nearClipping,systemUniforms.camera.farClipping);\nlet fogFactor=calculateFogFactor(linearDepth,systemUniforms.camera.farClipping);\nlet finalColor=mix(uniforms.fogColor.rgb,sceneColor.rgb,fogFactor);\ntextureStore(outputTexture,coord,vec4<f32>(finalColor,sceneColor.a));\n","struct Uniforms { fogType:u32, density:f32, nearDistance:f32, farDistance:f32, fogColor:vec3<f32>, padding1:f32,\n};\nfn linearizeDepth(depth:f32,cameraNear:f32,cameraFar:f32) -> f32 { let z=depth * 2.0 - 1.0; return (2.0 * cameraNear * cameraFar)/ (cameraFar + cameraNear - z * (cameraFar - cameraNear));\n}\nfn calculateFogFactor(linearDepth:f32,cameraFar:f32) -> f32 { let u_density=uniforms.density; let u_fogType=uniforms.fogType; let u_nearDistance=uniforms.nearDistance; let u_farDistance=uniforms.farDistance; let isBackground=linearDepth >=(cameraFar * 0.99); if (isBackground) { return 1.0 - u_density; } let distance=max(0.0,linearDepth - u_nearDistance); let maxDistance=u_farDistance - u_nearDistance; let normalizedDistance=clamp(distance/max(0.1,maxDistance),0.0,1.0); var fogFactor:f32; if (u_fogType==0u) { fogFactor=exp(-u_density * normalizedDistance * 10.0); } else { let expValue=u_density * normalizedDistance * 5.0; fogFactor=exp(-(expValue * expValue)); } return clamp(fogFactor,0.0,1.0);\n}\n")),this.#yx=new ColorRGB(178,178,204,()=>{this.updateUniform("fogColor",this.#yx.rgbNormalLinear)}),this.fogType=this.#xx,this.density=this.#_x,this.nearDistance=this.#vx,this.farDistance=this.#bx}get fogType(){return this.#xx}set fogType(i){validateNumberRange(i,0,1),this.#xx=Math.floor(i),this.updateUniform("fogType",this.#xx)}get density(){return this.#_x}set density(i){validateNumberRange(i,0,1),this.#_x=Math.max(0,Math.min(1,i)),this.updateUniform("density",this.#_x)}get nearDistance(){return this.#vx}set nearDistance(i){validateNumberRange(i,0),this.#vx=Math.max(.1,i),this.#bx<=this.#vx&&(this.#bx=this.#vx+.1,this.updateUniform("farDistance",this.#bx)),this.updateUniform("nearDistance",this.#vx)}get farDistance(){return this.#bx}set farDistance(i){validateNumberRange(i,0),this.#bx=Math.max(this.#vx+.1,i),this.updateUniform("farDistance",this.#bx)}get fogColor(){return this.#yx}render(i,g,x,_){return super.render(i,g,x,_)}}Object.freeze(Fog);class HeightFog extends ASinglePassPostEffect{static EXPONENTIAL=0;static EXPONENTIAL_SQUARED=1;#xx=HeightFog.EXPONENTIAL;#_x=1;#yx;#Sx=0;#Tx=100;#Mx=.1;constructor(i){super(i),this.useDepthTexture=!0,this.init(i,"POST_EFFECT_HEIGHT_FOG",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet global_id_vec=vec2<f32>(f32(global_id.x),f32(global_id.y));\nlet screenCoord=vec2<f32>( global_id_vec.x/dimW,global_id_vec.y/dimH );\nvar depth:f32=1.0;\nif (dimensions.x > u32(global_id.x) && dimensions.y > u32(global_id.y)) { depth=textureLoad(depthTexture,vec2<i32>(global_id.xy),0);\n}\nlet fogFactor=calculateHeightFogFactor(screenCoord,depth);\nlet originalColor=textureLoad(sourceTexture,vec2<i32>(global_id.xy)).rgb;\nlet foggedColor=mix(uniforms.fogColor,originalColor,fogFactor);\ntextureStore(outputTexture,vec2<i32>(global_id.xy),vec4<f32>(foggedColor,1.0));\n","struct Uniforms { fogType:u32, density:f32, baseHeight:f32, falloff:f32, maxHeight:f32, fogColor:vec3<f32>, padding1:f32, padding2:f32,\n};\nfn isFiniteValue(value:f32) -> bool { return value==value;\n}\nfn isFiniteVec3(v:vec3<f32>) -> bool { return isFiniteValue(v.x) && isFiniteValue(v.y) && isFiniteValue(v.z);\n}\nfn reconstructWorldPositionUltraPrecise(screenCoord:vec2<f32>,depth:f32) -> vec3<f32> { let ndcX=fma(screenCoord.x,2.0,-1.0); let ndcY=fma(-screenCoord.y,2.0,1.0); let safeDepth=clamp(depth,1e-7,1.0 - 1e-7); let ndc=vec3<f32>(ndcX,ndcY,safeDepth); let clipPos=vec4<f32>(ndc,1.0); let worldPos4=systemUniforms.inverseProjectionCameraMatrix * clipPos; let epsilon=1e-6; let w=select(worldPos4.w,epsilon,abs(worldPos4.w) < epsilon); let worldPos=worldPos4.xyz/w; let maxCoord=1e6; let stabilizedX=clamp(worldPos.x,-maxCoord,maxCoord); let stabilizedY=clamp(worldPos.y,-maxCoord,maxCoord); let stabilizedZ=clamp(worldPos.z,-maxCoord,maxCoord); let finalPos=vec3<f32>(stabilizedX,stabilizedY,stabilizedZ); return select(vec3<f32>(0.0,0.0,0.0),finalPos,isFiniteVec3(finalPos));\n}\nfn calculateHeightFogFactor(screenCoord:vec2<f32>,depth:f32) -> f32 { let backgroundThreshold=1.0 - 1e-5; let isBackground=depth >=backgroundThreshold; var pixelWorldHeight:f32; if (isBackground) { let rayDirection=getRayDirectionMaxPrecision(screenCoord); pixelWorldHeight=getSkyboxHeightMaxPrecision(rayDirection); } else { let worldPos=reconstructWorldPositionUltraPrecise(screenCoord,depth); pixelWorldHeight=worldPos.y; } return calculateAbsoluteHeightFogMaxPrecision(pixelWorldHeight);\n}\nfn getSkyboxHeightMaxPrecision(rayDirection:vec3<f32>) -> f32 { let u_baseHeight=uniforms.baseHeight; let u_maxHeight=uniforms.maxHeight; let rayY=clamp(rayDirection.y,-0.999,0.999); let upThreshold=0.08; let downThreshold=-0.015; let transitionRange=upThreshold - downThreshold; let safeTransitionRange=max(transitionRange,1e-6); if (rayY > upThreshold) { return u_maxHeight + 25.0; } else if (rayY < downThreshold) { return fma(u_maxHeight - u_baseHeight,0.03,u_baseHeight); } else { let normalizedT=(rayY - downThreshold)/safeTransitionRange; let smoothT=smoothstep(0.0,1.0,normalizedT); let lowValue=fma(u_maxHeight - u_baseHeight,0.03,u_baseHeight); let highValue=u_maxHeight + 25.0; return fma(smoothT,highValue - lowValue,lowValue); }\n}\nfn calculateAbsoluteHeightFogMaxPrecision(worldHeight:f32) -> f32 { let u_baseHeight=uniforms.baseHeight; let u_maxHeight=uniforms.maxHeight; let u_density=uniforms.density; let u_falloff=uniforms.falloff; let u_fogType=uniforms.fogType; if (!isFiniteValue(worldHeight)) { return 1.0; } let heightRange=u_maxHeight - u_baseHeight; let safeHeightRange=max(heightRange,1e-3); let margin=fma(safeHeightRange,0.18,1.2); let extendedBaseHeight=u_baseHeight - margin; let extendedMaxHeight=u_maxHeight + margin; let extendedRange=extendedMaxHeight - extendedBaseHeight; if (worldHeight <=extendedBaseHeight || worldHeight >=extendedMaxHeight) { return 1.0; } let safeExtendedRange=max(extendedRange,1e-3); if (safeExtendedRange <=0.3) { return 1.0; } let normalizedHeight=clamp( (worldHeight - extendedBaseHeight)/safeExtendedRange, 0.0, 1.0 ); let centerOffset=normalizedHeight - 0.5; let edgeFactor=fma(-abs(centerOffset),0.25,1.0); let heightFactor=1.0 - normalizedHeight; let safeHeightFactor=max(heightFactor,1e-4); let safeFalloff=clamp(u_falloff,0.05,1.8); let expPower=fma(safeFalloff,0.73,1.05); var fogDensity:f32; if (u_fogType==0u) { fogDensity=pow(safeHeightFactor,expPower); fogDensity=smoothstep(0.0,1.0,fogDensity); } else { let expResult=pow(safeHeightFactor,expPower); fogDensity=expResult * expResult; fogDensity=smoothstep(0.0,1.0,fogDensity); } let densityWithEdge=fogDensity * edgeFactor; let safeDensity=clamp(u_density,0.0,4.0); let finalFogAmount=fma(densityWithEdge,safeDensity,0.0) * 0.42; let result=clamp(1.0 - finalFogAmount,0.0,1.0); return select(1.0,result,isFiniteValue(result));\n}\nfn getRayDirectionMaxPrecision(screenCoord:vec2<f32>) -> vec3<f32> { let centeredX=fma(screenCoord.x,1.0,-0.5); let centeredY=fma(screenCoord.y,1.0,-0.5); let ndcX=centeredX * 2.0; let ndcY=-(centeredY * 2.0); let ndc=vec3<f32>(ndcX,ndcY,1.0); let clipPos=vec4<f32>(ndc,1.0); let worldPos4=systemUniforms.inverseProjectionCameraMatrix * clipPos; let epsilon=1e-6; let w=select(worldPos4.w,epsilon,abs(worldPos4.w) < epsilon); let worldPos=worldPos4.xyz/w; let cameraPos=systemUniforms.camera.cameraPosition; let rayDir=worldPos - cameraPos; let rayLength=length(rayDir); let minLength=1e-6; if (rayLength < minLength) { return vec3<f32>(0.0,0.0,1.0); } let normalizedRay=rayDir/rayLength; let safeRayX=clamp(normalizedRay.x,-0.999,0.999); let safeRayY=clamp(normalizedRay.y,-0.999,0.999); let safeRayZ=clamp(normalizedRay.z,-0.999,0.999); let safeRay=vec3<f32>(safeRayX,safeRayY,safeRayZ); let finalRayLength=length(safeRay); let isValidRay=finalRayLength > 1e-6 && isFiniteValue(finalRayLength); if (isValidRay) { let finalRay=safeRay/finalRayLength; return select(vec3<f32>(0.0,0.0,1.0),finalRay,isFiniteVec3(finalRay)); } return vec3<f32>(0.0,0.0,1.0);\n}\n")),this.#yx=new ColorRGB(178,178,204,()=>{this.updateUniform("fogColor",this.#yx.rgbNormal)}),this.fogType=this.#xx,this.density=this.#_x,this.baseHeight=this.#Sx,this.thickness=this.#Tx,this.falloff=this.#Mx}get fogType(){return this.#xx}set fogType(i){validateNumberRange(i,0,1),this.#xx=Math.floor(i),this.updateUniform("fogType",this.#xx)}get density(){return this.#_x}set density(i){validateNumberRange(i,0,5),this.#_x=Math.max(0,Math.min(5,i)),this.updateUniform("density",this.#_x)}get fogColor(){return this.#yx}get baseHeight(){return this.#Sx}set baseHeight(i){validateNumberRange(i),this.#Sx=i,this.updateUniform("baseHeight",this.#Sx),this.updateUniform("maxHeight",this.maxHeight)}get maxHeight(){return this.#Sx+this.#Tx}get thickness(){return this.#Tx}set thickness(i){validateNumberRange(i,.1),this.#Tx=Math.max(.1,i),this.updateUniform("maxHeight",this.#Sx+this.#Tx)}get falloff(){return this.#Mx}set falloff(i){validateNumberRange(i,0,2),this.#Mx=Math.max(.001,Math.min(2,i)),this.updateUniform("falloff",this.#Mx)}render(i,g,x,_){return super.render(i,g,x,_)}}Object.freeze(HeightFog);class ChromaticAberration extends ASinglePassPostEffect{#Qg=.015;#sf=.5;#of=.5;#Mx=1;constructor(i){super(i),this.init(i,"POST_EFFECT_CHROMATIC_ABERRATION",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet uv=vec2<f32>(f32(global_id.x),f32(global_id.y))/vec2<f32>(dimW,dimH);\nlet center=vec2<f32>(uniforms.centerX,uniforms.centerY);\nlet offset=uv - center;\nlet distance=length(offset);\nlet distortion=uniforms.strength * pow(distance,uniforms.falloff);\nlet redOffset=uv + offset * distortion * vec2<f32>(-1.0,-1.0);\nlet greenOffset=uv;\nlet blueOffset=uv + offset * distortion * vec2<f32>(1.0,1.0);\nvar finalColor=vec3<f32>(0.0);\nif (redOffset.x >=0.0 && redOffset.x <=1.0 && redOffset.y >=0.0 && redOffset.y <=1.0) { let redCoord=vec2<i32>( i32(clamp(redOffset.x * dimW,0.0,dimW - 1.0)), i32(clamp(redOffset.y * dimH,0.0,dimH - 1.0)) ); finalColor.r=textureLoad(sourceTexture,redCoord).r;\n}\nlet greenCoord=vec2<i32>( i32(clamp(greenOffset.x * dimW,0.0,dimW - 1.0)), i32(clamp(greenOffset.y * dimH,0.0,dimH - 1.0))\n);\nfinalColor.g=textureLoad(sourceTexture,greenCoord).g;\nif (blueOffset.x >=0.0 && blueOffset.x <=1.0 && blueOffset.y >=0.0 && blueOffset.y <=1.0) { let blueCoord=vec2<i32>( i32(clamp(blueOffset.x * dimW,0.0,dimW - 1.0)), i32(clamp(blueOffset.y * dimH,0.0,dimH - 1.0)) ); finalColor.b=textureLoad(sourceTexture,blueCoord).b;\n}\nlet originalAlpha=textureLoad(sourceTexture,vec2<i32>(global_id.xy)).a;\ntextureStore(outputTexture,vec2<i32>(global_id.xy),vec4<f32>(finalColor,originalAlpha));\n","struct Uniforms { strength:f32, centerX:f32, centerY:f32, falloff:f32\n};\n")),this.strength=this.#Qg,this.centerX=this.#sf,this.centerY=this.#of,this.falloff=this.#Mx}get strength(){return this.#Qg}set strength(i){validateNumberRange(i,0),this.#Qg=i,this.updateUniform("strength",i)}get centerX(){return this.#sf}set centerX(i){validateNumberRange(i,0,1),this.#sf=i,this.updateUniform("centerX",i)}get centerY(){return this.#of}set centerY(i){validateNumberRange(i,0,1),this.#of=i,this.updateUniform("centerY",i)}get falloff(){return this.#Mx}set falloff(i){validateNumberRange(i,0,5),this.#Mx=i,this.updateUniform("falloff",i)}}Object.freeze(ChromaticAberration);class DOFCoC extends ASinglePassPostEffect{#wx=15;#Cx=1.4;#Px=32;#Rx=.1;#Bx=1e3;constructor(i){super(i),this.useDepthTexture=!0,this.init(i,"POST_EFFECT_DOF_COC",createBasicPostEffectCode(this,"let index=vec2<u32>(global_id.xy);\nlet coord=vec2<i32>(global_id.xy);\nlet originalColor=textureLoad(sourceTexture,coord).xyzw;\nlet depth=textureLoad(depthTexture,coord,0);\nlet linearDepth=linearizeDepth(depth);\nlet coc=calculateCoC(linearDepth);\nlet encodedCoC=encodeCoC(coc);\ntextureStore(outputTexture,coord,vec4<f32>(originalColor.rgb,encodedCoC));\n","struct Uniforms { focusDistance:f32, aperture:f32, maxCoC:f32, nearPlane:f32, farPlane:f32,\n};\nfn linearizeDepth(depth:f32) -> f32 { let z=depth * 2.0 - 1.0; return (2.0 * uniforms.nearPlane * uniforms.farPlane)/ (uniforms.farPlane + uniforms.nearPlane - z * (uniforms.farPlane - uniforms.nearPlane));\n}\nfn encodeCoC(coc:f32) -> f32 { return (coc + 1.0) * 0.5;\n}\nfn calculateCoC(linearDepth:f32) -> f32 { let subjectDistance=linearDepth; let focalLength=50.0; let focusRange=uniforms.focusDistance * 0.15; let transitionRange=uniforms.focusDistance * 0.35; let distanceFromFocus=abs(subjectDistance - uniforms.focusDistance); if (distanceFromFocus < focusRange) { let focusFactor=smoothstep(0.0,focusRange,distanceFromFocus); return mix(0.0,0.02,focusFactor); } var rawCoC:f32; var signedCoC:f32; if (subjectDistance < uniforms.focusDistance) { let nearDistance=uniforms.focusDistance - subjectDistance; let nearFactor=nearDistance/uniforms.focusDistance; rawCoC=(uniforms.aperture * focalLength * nearDistance)/ (subjectDistance * (uniforms.focusDistance - focalLength)); rawCoC=rawCoC * (1.0 + nearFactor * 1.5); signedCoC=-(rawCoC/uniforms.maxCoC); let absCoC=abs(signedCoC); if (absCoC > 0.05) { signedCoC=-min(1.0,absCoC * smoothstep(0.05,0.3,absCoC) * 1.5); } if (distanceFromFocus < transitionRange) { let transitionFactor=smoothstep(focusRange,transitionRange,distanceFromFocus); signedCoC=mix(0.0,signedCoC,transitionFactor); } return clamp(signedCoC,-1.0,0.0); } else { let farDistance=subjectDistance - uniforms.focusDistance; rawCoC=(uniforms.aperture * focalLength * farDistance)/ (subjectDistance * (uniforms.focusDistance + focalLength)); rawCoC=rawCoC * (1.0 + farDistance * 0.08); signedCoC=rawCoC/uniforms.maxCoC; let absCoC=abs(signedCoC); if (absCoC > 0.1) { signedCoC=min(1.0,absCoC * smoothstep(0.1,0.5,absCoC) * 1.2); } if (distanceFromFocus < transitionRange) { let transitionFactor=smoothstep(focusRange,transitionRange,distanceFromFocus); signedCoC=mix(0.0,signedCoC,transitionFactor); } return clamp(signedCoC,0.0,1.0); }\n}\n")),this.focusDistance=this.#wx,this.aperture=this.#Cx,this.maxCoC=this.#Px,this.nearPlane=this.#Rx,this.farPlane=this.#Bx}get focusDistance(){return this.#wx}set focusDistance(i){validateNumberRange(i),this.#wx=i,this.updateUniform("focusDistance",i)}get aperture(){return this.#Cx}set aperture(i){validateNumberRange(i),this.#Cx=i,this.updateUniform("aperture",i)}get maxCoC(){return this.#Px}set maxCoC(i){validateNumberRange(i),this.#Px=i,this.updateUniform("maxCoC",i)}get nearPlane(){return this.#Rx}set nearPlane(i){validateNumberRange(i),this.#Rx=i,this.updateUniform("nearPlane",i)}get farPlane(){return this.#Bx}set farPlane(i){validateNumberRange(i),this.#Bx=i,this.updateUniform("farPlane",i)}}Object.freeze(DOFCoC);class DOFUnified extends ASinglePassPostEffect{#Ix=16;#Ex=24;#Dx=1;#Ux=1;constructor(i){super(i);const{WORK_SIZE_X:g,WORK_SIZE_Y:x,WORK_SIZE_Z:_}=this,v=` struct Uniforms { nearBlurSize:f32, farBlurSize:f32, nearStrength:f32, farStrength:f32, };  @group(0) @binding(0) var sourceTexture:texture_storage_2d<rgba16float,read>; @group(0) @binding(1) var cocTexture:texture_storage_2d<rgba16float,read>; @group(1) @binding(0) var outputTexture:texture_storage_2d<rgba16float,write>; @group(1) @binding(1) var<uniform> uniforms:Uniforms;  /* CoC 디코딩 함수 */ fn decodeCoC(encoded:f32) -> f32 { /* 0~1 범위를 -1~1 범위로 복원 */ return encoded * 2.0 - 1.0; }  @compute @workgroup_size(${g},${x},${_}) fn main (@builtin(global_invocation_id) global_id:vec3<u32>) { let index=vec2<u32>(global_id.xy); let dimensions:vec2<u32>=textureDimensions(sourceTexture);  if (index.x >=dimensions.x || index.y >=dimensions.y) { return; }  let originalSample=textureLoad(sourceTexture,index); let originalColor=originalSample.rgb; let originalAlpha=originalSample.a; let encodedCoC=textureLoad(cocTexture,index).a;  /* CoC 값 디코딩 */ let cocValue=decodeCoC(encodedCoC);  /* CoC 임계값 체크 */ if (abs(cocValue) < 0.005) { textureStore(outputTexture,index,vec4<f32>(originalColor,originalAlpha)); return; }  var finalColor=originalColor; var finalAlpha=originalAlpha;  /* Near blur 처리 (CoC < 0) */ if (cocValue < 0.0) { let blurResult=calculateBlur(index,abs(cocValue),uniforms.nearBlurSize,true); let nearBlur=blurResult.rgb; let nearBlurAlpha=blurResult.a; /* Near strength 블렌딩 개선 - 더 강한 효과 */ let nearBlend=saturate(pow(abs(cocValue) * uniforms.nearStrength,0.7)); finalColor=mix(originalColor,nearBlur,nearBlend); finalAlpha=mix(originalAlpha,nearBlurAlpha,nearBlend); } /* Far blur 처리 (CoC > 0) */ else if (cocValue > 0.0) { let blurResult=calculateBlur(index,cocValue,uniforms.farBlurSize,false); let farBlur=blurResult.rgb; let farBlurAlpha=blurResult.a; let rawBlend=cocValue * uniforms.farStrength; let farBlend=saturate(smoothstep(0.0,0.8,rawBlend)); finalColor=mix(originalColor,farBlur,farBlend); finalAlpha=mix(originalAlpha,farBlurAlpha,farBlend); }  textureStore(outputTexture,index,vec4<f32>(finalColor,finalAlpha)); }  fn calculateBlur(center:vec2<u32>,intensity:f32,maxBlurSize:f32,isNear:bool) -> vec4<f32> { let dimensions:vec2<u32>=textureDimensions(sourceTexture); let blurRadius=intensity * maxBlurSize;  /* 최소 블러 반경 조정 */ if (blurRadius < 0.3) { return textureLoad(sourceTexture,center); }  var sum:vec3<f32>=vec3<f32>(0.0); var sumAlpha:f32=0.0; var totalWeight=0.0;  let maxRadius=min(blurRadius,maxBlurSize); /* Near blur에 더 많은 샘플 적용 */ let samples=select(8,16,isNear);/* near=16,far=8 */ let angleStep=6.28318530718/f32(samples);  let originalSample=textureLoad(sourceTexture,center); let originalColor=originalSample.rgb; let originalAlpha=originalSample.a; /* Near blur에 더 강한 중앙 가중치 */ let centerWeight=select(0.4,0.2,isNear);/* near=0.2,far=0.4 */ sum +=originalColor * centerWeight; sumAlpha +=originalAlpha * centerWeight; totalWeight +=centerWeight;  /* 방사형 샘플링 */ for (var i=0;i < samples;i=i + 1) { for (var r=1.0;r <=maxRadius;r=r + 1.0) { let angle=f32(i) * angleStep; let offset=vec2<f32>(cos(angle) * r,sin(angle) * r);  let samplePos=vec2<i32>( clamp(i32(f32(center.x) + offset.x),0,i32(dimensions.x) - 1), clamp(i32(f32(center.y) + offset.y),0,i32(dimensions.y) - 1) );  let sampleData=textureLoad(sourceTexture,vec2<u32>(samplePos)); let sampleColor=sampleData.rgb; let sampleAlpha=sampleData.a; let sampleEncodedCoC=textureLoad(cocTexture,vec2<u32>(samplePos)).a; let sampleCoC=decodeCoC(sampleEncodedCoC);/* 디코딩 추가 */  /* 가우시안 가중치 */ var weight=exp(-r * r/(maxRadius * maxRadius * 0.5));  /* CoC 기반 가중치 조정 */ if (isNear) { /* Near blur:더 강한 조건으로 가중치 증가 */ if (sampleCoC < 0.0 && abs(sampleCoC) >=intensity * 0.5) { weight *=1.5; } } else { /* Far blur:기존 조건 유지 */ if (sampleCoC > 0.0 && sampleCoC >=intensity * 0.7) { weight *=1.2; } }  sum +=sampleColor * weight; sumAlpha +=sampleAlpha * weight; totalWeight +=weight; } }  /* 추가 근거리 샘플링 (near blur만) */ if (isNear && maxRadius > 2.0) { let additionalSamples=8; let innerRadius=maxRadius * 0.3; let innerAngleStep=6.28318530718/f32(additionalSamples);  for (var i=0;i < additionalSamples;i=i + 1) { let angle=f32(i) * innerAngleStep + 0.5;/* 약간의 오프셋 */ let offset=vec2<f32>(cos(angle) * innerRadius,sin(angle) * innerRadius);  let samplePos=vec2<i32>( clamp(i32(f32(center.x) + offset.x),0,i32(dimensions.x) - 1), clamp(i32(f32(center.y) + offset.y),0,i32(dimensions.y) - 1) );  let sampleData=textureLoad(sourceTexture,vec2<u32>(samplePos)); let sampleColor=sampleData.rgb; let sampleAlpha=sampleData.a; let weight=0.8;  sum +=sampleColor * weight; sumAlpha +=sampleAlpha * weight; totalWeight +=weight; } }  if (totalWeight > 0.0) { return vec4<f32>(sum/totalWeight,sumAlpha/totalWeight); } else { return vec4<f32>(originalColor,originalAlpha); } } `;this.init(i,"POST_EFFECT_DOF_UNIFIED",{msaa:v,nonMsaa:v}),this.nearBlurSize=this.#Ix,this.farBlurSize=this.#Ex,this.nearStrength=this.#Dx,this.farStrength=this.#Ux}get nearBlurSize(){return this.#Ix}set nearBlurSize(i){validateNumberRange(i),this.#Ix=i,this.updateUniform("nearBlurSize",i)}get farBlurSize(){return this.#Ex}set farBlurSize(i){validateNumberRange(i),this.#Ex=i,this.updateUniform("farBlurSize",i)}get nearStrength(){return this.#Dx}set nearStrength(i){validateNumberRange(i),this.#Dx=i,this.updateUniform("nearStrength",i)}get farStrength(){return this.#Ux}set farStrength(i){validateNumberRange(i),this.#Ux=i,this.updateUniform("farStrength",i)}render(i,g,x,_,v){return super.render(i,g,x,_,v)}}Object.freeze(DOFUnified);class DOF extends AMultiPassPostEffect{#Lx;#Ax;#wx=15;#Cx=2.8;#Px=25;#Rx=.1;#Bx=1e3;#Ix=15;#Ex=15;#Dx=1;#Ux=1;constructor(i){super(i,[new DOFCoC(i),new DOFUnified(i)]),this.#Lx=this.passList[0],this.#Ax=this.passList[1],this.#Lx.focusDistance=this.#wx,this.#Lx.aperture=this.#Cx,this.#Lx.maxCoC=this.#Px,this.#Lx.nearPlane=this.#Rx,this.#Lx.farPlane=this.#Bx,this.#Ax.nearBlurSize=this.#Ix,this.#Ax.farBlurSize=this.#Ex,this.#Ax.nearStrength=this.#Dx,this.#Ax.farStrength=this.#Ux}get focusDistance(){return this.#wx}set focusDistance(i){this.#wx=i,this.#Lx.focusDistance=i}get aperture(){return this.#Cx}set aperture(i){this.#Cx=i,this.#Lx.aperture=i}get maxCoC(){return this.#Px}set maxCoC(i){this.#Px=i,this.#Lx.maxCoC=i}get nearPlane(){return this.#Rx}set nearPlane(i){this.#Rx=i,this.#Lx.nearPlane=i}get farPlane(){return this.#Bx}set farPlane(i){this.#Bx=i,this.#Lx.farPlane=i}get nearBlurSize(){return this.#Ix}set nearBlurSize(i){this.#Ix=i,this.#Ax.nearBlurSize=i}get farBlurSize(){return this.#Ex}set farBlurSize(i){this.#Ex=i,this.#Ax.farBlurSize=i}get nearStrength(){return this.#Dx}set nearStrength(i){this.#Dx=i,this.#Ax.nearStrength=i}get farStrength(){return this.#Ux}set farStrength(i){this.#Ux=i,this.#Ax.farStrength=i}setGameDefault(){this.focusDistance=15,this.aperture=2.8,this.maxCoC=25,this.nearBlurSize=15,this.farBlurSize=15,this.nearStrength=1,this.farStrength=1}setCinematic(){this.focusDistance=20,this.aperture=1.4,this.maxCoC=40,this.nearBlurSize=25,this.farBlurSize=30,this.nearStrength=1.2,this.farStrength=1.3}setPortrait(){this.focusDistance=8,this.aperture=1.8,this.maxCoC=35,this.nearBlurSize=12,this.farBlurSize=25,this.nearStrength=.8,this.farStrength=1.4}setLandscape(){this.focusDistance=50,this.aperture=8,this.maxCoC=20,this.nearBlurSize=20,this.farBlurSize=10,this.nearStrength=1.1,this.farStrength=.6}setMacro(){this.focusDistance=2,this.aperture=1,this.maxCoC=50,this.nearBlurSize=30,this.farBlurSize=35,this.nearStrength=1.5,this.farStrength=1.6}setSports(){this.focusDistance=25,this.aperture=4,this.maxCoC=18,this.nearBlurSize=10,this.farBlurSize=12,this.nearStrength=.8,this.farStrength=.9}setNightMode(){this.focusDistance=12,this.aperture=2,this.maxCoC=30,this.nearBlurSize=18,this.farBlurSize=20,this.nearStrength=1.1,this.farStrength=1.2}render(i,g,x,_){const v=this.#Lx.render(i,g,x,_);return this.#Ax.render(i,g,x,_,v)}}Object.freeze(DOF);class LensDistortion extends ASinglePassPostEffect{#Gx=.1;#kx=0;#sf=0;#of=0;constructor(i){super(i),this.init(i,"POST_EFFECT_LENS_DISTORTION",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet center=vec2<f32>(dimW * 0.5 + uniforms.centerX,dimH * 0.5 + uniforms.centerY);\nlet global_id_vec=vec2<f32>(f32(global_id.x),f32(global_id.y));\nlet uv=global_id_vec/vec2<f32>(dimW,dimH);\nlet uvCenter=center/vec2<f32>(dimW,dimH);\nlet offset=uv - uvCenter;\nlet distance=length(offset);\nlet barrelFactor=1.0 + uniforms.barrelStrength * distance * distance;\nlet pincushionFactor=1.0 - uniforms.pincushionStrength * distance * distance;\nlet distortionFactor=barrelFactor * pincushionFactor;\nlet distortedUV=uvCenter + offset * distortionFactor;\nif (distortedUV.x < 0.0 || distortedUV.x > 1.0 || distortedUV.y < 0.0 || distortedUV.y > 1.0) { textureStore(outputTexture,vec2<i32>(global_id.xy),vec4<f32>(0.0,0.0,0.0,1.0));\n} else { let sampleCoord=vec2<i32>( i32(clamp(distortedUV.x * dimW,0.0,dimW - 1.0)), i32(clamp(distortedUV.y * dimH,0.0,dimH - 1.0)) ); let sampledColor=textureLoad(sourceTexture,sampleCoord).xyzw; textureStore(outputTexture,vec2<i32>(global_id.xy),sampledColor);\n}\n","struct Uniforms { barrelStrength:f32, pincushionStrength:f32, centerX:f32, centerY:f32\n};\n")),this.barrelStrength=this.#Gx,this.pincushionStrength=this.#kx,this.centerX=this.#sf,this.centerY=this.#of}get barrelStrength(){return this.#Gx}set barrelStrength(i){validateNumberRange(i,0),this.#Gx=i,this.updateUniform("barrelStrength",i)}get pincushionStrength(){return this.#kx}set pincushionStrength(i){validateNumberRange(i,0),this.#kx=i,this.updateUniform("pincushionStrength",i)}get centerX(){return this.#sf}set centerX(i){validateNumber(i),this.#sf=i,this.updateUniform("centerX",i)}get centerY(){return this.#of}set centerY(i){validateNumber(i),this.#of=i,this.updateUniform("centerY",i)}}Object.freeze(LensDistortion);class Vignetting extends ASinglePassPostEffect{#Ox=.2;#en=.5;constructor(i){super(i),this.init(i,"POST_EFFECT_VIGNETTING",createBasicPostEffectCode(this,"let dimensions=textureDimensions(sourceTexture);\nlet dimW=f32(dimensions.x);\nlet dimH=f32(dimensions.y);\nlet index=vec2<u32>(global_id.xy);\nlet uv=vec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH);\nlet smoothness=uniforms.smoothness;\nlet size=uniforms.size;\nvar color:vec4<f32>=textureLoad(sourceTexture,index);\nvar diff=size - distance(uv,vec2<f32>(0.5));\nlet vignette=smoothstep(-smoothness,smoothness,diff);\ncolor.r *=vignette;\ncolor.g *=vignette;\ncolor.b *=vignette;\ntextureStore(outputTexture,index,color);\n","struct Uniforms { smoothness:f32, size:f32,\n};\n")),this.smoothness=this.#Ox,this.size=this.#en}get size(){return this.#en}set size(i){validateNumberRange(i,0),this.#en=i,this.updateUniform("size",i)}get smoothness(){return this.#Ox}set smoothness(i){validateNumberRange(i,0,1),this.#Ox=i,this.updateUniform("smoothness",i)}}Object.freeze(Vignetting);class OldBloomBlend extends ASinglePassPostEffect{#Nx=1;#gc=1;constructor(i){super(i);const{WORK_SIZE_X:g,WORK_SIZE_Y:x,WORK_SIZE_Z:_}=this,v=` struct Uniforms { bloomStrength:f32, exposure:f32 }; @group(0) @binding(0) var sourceTexture0:texture_storage_2d<rgba16float,read>; @group(0) @binding(1) var sourceTexture1:texture_storage_2d<rgba16float,read>; @group(1) @binding(0) var outputTexture:texture_storage_2d<rgba16float,write>; @group(1) @binding(1) var<uniform> uniforms:Uniforms; @compute @workgroup_size(${g},${x},${_}) fn main ( @builtin(global_invocation_id) global_id:vec3<u32>, ){ let index=vec2<u32>(global_id.xy ); let dimensions:vec2<u32>=textureDimensions(sourceTexture0); let dimW=f32(dimensions.x); let dimH=f32(dimensions.y); let uv=\tvec2<f32>(f32(index.x)/dimW,f32(index.y)/dimH); var diffuse:vec4<f32>=textureLoad( sourceTexture0, index, ); var blur:vec4<f32>=textureLoad( sourceTexture1, index, );  let finalColor=vec4<f32>((diffuse.rgb + blur.rgb * uniforms.bloomStrength ) * uniforms.exposure,diffuse.a); textureStore(outputTexture,index,finalColor ); }; `;this.init(i,"POST_EFFECT_OLD_BLOOM",{msaa:v,nonMsaa:v}),this.exposure=this.#gc,this.bloomStrength=this.#Nx}get bloomStrength(){return this.#Nx}set bloomStrength(i){this.#Nx=i,this.updateUniform("bloomStrength",i)}get exposure(){return this.#gc}set exposure(i){this.#gc=i,this.updateUniform("exposure",i)}render(i,g,x,_,v){return super.render(i,g,x,_,v)}}Object.freeze(OldBloomBlend);class OldBloom extends AMultiPassPostEffect{#Vx;#Fx;#zx;#nx=156;#Hx=32;#gc=1;#Nx=1.2;constructor(i){super(i,[new Threshold(i),new GaussianBlur(i),new OldBloomBlend(i)]),this.#Vx=this.passList[0],this.#Fx=this.passList[1],this.#zx=this.passList[2],this.#Vx.threshold=this.#nx,this.#Fx.size=this.#Hx,this.#zx.exposure=this.#gc,this.#zx.bloomStrength=this.#Nx}get threshold(){return this.#nx}set threshold(i){this.#nx=i,this.#Vx.threshold=i}get gaussianBlurSize(){return this.#Hx}set gaussianBlurSize(i){this.#Hx=i,this.#Fx.size=i}get exposure(){return this.#gc}set exposure(i){this.#gc=i,this.#zx.exposure=i}get bloomStrength(){return this.#Nx}set bloomStrength(i){this.#Nx=i,this.#zx.bloomStrength=i}render(i,g,x,_){const v=this.#Vx.render(i,g,x,_),b=this.#Fx.render(i,g,x,v);return this.#zx.render(i,g,x,_,b)}}Object.freeze(OldBloom);class Sharpen extends AMultiPassPostEffect{#ax;constructor(i){super(i,[new Convolution(i)]),this.#ax=this.passList[0],this.#ax.kernel=Convolution.SHARPEN}render(i,g,x,_){return this.#ax.render(i,g,x,_)}}Object.freeze(Sharpen);var wo=Object.freeze({__proto__:null,AMultiPassPostEffect:AMultiPassPostEffect,ASinglePassPostEffect:ASinglePassPostEffect,createBasicPostEffectCode:createBasicPostEffectCode}),Co=Object.freeze({__proto__:null,Blur:Blur,BlurX:BlurX,BlurY:BlurY,BrightnessContrast:BrightnessContrast,ChromaticAberration:ChromaticAberration,ColorBalance:ColorBalance,ColorTemperatureTint:ColorTemperatureTint,Convolution:Convolution,Core:wo,DOF:DOF,DirectionalBlur:DirectionalBlur,FilmGrain:FilmGrain,Fog:Fog,GaussianBlur:GaussianBlur,Grayscale:Grayscale,HeightFog:HeightFog,HueSaturation:HueSaturation,Invert:Invert,LensDistortion:LensDistortion,OldBloom:OldBloom,PostEffectManager:PostEffectManager,RadialBlur:RadialBlur,Sharpen:Sharpen,Threshold:Threshold,Vibrance:Vibrance,Vignetting:Vignetting,ZoomBlur:ZoomBlur}),Po=Object.freeze({__proto__:null,PICKING_EVENT_TYPE:i,PickingEvent:PickingEvent,PickingManager:PickingManager,Raycaster2D:Raycaster2D,Raycaster3D:Raycaster3D}),Ro=Object.freeze({__proto__:null,BlendState:BlendState,DepthStencilState:DepthStencilState,PrimitiveState:PrimitiveState}),Bo=Object.freeze({__proto__:null,TONE_MAPPING_MODE:qi,ToneMappingManager:ToneMappingManager}),Io=Object.freeze({__proto__:null,DirectionalShadowManager:DirectionalShadowManager,ShadowManager:ShadowManager}),Eo=Object.freeze({__proto__:null,AntialiasingManager:AntialiasingManager,FXAA:FXAA,TAA:TAA,TAASharpen:TAASharpen});var Do=Object.freeze({__proto__:null,PHYSICS_BODY_TYPE:{DYNAMIC:"dynamic",STATIC:"static",KINEMATIC:"kinematic",KINEMATIC_POSITION:"kinematicPosition",KINEMATIC_VELOCITY:"kinematicVelocity"},PHYSICS_SHAPE:{BOX:"box",SPHERE:"sphere",CAPSULE:"capsule",CYLINDER:"cylinder",HEIGHTFIELD:"heightfield",MESH:"mesh"}});export{Eo as Antialiasing,ua as Bound,_a as Camera,ya as Color,ba as Context,dr as DefineForFragment,Er as DefineForVertex,Bs as Display,GLTFLoader,_ as GPU_ADDRESS_MODE,mr as GPU_BLEND_FACTOR,pr as GPU_BLEND_OPERATION,Tn as GPU_COMPARE_FUNCTION,ei as GPU_CULL_MODE,v as GPU_FILTER_MODE,ti as GPU_FRONT_FACE,Dr as GPU_INDEX_FORMAT,z as GPU_LOAD_OP,b as GPU_MIPMAP_FILTER_MODE,Lr as GPU_PRIMITIVE_TOPOLOGY,H as GPU_STORE_OP,Geometry,Es as Light,Gs as Material,Ds as Math,Do as Physics,Po as Picking,Co as PostEffect,Ls as Primitive,Ro as RenderState,Renderer,Js as Resource,po as RuntimeChecker,Io as Shadow,Ke as SystemCode,Bo as ToneMapping,x as Util,init};